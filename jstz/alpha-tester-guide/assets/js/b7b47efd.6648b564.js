"use strict";(self.webpackChunkjstz_docs=self.webpackChunkjstz_docs||[]).push([[326],{3023:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var s=n(6540);const a={},i=s.createContext(a);function o(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(i.Provider,{value:t},e.children)}},3246:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"functions/data_storage","title":"Storing data","description":"Smart functions store persistent data in a key-value database that is specific to each function.","source":"@site/functions/data_storage.md","sourceDirName":"functions","slug":"/functions/data_storage","permalink":"/previews/jstz/alpha-tester-guide/functions/data_storage","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Storing data"},"sidebar":"documentationSidebar","previous":{"title":"Handling requests","permalink":"/previews/jstz/alpha-tester-guide/functions/requests"},"next":{"title":"Calling","permalink":"/previews/jstz/alpha-tester-guide/functions/calling"}}');var a=n(4848),i=n(3023);const o={title:"Storing data"},r=void 0,c={},l=[{value:"Errors",id:"errors",level:2},{value:"Smart functions",id:"smart-functions",level:2},{value:"TypeScript applications",id:"typescript-applications",level:2},{value:"Command line",id:"command-line",level:2}];function d(e){const t={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:"Smart functions store persistent data in a key-value database that is specific to each function.\nOnly the function itself can write to its storage.\nSmart functions cannot read the data of other functions, but the data is publicly visible to applications outside of Jstz via the client API."}),"\n",(0,a.jsx)(t.p,{children:"Keys are strings and values can be any serializable JavaScript object.\nA smart function can write a new value for a certain key and the next time it reads that key, it receives the new value."}),"\n",(0,a.jsx)(t.h2,{id:"errors",children:"Errors"}),"\n",(0,a.jsx)(t.p,{children:"Uncaught errors in smart functions reverse the entire transaction, as if the initial call to the smart function never happened.\nThis reversal includes any changes to the database."}),"\n",(0,a.jsx)(t.p,{children:"For example, this code writes a value to storage in one line and throws an error on the next line.\nIf the smart function does not catch this error, the change to the key-value database on the first line does not happen.\nThe key keeps the same value that it had before the failed transaction."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-typescript",children:'Kv.set("myKey", "This value is not stored because the next line fails");\nthrow "There is a problem, so reverse this transaction.";\n'})}),"\n",(0,a.jsx)(t.p,{children:"You can catch errors in smart functions with try/catch blocks just like in ordinary JavaScript/TypeScript."}),"\n",(0,a.jsx)(t.p,{children:"Although changes to the key-value database are atomic and committed only when the smart function request completes successfully, changes to the database are visible inside the smart function.\nFor example, if you set a value on one line and read it on the next line, you get the new value of the key, not the value prior to when the smart function was called."}),"\n",(0,a.jsx)(t.h2,{id:"smart-functions",children:"Smart functions"}),"\n",(0,a.jsxs)(t.p,{children:["To store a value in a smart function, use the function ",(0,a.jsx)(t.code,{children:"Kv.set"}),".\nThis example assigns the JSON object ",(0,a.jsx)(t.code,{children:"{ myValue: 5 }"})," to the key ",(0,a.jsx)(t.code,{children:"myKey"}),":"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-typescript",children:'Kv.set("myKey", { myValue: 5 });\n'})}),"\n",(0,a.jsxs)(t.p,{children:["To read a key-value pair, use the function ",(0,a.jsx)(t.code,{children:"Kv.get"}),", as in this example:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-typescript",children:'const data: object | null = Kv.get("myKey");\nif (data) {\n  const { myValue } = data;\n  console.log(myValue); // 5\n}\n'})}),"\n",(0,a.jsxs)(t.p,{children:["To delete a value, pass the key to the function ",(0,a.jsx)(t.code,{children:"Kv.delete"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["To check if a value exists, pass the key to the function ",(0,a.jsx)(t.code,{children:"Kv.has"}),", which returns a Boolean value."]}),"\n",(0,a.jsxs)(t.p,{children:["The database stores keys separated with slashes as subkeys.\nFor example, it splits the key ",(0,a.jsx)(t.code,{children:"myKey/subKey"})," into the subkey ",(0,a.jsx)(t.code,{children:"subKey"})," of the key ",(0,a.jsx)(t.code,{children:"myKey"}),".\nThis does not change how smart functions store and access data, but it allows API clients to browse subkeys when a smart function stores complex data."]}),"\n",(0,a.jsxs)(t.p,{children:["For more information about the smart function key-value API, see ",(0,a.jsx)(t.a,{href:"/api/kv",children:"KV"}),"."]}),"\n",(0,a.jsx)(t.h2,{id:"typescript-applications",children:"TypeScript applications"}),"\n",(0,a.jsx)(t.p,{children:"Other applications can read the Jstz key-value store if they know the address of the smart function that wrote the value and the key that it used.\nThey cannot write to the key-value store."}),"\n",(0,a.jsx)(t.p,{children:"This example uses the Jstz client SDK to get a value:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-typescript",children:'import { Jstz } from "@jstz-dev/jstz-client";\n\ntype myData = {\n  myValue: number;\n};\n\nconst storedData: myData | null = await jstzClient.accounts\n  .getKv(contractAddress, {\n    key: "myKey",\n  })\n  .catch(() => {\n    console.log("Value is not set");\n  });\n\nif (storedData) {\n  console.log("myValue:", storedData.myValue);\n}\n'})}),"\n",(0,a.jsx)(t.h2,{id:"command-line",children:"Command line"}),"\n",(0,a.jsxs)(t.p,{children:["You can retrieve the value of a key with the ",(0,a.jsx)(t.code,{children:"jstz kv get"})," command, where ",(0,a.jsx)(t.code,{children:"<ADDRESS_OR_ALIAS>"})," is the address or alias of the smart function and ",(0,a.jsx)(t.code,{children:"<KEY>"})," is the key:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"jstz kv get -a <ADDRESS_OR_ALIAS> -n dev <KEY>\n"})}),"\n",(0,a.jsxs)(t.p,{children:["If the smart function stores data with subkey, delimited by slashes, you can get those subkey with the ",(0,a.jsx)(t.code,{children:"jstz kv list"})," command.\nFor example, if a smart function stores data in the keys ",(0,a.jsx)(t.code,{children:"myKey/a"}),", ",(0,a.jsx)(t.code,{children:"myKey/b"}),", and ",(0,a.jsx)(t.code,{children:"myKey/c"}),", you can get a list of these three subkey with this command:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"jstz kv list -a <ADDRESS_OR_ALIAS> -n dev myKey\n"})}),"\n",(0,a.jsxs)(t.p,{children:["This command helps you explore complex data stored by smart functions.\nTo get the data for one of these subkey, use the ",(0,a.jsx)(t.code,{children:"jstz kv get"})," command as usual, as in this example:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"jstz kv get -a <ADDRESS_OR_ALIAS> -n dev `myKey/a\n"})})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);