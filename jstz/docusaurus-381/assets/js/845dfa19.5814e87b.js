"use strict";(self.webpackChunkjstz_docs=self.webpackChunkjstz_docs||[]).push([[353],{172:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"functions/overview","title":"Smart functions","description":"Smart functions are the main processing unit of Jstz.","source":"@site/functions/overview.md","sourceDirName":"functions","slug":"/functions/overview","permalink":"/previews/jstz/docusaurus-381/functions/overview","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Smart functions"},"sidebar":"documentationSidebar","previous":{"title":"Accounts","permalink":"/previews/jstz/docusaurus-381/architecture/accounts"},"next":{"title":"Building","permalink":"/previews/jstz/docusaurus-381/functions/building"}}');var r=t(4848),a=t(3023);const i={title:"Smart functions"},c=void 0,o={},l=[{value:"Example smart function",id:"example-smart-function",level:2},{value:"Accounts",id:"accounts",level:2},{value:"Error handling",id:"error-handling",level:2},{value:"Differences from other JavaScript/TypeScript applications",id:"differences-from-other-javascripttypescript-applications",level:2},{value:"Limitations of smart functions",id:"limitations-of-smart-functions",level:2},{value:"Similarities and differences from smart contracts",id:"similarities-and-differences-from-smart-contracts",level:2}];function u(e){const n={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["Smart functions are the main processing unit of Jstz.\nThey behave like ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Serverless_computing",children:"serverless applications"}),", small applications that run only when called and do not have a long-term presence on any server.\nClients call them, servers load them into memory to run them, they return a value, and they are removed from the server's memory until they are called again.\nFor this reason, smart functions themselves have no persistent state; they must store all persistent data in the key-value store, as described in ",(0,r.jsx)(n.a,{href:"/functions/data_storage",children:"Storing data"}),".\nAny global variables are reset each time they run, and if a smart function is called more than once at the same time, the instances do not have access to each other's state or variables."]}),"\n",(0,r.jsxs)(n.p,{children:["As described in ",(0,r.jsx)(n.a,{href:"/functions/requests",children:"Accepting requests"}),", each smart function must have a ",(0,r.jsx)(n.code,{children:"handler"})," function that receives these requests from callers.\nThis function receives a Jstz ",(0,r.jsx)(n.a,{href:"/api/request",children:"Request"})," object that includes the message sent from the client and metadata such as the address of the account that called the smart function.\nThe function runs and returns a Jstz",(0,r.jsx)(n.a,{href:"/api/response",children:"Response"})," object to the caller."]}),"\n",(0,r.jsx)(n.h2,{id:"example-smart-function",children:"Example smart function"}),"\n",(0,r.jsx)(n.p,{children:"This smart function stores a number and allows users to add or subtract a number from that number.\nThey can also get the current value of the number:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// Get the current number from storage\nconst get = (): number => {\n  const num: number | null = Kv.get("myNumber");\n  return num || 0;\n};\n\n// Set the number in storage\nconst set = (num: number) => {\n  Kv.set("myNumber", num);\n};\n\n// Pass the message `get` to get the current value in storage\n// Pass `increment` to add one\n// Pass `decrement` to subtract one\n// Any other message returns a message\nconst handler = async (request: Request): Promise<Response> => {\n  // Extract the requester\'s address and message from the request\n  const requester = request.headers.get("Referer") as Address;\n  const { message } = await request.json();\n\n  console.log(`${requester} says: ${message}`);\n\n  const currentValue = get();\n\n  let responseString = "";\n\n  if (message === "increment") {\n    set(currentValue + 1);\n    responseString = "Incremented. ";\n  } else if (message === "decrement") {\n    set(currentValue - 1);\n    responseString = "Decremented. ";\n  } else if (message !== "get") {\n    return new Response(\n      JSON.stringify("Pass \'get\', \'increment\', or \'decrement\'."),\n    );\n  }\n\n  responseString += "Current value is " + get();\n  return new Response(JSON.stringify(responseString));\n};\n\nexport default handler;\n'})}),"\n",(0,r.jsx)(n.h2,{id:"accounts",children:"Accounts"}),"\n",(0,r.jsx)(n.p,{children:"Smart functions are a kind of cryptocurrency account.\nLike user accounts, they can receive, store, and send tez (XTZ)."}),"\n",(0,r.jsx)(n.h2,{id:"error-handling",children:"Error handling"}),"\n",(0,r.jsx)(n.p,{children:"Calls to smart functions are atomic, which means that all of the request completes or none of it does.\nIf a smart function throws an exception and does not catch it, all effects of the request are reverted, so it is as if the call to the smart function never happened."}),"\n",(0,r.jsxs)(n.p,{children:["For more information, see ",(0,r.jsx)(n.a,{href:"/functions/errors",children:"Handling errors"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"differences-from-other-javascripttypescript-applications",children:"Differences from other JavaScript/TypeScript applications"}),"\n",(0,r.jsx)(n.p,{children:"Smart functions look like ordinary JavaScript functions, but because they run on Jstz, they have some differences in their behavior."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Smart functions cannot be changed or stopped after they are deployed."}),"\n",(0,r.jsx)(n.li,{children:"Smart functions are permissionless, so anyone can call them, but you can add your own logic to them to restrict who can call them."}),"\n",(0,r.jsx)(n.li,{children:"Anyone can inspect the code and storage of deployed smart functions."}),"\n",(0,r.jsx)(n.li,{children:"Because smart functions run in a decentralized manner on many Jstz Smart Rollup nodes, they are censorship-resistant."}),"\n",(0,r.jsxs)(n.li,{children:["Smart functions must be built with Jstz dependencies as described in ",(0,r.jsx)(n.a,{href:"/functions/building",children:"Building smart functions"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"limitations-of-smart-functions",children:"Limitations of smart functions"}),"\n",(0,r.jsx)(n.p,{children:"Smart functions behave much like other serverless JavaScript/TypeScript applications, but they have these limitations:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Smart functions cannot call external APIs."}),"\n",(0,r.jsx)(n.li,{children:"Smart functions are restricted to 10MB in size."}),"\n",(0,r.jsx)(n.li,{children:"Smart functions can import and use packages, but they can use only certain JavaScript APIs, which limits the packages that they can use."}),"\n",(0,r.jsxs)(n.li,{children:["Smart functions run in an isolated context; each time a smart function runs, it is as if it is running for the first time.\nFor this reason, smart functions themselves have no persistent state; they must store all persistent data in the key-value store, as described in ",(0,r.jsx)(n.a,{href:"/functions/data_storage",children:"Storing data"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"similarities-and-differences-from-smart-contracts",children:"Similarities and differences from smart contracts"}),"\n",(0,r.jsxs)(n.p,{children:["Smart functions are similar to Tezos ",(0,r.jsx)(n.a,{href:"https://docs.tezos.com/smart-contracts",children:"smart contracts"})," in many ways, including:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"They are transparent, persistent, and cannot be changed after deployment"}),"\n",(0,r.jsx)(n.li,{children:"They have dedicated storage that only they can write to but is readable to outside clients"}),"\n",(0,r.jsx)(n.li,{children:"They can accept, store, and transfer tez between accounts"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"One important difference between smart contracts and smart functions is that Tezos smart contracts are often written in a higher-level language and compiled to the Michelson stack-based language.\nBy contrast, smart functions are written in JavaScript or TypeScript, transpiled to JavaScript if necessary, and then Jstz runs the JavaScript code directly."}),"\n",(0,r.jsx)(n.p,{children:"Here are some other things to know about smart functions and smart contracts:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Despite having many similarities and similar-looking addresses, smart functions and smart contracts run in different environments:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Smart functions run only on Jstz, which is a layer that runs on top of Tezos layer 1"}),"\n",(0,r.jsx)(n.li,{children:"Smart contracts run directly on Tezos layer 1"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Therefore, smart functions and smart contracts cannot directly interact with each other; smart functions cannot directly call smart contracts, and smart contracts cannot directly call smart functions"}),"\n"]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},3023:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>c});var s=t(6540);const r={},a=s.createContext(r);function i(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);