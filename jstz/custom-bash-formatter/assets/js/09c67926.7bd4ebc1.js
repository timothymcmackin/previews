"use strict";(self.webpackChunkjstz_docs=self.webpackChunkjstz_docs||[]).push([[285],{3023:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>i});var s=t(6540);const r={},a=s.createContext(r);function o(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(a.Provider,{value:n},e.children)}},6484:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>l,frontMatter:()=>o,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"functions/tokens","title":"Managing tokens","description":"Jstz maintains a ledger of how many tez tokens (also known as XTZ) each user and smart function account owns, similar to but separate from the ledger that Tezos layer 1 uses.","source":"@site/functions/tokens.md","sourceDirName":"functions","slug":"/functions/tokens","permalink":"/previews/jstz/custom-bash-formatter/functions/tokens","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Managing tokens"},"sidebar":"documentationSidebar","previous":{"title":"Calling external APIs","permalink":"/previews/jstz/custom-bash-formatter/functions/apis"},"next":{"title":"Handling errors","permalink":"/previews/jstz/custom-bash-formatter/functions/errors"}}');var r=t(4848),a=t(3023);const o={title:"Managing tokens"},i=void 0,c={},d=[{value:"Sending tez",id:"sending-tez",level:2},{value:"Transferring tez in a response",id:"transferring-tez-in-a-response",level:2},{value:"Receiving tez",id:"receiving-tez",level:2}];function u(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["Jstz maintains a ledger of how many tez tokens (also known as XTZ) each user and smart function account owns, similar to but separate from the ledger that Tezos layer 1 uses.\nSmart functions can accept and store the tez that callers include with requests, and they can send tez to users and smart functions.\nYou can use the ",(0,r.jsx)(n.a,{href:"/architecture/bridge",children:"Asset bridge"})," to move tez from layer 1 to Jstz and back."]}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsxs)(n.p,{children:["Internally, Jstz tracks balances not as individual tez but as ",(0,r.jsx)(n.em,{children:"mutez"}),", which are equal to one-millionth of one tez."]})}),"\n",(0,r.jsx)(n.h2,{id:"sending-tez",children:"Sending tez"}),"\n",(0,r.jsxs)(n.p,{children:["If a smart function has tez, it can send tez to a user account or smart function as part of a request by putting the amount of mutez in the ",(0,r.jsx)(n.code,{children:"X-JSTZ-TRANSFER"})," header in requests, as in this example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// 1 tez = 1 million mutez\nconst ONE_TEZ = 1000000;\n// Transfer 1 XTZ to smart function B\nconst smartFunctionB = "KT1TxqZ8QtKvLu3V3JH7Gx58n7Co8pgtpQU5";\nif (Ledger.balance(Ledger.selfAddress) >= ONE_TEZ) {\n  const send_request = new Request(`jstz://${smartFunctionB}`, {\n    headers: {\n      "X-JSTZ-TRANSFER": ONE_TEZ,\n    },\n  });\n  await fetch(send_request);\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["As described in ",(0,r.jsx)(n.a,{href:"/functions/errors",children:"Errors"}),", any transfers are reverted if a smart function throws an uncaught error."]}),"\n",(0,r.jsx)(n.h2,{id:"transferring-tez-in-a-response",children:"Transferring tez in a response"}),"\n",(0,r.jsxs)(n.p,{children:["Similarly, a smart function can transfer tez to the user or smart function that called it by setting the ",(0,r.jsx)(n.code,{children:"X-JSTZ-TRANSFER"})," header in the response.\nFor example, this smart function sends one tez to the caller:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'const ONE_TEZ = 1000000; // 1 XTZ in mutez\n\nconst handler = async (request: Request): Promise<Response> => {\n  if (Ledger.balance(Ledger.selfAddress) >= ONE_TEZ) {\n    return new Response("Have one tez from me!", {\n      headers: {\n        "Content-Type": "text/utf-8",\n        "X-JSTZ-TRANSFER": ONE_TEZ.toString(),\n      },\n    });\n  } else {\n    return new Response("I have no tez to send you");\n  }\n};\n\nexport default handler;\n'})}),"\n",(0,r.jsx)(n.h2,{id:"receiving-tez",children:"Receiving tez"}),"\n",(0,r.jsxs)(n.p,{children:["Smart functions automatically accept tez sent to them.\nYou can see how many mutez are in a request by checking the ",(0,r.jsx)(n.code,{children:"X-JSTZ-AMOUNT"})," header, which includes the amount as a string:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'const ONE_TEZ = 1000000; // 1 XTZ in mutez\n\nconst handler = async (request: Request): Promise<Response> => {\n  const transferred_amount_string = request.headers.get("X-JSTZ-AMOUNT");\n  const transferred_amount = parseInt(transferred_amount_string || "0");\n  console.log(`Received ${transferred_amount} mutez.`);\n\n  return new Response("Thank you!");\n};\n\nexport default handler;\n'})}),"\n",(0,r.jsxs)(n.p,{children:["To prevent a smart function from receiving tez, throw an exception to revert the transfer if the ",(0,r.jsx)(n.code,{children:"X-JSTZ-AMOUNT"})," header is set, as in this example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'const handler = (request: Request): Response => {\n  const transferred_amount_string = request.headers.get("X-JSTZ-AMOUNT");\n  const transferred_amount = parseInt(transferred_amount_string || "0");\n  console.log(`Received ${transferred_amount} mutez`);\n  if (transferred_amount > 0) {\n    throw "Don\'t send tez to this smart function.";\n  }\n  return new Response("OK");\n};\n\nexport default handler;\n'})})]})}function l(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}}}]);