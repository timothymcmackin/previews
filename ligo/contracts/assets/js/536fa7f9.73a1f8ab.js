"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[87496],{48720:(e,t,n)=>{n.d(t,{D:()=>a.Z,Z:()=>i});var s=n(67294),a=n(75402);const i=function(e){return s.createElement(a.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:s.createElement(s.Fragment,null)}))}},99191:(e,t,n)=>{n.d(t,{Z:()=>d});var s=n(43164),a=n(67294),i=n(52263),r=n(48720),o=n(11506);function l(){return l=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&(e[s]=n[s])}return e},l.apply(this,arguments)}const{Prism:h}=n(43164);h.languages={...h.languages,cameligo:{...h.languages.ocaml,comment:[/(^|[^\\])\/\*[\s\S]*?\*\//,/\(\*[\s\S]*?\*\)/,/\/\/.*/]},jsligo:h.languages.typescript};const d=function(e){const{siteConfig:{themeConfig:{prism:t={}}}}=(0,i.Z)(),n=t.singleTheme||o.Z,[h,d]=(0,a.useState)(!1);return(0,a.useEffect)((()=>{d(!0)}),[]),a.createElement(r.D.Consumer,null,(t=>{let{syntax:i}=t;return i===e.syntax?a.createElement(s.default,l({},s.defaultProps,{key:h,language:e.syntax,code:e.children,theme:n}),(e=>{let{className:t,tokens:n,getLineProps:s,getTokenProps:i}=e;return a.createElement("h4",{className:t,style:{backgroundColor:"var(--ifm-background-color)",fontFamily:"var(--ifm-font-family-monospace)",lineHeight:"var(--ifm-pre-line-height)",fontSize:"1.1rem",fontWeight:"bold",padding:0,whiteSpace:"break-spaces",marginTop:"3rem"}},n.map(((e,t)=>a.createElement("div",s({line:e,key:t}),e.map(((e,t)=>a.createElement("span",i({token:e,key:t}))))))))})):a.createElement("div",null)}))}},65880:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>o,default:()=>b,frontMatter:()=>r,metadata:()=>l,toc:()=>d});var s=n(87462),a=(n(67294),n(3905)),i=(n(48720),n(99191));const r={id:"bitwise-reference",title:"bitwise",hide_table_of_contents:!0},o=void 0,l={unversionedId:"reference/bitwise-reference",id:"version-1.7.0/reference/bitwise-reference",title:"bitwise",description:"Bitwise operations",source:"@site/versioned_docs/version-1.7.0/reference/bitwise.md",sourceDirName:"reference",slug:"/reference/bitwise-reference",permalink:"/previews/ligo/contracts/docs/reference/bitwise-reference",draft:!1,tags:[],version:"1.7.0",frontMatter:{id:"bitwise-reference",title:"bitwise",hide_table_of_contents:!0},sidebar:"API",previous:{title:"list",permalink:"/previews/ligo/contracts/docs/reference/list-reference"},next:{title:"set",permalink:"/previews/ligo/contracts/docs/reference/set-reference"}},h={},d=[],c={toc:d};function b(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,s.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Bitwise operations"),(0,a.kt)(i.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val and : 'a 'b.'a -> 'b -> ('a, 'b) external_and"),(0,a.kt)(i.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let and: <a, b>(_: a) => (_: b) => external_and<a, b>"),'The call `Bitiwise.@and a b` is the conjunction defined on boolean, natural number and bytes operands. In the boolean case, the result is the logical "and" of the operands. In the natural number and bytes cases, the result is the bitwise "and" of the operands.',(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'The function `Bitwise.@and` is also defined when the left operand is of\ntype `int`. Negative numbers are considered in two\'s complement\nrepresentation, starting with a virtual infinite number of 1s.\n\nWhen `Bitwise.@and` is used for bytes operands, the bytes result\nhas the same length as the shorter operand. The prefix of the\nlonger operand is cut to match with the length of the shorter one\nbefore taking the bitwise "and".\n')),(0,a.kt)(i.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val or : 'a 'b.'a -> 'b -> ('a, 'b) external_or"),(0,a.kt)(i.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let or: <a, b>(_: a) => (_: b) => external_or<a, b>"),'The call `Bitwise.@or a b` is the disjunction defined on boolean, natural number and bytes operands. In the boolean case, the result is the logical "or" of the operands. In the natural number and bytes cases, the result is the bitwise "or" of the operands.',(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'When the function `Bitwise.@or` is used for bytes operands, the result\nbytes has the same length as the longer operand. The shorter\noperand is zero-padded on the left to match with the length of the\nlonger one before taking the bitwise "or".\n')),(0,a.kt)(i.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val xor : 'a 'b.'a -> 'b -> ('a, 'b) external_xor"),(0,a.kt)(i.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let xor: <a, b>(_: a) => (_: b) => external_xor<a, b>"),'The call `Bitwise.xor a b` is the exclusive disjunction defined on boolean, natural number and bytes operands. In the boolean case, the result is the logical "exclusive or" of the operands. In the natural number and bytes cases, the result is the bitwise "xor" of the operands.',(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'When `Bitwise.xor` is used for bytes operands, the result bytes\nhas the same length as the longer operand. The shorter operand is\nzero-padded on the left to match with the length of the longer one\nbefore taking the bitwise "xor".\n')),(0,a.kt)(i.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val shift_left : 'a 'b.'a -> 'b -> ('a, 'b) external_lsl"),(0,a.kt)(i.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let shift_left: <a, b>(_: a) => (_: b) => external_lsl<a, b>"),"The function `Bitwise.shift_left` on natural numbers consumes two natural numbers and produces the first number logically left-shifted by the second number. This instruction is only defined if the second number is less than or equal to 256.",(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"For bytes, the function `Biwise.shift_left` consumes one byte sequence\nand one natural number, and produces the bytes logically\nleft-shifted by the natural number. The vacated bits on the right\nare filled with zeros. The shifted bits are minimally zero-padded\non the left in order to keep all the original bits, regardless if\nthey are 0 or 1: for example, `Bitwise.shift_left 0x1234 1` is `0x002468`,\ninstead of `0x2468` (even though in this case no significant bit\nwould be lost) or `0x00002468` (where padding is not minimal). The\nlength of the bytes returned by `Bitwise.shift_left` is `l + (s + 7) / 8`\nbytes where `l` is the length of the original bytes and `s` is the\nnatural number. This instruction is only defined if the second\nnumber is less than or equal to 64000.\n")),(0,a.kt)(i.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val shift_right : 'a 'b.'a -> 'b -> ('a, 'b) external_lsr"),(0,a.kt)(i.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let shift_right: <a, b>(_: a) => (_: b) => external_lsr<a, b>"),"The function `Bitwise.shift_right` on natural numbers consumes two natural numbers and produces the first number logically right-shifted by second number. This function is only defined if the second number is less than or equal to 256.",(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"For bytes, the function `Bitwise.shift_right` consumes one chunk of bytes\nand one natural number and produces the bytes logically\nright-shifted by the natural number. The shifted bits are\nminimally zero-padded on the left. For example, `Bitwise.shift_right\n0x012349 9` is `0x0091`, instead of `0x91` (where the 7 left-most\nbits are lost) or `0x000091` (not minimal padding). The length of\nthe returned bytes by `Bitwise.shift_right` is `max 0 (l - s / 8)` bytes,\nwhere `l` is the length of the original bytes, and `s` is the\nnatural number.\n")))}b.isMDXComponent=!0}}]);