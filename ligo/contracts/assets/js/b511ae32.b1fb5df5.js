"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[47211],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>g});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=r.createContext({}),s=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=s(e.components);return r.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=s(n),g=a,m=d["".concat(c,".").concat(g)]||d[g]||u[g]||o;return n?r.createElement(m,i(i({ref:t},p),{},{components:n})):r.createElement(m,i({ref:t},p))}));function g(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=d;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var s=2;s<o;s++)i[s]=n[s];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},48720:(e,t,n)=>{n.d(t,{D:()=>a.Z,Z:()=>o});var r=n(67294),a=n(75402);const o=function(e){return r.createElement(a.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:r.createElement(r.Fragment,null)}))}},73918:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>c,toc:()=>p});var r=n(87462),a=(n(67294),n(3905)),o=n(48720);const i={id:"first-contract",title:"First contract"},l=void 0,c={unversionedId:"advanced/first-contract",id:"version-1.6.0/advanced/first-contract",title:"First contract",description:"So far so good, we have learned enough of the LIGO language, we are",source:"@site/versioned_docs/version-1.6.0/advanced/first-contract.md",sourceDirName:"advanced",slug:"/advanced/first-contract",permalink:"/previews/ligo/contracts/docs/1.6.0/advanced/first-contract",draft:!1,tags:[],version:"1.6.0",frontMatter:{id:"first-contract",title:"First contract"}},s={},p=[{value:"Dry-running a Contract",id:"dry-running-a-contract",level:2},{value:"A Counter Contract",id:"a-counter-contract",level:2},{value:"Deploying and interacting with a contract on a live-chain",id:"deploying-and-interacting-with-a-contract-on-a-live-chain",level:2},{value:"Invoking a LIGO contract",id:"invoking-a-ligo-contract",level:2}],u={toc:p};function d(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"So far so good, we have learned enough of the LIGO language, we are\nconfident enough to write out first smart contract."),(0,a.kt)("p",null,"We will be implementing a counter contract."),(0,a.kt)("h2",{id:"dry-running-a-contract"},"Dry-running a Contract"),(0,a.kt)("p",null,"Testing a contract can be quite easy if we utilise LIGO's built-in dry\nrun feature. Dry-run works by simulating the main function execution,\nas if it were deployed on a real chain. You need to provide the\nfollowing:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"file")," - contract to run"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"parameter")," - parameter passed to the contract (in a\ntheoretical invocation operation)"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"storage")," - a mock storage value, as if it were stored on a real chain")),(0,a.kt)("p",null,"Here is a full example:"),(0,a.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=first-contract",group:"first-contract"},"type storage = int\n\n[@entry]\nlet main (_action : unit) (store : storage) : operation list * storage =\n  ([], store + 1)\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell",metastring:"skip",skip:!0},"ligo run dry-run src/basic.mligo unit 42 ./gitlab-pages/docs/advanced/src/first-contract.mligo\n// Outputs:\n// tuple[   list[]\n//          Unit\n// ]\n"))),(0,a.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=first-contract",group:"first-contract"},"type storage = int\n\n@entry\nconst main = (_action : unit, store : storage) : [list<operation>, storage] =>\n  [[], store + 1]\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell",metastring:"skip",skip:!0},"ligo run dry-run src/basic.mligo unit 42 ./gitlab-pages/docs/advanced/src/first-contract.jsligo\n// Outputs:\n// tuple[   list[]\n//          Unit\n// ]\n"))),(0,a.kt)("p",null,"Output of the ",(0,a.kt)("inlineCode",{parentName:"p"},"dry-run")," is the return value of our main function, we\ncan see the operations emitted (in our case an empty list, and the new\nstorage value being returned) which in our case is still ",(0,a.kt)("inlineCode",{parentName:"p"},"Unit"),"."),(0,a.kt)("h2",{id:"a-counter-contract"},"A Counter Contract"),(0,a.kt)("p",null,"Our counter contract will store a single ",(0,a.kt)("inlineCode",{parentName:"p"},"int")," as it's storage, and\nwill accept an ",(0,a.kt)("inlineCode",{parentName:"p"},"action")," variant in order to re-route our single ",(0,a.kt)("inlineCode",{parentName:"p"},"main"),"\nfunction to two entrypoints for ",(0,a.kt)("inlineCode",{parentName:"p"},"add")," (addition) and ",(0,a.kt)("inlineCode",{parentName:"p"},"sub"),"\n(subtraction)."),(0,a.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=counter",group:"counter"},"type storage = int\ntype result = operation list * storage\n\n[@entry] let increment (n : int) (store : storage) : result = [], store + n\n[@entry] let decrement (n : int) (store : storage) : result = [], store - n\n\n[@view] let v1 (n : int) (store : storage) : int = store + n\n"))),(0,a.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=counter",group:"counter"},"\ntype storage = int;\ntype result = [list<operation>, storage];\n\n@entry\nconst increment = (n: int, store: storage): result =>\n  [[], store + n];\n\n@entry\nconst decrement = (n: int, store: storage): result =>\n  [[], store - n];\n\n[@view]\nconst v1 = (n : int, store : storage) : int => store + n\n"))),(0,a.kt)("p",null,"To dry-run the counter contract, we will provide the ",(0,a.kt)("inlineCode",{parentName:"p"},"main")," function\nwith a variant parameter of value ",(0,a.kt)("inlineCode",{parentName:"p"},"Increment (5)")," and an initial\nstorage value of ",(0,a.kt)("inlineCode",{parentName:"p"},"5"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},'ligo run dry-run ./gitlab-pages/docs/advanced/src/first-contract/counter.mligo "Increment(5)" 5\n# tuple[   list[]\n#          10\n# ]\n')),(0,a.kt)("p",null,"Our contract's storage has been successfully incremented to ",(0,a.kt)("inlineCode",{parentName:"p"},"10"),"."),(0,a.kt)("h2",{id:"deploying-and-interacting-with-a-contract-on-a-live-chain"},"Deploying and interacting with a contract on a live-chain"),(0,a.kt)("p",null,"In order to deploy the counter contract to a real Tezos network, we'd\nhave to compile it first, this can be done with the help of the\n",(0,a.kt)("inlineCode",{parentName:"p"},"compile-contract")," CLI command:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"ligo compile contract ./gitlab-pages/docs/advanced/src/first-contract/counter.mligo\n")),(0,a.kt)("p",null,"Command above will output the following Michelson code:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-michelson"},'{ parameter (or (int %decrement) (int %increment)) ;\n  storage int ;\n  code { UNPAIR ; IF_LEFT { SWAP ; SUB } { ADD } ; NIL operation ; PAIR } ;\n  view "v1" int int { UNPAIR ; ADD } }\n')),(0,a.kt)("p",null,"However in order to originate a Michelson contract on Tezos, we also\nneed to provide the initial storage value, we can use\n",(0,a.kt)("inlineCode",{parentName:"p"},"compile-storage")," to compile the LIGO representation of the storage to\nMichelson."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"ligo compile storage ./gitlab-pages/docs/advanced/src/first-contract/counter.mligo 5\n# Outputs: 5\n")),(0,a.kt)("p",null,"In our case the LIGO storage value maps 1:1 to its Michelson\nrepresentation, however this will not be the case once the parameter\nis of a more complex data type, like a record."),(0,a.kt)("h2",{id:"invoking-a-ligo-contract"},"Invoking a LIGO contract"),(0,a.kt)("p",null,"Same rules apply for parameters, as apply for translating LIGO storage\nvalues to Michelson. We will need to use ",(0,a.kt)("inlineCode",{parentName:"p"},"compile-parameter")," to\ncompile our ",(0,a.kt)("inlineCode",{parentName:"p"},"action")," variant into Michelson, here's how:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"ligo compile parameter ./gitlab-pages/docs/advanced/src/first-contract/counter.mligo 'Increment(5)'\n# Outputs: (Right 5)\n")),(0,a.kt)("p",null,"Now we can use ",(0,a.kt)("inlineCode",{parentName:"p"},"(Right 5)")," which is a Michelson value, to invoke our\ncontract - e.g., via ",(0,a.kt)("inlineCode",{parentName:"p"},"tezos-client")))}d.isMDXComponent=!0}}]);