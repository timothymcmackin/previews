"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[17152],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var o=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var i=o.createContext({}),p=function(e){var t=o.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=p(e.components);return o.createElement(i.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,i=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=p(n),m=a,g=d["".concat(i,".").concat(m)]||d[m]||c[m]||r;return n?o.createElement(g,l(l({ref:t},u),{},{components:n})):o.createElement(g,l({ref:t},u))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,l=new Array(r);l[0]=d;var s={};for(var i in t)hasOwnProperty.call(t,i)&&(s[i]=t[i]);s.originalType=e,s.mdxType="string"==typeof e?e:a,l[1]=s;for(var p=2;p<r;p++)l[p]=n[p];return o.createElement.apply(null,l)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},48720:(e,t,n)=>{n.d(t,{D:()=>a.Z,Z:()=>r});var o=n(67294),a=n(75402);const r=function(e){return o.createElement(a.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:o.createElement(o.Fragment,null)}))}},66585:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>s,default:()=>d,frontMatter:()=>l,metadata:()=>i,toc:()=>u});var o=n(87462),a=(n(67294),n(3905)),r=n(48720);const l={id:"booleans",title:"Booleans"},s=void 0,i={unversionedId:"data-types/booleans",id:"data-types/booleans",title:"Booleans",description:"The predefined type bool has exactly two values: true and false.",source:"@site/../docs/data-types/booleans.md",sourceDirName:"data-types",slug:"/data-types/booleans",permalink:"/previews/ligo/contracts/docs/next/data-types/booleans",draft:!1,tags:[],version:"current",frontMatter:{id:"booleans",title:"Booleans"},sidebar:"docs",previous:{title:"Numbers",permalink:"/previews/ligo/contracts/docs/next/data-types/numbers"},next:{title:"Strings",permalink:"/previews/ligo/contracts/docs/next/data-types/strings"}},p={},u=[{value:"Or",id:"or",level:2},{value:"And",id:"and",level:2},{value:"Not",id:"not",level:2},{value:"Comparing",id:"comparing",level:2},{value:"Conditional expressions",id:"conditional-expressions",level:2}],c={toc:u};function d(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,o.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"The predefined type ",(0,a.kt)("inlineCode",{parentName:"p"},"bool")," has exactly two values: ",(0,a.kt)("inlineCode",{parentName:"p"},"true")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"false"),"."),(0,a.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=booleans",group:"booleans"},"let a : bool = true\nlet b : bool = false\n"))),(0,a.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=booleans",group:"booleans"},"const a: bool = true;\nconst b: bool = false;\n"))),(0,a.kt)("h2",{id:"or"},"Or"),(0,a.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,a.kt)("p",null,'The logical disjunction ("or") is implemented by the binary operator\n',(0,a.kt)("inlineCode",{parentName:"p"},"||"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=or",group:"or"},"let or_1 : bool = false || true  // true\nlet or_2 : bool = false || false // false\nlet or_3 : bool = true  || true  // true\nlet or_4 : bool = true  || false // true\n")),(0,a.kt)("p",null,"Note that you can also use the keyword ",(0,a.kt)("inlineCode",{parentName:"p"},"or")," instead of the symbol ",(0,a.kt)("inlineCode",{parentName:"p"},"||"),"\n(as in OCaml):"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=or",group:"or"},"let or_1 : bool = false or true  // true\nlet or_2 : bool = false or false // false\nlet or_3 : bool = true  or true  // true\nlet or_4 : bool = true  or false // true\n"))),(0,a.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,a.kt)("p",null,'The logical disjunction ("or") is implemented by the binary operator\n',(0,a.kt)("inlineCode",{parentName:"p"},"||"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=or",group:"or"},"const or_1: bool = false || true;  // true\nconst or_2: bool = false || false; // false\nconst or_3: bool = true  || true;  // true\nconst or_4: bool = true  || false; // true\n"))),(0,a.kt)("h2",{id:"and"},"And"),(0,a.kt)("p",null,'The logical conjunction ("and") is implemented by the binary operator\n',(0,a.kt)("inlineCode",{parentName:"p"},"&&"),"."),(0,a.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=conjunction",group:"conjunction"},"let and_1 : bool = false && true  // false\nlet and_2 : bool = false && false // false\nlet and_3 : bool = true  && true  // true\nlet and_4 : bool = true  && false // false\n"))),(0,a.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=conjunction",group:"conjunction"},"const and_1: bool = false && true;  // false\nconst and_2: bool = false && false; // false\nconst and_3: bool = true  && true;  // true\nconst and_4: bool = true  && false; // false\n"))),(0,a.kt)("h2",{id:"not"},"Not"),(0,a.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,a.kt)("p",null,'The logical negation ("not") is implemented by the unary operator\n',(0,a.kt)("inlineCode",{parentName:"p"},"not"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=not",group:"not"},"let not_1 : bool = not true  // false\nlet not_2 : bool = not false // true\n"))),(0,a.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,a.kt)("p",null,'The logical negation ("not") is implemented by the unary operator\n',(0,a.kt)("inlineCode",{parentName:"p"},"!"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=not",group:"not"},"const not_1: bool = !true  // false\nconst not_2: bool = !false // true\n"))),(0,a.kt)("h2",{id:"comparing"},"Comparing"),(0,a.kt)("p",null,"Boolean values are the result of comparisons of values. Numbers and\nstrings are completely ordered. Booleans can be compared for\nequality. Two values need to be of the same type to be compared, but\nnot all values of the same type can be compared: only those with ",(0,a.kt)("em",null,"comparable types")," (a concept directly lifted from Michelson)\nsuch as ",(0,a.kt)("inlineCode",{parentName:"p"},"int"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"nat"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"string"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"bool")," itself. The comparison\noperators are overloaded so they are defined on all comparable types."),(0,a.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=comparing",group:"comparing"},"let a : bool = 1 = 1   // equality (true)\nlet b : bool = 1 <> 0  // inequality (true)\nlet c : bool = 1 > 0   // greater than (true)\nlet d : bool = 0 < 1   // lower than (true)\nlet e : bool = 0 >= 0  // greater than or equal (true)\nlet f : bool = 0 <= 0  // lower than or equal (true)\n"))),(0,a.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=comparing",group:"comparing"},"const a: bool = 1 == 1;  // equality (true)\nconst b: bool = 1 != 0;  // inequality (true)\nconst c: bool = 1 > 0;   // greater than (true)\nconst d: bool = 0 < 1;   // lower than (true)\nconst e: bool = 0 >= 0;  // greater than or equal (true)\nconst f: bool = 0 <= 0;  // lower than or equal (true)\n"))),(0,a.kt)("h2",{id:"conditional-expressions"},"Conditional expressions"),(0,a.kt)("p",null,"Conditional logic enables forking the control flow depending on the\nstate, that is, the values available at a given point in the code. Put\nin a less technical manner, conditionals enable decision making."),(0,a.kt)("p",null,"A conditional expression is made of three parts:"),(0,a.kt)("ol",null,(0,a.kt)("li",null," a condition, that is, a boolean expression;"),(0,a.kt)("li",null," an expression evaluated if, and only if, the condition is true;"),(0,a.kt)("li",null," an expression evaluated if, and only if, the condition is false.")),(0,a.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,a.kt)("p",null,"The syntax uses the keywords ",(0,a.kt)("inlineCode",{parentName:"p"},"if"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"then")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"else")," to separate the\nthree parts, like so:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=conditionals",group:"conditionals"},"let a = 0\nlet b = 1\nlet min = if a < b then a else b // min = 0\n"))),(0,a.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,a.kt)("p",null,"The syntax uses a ternary operator with the symbols ",(0,a.kt)("inlineCode",{parentName:"p"},"?")," and ",(0,a.kt)("inlineCode",{parentName:"p"},":")," to\nseparate the three parts:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=conditionals",group:"conditionals"},"const a = 0;\nconst b = 1;\nconst min = (a < b) ? a : b; // min == 0\n")),(0,a.kt)("p",null,"Note: Parentheses are often necessary before ",(0,a.kt)("inlineCode",{parentName:"p"},"?"),", but not always: you\ncan either rely on the compiler error message or always use\nparentheses.")))}d.isMDXComponent=!0}}]);