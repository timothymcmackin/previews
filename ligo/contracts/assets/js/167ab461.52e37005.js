"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[72975],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>u});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),l=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},m=function(e){var t=l(e.components);return a.createElement(p.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),d=l(n),u=r,g=d["".concat(p,".").concat(u)]||d[u]||c[u]||i;return n?a.createElement(g,o(o({ref:t},m),{},{components:n})):a.createElement(g,o({ref:t},m))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=d;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var l=2;l<i;l++)o[l]=n[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},48720:(e,t,n)=>{n.d(t,{D:()=>r.Z,Z:()=>i});var a=n(67294),r=n(75402);const i=function(e){return a.createElement(r.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},38444:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>p,toc:()=>m});var a=n(87462),r=(n(67294),n(3905)),i=n(48720);const o={id:"declaring",title:"Declaring"},s=void 0,p={unversionedId:"tezos/big_maps/declaring",id:"version-1.7.0/tezos/big_maps/declaring",title:"Declaring",description:"Ordinary maps are fine for contracts with a finite lifespan or a",source:"@site/versioned_docs/version-1.7.0/tezos/big_maps/declaring.md",sourceDirName:"tezos/big_maps",slug:"/tezos/big_maps/declaring",permalink:"/docs/tezos/big_maps/declaring",draft:!1,tags:[],version:"1.7.0",frontMatter:{id:"declaring",title:"Declaring"},sidebar:"docs",previous:{title:"Updating",permalink:"/docs/tezos/big_sets/updating"},next:{title:"Searching",permalink:"/docs/tezos/big_maps/searching"}},l={},m=[],c={toc:m};function d(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Ordinary maps are fine for contracts with a finite lifespan or a\nbounded number of users. For many contracts however, the intention is\nto have a map holding ",(0,r.kt)("em",{parentName:"p"},"many")," entries, potentially millions of\nthem. The cost of loading those entries into the environment each time\na user executes the contract would eventually become too expensive\nwere it not for ",(0,r.kt)("em",{parentName:"p"},"big maps"),". Big maps are a data structure offered by\nMichelson which handles the scaling concerns for us. In LIGO, the\ninterface for big maps is analogous to the one used for ordinary\nmaps."),(0,r.kt)("p",null,"For convenience, we duplicate here the documentation for maps in order\nto feature big maps, and we point out any relevant differences:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The hash of the keys are internally used to access the entries of\na big map, so this is advantageous when keys are large.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Since big maps are lazily-accessed maps, it makes no sense iterate\nover them. In particular, there is not equivalent to the function\n",(0,r.kt)("inlineCode",{parentName:"p"},"Map.size"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Big maps are not ",(0,r.kt)("em",{parentName:"p"},"packable"),", as this would assume that they are\nentirely serialised first."))),(0,r.kt)("p",null,"Big maps are a data structure which associates values of the same type\nto values of the same type. The former are called ",(0,r.kt)("em",{parentName:"p"},"key")," and the latter\n",(0,r.kt)("em",{parentName:"p"},"values"),". Together they make up a ",(0,r.kt)("em",{parentName:"p"},"binding"),". An additional requirement\nis that the type of the keys must be ",(0,r.kt)("em",{parentName:"p"},"comparable"),", in the Michelson\nsense."),(0,r.kt)("p",null,"As a consequence, the predefined type ",(0,r.kt)("inlineCode",{parentName:"p"},"big_map")," has two parameters:\nthe first is the type of the keys, and the second the type of the\nassociated values."),(0,r.kt)("p",null,"The empty big map is denoted by the predefined value\n",(0,r.kt)("inlineCode",{parentName:"p"},"Big_map.empty"),". A non-empty big map can be built by using the\nfunction ",(0,r.kt)("inlineCode",{parentName:"p"},"Big_map.literal")," which takes a list of pairs of key and\nvalues, and returns a big map containing them as bindings, and only\nthem."),(0,r.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=big_maps",group:"big_maps"},'type word       = string\ntype definition = string list\ntype dictionary = (word, definition) big_map\n\nlet empty_dict : dictionary = Big_map.empty\n\nlet dictionary : dictionary =\n  Big_map.literal [\n    ("one", ["The number 1."; "A member of a group."]);\n    ("two", ["The number 2"])]\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Big_map.literal")," predefined function builds a big map from a list\nof key-value pairs, ",(0,r.kt)("inlineCode",{parentName:"p"},"(<key>, <value>)"),'.  Note also the "',(0,r.kt)("inlineCode",{parentName:"p"},";"),'" to\nseparate individual map bindings. Note that ',(0,r.kt)("inlineCode",{parentName:"p"},'("<string value>":\naddress)')," means that we type-cast a string into an address.")),(0,r.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=big_maps",group:"big_maps"},'type word       = string;\ntype definition = list<string>;\ntype dictionary = big_map<word, definition>;\n\nconst empty_dict: dictionary = Big_map.empty;\n\nconst dictionary : dictionary =\n  Big_map.literal([\n    ["one", (["The number 1.", "A member of a group."] as definition)],\n    ["two", (["The number 2."] as definition)]]);\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Big_map.literal")," predefined function builds a big map from a list\nof key-value pairs, ",(0,r.kt)("inlineCode",{parentName:"p"},"[<key>, <value>]"),'.  Note also the "',(0,r.kt)("inlineCode",{parentName:"p"},","),'" to\nseparate individual big map bindings. Note that ',(0,r.kt)("inlineCode",{parentName:"p"},'"<string value>" as\naddress')," means that we type-cast a string into an address.")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note: Map keys are internally sorted by increasing values, so the\ntype of the keys be ",(0,r.kt)("em",{parentName:"p"},"comparable"),", that is, they obey a total order\n(any two keys can be compared).")))}d.isMDXComponent=!0}}]);