"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[15968],{3905:(e,t,a)=>{a.d(t,{Zo:()=>l,kt:()=>c});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function p(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var m=n.createContext({}),s=function(e){var t=n.useContext(m),a=t;return e&&(a="function"==typeof e?e(t):p(p({},t),e)),a},l=function(e){var t=s(e.components);return n.createElement(m.Provider,{value:t},e.children)},g={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,m=e.parentName,l=o(e,["components","mdxType","originalType","parentName"]),d=s(a),c=i,u=d["".concat(m,".").concat(c)]||d[c]||g[c]||r;return a?n.createElement(u,p(p({ref:t},l),{},{components:a})):n.createElement(u,p({ref:t},l))}));function c(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,p=new Array(r);p[0]=d;var o={};for(var m in t)hasOwnProperty.call(t,m)&&(o[m]=t[m]);o.originalType=e,o.mdxType="string"==typeof e?e:i,p[1]=o;for(var s=2;s<r;s++)p[s]=a[s];return n.createElement.apply(null,p)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},48720:(e,t,a)=>{a.d(t,{D:()=>i.Z,Z:()=>r});var n=a(67294),i=a(75402);const r=function(e){return n.createElement(i.Z.Consumer,null,(t=>{let{syntax:a}=t;return a===e.syntax?e.children:n.createElement(n.Fragment,null)}))}},96625:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>p,metadata:()=>m,toc:()=>l});var n=a(87462),i=(a(67294),a(3905)),r=a(48720);const p={title:"Big maps",id:"big_maps"},o=void 0,m={unversionedId:"data-types/big_maps",id:"data-types/big_maps",title:"Big maps",description:"Ordinary maps are fine for contracts with a finite lifespan or a",source:"@site/../docs/data-types/big_maps.md",sourceDirName:"data-types",slug:"/data-types/big_maps",permalink:"/docs/next/data-types/big_maps",draft:!1,tags:[],version:"current",frontMatter:{title:"Big maps",id:"big_maps"},sidebar:"docs",previous:{title:"Big sets",permalink:"/docs/next/data-types/big_sets"},next:{title:"Tickets",permalink:"/docs/next/data-types/tickets"}},s={},l=[{value:"Searching",id:"searching",level:2},{value:"Adding",id:"adding",level:2},{value:"Removing",id:"removing",level:2},{value:"Updating",id:"updating",level:2}],g={toc:l};function d(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},g,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Ordinary maps are fine for contracts with a finite lifespan or a\nbounded number of users. For many contracts however, the intention is\nto have a map holding ",(0,i.kt)("em",{parentName:"p"},"many")," entries, potentially millions of\nthem. The cost of loading those entries into the environment each time\na user executes the contract would eventually become too expensive\nwere it not for ",(0,i.kt)("em",{parentName:"p"},"big maps"),". Big maps are a data structure offered by\nMichelson which handles the scaling concerns for us. In LIGO, the\ninterface for big maps is analogous to the one used for ordinary\nmaps."),(0,i.kt)("p",null,"For convenience, we duplicate here the documentation for maps in order\nto feature big maps, and we point out any relevant differences:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The hash of the keys are internally used to access the entries of\na big map, so this is advantageous when keys are large.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Since big maps are lazily-accessed maps, it makes no sense iterate\nover them. In particular, there is not equivalent to the function\n",(0,i.kt)("inlineCode",{parentName:"p"},"Map.size"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Big maps are not ",(0,i.kt)("em",{parentName:"p"},"packable"),", as this would assume that they are\nentirely serialised first."))),(0,i.kt)("p",null,"Big maps are a data structure which associates values of the same type\nto values of the same type. The former are called ",(0,i.kt)("em",{parentName:"p"},"key")," and the latter\n",(0,i.kt)("em",{parentName:"p"},"values"),". Together they make up a ",(0,i.kt)("em",{parentName:"p"},"binding"),". An additional requirement\nis that the type of the keys must be ",(0,i.kt)("em",{parentName:"p"},"comparable"),", in the Michelson\nsense."),(0,i.kt)("p",null,"As a consequence, the predefined type ",(0,i.kt)("inlineCode",{parentName:"p"},"big_map")," has two parameters:\nthe first is the type of the keys, and the second the type of the\nassociated values."),(0,i.kt)("p",null,"The empty big map is denoted by the predefined value\n",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.empty"),". A non-empty big map can be built by using the\nfunction ",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.literal")," which takes a list of pairs of key and\nvalues, and returns a big map containing them as bindings, and only\nthem."),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=big_maps",group:"big_maps"},'type word       = string\ntype definition = string list\ntype dictionary = (word, definition) big_map\n\nlet empty_dict : dictionary = Big_map.empty\n\nlet dictionary : dictionary =\n  Big_map.literal [\n    ("one", ["The number 1."; "A member of a group."]);\n    ("two", ["The number 2"])]\n')),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.literal")," predefined function builds a big map from a list\nof key-value pairs, ",(0,i.kt)("inlineCode",{parentName:"p"},"(<key>, <value>)"),'.  Note also the "',(0,i.kt)("inlineCode",{parentName:"p"},";"),'" to\nseparate individual map bindings. Note that ',(0,i.kt)("inlineCode",{parentName:"p"},'("<string value>":\naddress)')," means that we type-cast a string into an address.")),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=big_maps",group:"big_maps"},'type word       = string;\ntype definition = list<string>;\ntype dictionary = big_map<word, definition>;\n\nconst empty_dict: dictionary = Big_map.empty;\n\nconst dictionary : dictionary =\n  Big_map.literal([\n    ["one", (["The number 1.", "A member of a group."] as definition)],\n    ["two", (["The number 2."] as definition)]]);\n')),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.literal")," predefined function builds a big map from a list\nof key-value pairs, ",(0,i.kt)("inlineCode",{parentName:"p"},"[<key>, <value>]"),'.  Note also the "',(0,i.kt)("inlineCode",{parentName:"p"},","),'" to\nseparate individual big map bindings. Note that ',(0,i.kt)("inlineCode",{parentName:"p"},'"<string value>" as\naddress')," means that we type-cast a string into an address.")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Note: Map keys are internally sorted by increasing values, so the\ntype of the keys be ",(0,i.kt)("em",{parentName:"p"},"comparable"),", that is, they obey a total order\n(any two keys can be compared).")),(0,i.kt)("h2",{id:"searching"},"Searching"),(0,i.kt)("p",null,"The predicate ",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.mem")," tests for membership in a given big map,\ngiven a purported key."),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=big_map_searching",group:"big_map_searching"},'let my_map : (int, string) big_map =\n  Big_map.literal [(1,"one"); (2,"two")]\nlet contains_2 : bool = Big_map.mem 2 my_map // = true\n'))),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=big_map_searching",group:"big_map_searching"},'const my_map: big_map<int,string> =\n  Big_map.literal([[1,"one"],[2,"two"]]);\nconst contains_2: bool = Big_map.mem(2, my_map); // == true\n'))),(0,i.kt)("p",null,"In practice, however, we would like to get the value associated to the\nkey we searched. This is achieved by means of ",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.find_opt"),"."),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=big_map_searching",group:"big_map_searching"},"let v : string option = Big_map.find_opt 2 my_map\n"))),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=big_map_searching",group:"big_map_searching"},"const v : option<string> = Big_map.find_opt(2, my_map);\n"))),(0,i.kt)("p",null,"Notice how the value we read is an optional value: this is to force\nthe reader to account for a missing key in the big map. This requires\n",(0,i.kt)("em",{parentName:"p"},"pattern matching"),"."),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=big_map_searching",group:"big_map_searching"},'let force_access key map =\n  match Big_map.find_opt key map with\n    Some value -> value\n  | None -> failwith "No value."\n'))),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=big_map_searching",group:"big_map_searching"},'let force_access = (key, map) => {\n  return match(Big_map.find_opt (key, map)) {\n    when(Some(value)): value;\n    when(None): failwith("No value.")\n  };\n};\n'))),(0,i.kt)("p",null,"In fact, the predefined function ",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.find")," does exactly that,\nexcept that the exception raised by ",(0,i.kt)("inlineCode",{parentName:"p"},"failwith")," carries the default\nstring ",(0,i.kt)("inlineCode",{parentName:"p"},'"MAP FIND"'),"."),(0,i.kt)("h2",{id:"adding"},"Adding"),(0,i.kt)("p",null,"Adding a binding to a big map is done by calling the function\n",(0,i.kt)("inlineCode",{parentName:"p"},"Big_Map.add"),". If the key was already present in the given big map,\nthe corresponding value is updated."),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=big_map_adding",group:"big_map_adding"},'let my_map : (int, string) big_map =\n  Big_map.literal [(1,"one"); (2,"two")]\nlet new_map = Big_map.add 3 "three" my_map\nlet contains_3 = Big_map.mem 3 new_map // = true\n'))),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=big_map_adding",group:"big_map_adding"},'const my_map: big_map<int,string> =\n  Big_map.literal([[1,"one"],[2,"two"]]);\nconst new_map = Big_map.add(3, "three", my_map);\nconst contains_3 = Big_map.mem(3, new_map); // == true\n'))),(0,i.kt)("h2",{id:"removing"},"Removing"),(0,i.kt)("p",null,"The function ",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.remove")," creates a big map containing the\nelements of a given big map, without a given element. If the element\nis not already present, the new big map is the same as the old one, as\nexpected."),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=big_map_removing",group:"big_map_removing"},'let my_map : (int, string) big_map =\n  Big_map.literal [(1,"one"); (2,"two")]\nlet new_map = Big_map.remove 2 my_map\nlet contains_3 = Big_map.mem 2 new_map // = false\n'))),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=big_map_removing",group:"big_map_removing"},'const my_map: big_map<int,string> =\n  Big_map.literal([[1,"one"],[2,"two"]]);\nconst new_map = Big_map.remove(2, my_map);\nconst contains_3 = Big_map.mem(2, new_map); // == false\n'))),(0,i.kt)("h2",{id:"updating"},"Updating"),(0,i.kt)("p",null,"Previous sections show how to add and remove a binding from a given\nbig map. The function ",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.update")," can do both depending whether\nsome value is given for the new binding or not: in the former case, a\nnew binding is added (and replaces any previous binding with the same\nkey); in the latter case, any binding with the same key is removed and\na new big map is returned."),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=big_map_updating",group:"big_map_updating"},'let my_map : (int, string) big_map =\n  Big_map.literal [(1,"one"); (2,"two")]\nlet map_with_3 = Big_map.update 3 (Some "three") my_map\nlet contains_3 = Big_map.mem 3 map_with_3 // = true\nlet map_without_2 = Big_map.update 2 None my_map\nlet contains_2 = Big_map.mem 2 map_without_2 // = false\n'))),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=big_map_updating",group:"big_map_updating"},'const my_map: big_map<int,string> =\n  Big_map.literal([[1,"one"],[2,"two"]]);\nconst map_with_3 = Big_map.update (3, Some("three"), my_map);\nconst contains_3 = Big_map.mem(3, map_with_3); // == true\nconst map_without_2 = Big_map.update(2, None(), my_map);\nconst contains_2 = Big_map.mem (2, map_without_2); // == false\n'))),(0,i.kt)("p",null,"When we want to update a big map, but also obtain the value of the\nupdated binding, we can use ",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.get_and_update"),"."),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=big_map_updating",group:"big_map_updating"},'// three = Some "three"\nlet three, map_without_3 = Big_map.get_and_update 3 None map_with_3\n'))),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=big_map_updating",group:"big_map_updating"},'// three == Some("three")\nconst [three, map_without_3] =\n  Big_map.get_and_update(3, None(), map_with_3);\n'))))}d.isMDXComponent=!0}}]);