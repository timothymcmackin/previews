"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[11410],{3905:(e,t,r)=>{r.d(t,{Zo:()=>p,kt:()=>d});var n=r(67294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var l=n.createContext({}),c=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},p=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(r),d=o,f=u["".concat(l,".").concat(d)]||u[d]||m[d]||a;return r?n.createElement(f,i(i({ref:t},p),{},{components:r})):n.createElement(f,i({ref:t},p))}));function d(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=r.length,i=new Array(a);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var c=2;c<a;c++)i[c]=r[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}u.displayName="MDXCreateElement"},59342:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var n=r(87462),o=(r(67294),r(3905));const a={id:"long-term",title:"Longer term"},i=void 0,s={unversionedId:"contributors/road-map/long-term",id:"version-1.5.0/contributors/road-map/long-term",title:"Longer term",description:"Soon enough, the Schema for the front-end will look like this:",source:"@site/versioned_docs/version-1.5.0/contributors/road-map/long-term.md",sourceDirName:"contributors/road-map",slug:"/contributors/road-map/long-term",permalink:"/previews/ligo/contracts/docs/1.5.0/contributors/road-map/long-term",draft:!1,tags:[],version:"1.5.0",frontMatter:{id:"long-term",title:"Longer term"}},l={},c=[{value:"Super Type System",id:"super-type-system",level:2}],p={toc:c};function m(e){let{components:t,...a}=e;return(0,o.kt)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Soon enough, the Schema for the front-end will look like this:"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"LIGO Overview",src:r(41448).Z,width:"1408",height:"828"})),(0,o.kt)("p",null,"Basically, as we support more syntaxes (up to half a dozen), we\u2019ll have a bigger need for a unified representation and generation of the helpers around it.\nFor instance:\nParsers. So far, parsers are generated by LR grammars. LR grammars have a steep learning curve, regularly making not worth it for someone to learn the whole formalism to extend a given grammar with a few cases. Generating those LR Grammars would thus save a lot of time.\nDisplayers. The idea is that if you can parse and display code in a given syntax, it becomes much easier to have a translator between each syntax. So that not only it becomes possible for users to write code in their favourite syntax, but also to only read code in their favourite syntax.\nBNFs. BNF grammars are a common formalism to represent grammars. They are understood by many tools, and are an easy way to document a given syntax."),(0,o.kt)("h2",{id:"super-type-system"},"Super Type System"),(0,o.kt)("p",null,"Soon enough, the Schema for the middle-end will look like this:\n",(0,o.kt)("img",{alt:"LIGO Overview",src:r(12439).Z,width:"1410",height:"838"}),"\nBasically, this schema shows that the Back-End will stop being the main consumer of the Typed AST, and the External World will in its stead.\nAs such, annotating the AST with quality information, documenting it and exposing the libraries that produced the information in the first place will be paramount.\nThe imagined type-system so far is a mixture of MLF, extensible data-types and Algebraic Effects."))}m.isMDXComponent=!0},41448:(e,t,r)=>{r.d(t,{Z:()=>n});const n=r.p+"assets/images/generic-front-end-3f46274e15155257fb79fa3f278f12ab.png"},12439:(e,t,r)=>{r.d(t,{Z:()=>n});const n=r.p+"assets/images/super-type-system-20c1bcc61c21fafe57f8687df3a8d6d7.png"}}]);