"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9541],{48720:(e,t,n)=>{n.d(t,{D:()=>i.Z,Z:()=>s});var a=n(67294),i=n(75402);const s=function(e){return a.createElement(i.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},99191:(e,t,n)=>{n.d(t,{Z:()=>u});var a=n(43164),i=n(67294),s=n(52263),r=n(48720),o=n(11506);function l(){return l=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},l.apply(this,arguments)}const{Prism:c}=n(43164);c.languages={...c.languages,cameligo:{...c.languages.ocaml,comment:[/(^|[^\\])\/\*[\s\S]*?\*\//,/\(\*[\s\S]*?\*\)/,/\/\/.*/]},jsligo:c.languages.typescript};const u=function(e){const{siteConfig:{themeConfig:{prism:t={}}}}=(0,s.Z)(),n=t.singleTheme||o.Z,[c,u]=(0,i.useState)(!1);return(0,i.useEffect)((()=>{u(!0)}),[]),i.createElement(r.D.Consumer,null,(t=>{let{syntax:s}=t;return s===e.syntax?i.createElement(a.default,l({},a.defaultProps,{key:c,language:e.syntax,code:e.children,theme:n}),(e=>{let{className:t,tokens:n,getLineProps:a,getTokenProps:s}=e;return i.createElement("h4",{className:t,style:{backgroundColor:"var(--ifm-background-color)",fontFamily:"var(--ifm-font-family-monospace)",lineHeight:"var(--ifm-pre-line-height)",fontSize:"1.1rem",fontWeight:"bold",padding:0,whiteSpace:"break-spaces",marginTop:"3rem"}},n.map(((e,t)=>i.createElement("div",a({line:e,key:t}),e.map(((e,t)=>i.createElement("span",s({token:e,key:t}))))))))})):i.createElement("div",null)}))}},98668:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>l,toc:()=>u});var a=n(87462),i=(n(67294),n(3905)),s=(n(48720),n(99191));const r={id:"test.next.mutation.all-reference",title:"all",hide_table_of_contents:!0},o=void 0,l={unversionedId:"reference/test.next.mutation.all-reference",id:"version-1.6.0/reference/test.next.mutation.all-reference",title:"all",description:"val func : &#39;a &#39;b.&#39;a -&gt; (&#39;a -&gt; &#39;b) -&gt; (&#39;b * mutation) list",source:"@site/versioned_docs/version-1.6.0/reference/test.next.mutation.all.md",sourceDirName:"reference",slug:"/reference/test.next.mutation.all-reference",permalink:"/docs/1.6.0/reference/test.next.mutation.all-reference",draft:!1,tags:[],version:"1.6.0",frontMatter:{id:"test.next.mutation.all-reference",title:"all",hide_table_of_contents:!0},sidebar:"API",previous:{title:"contract",permalink:"/docs/1.6.0/reference/test.next.account.contract-reference"},next:{title:"mutation",permalink:"/docs/1.6.0/reference/test.next.mutation-reference"}},c={},u=[],m={toc:u};function d(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)(s.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val func : 'a 'b.'a -> ('a -> 'b) -> ('b * mutation) list"),(0,i.kt)(s.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let func: <a, b>(_: a) => (_: (_: a) => b) => list<[b, mutation]>"),"Given a value to mutate (first argument), it will try all the mutations of it, passing each one to the function (second argument). In case no failure arises when running the function on a mutation, the failure and mutation involved will be added to the list to be returned.",(0,i.kt)(s.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val from_file : 'b 'p 's.string -> 's -> tez -> ((('p, 's) typed_address * ('p, 's) michelson_contract * int) -> 'b) -> ('b * mutation) list"),(0,i.kt)(s.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let from_file: <b, p, s>(_: string) => (_: s) => (_: tez) => (_: (_: [typed_address<p, s>, michelson_contract<p, s>, int]) => b) => list< [b, mutation] >"),"Given a contract from a file (passed by filepath, entrypoint and views), an initial storage and balance, it will originate mutants of the contract and pass the result to the function (last argument). In case no failure arises when running the function on a mutation, the failure and mutation involved will be added to the list to be returned.",(0,i.kt)(s.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val contract : 'p 's 'b.('p, 's) module_contract -> 's -> tez -> (('p, 's) typed_address -> ('p, 's) michelson_contract -> int -> 'b) -> ('b * mutation) list"),(0,i.kt)(s.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let contract: <p, s, b>(_: module_contract<p, s>) => (_: s) => (_: tez) => ( _: (_: typed_address<p, s>) => (_: michelson_contract<p, s>) => (_: int) => b ) => list<[b, mutation]>"),"Given a contract as a module/namespace, an initial storage and balance, it will originate mutants of the contract and pass the result to the function (last argument). In case no failure arises when running the function on a mutation, the failure and mutation involved will be added to the list to be returned.")}d.isMDXComponent=!0}}]);