"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[40886],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>u});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var o=a.createContext({}),p=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(o.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,l=e.originalType,o=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),c=p(n),u=i,f=c["".concat(o,".").concat(u)]||c[u]||d[u]||l;return n?a.createElement(f,r(r({ref:t},m),{},{components:n})):a.createElement(f,r({ref:t},m))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=n.length,r=new Array(l);r[0]=c;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var p=2;p<l;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},48720:(e,t,n)=>{n.d(t,{D:()=>i.Z,Z:()=>l});var a=n(67294),i=n(75402);const l=function(e){return a.createElement(i.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},66275:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>s,default:()=>c,frontMatter:()=>r,metadata:()=>o,toc:()=>m});var a=n(87462),i=(n(67294),n(3905)),l=n(48720);const r={title:"Lists"},s=void 0,o={unversionedId:"data-types/lists",id:"version-1.7.0/data-types/lists",title:"Lists",description:"Lists are linear collections of elements of the same type. Linear",source:"@site/versioned_docs/version-1.7.0/data-types/lists.md",sourceDirName:"data-types",slug:"/data-types/lists",permalink:"/docs/data-types/lists",draft:!1,tags:[],version:"1.7.0",frontMatter:{title:"Lists"},sidebar:"docs",previous:{title:"Variants",permalink:"/docs/data-types/variants"},next:{title:"Records",permalink:"/docs/data-types/records"}},p={},m=[{value:"Adding",id:"adding",level:2},{value:"Matching",id:"matching",level:2},{value:"Updating",id:"updating",level:2},{value:"Folding",id:"folding",level:2},{value:"Mapping",id:"mapping",level:2},{value:"Looping",id:"looping",level:2}],d={toc:m};function c(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Lists are linear collections of elements of the same type. Linear\nmeans that, in order to reach an element in a list, we must visit all\nthe elements before (sequential access). Elements can be repeated, as\nonly their order in the collection matters. The first element is\ncalled the ",(0,i.kt)("em",{parentName:"p"},"head"),", and the sub-list after the head is called the\n",(0,i.kt)("em",{parentName:"p"},"tail"),". For those familiar with algorithmic data structure, you can\nthink of a list a ",(0,i.kt)("em",{parentName:"p"},"stack"),", where the top is written on the left."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"\ud83d\udca1 Lists are needed when returning operations from a smart\ncontract.")),(0,i.kt)("p",null,'The type for lists is polymorphic, that is, parameterised by the type\nof the list elements, so we can define a "list of integers", a "list\nof natural numbers" etc.'),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=lists",group:"lists"},"let empty_list : int list = []\nlet my_list : int list = [1; 2; 2] (* The head is 1, the tail is [2; 2] *)\n")),(0,i.kt)("p",null,"See predefined\n",(0,i.kt)("a",{parentName:"p",href:"../reference/list-reference/?lang=cameligo"},"module List"),".")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=lists",group:"lists"},"const empty_list : list<int> = [];\nconst my_list : list<int> = [1, 2, 2]; // The head is 1, the tail is [2, 2]\n")),(0,i.kt)("p",null,"Note how we need to use the cast ",(0,i.kt)("inlineCode",{parentName:"p"},"list(...)")," on a tuple to make it a\nlist. In general, tuples are not lists: tuples have a fixed number of\ncomponents that appear in their type, and each component can have a\ndifferent type, whereas lists have a variable number of elements and\nthey have all the same type. Nevertheless, LIGO uses the same syntax\nfor tuples and lists, except that the latter is enclosed in\n",(0,i.kt)("inlineCode",{parentName:"p"},"list(...)"),", except when the context makes it unambiguous that it is a\nlist (we will see some example with pattern matching)."),(0,i.kt)("p",null,"See predefined\n",(0,i.kt)("a",{parentName:"p",href:"../reference/list-reference/?lang=jsligo"},"namespace List"),".")),(0,i.kt)("h2",{id:"adding"},"Adding"),(0,i.kt)("p",null,"Lists can be augmented by adding an element before the head (or, in\nterms of stack, by ",(0,i.kt)("em",{parentName:"p"},"pushing an element on top"),"). This operation is\nusually called ",(0,i.kt)("em",{parentName:"p"},"consing")," in functional languages."),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The ",(0,i.kt)("em",{parentName:"p"},"cons operator"),' is infix and noted "',(0,i.kt)("inlineCode",{parentName:"p"},"::"),'". It is not symmetric: on\nthe left lies the element to cons, and, on the right, a list on which\nto cons.'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=consing",group:"consing"},"let short_list = [1; 2; 2]\n// long_list = [5; 1; 2; 2]\nlet long_list : int list = 5 :: short_list\n")),(0,i.kt)("p",null,"There is also a predefined function ",(0,i.kt)("inlineCode",{parentName:"p"},"List.cons"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=consing",group:"consing"},"// longer_list = [6; 5; 1; 2; 2]\nlet longer_list = List.cons 6 long_list\n")),(0,i.kt)("p",null,"See predefined\n",(0,i.kt)("a",{parentName:"p",href:"../reference/list-reference/?lang=cameligo"},"module List"),".")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The ",(0,i.kt)("em",{parentName:"p"},"cons operator"),' is infix and noted "',(0,i.kt)("inlineCode",{parentName:"p"},", ..."),'". It is not symmetric:\non the left lies the element to cons, and, on the right, a list on\nwhich to cons.'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=consing",group:"consing"},"const short_list : list<int> = [1, 2, 2];\n// long_list == [5,1,2,2]\nconst long_list : list<int> = [5, ...short_list];\n")),(0,i.kt)("p",null,"There is also a predefined function ",(0,i.kt)("inlineCode",{parentName:"p"},"List.cons"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=consing",group:"consing"},"// longer_list == [6, 5, 1, 2, 2]\nconst longer_list = List.cons(6, long_list);\n")),(0,i.kt)("p",null,"See predefined\n",(0,i.kt)("a",{parentName:"p",href:"../reference/list-reference/?lang=jsligo"},"namespace List"),".")),(0,i.kt)("h2",{id:"matching"},"Matching"),(0,i.kt)("p",null,"Polymorphism is especially useful when writing functions over\nparametric types, which include built-in types like lists, sets, and\nmaps."),(0,i.kt)("p",null,"As an example, we will see how to implement list reversing\nparametrically on any type, rather than just on lists of a specific\ntype."),(0,i.kt)("p",null,"Similarly to the polymorphic identity function, we can introduce a\ntype variable that can be generalised. We will write a direct version\nof the function using an accumulator."),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=reverse",group:"reverse"},"let rev (type a) (xs : a list) : a list =\n  let rec rev (type a) (xs : a list) (acc : a list) : a list =\n    match xs with\n    | [] -> acc\n    | x :: xs -> rev xs (x::acc)\n  in rev xs []\n")),(0,i.kt)("p",null,"Note that because the type variable ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," was introduced (bound) by\nmeans of ",(0,i.kt)("inlineCode",{parentName:"p"},"type"),", it does not need a quote, like ",(0,i.kt)("inlineCode",{parentName:"p"},"'a"),".")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=reverse",group:"reverse"},"function rev <T>(xs : list<T>) : list<T> {\n  const rev = <T>([xs, acc] : [list<T>, list<T>]) : list<T> =>\n    match(xs) {\n      when([]): acc;\n      when([y,...ys]): rev([ys, list([y,...acc])])\n    };\n\n  return rev([xs, []]);\n};\n")),(0,i.kt)("p",null,"Note how the type checker was able to infer the types of ",(0,i.kt)("inlineCode",{parentName:"p"},"[]")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"[y,...ys]")," in the ",(0,i.kt)("inlineCode",{parentName:"p"},"when")," clauses (without the need of using\n",(0,i.kt)("inlineCode",{parentName:"p"},"[]")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"[y,...ys]"),"), but in ",(0,i.kt)("inlineCode",{parentName:"p"},"[y,...acc]")," the cast\nto ",(0,i.kt)("inlineCode",{parentName:"p"},"list")," is necessary, because of the rest property that needs to be\ninterpreted as a cons. Similarly, the ",(0,i.kt)("inlineCode",{parentName:"p"},"list")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"[xs, []]")," is\nneeded to force the interpretation of ",(0,i.kt)("inlineCode",{parentName:"p"},"[]"),' as the empty list, instead\nof the empty array ("unit").'),(0,i.kt)("p",null,"See predefined\n",(0,i.kt)("a",{parentName:"p",href:"../reference/list-reference/?lang=cameligo"},"module List"),".")),(0,i.kt)("p",null,"We use an accumulator variable ",(0,i.kt)("inlineCode",{parentName:"p"},"acc")," to keep the elements of the list\nprocessed, consing each element on it."),(0,i.kt)("p",null,"As with the identity function, we can then use ",(0,i.kt)("inlineCode",{parentName:"p"},"rev")," directly with\ndifferent type instances:"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=reverse",group:"reverse"},"let ints : int list = rev [1; 2; 3]\nlet nats : nat list = rev [1n; 2n; 3n]\n"))),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=reverse",group:"reverse"},"const ints : list<int> = rev([1, 2, 3]);\nconst nats : list<nat> = rev([1n, 2n, 3n]);\n")),(0,i.kt)("p",null,"See predefined\n",(0,i.kt)("a",{parentName:"p",href:"../reference/list-reference/?lang=jsligo"},"namespace List"),".")),(0,i.kt)("h2",{id:"updating"},"Updating"),(0,i.kt)("p",null,"The function ",(0,i.kt)("inlineCode",{parentName:"p"},"List.update_with")," enables the replacement of elements of\na given list according to a boolean function: if the call of that\nfunction on a element is true, then the element is replaced, otherwise\nit remains."),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=list_updating",group:"list_updating"},"let nats = [0; 1; 2; 3; 4]\n// evens_zeroed = [0; 1; 0; 3; 0]\nlet evens_zeroed = List.update_with (fun x -> x mod 2 = 0n) 0 nats\n"))),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=list_updating",group:"list_updating"},"const nats : list<int> = [0, 1, 2, 3, 4];\n// evens_zeroed == [0, 1, 0, 3, 0]\nconst evens_zeroed = List.update_with(x => x % 2 == 0n, 0, nats);\n"))),(0,i.kt)("p",null,"The function ",(0,i.kt)("inlineCode",{parentName:"p"},"List.update")," enables the selective replacement of\nelements of a given list according to a function that returns an\noptional value, instead of a boolean as ",(0,i.kt)("inlineCode",{parentName:"p"},"List.update_with")," above."),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"That function takes an element and returns an optional value: if that\nvalue is ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),", then the element is left unchanged, otherwise, if the\nvalue is ",(0,i.kt)("inlineCode",{parentName:"p"},"Some v"),", then the element is replaced in the resulting list\nby ",(0,i.kt)("inlineCode",{parentName:"p"},"v"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=list_updating",group:"list_updating"},"let f x = if x mod 2 = 0n then None else Some (x*x)\n// odds = [0; 1; 2; 9; 4]\nlet odds_squared = List.update f nats\n")),(0,i.kt)("p",null,"See predefined\n",(0,i.kt)("a",{parentName:"p",href:"../reference/list-reference/?lang=cameligo"},"module List"),".")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"That function takes an element and returns an optional value: if that\nvalue is ",(0,i.kt)("inlineCode",{parentName:"p"},"None()"),", then the element is left unchanged, otherwise, if\nthe value is ",(0,i.kt)("inlineCode",{parentName:"p"},"Some(v)"),", then the element is replaced in the resulting\nlist by ",(0,i.kt)("inlineCode",{parentName:"p"},"v"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=list_updating",group:"list_updating"},"const f = x => x % 2 == 0n ? None() : Some(x*x);\n// odds == [0, 1, 2, 9, 4]\nconst odds_squared = List.update(f, nats);\n")),(0,i.kt)("p",null,"See predefined\n",(0,i.kt)("a",{parentName:"p",href:"../reference/list-reference/?lang=jsligo"},"namespace List"),".")),(0,i.kt)("h2",{id:"folding"},"Folding"),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"functional iterator")," is a function that traverses a data structure\nand calls in turn a given function over the elements of that structure\nto compute some value. Another approach is sometimes possible: ",(0,i.kt)("em",{parentName:"p"},"loops"),"\n(see sections loops, sets and maps)."),(0,i.kt)("p",null,"There are three kinds of functional iterations over lists: the ",(0,i.kt)("em",{parentName:"p"},"fold"),",\nthe ",(0,i.kt)("em",{parentName:"p"},"map")," (not to be confused with the ",(0,i.kt)("em",{parentName:"p"},"map data structure"),") and the\n",(0,i.kt)("em",{parentName:"p"},"iteration"),"."),(0,i.kt)("p",null,"Let us consider first here the fold, which is the most general form of\nfunctional iteration. The folded function takes two arguments: an\n",(0,i.kt)("em",{parentName:"p"},"accumulator")," and the structure ",(0,i.kt)("em",{parentName:"p"},"element")," at hand, with which it then\nproduces a new accumulator. This enables having a partial result that\nbecomes complete when the traversal of the data structure is over."),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The module ",(0,i.kt)("inlineCode",{parentName:"p"},"List")," exports the functions ",(0,i.kt)("inlineCode",{parentName:"p"},"fold_left")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"fold_right"),",\nso folds have either the form:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"List.fold_left folded init list\n")),(0,i.kt)("p",null,"or"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"List.fold_right folded list init\n")),(0,i.kt)("p",null,"which means that the folding can be done leftwards or rightwards on\nthe list. One way to tell them apart is to look where the folded\nfunction, and the fold itself, keep the accumulator in their\nsignatures. Take for example a function ",(0,i.kt)("inlineCode",{parentName:"p"},"f"),", a list ",(0,i.kt)("inlineCode",{parentName:"p"},"[1; 2; 3]"),", and\nan initial accumulator ",(0,i.kt)("inlineCode",{parentName:"p"},"init"),". Then"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"List.fold_left f init [1; 2; 3] = f (f (f (init, 1), 2), 3)\n")),(0,i.kt)("p",null,"and"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"List.fold_right f [1; 2; 3] init = f (1, f (2, f (3, init)))\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The type of ",(0,i.kt)("inlineCode",{parentName:"p"},"List.fold_left")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"('a * 'b -> 'a) -> 'a -> 'b list\n-> 'a"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The type of ",(0,i.kt)("inlineCode",{parentName:"p"},"List.fold_right")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"('b * 'a -> 'a) -> 'b list ->\n'a -> 'a"),"."))),(0,i.kt)("p",null,"For example, let us compute the sum of integers in a list, assuming\nthat the empty list yields ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=folding_lists",group:"folding_lists"},"let sum1 = List.fold_left (fun (a,i) -> a + i) 0 [1; 2; 3]\nlet sum2 = List.fold_right (fun (i,a) -> i + a) [1; 2; 3] 0\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"For OCaml users: In OCaml, the folded functions are curryfied, so\ntheir types are ",(0,i.kt)("inlineCode",{parentName:"p"},"('a -> 'b -> 'a)")," ",(0,i.kt)("inlineCode",{parentName:"p"},"List.fold_left"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"('b -> 'a\n-> 'a)")," with ",(0,i.kt)("inlineCode",{parentName:"p"},"List.fold_right"),".")),(0,i.kt)("p",null,"See predefined\n",(0,i.kt)("a",{parentName:"p",href:"../reference/list-reference/?lang=cameligo"},"module List"),".")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The module ",(0,i.kt)("inlineCode",{parentName:"p"},"List")," exports the functions ",(0,i.kt)("inlineCode",{parentName:"p"},"fold_left")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"fold_right"),",\nso folds have either the form:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"List.fold_left (folded, init, list)\n")),(0,i.kt)("p",null,"or"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"List.fold_right (folded, list, init)\n")),(0,i.kt)("p",null,"which mean that the folding can be done leftwards or rightwards on the\nlist. One way to tell them apart is to look where the folded function,\nand the fold itself, keep the accumulator in their signatures. Take\nfor example a function ",(0,i.kt)("inlineCode",{parentName:"p"},"f"),", a list ",(0,i.kt)("inlineCode",{parentName:"p"},"[1, 2, 3]"),", and an initial\naccumulator ",(0,i.kt)("inlineCode",{parentName:"p"},"init"),". Then"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"List.fold_left (f, init, [1;2;3]) = f (f (f (init, 1), 2), 3)\n")),(0,i.kt)("p",null,"and"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"List.fold_right (f, [1;2;3], init) = f (1, (f (2, (f (3, init)))))\n")),(0,i.kt)("p",null,"The type of ",(0,i.kt)("inlineCode",{parentName:"p"},"List.fold_left")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"(p : [a * b => a, a, b list]) => a"),"."),(0,i.kt)("p",null,"The type of ",(0,i.kt)("inlineCode",{parentName:"p"},"List.fold_right")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"(p : [b * a => a, b list, a]) => a"),"."),(0,i.kt)("p",null,"For example, let us compute the sum of integers in a list, assuming\nthat the empty list yields ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=folding_lists",group:"folding_lists"},"const add1 = ([a, i]) => a + i;\nconst sum1 = List.fold_left(add1, 0, [1, 2, 3]);\nconst add2 = ([i, a]) => i + a;\nconst sum2 = List.fold_right(add2, [1, 2, 3], 0);\n")),(0,i.kt)("p",null,"See predefined\n",(0,i.kt)("a",{parentName:"p",href:"../reference/list-reference/?lang=jsligo"},"namespace List"),".")),(0,i.kt)("h2",{id:"mapping"},"Mapping"),(0,i.kt)("p",null,"We may want to change all the elements of a given list by applying to\nthem a function. This is called a ",(0,i.kt)("em",{parentName:"p"},"map operation"),", not to be confused\nwith the map data structure. The predefined functional iterator\nimplementing the mapped operation over lists is called ",(0,i.kt)("inlineCode",{parentName:"p"},"List.map")," and\nis used as follows."),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=map_lists",group:"map_lists"},"let plus_one = List.map (fun i -> i + 1) [6; 2; 3; 3]\n")),(0,i.kt)("p",null,"See predefined\n",(0,i.kt)("a",{parentName:"p",href:"../reference/list-reference/?lang=cameligo"},"module List"),".")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=map_lists",group:"map_lists"},"const plus_one = List.map(i => i + 1, [6, 2, 3, 3]);\n")),(0,i.kt)("p",null,"See predefined\n",(0,i.kt)("a",{parentName:"p",href:"../reference/list-reference/?lang=jsligo"},"namespace List"),".")),(0,i.kt)("h2",{id:"looping"},"Looping"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},"There is no loop over lists in CameLIGO.",(0,i.kt)("p",null,"See predefined\n",(0,i.kt)("a",{parentName:"p",href:"../reference/list-reference/?lang=cameligo"},"module List"),".")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"One can iterate through all the elements of a list, from left to\nright, thanks to a loop of the form ",(0,i.kt)("inlineCode",{parentName:"p"},"for (const <variable> of <list>) <block>"),". It means that the ",(0,i.kt)("inlineCode",{parentName:"p"},"<block>")," of statements (or a single\nstatement) will be computed once for each ",(0,i.kt)("inlineCode",{parentName:"p"},"<variable>")," ranging over\nthe elements of the list ",(0,i.kt)("inlineCode",{parentName:"p"},"<list>")," from left to right."),(0,i.kt)("p",null,"Here is an example where the integers in a list are summed up, and the\nsum is zero if the list is empty:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=list_looping",group:"list_looping"},"function sum_list (l: list<int>) {\n  let sum = 0;\n  for (const i of l) sum = sum + i;\n  return sum;\n};\n")),(0,i.kt)("p",null,"See predefined\n",(0,i.kt)("a",{parentName:"p",href:"../reference/list-reference/?lang=jsligo"},"namespace List"),".")))}c.isMDXComponent=!0}}]);