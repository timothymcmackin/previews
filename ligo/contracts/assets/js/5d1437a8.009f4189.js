"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[93478],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>g});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var i=a.createContext({}),c=function(e){var n=a.useContext(i),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},u=function(e){var n=c(e.components);return a.createElement(i.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=c(t),g=r,m=d["".concat(i,".").concat(g)]||d[g]||p[g]||o;return t?a.createElement(m,s(s({ref:n},u),{},{components:t})):a.createElement(m,s({ref:n},u))}));function g(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,s=new Array(o);s[0]=d;var l={};for(var i in n)hasOwnProperty.call(n,i)&&(l[i]=n[i]);l.originalType=e,l.mdxType="string"==typeof e?e:r,s[1]=l;for(var c=2;c<o;c++)s[c]=t[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},48720:(e,n,t)=>{t.d(n,{D:()=>r.Z,Z:()=>o});var a=t(67294),r=t(75402);const o=function(e){return a.createElement(r.Z.Consumer,null,(n=>{let{syntax:t}=n;return t===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},11272:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>d,frontMatter:()=>s,metadata:()=>i,toc:()=>u});var a=t(87462),r=(t(67294),t(3905)),o=t(48720);const s={id:"constants-and-variables",title:"Constants & Variables"},l=void 0,i={unversionedId:"language-basics/constants-and-variables",id:"version-1.5.0/language-basics/constants-and-variables",title:"Constants & Variables",description:"The next building block after types are constants and variables.",source:"@site/versioned_docs/version-1.5.0/language-basics/variables-and-constants.md",sourceDirName:"language-basics",slug:"/language-basics/constants-and-variables",permalink:"/previews/ligo/contracts/docs/1.5.0/language-basics/constants-and-variables",draft:!1,tags:[],version:"1.5.0",frontMatter:{id:"constants-and-variables",title:"Constants & Variables"}},c={},u=[{value:"Constants",id:"constants",level:2},{value:"Variables",id:"variables",level:2},{value:"Escaped Identifiers",id:"escaped-identifiers",level:2}],p={toc:u};function d(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The next building block after types are ",(0,r.kt)("em",{parentName:"p"},"constants")," and ",(0,r.kt)("em",{parentName:"p"},"variables"),"."),(0,r.kt)("h2",{id:"constants"},"Constants"),(0,r.kt)("p",null,"Constants are immutable by design, which means their values cannot be\nreassigned. Put in another way, they can be assigned once, at their\ndeclaration. When defining a constant you need to provide a ",(0,r.kt)("inlineCode",{parentName:"p"},"name"),",\n",(0,r.kt)("inlineCode",{parentName:"p"},"type")," and a ",(0,r.kt)("inlineCode",{parentName:"p"},"value"),":"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=const",group:"const"},"let age : int = 25\n")),(0,r.kt)("p",null,"You can evaluate the constant definition above using the following CLI\ncommand:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"ligo run evaluate-expr gitlab-pages/docs/language-basics/src/variables-and-constants/const.mligo age\n# Outputs: 25\n"))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Constants in JsLIGO are enforced:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},"const x = do {\n  const age = 25;\n  age = 3; // Yields an error\n};\n")),(0,r.kt)("p",null,"Unlike the other syntaxes, JsLIGO doesn't allow variable names to be reused in the same block scope:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},"const x = () => {\n  const age = 25;\n  const age = 3; // Yields an error\n};\n")),(0,r.kt)("p",null,"However, the following does work:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=d",group:"d"},"const x = () => {\n  const _age = 25;\n  {\n    const _age = 3; // does not give an error\n    return _age;\n  }\n};\n")),(0,r.kt)("p",null,"You can evaluate a constant definition using the following CLI\ncommand:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=const",group:"const"},"const age : int = 25;\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"ligo run evaluate-expr gitlab-pages/docs/language-basics/src/variables-and-constants/const.jsligo age\n# Outputs: 25\n"))),(0,r.kt)("h2",{id:"variables"},"Variables"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("p",null,"As expected in the pure subset of a functional language, CameLIGO only\nfeatures ",(0,r.kt)("em",{parentName:"p"},"constant values"),': once they are declared, the value cannot\nbe changed (or "mutated").'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=add",group:"add"},"let add (a : int) (b : int) =\n  let c = a + b in c\n")),(0,r.kt)("p",null,"You can run the ",(0,r.kt)("inlineCode",{parentName:"p"},"add")," function defined above using the LIGO compiler\nlike this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"ligo run evaluate-expr gitlab-pages/docs/language-basics/src/variables-and-constants/add.mligo 'add 1 1'\n# Outputs: 2\n"))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("p",null,"Variables, unlike constants, are ",(0,r.kt)("em",{parentName:"p"},"mutable"),"."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"\u26a0\ufe0f Please be wary that mutation only works within the function scope\nitself, values outside of the function scope will not be\naffected. In other words, when a function is called, its arguments\nare copied, ",(0,r.kt)("em",{parentName:"p"},"as well as the environment"),". Any side-effect to that\nenvironment is therefore lost when the function returns.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=add",group:"add"},"let add = (a: int, b: int): int => {\n  let c = a;\n  c = c + b;\n  return c;\n}\n")),(0,r.kt)("p",null,"You can run the ",(0,r.kt)("inlineCode",{parentName:"p"},"add")," function defined above using the LIGO compiler\nlike this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"ligo run evaluate-expr gitlab-pages/docs/language-basics/src/variables-and-constants/add.jsligo 'add(1, 1)'\n# Outputs: 2\n"))),(0,r.kt)("h2",{id:"escaped-identifiers"},"Escaped Identifiers"),(0,r.kt)("p",null,"Both variables and constants are, at the level of the lexicon,\n",(0,r.kt)("em",{parentName:"p"},"identifiers"),". Each flavour of LIGO has its own set of\nkeywords. Sometimes we need an identifier that is the same as a\nkeyword, or, perhaps, we do not want to shadow a predefined\nidentifier, like ",(0,r.kt)("inlineCode",{parentName:"p"},"amount"),". In those cases, you could suffix your\nidentifier with an underscore, like ",(0,r.kt)("inlineCode",{parentName:"p"},"amount_"),". (Beware that if you\nprefix with an underscore, like ",(0,r.kt)("inlineCode",{parentName:"p"},"_amount"),", the compiler will not\ncomplain about the value being not used.) But this is not a good\npractice because we do not pronounce aloud the underscores, and there\nis the issue of one or two underscores. To solve all those problems,\nin LIGO, you can prefix you identifier with ",(0,r.kt)("inlineCode",{parentName:"p"},"@"),", like ",(0,r.kt)("inlineCode",{parentName:"p"},"@amount"),"."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=a",group:"a"},"let @Unique_name = true\n"))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=a",group:"a"},"const @Unique_name = true\n"))))}d.isMDXComponent=!0}}]);