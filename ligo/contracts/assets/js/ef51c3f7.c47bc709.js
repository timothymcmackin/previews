"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[65987],{3905:(t,e,n)=>{n.d(e,{Zo:()=>p,kt:()=>k});var a=n(67294);function r(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function i(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function o(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?i(Object(n),!0).forEach((function(e){r(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function s(t,e){if(null==t)return{};var n,a,r=function(t,e){if(null==t)return{};var n,a,r={},i=Object.keys(t);for(a=0;a<i.length;a++)n=i[a],e.indexOf(n)>=0||(r[n]=t[n]);return r}(t,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);for(a=0;a<i.length;a++)n=i[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(r[n]=t[n])}return r}var l=a.createContext({}),c=function(t){var e=a.useContext(l),n=e;return t&&(n="function"==typeof t?t(e):o(o({},e),t)),n},p=function(t){var e=c(t.components);return a.createElement(l.Provider,{value:e},t.children)},d={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},u=a.forwardRef((function(t,e){var n=t.components,r=t.mdxType,i=t.originalType,l=t.parentName,p=s(t,["components","mdxType","originalType","parentName"]),u=c(n),k=r,m=u["".concat(l,".").concat(k)]||u[k]||d[k]||i;return n?a.createElement(m,o(o({ref:e},p),{},{components:n})):a.createElement(m,o({ref:e},p))}));function k(t,e){var n=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var i=n.length,o=new Array(i);o[0]=u;var s={};for(var l in e)hasOwnProperty.call(e,l)&&(s[l]=e[l]);s.originalType=t,s.mdxType="string"==typeof t?t:r,o[1]=s;for(var c=2;c<i;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},12818:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>k,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var a=n(87462),r=(n(67294),n(3905));const i={id:"testing-tickets",title:"Testing tickets"},o=void 0,s={unversionedId:"testing/testing-tickets",id:"version-1.7.0/testing/testing-tickets",title:"Testing tickets",description:"Testing tickets requires some extra steps.",source:"@site/versioned_docs/version-1.7.0/testing/testing-tickets.md",sourceDirName:"testing",slug:"/testing/testing-tickets",permalink:"/docs/testing/testing-tickets",draft:!1,tags:[],version:"1.7.0",frontMatter:{id:"testing-tickets",title:"Testing tickets"},sidebar:"docs",previous:{title:"Testing",permalink:"/docs/testing/"},next:{title:"Mutation testing",permalink:"/docs/advanced/mutation-testing"}},l={},c=[{value:"The problem with testing tickets",id:"the-problem-with-testing-tickets",level:2},{value:"Proxy ticket contracts",id:"proxy-ticket-contracts",level:2},{value:"Usages",id:"usages",level:2},{value:"Transfer",id:"transfer",level:3},{value:"Origination",id:"origination",level:3}],p=(d="Syntax",function(t){return console.warn("Component "+d+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.kt)("div",t)});var d;const u={toc:c};function k(t){let{components:e,...n}=t;return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Testing tickets requires some extra steps."),(0,r.kt)("h2",{id:"the-problem-with-testing-tickets"},"The problem with testing tickets"),(0,r.kt)("p",null,"The Tezos protocol has two types of operations:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Internal operations are created from inside the chain, such as by smart contracts."),(0,r.kt)("li",{parentName:"ul"},"External operations are created from outside the chain, such as by the Octez client, other Tezos clients and SDKs, and in the context of LIGO testing, by functions such as ",(0,r.kt)("inlineCode",{parentName:"li"},"Test.Next.Originate.contract"),".\nFor more information about the technical implementation, see ",(0,r.kt)("a",{parentName:"li",href:"https://tezos.gitlab.io/active/michelson.html#semantics-of-smart-contracts-and-transactions"},"Semantics of smart contracts and transactions")," in the Octez documentation.")),(0,r.kt)("p",null,"In the protocol, both external and internal origination and transfer operations contain a piece of michelson code representing the initial storage for the origination or the parameter for the transfer."),(0,r.kt)("p",null,"Now imagine you have a value of type ",(0,r.kt)("inlineCode",{parentName:"p"},"parameter_ty"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"storage_ty")," containing a ticket, that you want to transfer or originate,\nin the operation data, tickets will be represented in Michelson as pairs:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"> ligo compile expression cameligo 'Tezos.create_ticket 0x0202 10n'\n(Pair \"KT1DUMMYDUMMYDUMMYDUMMYDUMMYDUMu2oHG\" 0x0202 10)\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"ticketer address , ticket value , ticket amount")),(0,r.kt)("p",null,'If we try to apply such an operation, the type wouldn\'t match: ticket of bytes VS some pair.\nThe protocol would not let you do that since you could be creating a ticket out of nowhere unless the operation happens to be forged from within a contract (i.e. "internally")!'),(0,r.kt)("p",null,'In the testing framework - for now - it means using "proxy-contracts" forging the operations using provided a ticket value and a ticket amount.'),(0,r.kt)("h2",{id:"proxy-ticket-contracts"},"Proxy ticket contracts"),(0,r.kt)("p",null,"The LIGO standard library provides a ",(0,r.kt)("inlineCode",{parentName:"p"},"Proxy_ticket")," module which helps in working with tickets in the Testing framework. Here is the interface of ",(0,r.kt)("inlineCode",{parentName:"p"},"Proxy_ticket"),":"),(0,r.kt)("hr",null),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"init_transfer")," accepts:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a function ",(0,r.kt)("inlineCode",{parentName:"li"},"mk_param")," which given a ticket must return a value of your parameter type")),(0,r.kt)("p",null,'and returns the typed address of a "transfer proxy-contract" which can then be used to do multiple transfers of tickets with the same ticketer address'),(0,r.kt)("hr",null),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"transfer")," accepts :"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},'the typed address of a "transfer proxy-contract"'),(0,r.kt)("li",{parentName:"ul"},"the ticket information (value and amount) together with the destination address")),(0,r.kt)("p",null,"and returns a value of type ",(0,r.kt)("inlineCode",{parentName:"p"},"test_exec_result")),(0,r.kt)("hr",null),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"originate")," accepts:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"the ticket information (value and amount)"),(0,r.kt)("li",{parentName:"ul"},"a function ",(0,r.kt)("inlineCode",{parentName:"li"},"mk_storage")," which given a ticket must return a value of your storage type"),(0,r.kt)("li",{parentName:"ul"},"your contract (having a ticket in its storage type)")),(0,r.kt)("hr",null),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note: Functions ",(0,r.kt)("inlineCode",{parentName:"p"},"mk_param")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"mk_storage")," will be executed in the proxy contract itself")),(0,r.kt)("p",null,"Find more detailed information on the API of ",(0,r.kt)("a",{parentName:"p",href:"/docs/reference/test.proxy-ticket-reference"},(0,r.kt)("inlineCode",{parentName:"a"},"Proxy_ticket")," here")),(0,r.kt)("h2",{id:"usages"},"Usages"),(0,r.kt)("h3",{id:"transfer"},"Transfer"),(0,r.kt)("p",null,"Here is an example using ",(0,r.kt)("inlineCode",{parentName:"p"},"Proxy_ticket.init_transfer")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Proxy_ticket.transfer"),":"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"import the module above as ",(0,r.kt)("inlineCode",{parentName:"li"},"Proxy_ticket")),(0,r.kt)("li",{parentName:"ol"},"define a contract ",(0,r.kt)("inlineCode",{parentName:"li"},"C")," holding a ticket of string in its parameter type. The contract will just store the value of\nthe received ticket and the address of the sender"),(0,r.kt)("li",{parentName:"ol"},"originate contract ",(0,r.kt)("inlineCode",{parentName:"li"},"C")),(0,r.kt)("li",{parentName:"ol"},'initialize a "transfer proxy-contract" providing a function to build a parameter out of a ticket'),(0,r.kt)("li",{parentName:"ol"},"transfer a ticket with a value ",(0,r.kt)("inlineCode",{parentName:"li"},'"hello"')," and an amount of ",(0,r.kt)("inlineCode",{parentName:"li"},"10")," to contract ",(0,r.kt)("inlineCode",{parentName:"li"},"C")),(0,r.kt)("li",{parentName:"ol"},"print the storage of contract ",(0,r.kt)("inlineCode",{parentName:"li"},"C")),(0,r.kt)("li",{parentName:"ol"},"transfer a ticket with a value ",(0,r.kt)("inlineCode",{parentName:"li"},'"world"')," and an amount of ",(0,r.kt)("inlineCode",{parentName:"li"},"5")," to contract ",(0,r.kt)("inlineCode",{parentName:"li"},"C")),(0,r.kt)("li",{parentName:"ol"},"print the storage of contract ",(0,r.kt)("inlineCode",{parentName:"li"},"C"))),(0,r.kt)(p,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"test-ligo group=usage_transfer","test-ligo":!0,group:"usage_transfer"},'module C = struct\n  type param = int * string ticket\n  type storage = string * address\n\n  [@entry]\n  let main (p : param) (_ : storage) : operation list * storage =\n    let (_,ticket) = p in\n    let (_,(v,_)) , _ = Tezos.read_ticket ticket in\n    [] , (v, Tezos.get_sender ())\nend\nlet test_transfer_to_contract =\n  let {addr = main_taddr; code = _ ; size = _} = Test.originate (contract_of C) ("bye",Test.nth_bootstrap_account 1) 1mutez in\n  let main_addr = Test.to_address main_taddr in\n\n  (* Use this address everytime you want to send tickets from the same proxy-contract *)\n  let proxy_taddr =\n    (* mk_param is executed __by the proxy contract__ *)\n    let mk_param : string ticket -> C.param = fun (t : string ticket) -> 42,t in\n    (* initialize a proxy contract in charge of creating and sending your tickets *)\n    Test.Proxy_ticket.init_transfer mk_param\n  in\n  let () = Test.log ("poxy addr:", proxy_taddr) in\n\n  let _ =\n    (* ticket_info lets you control the amount and the value of the tickets you send *)\n    let ticket_info = ("hello", 10n) in\n    (* we send ticket to C through the proxy-contract *)\n    Test.Proxy_ticket.transfer proxy_taddr (ticket_info,main_addr)\n  in\n  let () = Test.log (Test.get_storage main_taddr) in\n  let _ =\n    let ticket_info = ("world",5n) in\n    Test.Proxy_ticket.transfer proxy_taddr (ticket_info,main_addr)\n  in\n  let () = Test.log (Test.get_storage main_taddr) in\n  ()\n'))),(0,r.kt)(p,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"test-ligo group=usage_transfer","test-ligo":!0,group:"usage_transfer"},'namespace C {\n  export type param = [ int , ticket<string>]\n\n  @entry\n  function main (p: param, _s: [string , address]) : [list<operation> , [string , address]] {\n    let [_v,ticket] = p ;\n    let [[_addr,[v,_t]] , _ticket] = Tezos.read_ticket (ticket) ;\n    return ([[] , [v, Tezos.get_sender ()]])\n  };\n}\n\nconst test_transfer_to_contract = do {\n  let {addr : main_taddr, code , size } = Test.originate (contract_of(C), ["bye",Test.nth_bootstrap_account (1)], 1mutez) ;\n  let main_addr = Test.to_address (main_taddr) ;\n\n  /* mk_param is executed __by the proxy contract__ */\n  const mk_param = (t:ticket<string>) : C.param => { return [42,t] } ;\n  /* Use this address everytime you want to send tickets from the same proxy-contract */\n  /* initialize a proxy contract in charge of creating and sending your tickets */\n  let proxy_taddr = Test.Proxy_ticket.init_transfer (mk_param) ;\n  Test.log (["poxy addr:", proxy_taddr]) ;\n\n  /* ticket_info lets you control the amount and the value of the tickets you send */\n  let ticket_info1 = ["hello", 10n];\n  /* we send ticket to main through the proxy-contract */\n  Test.Proxy_ticket.transfer (proxy_taddr, [ticket_info1,main_addr]) ;\n  Test.log (Test.get_storage (main_taddr)) ;\n\n  let ticket_info2 = ["world",5n] ;\n  Test.Proxy_ticket.transfer (proxy_taddr, [ticket_info2,main_addr]) ;\n  Test.log (Test.get_storage (main_taddr));\n};\n'))),(0,r.kt)("p",null,"result:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'> ligo run test transfer_ticket.mligo\n("poxy addr:" , KT1QGANLjYsyJmw1QNww9Jkgb4ccQr6W2gsC)\n("hello" , KT1QGANLjYsyJmw1QNww9Jkgb4ccQr6W2gsC)\n("world" , KT1QGANLjYsyJmw1QNww9Jkgb4ccQr6W2gsC)\nEverything at the top-level was executed.\n- test_transfer_to_contract exited with value ().\n')),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note: note that the sender (stored in the contract) matches the address of the proxy contract")),(0,r.kt)("h3",{id:"origination"},"Origination"),(0,r.kt)("p",null,"Here is an example using ",(0,r.kt)("inlineCode",{parentName:"p"},"Proxy_ticket.originate")," and the type ",(0,r.kt)("inlineCode",{parentName:"p"},"unforged_ticket")," :"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"import the module above as ",(0,r.kt)("inlineCode",{parentName:"li"},"Proxy_ticket")),(0,r.kt)("li",{parentName:"ol"},"define a contract ",(0,r.kt)("inlineCode",{parentName:"li"},"main")," potentially holding a ticket of bytes in its storage. The contract will just reads the ticket\nin its storage if present. Note that we define two version of the contract storage type: one for the contract\nand one for the storage type that we would like to manipulate in our testing logic"),(0,r.kt)("li",{parentName:"ol"},"we define the ",(0,r.kt)("inlineCode",{parentName:"li"},"mk_storage")," function which simply wraps a ticket into an option type"),(0,r.kt)("li",{parentName:"ol"},"we define the ticket information for a ticket of value ",(0,r.kt)("inlineCode",{parentName:"li"},"0x0202")," and an amount of ",(0,r.kt)("inlineCode",{parentName:"li"},"15")),(0,r.kt)("li",{parentName:"ol"},"we call ",(0,r.kt)("inlineCode",{parentName:"li"},"originate")," and retrieve the address of the newly originated contract"),(0,r.kt)("li",{parentName:"ol"},"we use the address to fetch the current contract storage using ",(0,r.kt)("inlineCode",{parentName:"li"},"Test.get_storage_of_address")," and decompile it\nas a ",(0,r.kt)("inlineCode",{parentName:"li"},"human_storage")),(0,r.kt)("li",{parentName:"ol"},"we read the content of the ticket and perform a series of assertions")),(0,r.kt)(p,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"test-ligo group=usage_orig","test-ligo":!0,group:"usage_orig"},'(* originate.mligo *)\n\ntype storage = (bytes ticket) option\ntype unforged_storage = (bytes unforged_ticket) option\n\nlet main (() : unit) (s : storage) : operation list * storage =\n  [] , (\n    match s with\n    | Some ticket ->\n      let (_ , t) = Tezos.read_ticket ticket in\n      Some t\n    | None -> None\n  )\n\nlet test_originate_contract =\n  let mk_storage = fun (t:bytes ticket) -> Some t in\n  let ticket_info = (0x0202, 15n) in\n  let addr = Test.Proxy_ticket.originate ticket_info mk_storage main in\n  let unforged_storage : unforged_storage = Test.Proxy_ticket.get_storage addr in\n\n  (* the ticket \'unforged_storage\' can be manipulated freely without caring about ticket linearity *)\n\n  match unforged_storage with\n  | Some { ticketer ; value ; amount } ->\n    let () = Test.log ("unforged_ticket", unforged_storage) in\n    let () = assert (value = ticket_info.0) in\n    let () = assert (amount = ticket_info.1) in\n    ()\n  | None -> failwith "impossible"\n'))),(0,r.kt)(p,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"test-ligo group=usage_orig","test-ligo":!0,group:"usage_orig"},'type storage = option< ticket<bytes> >\ntype unforged_storage = option< unforged_ticket<bytes> >\n\nconst main = (_p: unit, s: storage) : [ list<operation> , storage] => {\n  let x =\n    match (s) {\n      when(Some(ticket)): ((ticket: ticket<bytes>) => {\n        let [_v , t] = Tezos.read_ticket (ticket) ;\n        return Some (t)\n      })(ticket);\n      when(None()): None()\n    };\n  return [list ([]), x]\n};\n\nconst test_originate_contract = do {\n  const mk_storage = (t:ticket<bytes>) : storage => { return (Some (t)) } ;\n  let ticket_info = [0x0202, 15n];\n  let addr = Test.Proxy_ticket.originate (ticket_info, mk_storage, main) ;\n  let unforged_storage = (Test.Proxy_ticket.get_storage (addr) as unforged_storage) ;\n\n  /* the ticket \'unforged_storage\' can be manipulated freely without caring about ticket linearity */\n\n  match (unforged_storage) {\n    when(Some(x)): do {\n      Test.log (["unforged_ticket", x]) ;\n      let { ticketer , value , amount } = x ;\n      assert (value == ticket_info[0]) ;\n      assert (amount == ticket_info[1]) ;\n      return unit\n    };\n    when(None()): failwith ("impossible")\n  }\n};\n'))),(0,r.kt)("p",null,"result:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'("unforged_ticket" , {amount = 15n ; ticketer = KT1Qp8u3v4seQHPYfpSw6eWvPG8CojH3m18G ; value = 0x0202})\nEverything at the top-level was executed.\n- test_originate_contract exited with value ().\n')))}k.isMDXComponent=!0}}]);