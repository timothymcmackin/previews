"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[60182],{48720:(e,n,t)=>{t.d(n,{D:()=>i.Z,Z:()=>l});var a=t(67294),i=t(75402);const l=function(e){return a.createElement(i.Z.Consumer,null,(n=>{let{syntax:t}=n;return t===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},99191:(e,n,t)=>{t.d(n,{Z:()=>r});var a=t(43164),i=t(67294),l=t(52263),p=t(48720),k=t(11506);function o(){return o=Object.assign?Object.assign.bind():function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e},o.apply(this,arguments)}const{Prism:m}=t(43164);m.languages={...m.languages,cameligo:{...m.languages.ocaml,comment:[/(^|[^\\])\/\*[\s\S]*?\*\//,/\(\*[\s\S]*?\*\)/,/\/\/.*/]},jsligo:m.languages.typescript};const r=function(e){const{siteConfig:{themeConfig:{prism:n={}}}}=(0,l.Z)(),t=n.singleTheme||k.Z,[m,r]=(0,i.useState)(!1);return(0,i.useEffect)((()=>{r(!0)}),[]),i.createElement(p.D.Consumer,null,(n=>{let{syntax:l}=n;return l===e.syntax?i.createElement(a.default,o({},a.defaultProps,{key:m,language:e.syntax,code:e.children,theme:t}),(e=>{let{className:n,tokens:t,getLineProps:a,getTokenProps:l}=e;return i.createElement("h4",{className:n,style:{backgroundColor:"var(--ifm-background-color)",fontFamily:"var(--ifm-font-family-monospace)",lineHeight:"var(--ifm-pre-line-height)",fontSize:"1.1rem",fontWeight:"bold",padding:0,whiteSpace:"break-spaces",marginTop:"3rem"}},t.map(((e,n)=>i.createElement("div",a({line:e,key:n}),e.map(((e,n)=>i.createElement("span",l({token:e,key:n}))))))))})):i.createElement("div",null)}))}},74153:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>o,default:()=>d,frontMatter:()=>k,metadata:()=>m,toc:()=>y});var a=t(87462),i=(t(67294),t(3905)),l=t(48720),p=t(99191);const k={id:"map-reference",title:"map",hide_table_of_contents:!0},o=void 0,m={unversionedId:"reference/map-reference",id:"version-1.7.0/reference/map-reference",title:"map",description:"Maps from keys to values, where the bindings key/value are ordered",source:"@site/versioned_docs/version-1.7.0/reference/map.md",sourceDirName:"reference",slug:"/reference/map-reference",permalink:"/previews/ligo/contracts/docs/reference/map-reference",draft:!1,tags:[],version:"1.7.0",frontMatter:{id:"map-reference",title:"map",hide_table_of_contents:!0},sidebar:"API",next:{title:"bytes",permalink:"/previews/ligo/contracts/docs/reference/bytes-reference"}},r={},y=[],s={toc:y};function d(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},s,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Maps from keys to values, where the bindings key/value are ordered\nby increasing keys."),(0,i.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type ('key, 'value) t = ('key, 'value) map"),(0,i.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type t<key, value> = map<key, value>"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The type ",(0,i.kt)("inlineCode",{parentName:"p"},"('key,'value) Map.t")," is an alias for ",(0,i.kt)("inlineCode",{parentName:"p"},"('key,'value) map"),".")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The type ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.t<key, value>")," is an alias for ",(0,i.kt)("inlineCode",{parentName:"p"},"map<key,value>"),".")),(0,i.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val empty : 'key 'value.('key, 'value) t"),(0,i.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let empty: <key, value>t<key, value>"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The value ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.empty")," is the empty map. In some contexts, it is\nuseful to annotate it with its type, for example:\n",(0,i.kt)("inlineCode",{parentName:"p"},"(Map.empty : (int, string) map)"),".")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The value ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.empty")," is the empty map. In some contexts, it is\nuseful to annotate it with its type, for example:\n",(0,i.kt)("inlineCode",{parentName:"p"},"(Map.empty as map<int, string>)"),".")),(0,i.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_and_update : 'key 'value.'key -> 'value option -> ('key, 'value) t -> ('value option * ('key, 'value) t)"),(0,i.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let get_and_update: <key, value>(_: key) => (_: option<value>) => (_: t<key, value>) => [option<value>, t<key, value>]"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.get_and_update key None map")," returns a copy of the map\n",(0,i.kt)("inlineCode",{parentName:"p"},"map")," without the entry for the key ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," (no change if\nthe key is absent). The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.get_and_update key (Some value) map"),"\nreturns a copy of the map ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," where there is an entry for the\nkey ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," associated with the value ",(0,i.kt)("inlineCode",{parentName:"p"},"value"),". In both cases, if\nthere was already a value ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," bound to ",(0,i.kt)("inlineCode",{parentName:"p"},"key"),", it is returned as\n",(0,i.kt)("inlineCode",{parentName:"p"},"Some v"),", otherwise ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),".")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.get_and_update(key, None(), map)")," returns a copy of the\nmap ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," without the entry for the key ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," (no change\nif the key is absent). The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.get_and_update(key, Some(value),\n    map)")," returns a copy of the map ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," where there is an entry for\nthe key ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," associated with the value ",(0,i.kt)("inlineCode",{parentName:"p"},"value"),". In both cases, if\nthere was already a value ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," bound to ",(0,i.kt)("inlineCode",{parentName:"p"},"key"),", it is returned as\n",(0,i.kt)("inlineCode",{parentName:"p"},"Some(v)"),", otherwise ",(0,i.kt)("inlineCode",{parentName:"p"},"None()"),".")),(0,i.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val update : 'key 'value.'key -> 'value option -> ('key, 'value) t -> ('key, 'value) t"),(0,i.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let update: <key, value>(_: key) => (_: option<value>) => (_: t<key, value>) => t<key, value>"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.update key None map")," returns a copy of the map ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),"\nwithout the entry for the key ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," (no change if the key\nis absent). The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.update key (Some value) map")," returns the map\n",(0,i.kt)("inlineCode",{parentName:"p"},"map")," where there is an entry for the key ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," associated with\nthe value ",(0,i.kt)("inlineCode",{parentName:"p"},"value"),". In both cases, the value originally bound to\n",(0,i.kt)("inlineCode",{parentName:"p"},"key")," is lost. See ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.get_and_update"),".")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.update(key, None(), map)")," returns a copy of the map ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),"\nwithout the entry for the key ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," (no change if the key\nis absent). The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.update(key, Some(value), map)")," returns the map\n",(0,i.kt)("inlineCode",{parentName:"p"},"map")," where there is an entry for the key ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," associated with\nthe value ",(0,i.kt)("inlineCode",{parentName:"p"},"value"),". In both cases, the value originally bound to\n",(0,i.kt)("inlineCode",{parentName:"p"},"key")," is lost. See ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.get_and_update"),".")),(0,i.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val add : 'key 'value.'key -> 'value -> ('key, 'value) t -> ('key, 'value) t"),(0,i.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let add: <key, value>(_: key) => (_: value) => (_: t<key, value>) => t<key, value>"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.add key value map")," returns a copy of the ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," where\nthere is a binding of key ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," to value ",(0,i.kt)("inlineCode",{parentName:"p"},"value"),". If there is a\nbinding for ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),", then it is lost.")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.add(key, value, map)")," returns a copy of the ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," where\nthere is a binding of key ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," to value ",(0,i.kt)("inlineCode",{parentName:"p"},"value"),". If there is a\nbinding for ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),", then it is lost.")),(0,i.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val remove : 'key 'value.'key -> ('key, 'value) t -> ('key, 'value) t"),(0,i.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let remove: <key, value>(_: key) => (_: t<key, value>) => t<key, value>"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.remove key map")," returns a copy of the map ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," where\nthe binding for key ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," is absent.")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.remove(key, map)")," returns a copy of the map ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," where\nthe binding for key ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," is absent.")),(0,i.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val literal : 'key 'value.('key * 'value) list -> ('key, 'value) t"),(0,i.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let literal: <key, value>(_: list<[key, value]>) => t<key, value>"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.literal [(k1,v1); ...; (kn,vn)]")," returns a map from\nthe pairs of key/value in the list. Note: The list must be a\nliteral, not an expression (compile-time list of values).")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.literal(list([[k1,v1], ..., [kn,vn]]))")," returns a map from\nthe pairs of key/value in the list. Note: The list must be a\nliteral, not an expression (compile-time list of values).")),(0,i.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val of_list : 'key 'value.('key * 'value) list -> ('key, 'value) t"),(0,i.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let of_list: <key, value>(_: list<[key, value]>) => t<key, value>"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.of_list bindings")," returns a map from the pairs of\nkey/value in the list ",(0,i.kt)("inlineCode",{parentName:"p"},"bindings"),". Note: Use ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.literal")," instead if\nusing a literal list.")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.of_list(bindings)")," returns a map from the pairs of\nkey/value in the list ",(0,i.kt)("inlineCode",{parentName:"p"},"bindings"),". Note: Use ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.literal")," instead if\nusing a literal list.")),(0,i.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val size : 'key 'value.('key, 'value) t -> nat"),(0,i.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let size: <key, value>(_: t<key, value>) => nat"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.size map")," evaluates in the number of entries in the\nmap ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),".")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.size(map)")," evaluates in the number of entries in the\nmap ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),".")),(0,i.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val mem : 'key 'value.'key -> ('key, 'value) t -> bool"),(0,i.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let mem: <key, value>(_: key) => (_: t<key, value>) => bool"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.mem key map")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," if, and only if, the key ",(0,i.kt)("inlineCode",{parentName:"p"},"key"),"\nis in the map ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),".")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.mem(key, map)")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," if, and only if, the key ",(0,i.kt)("inlineCode",{parentName:"p"},"key"),"\nis in the map ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),".")),(0,i.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val find_opt : 'key 'value.'key -> ('key, 'value) t -> 'value option"),(0,i.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let find_opt: <key, value>(_: key) => (_: t<key, value>) => option<value>"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.find_opt key map")," returns ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," if the key ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," is\npresent in the map ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),"; otherwise, it is ",(0,i.kt)("inlineCode",{parentName:"p"},"Some v"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," is\nthe value associated to ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),".")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.find_opt(key, map)")," returns ",(0,i.kt)("inlineCode",{parentName:"p"},"None()")," if the key ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," is\npresent in the map ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),"; otherwise, it is ",(0,i.kt)("inlineCode",{parentName:"p"},"Some(v)"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," is\nthe value associated to ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),".")),(0,i.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val find : 'key 'value.'key -> ('key, 'value) t -> 'value"),(0,i.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let find: <key, value>(_: key) => (_: t<key, value>) => value"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.find key map")," returns the value associated to ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," in\n",(0,i.kt)("inlineCode",{parentName:"p"},"map"),". If the key is absent, the execution fails with the string\n",(0,i.kt)("inlineCode",{parentName:"p"},'"MAP FIND"'),".")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.find(key, map)")," returns the value associated to ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," in\n",(0,i.kt)("inlineCode",{parentName:"p"},"map"),". If the key is absent, the execution fails with the string\n",(0,i.kt)("inlineCode",{parentName:"p"},'"MAP FIND"'),".")),(0,i.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val fold : 'key 'value 'acc.(('acc * 'key * 'value) -> 'acc) -> ('key, 'value) t -> 'acc -> 'acc"),(0,i.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let fold: <key, value, acc>(_: (_: [acc, [key, value]]) => acc) => (_: t<key, value>) => (_: acc) => acc"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.fold f map init")," is\n",(0,i.kt)("inlineCode",{parentName:"p"},"f ( ... f (f (init, (k1,v1)), (k2,v2)), ..., (kn,vn))"),"\nwhere ",(0,i.kt)("inlineCode",{parentName:"p"},"(k1,v1)"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"(k2,v2)"),", ..., ",(0,i.kt)("inlineCode",{parentName:"p"},"(kn,vn)")," are the bindings in the\nmap ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),", in increasing order of the keys ",(0,i.kt)("inlineCode",{parentName:"p"},"k1"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"k2"),", ..., and ",(0,i.kt)("inlineCode",{parentName:"p"},"kn"),".")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.fold(f, map, init)")," is\n",(0,i.kt)("inlineCode",{parentName:"p"},"f (... f (f (init, [k1,v1]), [k2,v2]), ..., [kn,vn])"),"\nwhere ",(0,i.kt)("inlineCode",{parentName:"p"},"[k1,v1]"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"[k2,v2]"),", ..., ",(0,i.kt)("inlineCode",{parentName:"p"},"[kn,vn]")," are the bindings in the\nmap ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),", in increasing order of the keys ",(0,i.kt)("inlineCode",{parentName:"p"},"k1"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"k2"),", ..., and ",(0,i.kt)("inlineCode",{parentName:"p"},"kn"),".")),(0,i.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val iter : 'key 'value.(('key * 'value) -> unit) -> ('key, 'value) t -> unit"),(0,i.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let iter: <key, value>(_: (_: [key, value]) => unit) => (_: t<key, value>) => unit"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.iter f map")," is\n",(0,i.kt)("inlineCode",{parentName:"p"},"let () = f (k1,v1) in let () = f (k2,v2) in ... in f (kn,vn)"),".")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.iter(f, map)")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"{f (k1,v1); (k2,v2); ...; f (kn,vn);}"),".")),(0,i.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val map : 'key 'value 'new_value.(('key * 'value) -> 'new_value) -> ('key, 'value) t -> ('key, 'new_value) t"),(0,i.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let map: <key, value, new_value>(_: (_: [key, value]) => new_value) => (_: t<key, value>) => t<key, new_value>"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.map f m"),", where the map ",(0,i.kt)("inlineCode",{parentName:"p"},"m")," contains the bindings\n",(0,i.kt)("inlineCode",{parentName:"p"},"(k1,v1)"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"(k2,v2)"),", ..., and ",(0,i.kt)("inlineCode",{parentName:"p"},"(kn,vn)")," in increasing order of\nthe keys, is the map containing the bindings ",(0,i.kt)("inlineCode",{parentName:"p"},"(k1, f (k1,v1))"),",\n",(0,i.kt)("inlineCode",{parentName:"p"},"(k2, f (k2,v2))"),", ..., ",(0,i.kt)("inlineCode",{parentName:"p"},"(kn, f (kn,vn))"),".")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.map(f, m)"),", where the map ",(0,i.kt)("inlineCode",{parentName:"p"},"m")," contains the bindings\n",(0,i.kt)("inlineCode",{parentName:"p"},"[k1,v1]"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"[k2,v2]"),", ..., and ",(0,i.kt)("inlineCode",{parentName:"p"},"[kn,vn]")," in increasing order of\nthe keys, is the map containing the bindings ",(0,i.kt)("inlineCode",{parentName:"p"},"[k1, f (k1,v1)]"),",\n",(0,i.kt)("inlineCode",{parentName:"p"},"[k2, f (k2,v2)]"),", ..., ",(0,i.kt)("inlineCode",{parentName:"p"},"[kn, f (kn,vn)]"),".")))}d.isMDXComponent=!0}}]);