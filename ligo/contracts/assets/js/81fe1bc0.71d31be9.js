"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[88389],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>d});var a=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var o=a.createContext({}),u=function(e){var n=a.useContext(o),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},c=function(e){var n=u(e.components);return a.createElement(o.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=u(t),d=i,g=m["".concat(o,".").concat(d)]||m[d]||p[d]||r;return t?a.createElement(g,l(l({ref:n},c),{},{components:t})):a.createElement(g,l({ref:n},c))}));function d(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,l=new Array(r);l[0]=m;var s={};for(var o in n)hasOwnProperty.call(n,o)&&(s[o]=n[o]);s.originalType=e,s.mdxType="string"==typeof e?e:i,l[1]=s;for(var u=2;u<r;u++)l[u]=t[u];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},48720:(e,n,t)=>{t.d(n,{D:()=>i.Z,Z:()=>r});var a=t(67294),i=t(75402);const r=function(e){return a.createElement(i.Z.Consumer,null,(n=>{let{syntax:t}=n;return t===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},43351:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>s,default:()=>m,frontMatter:()=>l,metadata:()=>o,toc:()=>c});var a=t(87462),i=(t(67294),t(3905)),r=t(48720);const l={id:"functions",title:"Functions"},s=void 0,o={unversionedId:"language-basics/functions",id:"language-basics/functions",title:"Functions",description:"LIGO functions are the basic building block of contracts. For example,",source:"@site/../docs/language-basics/functions.md",sourceDirName:"language-basics",slug:"/language-basics/functions",permalink:"/previews/ligo/contracts/docs/next/language-basics/functions",draft:!1,tags:[],version:"current",frontMatter:{id:"functions",title:"Functions"}},u={},c=[{value:"Declaring Functions",id:"declaring-functions",level:2},{value:"Anonymous functions (a.k.a. lambdas)",id:"anonymous-functions-aka-lambdas",level:2},{value:"Nested functions (also known as closures)",id:"nested-functions-also-known-as-closures",level:2},{value:"Recursive functions",id:"recursive-functions",level:2}],p={toc:c};function m(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"LIGO functions are the basic building block of contracts. For example,\nentrypoints are functions and each smart contract needs a main\nfunction that dispatches control to the entrypoints (it is not already\nthe default entrypoint)."),(0,i.kt)("p",null,"The semantics of function calls in LIGO is that of a ",(0,i.kt)("em",{parentName:"p"},"copy of the\narguments but also of the environment"),". In the case of JsLIGO, this\nmeans that any mutation (assignment) on variables outside the scope of\nthe function will be lost when the function returns, just as the\nmutations inside the functions will be."),(0,i.kt)("h2",{id:"declaring-functions"},"Declaring Functions"),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"Functions in CameLIGO are defined using the ",(0,i.kt)("inlineCode",{parentName:"p"},"let")," keyword, like other\nvalues. The difference is that a succession of parameters is provided\nafter the value name, followed by the return type. This follows OCaml\nsyntax. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=add",group:"add"},"let add (a : int) (b : int) : int = a + b\n")),(0,i.kt)("p",null,"You can call the function ",(0,i.kt)("inlineCode",{parentName:"p"},"add")," defined above using the LIGO compiler\nlike this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"ligo run evaluate-expr \\\n  gitlab-pages/docs/language-basics/src/functions/add.mligo \\\n  'add 1 2'\n# Outputs: 3\n")),(0,i.kt)("p",null,"CameLIGO is a little different from other syntaxes when it comes to\nfunction parameters. In OCaml, functions can only take one\nparameter. To get functions with multiple arguments like we are used\nto in imperative programming languages, a technique called\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Currying"},"currying")," is used.  Currying\nessentially translates a function with multiple arguments into a\nseries of single argument functions, each returning a new function\naccepting the next argument until every parameter is filled. This is\nuseful because it means that CameLIGO supports\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Partial_application"},"partial application"),"."),(0,i.kt)("p",null,"Currying is however ",(0,i.kt)("em",{parentName:"p"},"not")," the preferred way to pass function arguments\nin CameLIGO.  While this approach is faithful to the original OCaml,\nit is costlier in Michelson than naive function execution accepting\nmultiple arguments. Instead, for most functions with more than one\nparameter, we should gather the arguments in a\n",(0,i.kt)("a",{parentName:"p",href:"/previews/ligo/contracts/docs/next/language-basics/sets-lists-tuples"},"tuple")," and pass the tuple in as\na single parameter."),(0,i.kt)("p",null,"Here is how you define a basic function that accepts two integers and\nreturns an integer as well:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=curry",group:"curry"},"let add (a, b : int * int) : int = a + b             // Uncurried\nlet add_curry (a : int) (b : int) : int = add (a, b) // Curried\nlet increment : int -> int = add_curry 1             // Partial application\n")),(0,i.kt)("p",null,"You can run the ",(0,i.kt)("inlineCode",{parentName:"p"},"increment")," function defined above using the LIGO\ncompiler like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"ligo run evaluate-call \\\n  gitlab-pages/docs/language-basics/src/functions/curry.mligo \\\n  increment 5\n# Outputs: 6\n")),(0,i.kt)("p",null,"The function body is a single expression, whose value is returned."),(0,i.kt)("p",null,"By default, LIGO will warn about unused arguments inside\nfunctions. In case we do not use an argument, we can use the wildcard\n",(0,i.kt)("inlineCode",{parentName:"p"},"_")," to prevent warnings. Either use ",(0,i.kt)("inlineCode",{parentName:"p"},"_")," instead of the argument\nidentifier:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo"},"let k (x : int) (_ : int) = x\n")),(0,i.kt)("p",null,"or use an identifier starting with wildcard:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo"},"let k (x : int) (_y : int) = x\n")),(0,i.kt)("p",null,"Sometimes, one has to chain multiple function applications.\nIn this case, parentheses are needed."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=revapp",group:"revapp"},"let f (x : int) = x + 1\nlet g (x : int) = x - 2\nlet h (x : int) = x + x - 3\n\n(* Here we apply function f on value 42,\n   then apply g on the result,\n   and then apply h on the result *)\nlet result = h (g (f 42))\n\n(* Parentheses are indeed necessary here. If we remove them, we have : *)\n// let result' = h g f 42\n(* Which is different, it is equivalent to : *)\n// let result' = ((h g) f) 42\n")),(0,i.kt)("p",null,"Here, one might want to reduce the number of parentheses, for readability.\nIn this case, the reverse-application operator (",(0,i.kt)("inlineCode",{parentName:"p"},"|>"),") can be used instead."),(0,i.kt)("p",null,"Expression ",(0,i.kt)("inlineCode",{parentName:"p"},"f x")," can be rewritten as ",(0,i.kt)("inlineCode",{parentName:"p"},"x |> f"),",\nand ",(0,i.kt)("inlineCode",{parentName:"p"},"g (f x)")," can be rewritten as ",(0,i.kt)("inlineCode",{parentName:"p"},"x |> f |> g"),'\n(you can think of it as "I take ',(0,i.kt)("inlineCode",{parentName:"p"},"x"),", give it to function ",(0,i.kt)("inlineCode",{parentName:"p"},"f"),", and then the result to function ",(0,i.kt)("inlineCode",{parentName:"p"},"g"),'").'),(0,i.kt)("p",null,"Above ",(0,i.kt)("inlineCode",{parentName:"p"},"result")," can thus be rewritten as :"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=revapp",group:"revapp"},"let result = 42 |> f |> g |> h\n")),(0,i.kt)("p",null,"Function application has precedence over reverse-application operator,\nwhich means ",(0,i.kt)("inlineCode",{parentName:"p"},"f 42 |> g")," is the same as ",(0,i.kt)("inlineCode",{parentName:"p"},"(f 42) |> g")," and not ",(0,i.kt)("inlineCode",{parentName:"p"},"f (42 |> g)"),".\nSo you can rewrite ",(0,i.kt)("inlineCode",{parentName:"p"},"result")," as :"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=revapp",group:"revapp"},"let result = f 42 |> g |> h\n")),(0,i.kt)("p",null,"This can be useful when you have to deal with a long chain of function calls."),(0,i.kt)("p",null,"This operator actually comes from ",(0,i.kt)("a",{parentName:"p",href:"https://v2.ocaml.org/releases/4.02/htmlman/libref/Pervasives.html#6_Compositionoperators"},"OCaml's pervasives"),".\nOther similar operators will be added when enabling support for custom operator definition.")),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"Functions in JsLIGO can be defined in two main ways: using the keyword\n",(0,i.kt)("inlineCode",{parentName:"p"},"function")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"const")," (the keyword ",(0,i.kt)("inlineCode",{parentName:"p"},"let")," is defaulted to ",(0,i.kt)("inlineCode",{parentName:"p"},"const")," in\nthis instance). The latter manner is preferred when the function body\nis an expression. For example, here is how you define a basic function\nthat sums two integers:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=add",group:"add"},"const add = (a: int, b: int) => a + b;\n")),(0,i.kt)("p",null,"You can call the function ",(0,i.kt)("inlineCode",{parentName:"p"},"add")," defined above using the LIGO compiler\nlike this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"ligo run evaluate-expr \\\n  gitlab-pages/docs/language-basics/src/functions/add.jsligo \\\n  'add(1,2)'\n# Outputs: 3\n")),(0,i.kt)("p",null,"If the body contains statements instead of a single expression, you\nwould use a block and a ",(0,i.kt)("inlineCode",{parentName:"p"},"return")," statement:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=b",group:"b"},"const myFun = (x: int, y: int) => {\n  const doubleX = x + x;\n  const doubleY = y + y;\n  return doubleX + doubleY;\n};\n")),(0,i.kt)("p",null,"although it is arguably more readable to use ",(0,i.kt)("inlineCode",{parentName:"p"},"function"),", like so:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=b",group:"b"},"function myFun2 (x: int, y: int) {\n  const doubleX = x + x;\n  const doubleY = y + y;\n  return doubleX + doubleY;\n}\n")),(0,i.kt)("p",null,"Note that JsLIGO, like JavaScript, requires the ",(0,i.kt)("inlineCode",{parentName:"p"},"return")," keyword to indicate\nwhat is being returned. If ",(0,i.kt)("inlineCode",{parentName:"p"},"return")," is not used, it will be the same as\n",(0,i.kt)("inlineCode",{parentName:"p"},"return unit"),"."),(0,i.kt)("p",null,"By default, LIGO will warn about unused arguments inside\nfunctions. In case we do not use an argument, its name should start with\n",(0,i.kt)("inlineCode",{parentName:"p"},"_")," to prevent warnings."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo"},"const k_other = (x: int, _y: int) => x;\n"))),(0,i.kt)("h2",{id:"anonymous-functions-aka-lambdas"},"Anonymous functions (a.k.a. lambdas)"),(0,i.kt)("p",null,"It is possible to define functions without assigning them a name. They\nare useful when you want to pass them as arguments, or assign them to\na key in a record or a map."),(0,i.kt)("p",null,"Here is how to define an anonymous function:"),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=anon",group:"anon"},"let increment (b : int) : int = (fun (a : int) -> a + 1) b\nlet a = increment 1 // a = 2\n")),(0,i.kt)("p",null,"You can check the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," defined above using the LIGO compiler\nlike this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"ligo run evaluate-expr gitlab-pages/docs/language-basics/src/functions/anon.mligo a\n# Outputs: 2\n"))),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=anon",group:"anon"},"const increment = (b) => ((a) => a + 1) (b);\nconst a = increment(1); // a == 2\n")),(0,i.kt)("p",null,"You can check the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," defined above using the LIGO compiler\nlike this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"ligo run evaluate-expr gitlab-pages/docs/language-basics/src/functions/anon.jsligo a\n# Outputs: 2\n"))),(0,i.kt)("p",null,"If the example above seems contrived, here is a more common design\npattern for lambdas: to be used as parameters to functions. Consider\nthe use case of having a list of integers and mapping the increment\nfunction to all its elements."),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=incr_map",group:"incr_map"},"let incr_map (l : int list) : int list =\n  List.map (fun (i : int) -> i + 1) l\n")),(0,i.kt)("p",null,"You can call the function ",(0,i.kt)("inlineCode",{parentName:"p"},"incr_map")," defined above using the LIGO compiler\nlike so:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},'ligo run evaluate-call \\\n  gitlab-pages/docs/language-basics/src/functions/incr_map.mligo \\\n  incr_map "[1;2;3]"\n# Outputs: CONS(2 , CONS(3 , CONS(4 , LIST_EMPTY()))), equivalent to [ 2 ; 3 ; 4 ]\n'))),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=incr_map",group:"incr_map"},"let incr_map = l => List.map(i => i + 1, l);\n")),(0,i.kt)("p",null,"You can call the function ",(0,i.kt)("inlineCode",{parentName:"p"},"incr_map")," defined above using the LIGO compiler\nlike so:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},'ligo run evaluate-call \\\n  gitlab-pages/docs/language-basics/src/functions/incr_map.jsligo \\\n  incr_map "[1,2,3]"\n# Outputs: CONS(2 , CONS(3 , CONS(4 , LIST_EMPTY()))), equivalent to [2, 3, 4]\n'))),(0,i.kt)("h2",{id:"nested-functions-also-known-as-closures"},"Nested functions (also known as closures)"),(0,i.kt)("p",null,"It is possible to define a functions inside another function. These\nfunctions have access to variables in the same scope."),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo"},"let closure_example (i : int) : int =\n  let closure = fun (j : int) -> i + j in\n  closure i\n"))),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo"},"function closure_example (i) {\n  let closure = j => i + j;\n  return closure(i);\n};\n"))),(0,i.kt)("h2",{id:"recursive-functions"},"Recursive functions"),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},"In CameLIGO, recursive functions are defined using the `rec` keyword",(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=d",group:"d"},"let rec sum (n, acc : int * int) : int =\n  if n < 1 then acc else sum (n-1, acc + n)\n\nlet rec fibo (n, n_1, n_0 : int * int * int) : int =\n  if n < 2 then n_1 else fibo (n-1, n_1 + n_0, n_1)\n"))),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"In JsLigo, recursive functions are defined and called using the same syntax as non-recursive functions."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=d",group:"d"},"function sum (n: int, acc: int): int {\n  if (n < 1) return acc else return sum(n-1, acc + n);\n};\n\nfunction fibo (n: int, n_1: int, n_0: int): int {\n  if (n < 2) return n_1 else return fibo (n-1, n_1 + n_0, n_1);\n};\n"))))}m.isMDXComponent=!0}}]);