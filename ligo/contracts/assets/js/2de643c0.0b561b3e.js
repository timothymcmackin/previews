"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[64716],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>d});var a=n(67294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var o=a.createContext({}),p=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(o.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,s=e.mdxType,i=e.originalType,o=e.parentName,m=r(e,["components","mdxType","originalType","parentName"]),c=p(n),d=s,g=c["".concat(o,".").concat(d)]||c[d]||u[d]||i;return n?a.createElement(g,l(l({ref:t},m),{},{components:n})):a.createElement(g,l({ref:t},m))}));function d(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var i=n.length,l=new Array(i);l[0]=c;var r={};for(var o in t)hasOwnProperty.call(t,o)&&(r[o]=t[o]);r.originalType=e,r.mdxType="string"==typeof e?e:s,l[1]=r;for(var p=2;p<i;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},48720:(e,t,n)=>{n.d(t,{D:()=>s.Z,Z:()=>i});var a=n(67294),s=n(75402);const i=function(e){return a.createElement(s.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},59249:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>r,default:()=>c,frontMatter:()=>l,metadata:()=>o,toc:()=>m});var a=n(87462),s=(n(67294),n(3905)),i=n(48720);const l={id:"sets-lists-tuples",title:"Tuples, Lists, Sets"},r=void 0,o={unversionedId:"language-basics/sets-lists-tuples",id:"language-basics/sets-lists-tuples",title:"Tuples, Lists, Sets",description:"Apart from complex data types such as maps and records, LIGO also",source:"@site/../docs/language-basics/sets-lists-tuples.md",sourceDirName:"language-basics",slug:"/language-basics/sets-lists-tuples",permalink:"/docs/next/language-basics/sets-lists-tuples",draft:!1,tags:[],version:"current",frontMatter:{id:"sets-lists-tuples",title:"Tuples, Lists, Sets"}},p={},m=[{value:"Tuples",id:"tuples",level:2},{value:"Defining Tuples",id:"defining-tuples",level:3},{value:"Destructuring",id:"destructuring",level:3},{value:"Destructuring",id:"destructuring-1",level:3},{value:"Accessing Components",id:"accessing-components",level:3},{value:"Lists",id:"lists",level:2},{value:"Defining Lists",id:"defining-lists",level:3},{value:"Adding to Lists",id:"adding-to-lists",level:3},{value:"Accessing list elements",id:"accessing-list-elements",level:3},{value:"Functional Iteration over Lists",id:"functional-iteration-over-lists",level:3},{value:"Iterated Operation over Lists",id:"iterated-operation-over-lists",level:4},{value:"Mapped Operation over Lists",id:"mapped-operation-over-lists",level:4},{value:"Folded Operation over Lists",id:"folded-operation-over-lists",level:4},{value:"Sets",id:"sets",level:2},{value:"Empty Sets",id:"empty-sets",level:3},{value:"Non-empty Sets",id:"non-empty-sets",level:3},{value:"Adding an element to a Set",id:"adding-an-element-to-a-set",level:3},{value:"Set Membership",id:"set-membership",level:3},{value:"Cardinal of Sets",id:"cardinal-of-sets",level:3},{value:"Updating Sets",id:"updating-sets",level:3},{value:"Functional Iteration over Sets",id:"functional-iteration-over-sets",level:3},{value:"Iterated Operation",id:"iterated-operation",level:4},{value:"Folded Operation",id:"folded-operation",level:4}],u={toc:m};function c(e){let{components:t,...n}=e;return(0,s.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Apart from complex data types such as ",(0,s.kt)("inlineCode",{parentName:"p"},"maps")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"records"),", LIGO also\nfeatures ",(0,s.kt)("inlineCode",{parentName:"p"},"tuples"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"lists")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"sets"),"."),(0,s.kt)("h2",{id:"tuples"},"Tuples"),(0,s.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("p",null,"Tuples gather a given number of values in a specific order and those\nvalues, called ",(0,s.kt)("em",{parentName:"p"},"components"),", can be retrieved by their index\n(position).  Probably the most common tuple is the ",(0,s.kt)("em",{parentName:"p"},"pair"),". For\nexample, if we were storing coordinates on a two dimensional grid we\nmight use a pair ",(0,s.kt)("inlineCode",{parentName:"p"},"(x,y)")," to store the coordinates ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),". There\nis a ",(0,s.kt)("em",{parentName:"p"},"specific order"),", so ",(0,s.kt)("inlineCode",{parentName:"p"},"(y,x)")," is not equal to ",(0,s.kt)("inlineCode",{parentName:"p"},"(x,y)")," in\ngeneral. The number of components is part of the type of a tuple, so,\nfor example, we cannot add an extra component to a pair and obtain a\ntriple of the same type: ",(0,s.kt)("inlineCode",{parentName:"p"},"(x,y)")," has always a different type from\n",(0,s.kt)("inlineCode",{parentName:"p"},"(x,y,z)"),", whereas ",(0,s.kt)("inlineCode",{parentName:"p"},"(y,x)")," might have the same type as ",(0,s.kt)("inlineCode",{parentName:"p"},"(x,y)"),".")),(0,s.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("p",null,"Tuples gather a given number of values in a specific order and those\nvalues, called ",(0,s.kt)("em",{parentName:"p"},"components"),", can be retrieved by their index\n(position).  Probably the most common tuple is the ",(0,s.kt)("em",{parentName:"p"},"pair"),". For\nexample, if we were storing coordinates on a two dimensional grid we\nmight use a pair ",(0,s.kt)("inlineCode",{parentName:"p"},"[x, y]")," to store the coordinates ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"y"),". There\nis a ",(0,s.kt)("em",{parentName:"p"},"specific order"),", so ",(0,s.kt)("inlineCode",{parentName:"p"},"[y, x]")," is not equal to ",(0,s.kt)("inlineCode",{parentName:"p"},"[x, y]")," in\ngeneral. The number of components is part of the type of a tuple, so,\nfor example, we cannot add an extra component to a pair and obtain a\ntriple of the same type: ",(0,s.kt)("inlineCode",{parentName:"p"},"[x, y]")," has always a different type from\n",(0,s.kt)("inlineCode",{parentName:"p"},"[x, y, z]"),", whereas ",(0,s.kt)("inlineCode",{parentName:"p"},"[y, x]")," might have the same type as ",(0,s.kt)("inlineCode",{parentName:"p"},"[x, y]"),".")),"Like records, tuple components can be of arbitrary types.",(0,s.kt)("h3",{id:"defining-tuples"},"Defining Tuples"),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("a",{parentName:"p",href:"/docs/next/language-basics/maps-records"},"a record"),", tuple types do not\nhave to be defined before they can be used. However below we will give\nthem names by ",(0,s.kt)("em",{parentName:"p"},"type aliasing"),"."),(0,s.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=tuple",group:"tuple"},'type two_people = string * string  // Alias\n\nlet friends : two_people = ("Alice", "Johnson") // Optional parentheses\n'))),(0,s.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=tuple",group:"tuple"},'type two_people = [string, string];  // Alias\n\nconst friends: two_people = ["Alice", "Johnson"];\n'))),(0,s.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("h3",{id:"destructuring"},"Destructuring"),(0,s.kt)("p",null,"If we want to get the first and second names of the ",(0,s.kt)("inlineCode",{parentName:"p"},"two_people")," type, we can use\ndestructuring. Destructuring a tuple allows you to give names to the elements\ninside the tuple."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=tuple",group:"tuple"},"let (person_a, person_b) : two_people = friends\n")),(0,s.kt)("p",null,"This also works in functions:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=tuple",group:"tuple"},"let first_person ((person_a, _): two_people) = person_a\nlet alice = first_person friends\n")),(0,s.kt)("p",null,"Notice that we use the underscore to indicate that we ignore the last element\nof the tuple.")),(0,s.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("h3",{id:"destructuring-1"},"Destructuring"),(0,s.kt)("p",null,"If we want to get the first and second names of the ",(0,s.kt)("inlineCode",{parentName:"p"},"two_people")," type, we can use\ndestructuring. Destructuring a tuple allows you to give names to the elements\ninside the tuple."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=tuple",group:"tuple"},"let [person_a, person_b] = friends;\n")),(0,s.kt)("p",null,"This also works in functions:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=tuple",group:"tuple"},"let first_person_fun = ([person_a, _person_b]: two_people) => person_a;\nlet alice = first_person_fun(friends);\n")),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"note: the leading underscore to indicate that the argument ",(0,s.kt)("inlineCode",{parentName:"p"},"_person_b")," is unused.")),(0,s.kt)("p",null,"and within a code block:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=tuple",group:"tuple"},"let destruct_tuple = (x : [ int , [int , nat] ]) : nat => {\n  let [a,[b,c]] = x ;\n  return c\n};\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=tuple",group:"tuple"},"let destruct_record = (x : { a : int , b : string }) : int => {\n  let { a , b } = x ;\n  return a\n};\n")),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"note: nested patterns in record destructuring are not yet available"))),(0,s.kt)("h3",{id:"accessing-components"},"Accessing Components"),(0,s.kt)("p",null,"Accessing the components of a tuple in OCaml is achieved by\n",(0,s.kt)("a",{parentName:"p",href:"/docs/next/language-basics/unit-option-pattern-matching"},"pattern matching"),". LIGO\ncurrently supports tuple patterns only in the parameters of functions,\nnot in pattern matching. However, we can access components by their\nposition in their tuple, which cannot be done in OCaml. ",(0,s.kt)("em",{parentName:"p"},"Tuple\ncomponents are zero-indexed"),", that is, the first component has index\n",(0,s.kt)("inlineCode",{parentName:"p"},"0"),"."),(0,s.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=tuple",group:"tuple"},"let first_name : string = friends.0\n"))),(0,s.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=tuple",group:"tuple"},"const first_name_component = friends[0];\n"))),(0,s.kt)("h2",{id:"lists"},"Lists"),(0,s.kt)("p",null,"Lists are linear collections of elements of the same type. Linear\nmeans that, in order to reach an element in a list, we must visit all\nthe elements before (sequential access). Elements can be repeated, as\nonly their order in the collection matters. The first element is\ncalled the ",(0,s.kt)("em",{parentName:"p"},"head"),", and the sub-list after the head is called the\n",(0,s.kt)("em",{parentName:"p"},"tail"),". For those familiar with algorithmic data structure, you can\nthink of a list a ",(0,s.kt)("em",{parentName:"p"},"stack"),", where the top is written on the left."),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"\ud83d\udca1 Lists are needed when returning operations from a smart\ncontract's main function.")),(0,s.kt)("h3",{id:"defining-lists"},"Defining Lists"),(0,s.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=lists",group:"lists"},"let empty_list : int list = []\nlet my_list : int list = [1; 2; 2] (* The head is 1, the tail is [2; 2] *)\n"))),(0,s.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=lists",group:"lists"},"const empty_list : list<int> = [];\nconst my_list : list<int> = [1, 2, 2]; // The head is 1, the tail is [2, 2]\n"))),(0,s.kt)("h3",{id:"adding-to-lists"},"Adding to Lists"),(0,s.kt)("p",null,"Lists can be augmented by adding an element before the head (or, in\nterms of stack, by ",(0,s.kt)("em",{parentName:"p"},"pushing an element on top"),"). This operation is\nusually called ",(0,s.kt)("em",{parentName:"p"},"consing")," in functional languages."),(0,s.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("p",null,"In CameLIGO, the ",(0,s.kt)("em",{parentName:"p"},"cons operator")," is infix and noted ",(0,s.kt)("inlineCode",{parentName:"p"},"::"),". It is not\nsymmetric: on the left lies the element to cons, and, on the right, a\nlist on which to cons."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=lists",group:"lists"},"let larger_list : int list = 5 :: my_list (* [5;1;2;2] *)\n"))),(0,s.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("p",null,"In JsLIGO, the ",(0,s.kt)("em",{parentName:"p"},"cons operator")," is infix and noted ",(0,s.kt)("inlineCode",{parentName:"p"},", ..."),". It is\nnot symmetric: on the left lies the element to cons, and, on the\nright, a list on which to cons."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=lists",group:"lists"},"const larger_list : list<int> = [5, ...my_list]; // [5,1,2,2]\n"))),(0,s.kt)("h3",{id:"accessing-list-elements"},"Accessing list elements"),(0,s.kt)("p",null,"You cannot access element directly in list but you can access the\nfirst element, the head or the rest of the list, the tail.  The two\nfunction to access those are ",(0,s.kt)("inlineCode",{parentName:"p"},"List.head_opt")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"List.tail_opt")),(0,s.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=lists",group:"lists"},"let head : int option = List.head_opt my_list (* 1 *)\nlet tail : int list option = List.tail_opt my_list (* [2;2] *)\n"))),(0,s.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=lists",group:"lists"},"const head: option<int> = List.head_opt(my_list); // 1\nconst tail: option<list<int>> = List.tail_opt(my_list); // [2,2]\n"))),(0,s.kt)("p",null,"However, the canonical way to destructure lists is using ",(0,s.kt)("a",{parentName:"p",href:"/docs/next/language-basics/unit-option-pattern-matching#matching-lists"},"pattern\nmatching"),"."),(0,s.kt)("h3",{id:"functional-iteration-over-lists"},"Functional Iteration over Lists"),(0,s.kt)("p",null,"A ",(0,s.kt)("em",{parentName:"p"},"functional iterator")," is a function that traverses a data structure\nand calls in turn a given function over the elements of that structure\nto compute some value. Another approach is possible in JsLIGO:\n",(0,s.kt)("em",{parentName:"p"},"loops")," (see the relevant section)."),(0,s.kt)("p",null,"There are three kinds of functional iterations over LIGO lists: the\n",(0,s.kt)("em",{parentName:"p"},"iterated operation"),", the ",(0,s.kt)("em",{parentName:"p"},"map operation")," (not to be confused with the\n",(0,s.kt)("em",{parentName:"p"},"map data structure"),") and the ",(0,s.kt)("em",{parentName:"p"},"fold operation"),"."),(0,s.kt)("h4",{id:"iterated-operation-over-lists"},"Iterated Operation over Lists"),(0,s.kt)("p",null,"The first, the ",(0,s.kt)("em",{parentName:"p"},"iterated operation"),", is an iteration over the list\nwith a unit return value. It is useful to enforce certain invariants\non the element of a list, or fail."),(0,s.kt)("p",null,"For example you might want to check that each value inside of a list\nis within a certain range, and fail otherwise. The predefined\nfunctional iterator implementing the iterated operation over lists is\ncalled ",(0,s.kt)("inlineCode",{parentName:"p"},"List.iter"),"."),(0,s.kt)("p",null,"In the following example, a list is iterated to check that all its\nelements (integers) are strictly greater than ",(0,s.kt)("inlineCode",{parentName:"p"},"3"),"."),(0,s.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=lists",group:"lists"},"let assert_all_greater_than_three (l : int list) : unit =\n  let predicate = fun (i:int) -> assert (i > 3)\n  in List.iter predicate l\n"))),(0,s.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=lists",group:"lists"},"const assert_all_greater_than_three = (l: list<int>): unit => {\n  let predicate = i => assert(i > 3);\n  List.iter(predicate, l);\n};\n"))),(0,s.kt)("h4",{id:"mapped-operation-over-lists"},"Mapped Operation over Lists"),(0,s.kt)("p",null,"We may want to change all the elements of a given list by applying to\nthem a function. This is called a ",(0,s.kt)("em",{parentName:"p"},"map operation"),", not to be confused\nwith the map data structure. The predefined functional iterator\nimplementing the mapped operation over lists is called ",(0,s.kt)("inlineCode",{parentName:"p"},"List.map")," and\nis used as follows."),(0,s.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=lists",group:"lists"},"let increment (i : int) = i + 1\n\n// Creates a new list with all elements incremented by 1\nlet plus_one : int list = List.map increment larger_list (* [6,2,3,3] *)\n"))),(0,s.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=lists",group:"lists"},"const increment = i => i + 1;\n\n// Creates a new list with all elements incremented by 1\nconst plus_one: list<int> = List.map(increment, larger_list); // [6,2,3,3]\n"))),(0,s.kt)("h4",{id:"folded-operation-over-lists"},"Folded Operation over Lists"),(0,s.kt)("p",null,"A ",(0,s.kt)("em",{parentName:"p"},"folded operation")," is the most general of iterations. The folded\nfunction takes two arguments: an ",(0,s.kt)("em",{parentName:"p"},"accumulator")," and the structure\n",(0,s.kt)("em",{parentName:"p"},"element")," at hand, with which it then produces a new accumulator. This\nenables having a partial result that becomes complete when the\ntraversal of the data structure is over. Folding can be done in two\nways, labelled with the directions left and right. One way to tell them\napart is to look where the folded function, and the fold itself, keep\nthe accumulator in their signatures. Take for example a function ",(0,s.kt)("inlineCode",{parentName:"p"},"f"),",\na list ",(0,s.kt)("inlineCode",{parentName:"p"},"[1; 2; 3; 4; 5]"),", and an accumulator that's just an empty\nlist. A rough approximation of the result of a left fold would look\nlike ",(0,s.kt)("inlineCode",{parentName:"p"},"f(f(f(f(f([], 1), 2), 3), 4), 5)"),", while a right fold would\ninstead look like ",(0,s.kt)("inlineCode",{parentName:"p"},"f(1, f(2, f(3, f(4, f(5, [])))))"),"."),(0,s.kt)("p",null,"The left fold operation has a function signature of\n",(0,s.kt)("inlineCode",{parentName:"p"},"List.fold_left (a -> x -> a) -> a -> x list -> a"),", while the right\nfold operation has ",(0,s.kt)("inlineCode",{parentName:"p"},"List.fold_right (x -> a -> a) -> x list -> a -> a"),".\nHere is an example of their use."),(0,s.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=lists",group:"lists"},"let sum (acc, i: int * int) = acc + i\nlet sum_of_elements : int = List.fold_left sum 0 my_list\n"))),(0,s.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=lists",group:"lists"},"const sum = ([result, i]: [int, int]) => result + i;\nconst sum_of_elements: int = List.fold (sum, my_list, 0);\n"))),(0,s.kt)("h2",{id:"sets"},"Sets"),(0,s.kt)("p",null,"Sets are unordered collections of values of the same type, like lists\nare ordered collections. Like the mathematical sets and lists, sets\ncan be empty and, if not, elements of sets in LIGO are ",(0,s.kt)("em",{parentName:"p"},"unique"),",\nwhereas they can be repeated in a ",(0,s.kt)("em",{parentName:"p"},"list"),"."),(0,s.kt)("h3",{id:"empty-sets"},"Empty Sets"),(0,s.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("p",null,"In CameLIGO, the empty set is denoted by the predefined value\n",(0,s.kt)("inlineCode",{parentName:"p"},"Set.empty"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=sets",group:"sets"},"let my_set : int set = Set.empty\n"))),(0,s.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("p",null,"In JsLIGO, the empty set is denoted by the predefined value\n",(0,s.kt)("inlineCode",{parentName:"p"},"Set.empty"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=sets",group:"sets"},"const my_empty_set: set<int> = Set.empty;\n"))),(0,s.kt)("h3",{id:"non-empty-sets"},"Non-empty Sets"),(0,s.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("p",null,"In CameLIGO, you can create a non-empty set using the ",(0,s.kt)("inlineCode",{parentName:"p"},"Set.literal")," function\nwhich takes a list of elements & returns a set."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=sets",group:"sets"},"let my_set : int set = Set.literal [3; 2; 2; 1]\n")),(0,s.kt)("p",null,"You can check that ",(0,s.kt)("inlineCode",{parentName:"p"},"2")," is not repeated in ",(0,s.kt)("inlineCode",{parentName:"p"},"my_set")," by using the LIGO\ncompiler like this (the output will sort the elements of the set, but\nthat order is not significant for the compiler):"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},"ligo run evaluate-expr gitlab-pages/docs/language-basics/src/sets-lists-tuples/sets.mligo my_set\n# Outputs: SET_ADD(3 , SET_ADD(2 , SET_ADD(1 , SET_EMPTY())))\n"))),(0,s.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("p",null,"In JsLIGO, you can define a non-empty set using the ",(0,s.kt)("inlineCode",{parentName:"p"},"Set.literal")," function\nwhich takes a list of elements & returns a set."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=sets",group:"sets"},"let my_set: set<int> = Set.literal([3, 2, 2, 1]);\n")),(0,s.kt)("p",null,"You can check that ",(0,s.kt)("inlineCode",{parentName:"p"},"2")," is not repeated in ",(0,s.kt)("inlineCode",{parentName:"p"},"my_set")," by using the LIGO\ncompiler like this (the output will sort the elements of the set, but\nthat order is not significant for the compiler):"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},"ligo run evaluate-expr gitlab-pages/docs/language-basics/src/sets-lists-tuples/sets.jsligo my_set\n# Outputs: SET_ADD(3 , SET_ADD(2 , SET_ADD(1 , SET_EMPTY())))\n"))),(0,s.kt)("h3",{id:"adding-an-element-to-a-set"},"Adding an element to a Set"),(0,s.kt)("p",null,"You can add an element to a set, using ",(0,s.kt)("inlineCode",{parentName:"p"},"Set.add")," function."),(0,s.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=sets",group:"sets"},"let with_999 : int set = Set.add 999 my_set\n"))),(0,s.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=sets",group:"sets"},"const with_999: set<int> = Set.add(999, my_set);\n"))),(0,s.kt)("h3",{id:"set-membership"},"Set Membership"),(0,s.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("p",null,"In CameLIGO, the predefined predicate ",(0,s.kt)("inlineCode",{parentName:"p"},"Set.mem")," tests for membership\nin a set as follows:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=sets",group:"sets"},"let contains_3 : bool = Set.mem 3 my_set\n"))),(0,s.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("p",null,"In JsLIGO, the predefined predicate ",(0,s.kt)("inlineCode",{parentName:"p"},"Set.mem")," tests for membership\nin a set as follows:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=sets",group:"sets"},"const contains_3: bool = Set.mem(3, my_set);\n"))),(0,s.kt)("h3",{id:"cardinal-of-sets"},"Cardinal of Sets"),(0,s.kt)("p",null,"The predefined function ",(0,s.kt)("inlineCode",{parentName:"p"},"Set.size")," returns the number of\nelements in a given set as follows."),(0,s.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=sets",group:"sets"},"let cardinal : nat = Set.size my_set\n"))),(0,s.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=sets",group:"sets"},"const cardinal: nat = Set.size(my_set);\n"))),(0,s.kt)("h3",{id:"updating-sets"},"Updating Sets"),(0,s.kt)("p",null,"There are two ways to update a set, that is to add or remove from\nit."),(0,s.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("p",null,"In CameLIGO, we can use the predefined functions ",(0,s.kt)("inlineCode",{parentName:"p"},"Set.add")," and\n",(0,s.kt)("inlineCode",{parentName:"p"},"Set.remove"),". We update a given set by creating another one, with or\nwithout some elements."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=sets",group:"sets"},"let larger_set  : int set = Set.add 4 my_set\nlet smaller_set : int set = Set.remove 3 my_set\n"))),(0,s.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("p",null,"In JsLIGO, we can use the predefined functions ",(0,s.kt)("inlineCode",{parentName:"p"},"Set.add")," and\n",(0,s.kt)("inlineCode",{parentName:"p"},"Set.remove"),". We update a given set by creating another one, with or\nwithout some elements."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=sets",group:"sets"},"const larger_set: set<int> = Set.add(4, my_set);\nconst smaller_set: set<int> = Set.remove(3, my_set);\n"))),(0,s.kt)("h3",{id:"functional-iteration-over-sets"},"Functional Iteration over Sets"),(0,s.kt)("p",null,"A ",(0,s.kt)("em",{parentName:"p"},"functional iterator")," is a function that traverses a data structure\nand calls in turn a given function over the elements of that structure\nto compute some value. Another approach is possible in JsLIGO:\n",(0,s.kt)("em",{parentName:"p"},"loops")," (see the relevant section)."),(0,s.kt)("p",null,"There are three kinds of functional iterations over LIGO maps: the\n",(0,s.kt)("em",{parentName:"p"},"iterated operation"),", the ",(0,s.kt)("em",{parentName:"p"},"mapped operation")," (not to be confused with\nthe ",(0,s.kt)("em",{parentName:"p"},"map data structure"),") and the ",(0,s.kt)("em",{parentName:"p"},"folded operation"),"."),(0,s.kt)("h4",{id:"iterated-operation"},"Iterated Operation"),(0,s.kt)("p",null,"The first, the ",(0,s.kt)("em",{parentName:"p"},"iterated operation"),", is an iteration over the map with\nno return value: its only use is to produce side-effects. This can be\nuseful if for example you would like to check that each value inside\nof a map is within a certain range, and fail with an error otherwise."),(0,s.kt)("p",null,"The predefined functional iterator implementing the iterated operation\nover sets is called ",(0,s.kt)("inlineCode",{parentName:"p"},"Set.iter"),". In the following example, a set is\niterated to check that all its elements (integers) are greater than\n",(0,s.kt)("inlineCode",{parentName:"p"},"3"),"."),(0,s.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=sets",group:"sets"},"let assert_all_greater_than_three (s : int set) : unit =\n  let predicate = fun (i : int) -> assert (i > 3)\n  in Set.iter predicate s\n"))),(0,s.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=sets",group:"sets"},"const assert_all_greater_than_three = s => {\n  let predicate = i => assert(i > 3);\n  Set.iter(predicate, s);\n};\n"))),(0,s.kt)("h4",{id:"folded-operation"},"Folded Operation"),(0,s.kt)("p",null,"A ",(0,s.kt)("em",{parentName:"p"},"folded operation")," is the most general of iterations. The folded\nfunction takes two arguments: an ",(0,s.kt)("em",{parentName:"p"},"accumulator")," and the structure\n",(0,s.kt)("em",{parentName:"p"},"element")," at hand, with which it then produces a new accumulator. This\nenables having a partial result that becomes complete when the\ntraversal of the data structure is over."),(0,s.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("p",null,"The predefined fold over sets is called ",(0,s.kt)("inlineCode",{parentName:"p"},"Set.fold"),", however an\nadditional function, ",(0,s.kt)("inlineCode",{parentName:"p"},"Set.fold_right"),", has been added to properly\nconform to the function signature of OCaml's ",(0,s.kt)("inlineCode",{parentName:"p"},"Set.fold")," operation, and\nit has the signature ",(0,s.kt)("inlineCode",{parentName:"p"},"val fold_right : ('acc * 'elt -> 'acc) -> 'elt\nset -> 'acc -> 'acc"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=sets",group:"sets"},"let sum (acc, i : int * int) : int = acc + i\nlet sum_of_elements : int = Set.fold sum my_set 0\n"))),(0,s.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("p",null,"The predefined fold over sets is called ",(0,s.kt)("inlineCode",{parentName:"p"},"Set.fold"),", however an\nadditional function, ",(0,s.kt)("inlineCode",{parentName:"p"},"Set.fold_right"),", has been added with the\nsignature ",(0,s.kt)("inlineCode",{parentName:"p"},"val fold_right : ('acc * 'elt -> 'acc) * 'elt set * 'acc ->\n'acc"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=sets",group:"sets"},"const sum = ([acc, i]: [int, int]) => acc + i;\nconst sum_of_elements = Set.fold (sum, my_set, 0);\n"))))}c.isMDXComponent=!0}}]);