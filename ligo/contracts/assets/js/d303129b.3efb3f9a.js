"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[69103],{48720:(e,t,n)=>{n.d(t,{D:()=>i.Z,Z:()=>o});var a=n(67294),i=n(75402);const o=function(e){return a.createElement(i.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},99191:(e,t,n)=>{n.d(t,{Z:()=>p});var a=n(43164),i=n(67294),o=n(52263),s=n(48720),l=n(11506);function r(){return r=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},r.apply(this,arguments)}const{Prism:c}=n(43164);c.languages={...c.languages,cameligo:{...c.languages.ocaml,comment:[/(^|[^\\])\/\*[\s\S]*?\*\//,/\(\*[\s\S]*?\*\)/,/\/\/.*/]},jsligo:c.languages.typescript};const p=function(e){const{siteConfig:{themeConfig:{prism:t={}}}}=(0,o.Z)(),n=t.singleTheme||l.Z,[c,p]=(0,i.useState)(!1);return(0,i.useEffect)((()=>{p(!0)}),[]),i.createElement(s.D.Consumer,null,(t=>{let{syntax:o}=t;return o===e.syntax?i.createElement(a.default,r({},a.defaultProps,{key:c,language:e.syntax,code:e.children,theme:n}),(e=>{let{className:t,tokens:n,getLineProps:a,getTokenProps:o}=e;return i.createElement("h4",{className:t,style:{backgroundColor:"var(--ifm-background-color)",fontFamily:"var(--ifm-font-family-monospace)",lineHeight:"var(--ifm-pre-line-height)",fontSize:"1.1rem",fontWeight:"bold",padding:0,whiteSpace:"break-spaces",marginTop:"3rem"}},n.map(((e,t)=>i.createElement("div",a({line:e,key:t}),e.map(((e,t)=>i.createElement("span",o({token:e,key:t}))))))))})):i.createElement("div",null)}))}},41050:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>r,default:()=>g,frontMatter:()=>l,metadata:()=>c,toc:()=>m});var a=n(87462),i=(n(67294),n(3905)),o=n(48720),s=n(99191);const l={id:"hangzhou",title:"Hangzhou",description:"Hangzhou changes"},r=void 0,c={unversionedId:"protocol/hangzhou",id:"version-1.6.0/protocol/hangzhou",title:"Hangzhou",description:"Hangzhou changes",source:"@site/versioned_docs/version-1.6.0/protocol/hangzhou.md",sourceDirName:"protocol",slug:"/protocol/hangzhou",permalink:"/docs/1.6.0/protocol/hangzhou",draft:!1,tags:[],version:"1.6.0",frontMatter:{id:"hangzhou",title:"Hangzhou",description:"Hangzhou changes"},sidebar:"API",previous:{title:"LIGO Changelog",permalink:"/docs/1.6.0/intro/changelog"},next:{title:"Ithaca",permalink:"/docs/1.6.0/protocol/ithaca"}},p={},m=[{value:"API",id:"api",level:2},{value:"New types",id:"new-types",level:3},{value:"New primitives",id:"new-primitives",level:3},{value:"Tezos",id:"tezos",level:4},{value:"Test",id:"test",level:4},{value:"Examples",id:"examples",level:2},{value:"Timelock",id:"timelock",level:3},{value:"On-chain views",id:"on-chain-views",level:3},{value:"Global constant",id:"global-constant",level:3}],h={toc:m};function g(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"api"},"API"),(0,i.kt)("h3",{id:"new-types"},"New types"),(0,i.kt)(s.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type chest"),(0,i.kt)(s.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type chest"),"A type for chests",(0,i.kt)(s.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type chest_key"),(0,i.kt)(s.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type chest_key"),"A type for chest keys",(0,i.kt)(s.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type chest_opening_result = Ok_opening of bytes | Fail_decrypt | Fail_timelock"),(0,i.kt)(s.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},'type chest_opening_result = ["Ok_opening", bytes] | ["Fail_decrypt"] | ["Fail_timelock"];'),(0,i.kt)("p",null,"A type for the result of chest opening, see ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.open_chest")),(0,i.kt)("h3",{id:"new-primitives"},"New primitives"),(0,i.kt)("h4",{id:"tezos"},"Tezos"),(0,i.kt)(s.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val open_chest : chest_key -> chest -> nat -> chest_opening_result"),(0,i.kt)(s.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let open_chest : chest_key => chest => nat => chest_opening_result"),(0,i.kt)(s.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val call_view : string -> 'arg -> address -> 'ret option"),(0,i.kt)(s.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let call_view : string => 'arg => address => option <'ret>"),(0,i.kt)(s.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val constant : string -> 'a"),(0,i.kt)(s.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let constant : string => 'a"),(0,i.kt)("h4",{id:"test"},"Test"),(0,i.kt)("p",null,"New signature for originate_from_file:"),(0,i.kt)(s.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val originate_from_file : string -> string -> string list -> michelson_program -> tez -> (address * michelson_program * int)"),(0,i.kt)(s.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let originate_from_file = (filepath: string, entrypoint: string , views : list <'string> , init: michelson_program, balance: tez) => [address, michelson_program, int]"),(0,i.kt)("p",null,"Originate a contract with a path to the contract file, an entrypoint, a list of views, an initial storage and an initial balance."),(0,i.kt)(s.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val create_chest : bytes -> nat -> chest * chest_key"),(0,i.kt)(s.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let create_chest : bytes => nat => [chest , chest_key]"),(0,i.kt)("p",null,"Generate a locked value, the RSA parameters and encrypt the payload. Also returns the chest key\nExposes tezos timelock library function ",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.com/tezos/tezos/-/blob/v11-release/src/lib_crypto/timelock.mli#L197"},"create_chest_and_chest_key")),(0,i.kt)(s.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val create_chest_key : chest -> nat -> chest_key"),(0,i.kt)(s.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let create_chest_key : chest => nat => chest_key"),(0,i.kt)("p",null,"Unlock the value and create the time-lock proof.\nExposes tezos timelock library function ",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.com/tezos/tezos/-/blob/v11-release/src/lib_crypto/timelock.mli#L201"},"create_chest_key"),"."),(0,i.kt)("h2",{id:"examples"},"Examples"),(0,i.kt)("h3",{id:"timelock"},"Timelock"),(0,i.kt)("p",null,"Extensive documentation about timelock can be found ",(0,i.kt)("a",{parentName:"p",href:"https://tezos.gitlab.io/alpha/timelock.html#timelock"},"here"),".\nHere is an example of a contract trying to open a chest and the corresponding tests to trigger all error kinds:"),(0,i.kt)(o.Z,{"test-ligo":!0,syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},"type storage = bytes\ntype parameter = chest_key * chest\n\ntype return = operation list * storage\n\nlet main (p, _ : parameter * storage) : return =\n  let (ck,c) = p in\n  let new_s =\n    match Tezos.open_chest ck c 10n with\n    | Ok_opening b -> b\n    | Fail_timelock -> 0x00\n    | Fail_decrypt -> 0x01\n  in [], new_s\n\n\nlet test =\n  let init_storage : bytes = 0x00 in\n  let addr, _, _ = Test.originate main init_storage 0tez in\n  let payload = 0x0101\n  in\n  let test_open (cc : chest_key * chest) (expected : bytes) : unit =\n    let x : parameter contract = Test.to_contract addr in\n    let _ = Test.transfer_to_contract_exn x cc 0tez in\n    let s = Test.get_storage addr in\n    assert (s = expected)\n  in\n  let test1 = (* chest key/payload and time matches -> OK *)\n    let chest, chest_key = Test.create_chest payload 10n\n    in test_open (chest_key, chest) payload\n  in\n  let test2 = (* chest key/payload do not match -> Fail_decrypt *)\n    let chest, _ = Test.create_chest payload 10n in\n    let _, chest_key = Test.create_chest 0x2020 10n\n    in test_open (chest_key,chest) 0x01\n  in\n  let test3 = (* chest time do not match -> Fail_timelock *)\n    let chest, _ = Test.create_chest payload 2n in\n    let chest_key = Test.create_chest_key chest 10n\n    in test_open (chest_key, chest) 0x00\n  in ()\n\n"))),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},'let open_or_fail = ([ck, c, @time] : [chest_key, chest, nat]) : bytes => {\n  return (match ( Tezos.open_chest(ck,c,@time), {\n    Ok_opening: (b:bytes) => b,\n    Fail_decrypt: () => failwith("decrypt"),\n    Fail_timelock: () => failwith("timelock"),\n  }))\n};\n'))),(0,i.kt)("h3",{id:"on-chain-views"},"On-chain views"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Tezos documentation on views can be found ",(0,i.kt)("a",{parentName:"p",href:"https://tezos.gitlab.io/011/michelson.html#operations-on-views"},"here"))),(0,i.kt)("p",null,'On-chain views are named routines attached to your contract allowing\nanother contract to call them to get a "view" of your contract current\nstorage. It cannot modify your storage nor emit operations.  These\nroutines can either simply return your contract storage or apply some\nkind of processing to it: they take your current storage, a parameter\nand returns the data of your choice. Note that parameter and return\ntypes can be anything except ',(0,i.kt)("inlineCode",{parentName:"p"},"big_map"),"; ",(0,i.kt)("inlineCode",{parentName:"p"},"sapling_state")," ; ",(0,i.kt)("inlineCode",{parentName:"p"},"operation"),"\nand ",(0,i.kt)("inlineCode",{parentName:"p"},"ticket"),".  Views are named after their declaration name and can be\ncompiled in two ways:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"by passing their names to the command line option ",(0,i.kt)("inlineCode",{parentName:"p"},"--views"),"\n(e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"ligo compile contract --views v1,v2,v3"),")")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"by annotating their declarations in your code with ",(0,i.kt)("inlineCode",{parentName:"p"},"view")))),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Important: the first way (",(0,i.kt)("inlineCode",{parentName:"p"},"--views"),") will override any annotated\ndeclarations")),(0,i.kt)("p",null,"Given a very simple contract having a storage of type ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),", here\nare a few legit views:"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=views",group:"views"},"type storage = string\nlet main (((),s): unit * storage) : operation list * storage = [] , s\n\n(* view 'view1', simply returns the storage *)\n[@view] let view1 ((),s: unit * storage) : storage = s\n\n(* view 'v2', returns true if the storage has a given length *)\n[@view] let v2 (expected_length,s: nat * storage) : bool = (String.length s = expected_length)\n\n(* view 'v3' returns a constant int *)\n[@view] let v3 ((),_ : unit * storage) : int = 42\n"))),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=views",group:"views"},"type storage = string\nlet main = ([_ , s]: [unit , storage]) : [ list<operation> , storage] => [[], s];\n\n/* view 'view1', simply returns the storage */\n@view\nlet view1 = ([_ , s]: [unit , storage]) : storage => s;\n\n/* view 'v2', returns true if the storage has a given length */\n@view\nlet v2 = ([expected_length,s] : [nat , storage]) : bool => (String.length (s) == expected_length);\n\n/* view 'view3' returns a constant int */\n@view\nlet view3 = ([_ , _s]: [unit , storage]) : int => 42;\n"))),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Note: ",(0,i.kt)("inlineCode",{parentName:"p"},"[@view]")," attribute is only supported for top-level functions."),(0,i.kt)("p",{parentName:"blockquote"},"The use of ",(0,i.kt)("inlineCode",{parentName:"p"},"[@view]")," attribute anywhere other than top-level will be ignored.")),(0,i.kt)("p",null,"A few primitives have a slightly different meaning when executed as part of a view:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Tezos.get_balance")," represents the current amount of mutez held by the contract attached to the view"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Tezos.get_sender")," represents the caller of the view"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Tezos.get_amount")," is always 0 mutez"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Tezos.get_self_address")," represents the contract attached to the view")),(0,i.kt)("p",null,"On the caller side, the primitive ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.call_view")," will allow you to call another contract view and get its result by providing the view name; the contract address and the parameter of the view. If the address is nonexistent; the name does not match of of the contract\nview or the parameter type do not match, ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.call_view")," will return ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),"."),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=views",group:"views"},'let view_call ((name,parameter,addr): string * int * address) : int option = Tezos.call_view "sto_plus_n" 1 addr\n'))),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=views",group:"views"},'let view_call = ([name,parameter,addr]: [string , int , address]) : option<int> => Tezos.call_view ("sto_plus_n", 1, addr)\n'))),(0,i.kt)("h3",{id:"global-constant"},"Global constant"),(0,i.kt)("p",null,"The new primitive ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.constant")," allows you to use a predefined\nconstant already registered on chain.  It accepts a hash in the form\nof a string and will require a type annotation."))}g.isMDXComponent=!0}}]);