"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[117],{3905:(t,e,n)=>{n.d(e,{Zo:()=>p,kt:()=>d});var a=n(67294);function r(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function o(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function i(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?o(Object(n),!0).forEach((function(e){r(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function s(t,e){if(null==t)return{};var n,a,r=function(t,e){if(null==t)return{};var n,a,r={},o=Object.keys(t);for(a=0;a<o.length;a++)n=o[a],e.indexOf(n)>=0||(r[n]=t[n]);return r}(t,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);for(a=0;a<o.length;a++)n=o[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(r[n]=t[n])}return r}var c=a.createContext({}),l=function(t){var e=a.useContext(c),n=e;return t&&(n="function"==typeof t?t(e):i(i({},e),t)),n},p=function(t){var e=l(t.components);return a.createElement(c.Provider,{value:e},t.children)},u={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},g=a.forwardRef((function(t,e){var n=t.components,r=t.mdxType,o=t.originalType,c=t.parentName,p=s(t,["components","mdxType","originalType","parentName"]),g=l(n),d=r,k=g["".concat(c,".").concat(d)]||g[d]||u[d]||o;return n?a.createElement(k,i(i({ref:e},p),{},{components:n})):a.createElement(k,i({ref:e},p))}));function d(t,e){var n=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var o=n.length,i=new Array(o);i[0]=g;var s={};for(var c in e)hasOwnProperty.call(e,c)&&(s[c]=e[c]);s.originalType=t,s.mdxType="string"==typeof t?t:r,i[1]=s;for(var l=2;l<o;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}g.displayName="MDXCreateElement"},79778:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var a=n(87462),r=(n(67294),n(3905));const o={id:"testing-tickets",title:"Testing tickets"},i=void 0,s={unversionedId:"testing/testing-tickets",id:"testing/testing-tickets",title:"Testing tickets",description:"Testing code that uses tickets requires extra steps because of how tickets are used in Tezos operations.",source:"@site/../docs/testing/testing-tickets.md",sourceDirName:"testing",slug:"/testing/testing-tickets",permalink:"/docs/next/testing/testing-tickets",draft:!1,tags:[],version:"current",frontMatter:{id:"testing-tickets",title:"Testing tickets"},sidebar:"docs",previous:{title:"Testing",permalink:"/docs/next/testing/"},next:{title:"Mutation testing",permalink:"/docs/next/testing/mutation-testing"}},c={},l=[{value:"The problem with testing tickets",id:"the-problem-with-testing-tickets",level:2},{value:"Proxy ticket contracts",id:"proxy-ticket-contracts",level:2},{value:"Originating contracts with tickets",id:"originating-contracts-with-tickets",level:2},{value:"Calling entrypoints with tickets",id:"calling-entrypoints-with-tickets",level:2}],p=(u="Syntax",function(t){return console.warn("Component "+u+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.kt)("div",t)});var u;const g={toc:l};function d(t){let{components:e,...n}=t;return(0,r.kt)("wrapper",(0,a.Z)({},g,n,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Testing code that uses tickets requires extra steps because of how tickets are used in Tezos operations.\nLIGO provides the ",(0,r.kt)("inlineCode",{parentName:"p"},"Proxy_ticket")," module to help you test with tickets."),(0,r.kt)("h2",{id:"the-problem-with-testing-tickets"},"The problem with testing tickets"),(0,r.kt)("p",null,"Tickets have specific limitations on the Tezos platform that affect how they can be used in LIGO tests.\nFor example, tickets always have the address of the contract that created it as the ticketer field.\nAlso, their data payload cannot be changed after the ticket is created."),(0,r.kt)("p",null,"As a result, you can't create a ticket in a LIGO test with ",(0,r.kt)("inlineCode",{parentName:"p"},"Tezos.Next.Ticket.create")," and use it to test smart contract origination or entrypoints.\nIf LIGO allowed you to create and use tickets in this way, you could edit the ticket or assign a ticketer that was not the contract that created it.\nIf you try to use such a ticket in smart contract operations, the operations fail."),(0,r.kt)("p",null,"You also can't compile LIGO expressions that include tickets and use the compiled Michelson.\nIf you compile an expression that includes a ticket, the value is represented in Michelson as pairs.\nFor example, this code compiles a ticket with a binary value as its payload:"),(0,r.kt)(p,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"ligo compile expression cameligo 'Tezos.create_ticket 0x0202 10n'\n"))),(0,r.kt)(p,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"ligo compile expression jsligo 'Tezos.create_ticket(0x0202, 10n)'\n"))),(0,r.kt)("p",null,"The result (within an option type) is represented in pairs, showing the address of the ticketer, the payload, and the amount of the ticket:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'(Some (Pair "KT1DUMMYDUMMYDUMMYDUMMYDUMMYDUMu2oHG" 0x0202 10))\n')),(0,r.kt)("p",null,"If you pass this value for the parameter of an operation that requires a ticket, the Tezos protocol blocks the operation and does not recognize this value as a ticket because doing so could allow you edit and submit a false ticket."),(0,r.kt)("p",null,"LIGO testing tools to provide ways to create tickets via a proxy contract so you can use tickets in tests."),(0,r.kt)("h2",{id:"proxy-ticket-contracts"},"Proxy ticket contracts"),(0,r.kt)("p",null,"The LIGO test library provides a ",(0,r.kt)("inlineCode",{parentName:"p"},"Proxy_ticket")," module which helps in working with tickets in the test framework.\nInstead of creating tickets yourself, you use a proxy contract to create tickets and send them with operations."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Proxy_ticket")," module provides these functions:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"init_transfer"),": Creates a proxy contract that you can use as the source of tickets in test operations"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"transfer"),": Uses a proxy contract to create a ticket and send it as the parameter of a smart contract call"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"originate"),": Uses a proxy contract to originate a smart contract with initial storage that includes a ticket")),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Due to a limitation in the testing framework, you can use the proxy ticket contract only with contracts that contain a single entrypoint.")),(0,r.kt)("h2",{id:"originating-contracts-with-tickets"},"Originating contracts with tickets"),(0,r.kt)("p",null,"To originate a contract with one or more tickets in its storage, you can use a proxy contract to generate the tickets and include them in the origination operation."),(0,r.kt)("p",null,"For example, this contract stores an integer and a ticket.\nIt provides an entrypoint that reads the ticket and adds its amount to the integer in storage:"),(0,r.kt)(p,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=usage_orig",group:"usage_orig"},"module MyContract = struct\n\n  type storage = int * (bytes ticket) option\n  type unforged_storage = int * (bytes unforged_ticket) option\n\n  [@entry] let main (_ : unit) (storage : storage) :operation list * storage =\n    let (stored_value, ticket_opt) = storage in\n    let new_storage : storage =\n      match ticket_opt with\n        // If there is a ticket, add its amount to the int in storage\n        Some ticket ->\n          let ((_address, (_payload, amount)), new_ticket) = Tezos.Next.Ticket.read ticket in\n          (stored_value + (int amount), Some new_ticket)\n        // If there is no ticket in storage, do nothing\n        | None -> stored_value, None ()\n      in\n    [], new_storage\n\nend\n"))),(0,r.kt)(p,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=usage_orig",group:"usage_orig"},"namespace MyContract {\n  export type storage = [int, option<ticket<bytes>>];\n  export type unforged_storage = [int, option<unforged_ticket<bytes>>];\n\n  @entry\n  const main = (_: unit, storage: storage): [list<operation>, storage] => {\n    const [stored_value, ticket_opt] = storage;\n    const new_storage: storage =\n      match(ticket_opt) {\n        // If there is a ticket, add its amount to the int in storage\n        when(Some(ticket)): ((ticket: ticket<bytes>) => {\n          const [[_address, [_payload, amount]], new_ticket] = Tezos.Next.Ticket.read(ticket);\n          return [stored_value + int(amount), Some(new_ticket)];\n        })(ticket);\n        // If there is no ticket in storage, do nothing\n        when(None()): [stored_value, None()];\n      };\n    return [list([]), new_storage];\n  };\n\n}\n"))),(0,r.kt)("p",null,"To originate this contract, you need a ticket for its initial storage value.\nTo create this ticket, you use a proxy ticket contract."),(0,r.kt)("p",null,"To create a proxy ticket contract, create a function that returns a value of the initial storage for the contract or the parameter for the smart contract call.\nIn this example, the function returns zero for the integer and a ticket created by the proxy.\nThen, the test uses the proxy contract to originate the contract to test:"),(0,r.kt)(p,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=usage_orig",group:"usage_orig"},"let test_originate_contract =\n\n  // Create a function that the proxy runs to return the contract storage\n  let create_storage = fun (t : bytes ticket) : MyContract.storage -> (0, Some t) in\n  let ticket_bytes : bytes = 0x0202 in\n  let ticket_amount = 15n in\n  let ticket_info = ticket_bytes, ticket_amount in\n\n  // Create the proxy contract and use it to originate the contract\n  let addr = Test.Proxy_ticket.originate ticket_info create_storage MyContract.main in\n  // ...\n"))),(0,r.kt)(p,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=usage_orig",group:"usage_orig"},"const test_originate_contract = do {\n\n  // Create a function that the proxy runs to return the contract storage\n  const create_storage = (t: ticket<bytes>): MyContract.storage => [0, Some (t)];\n  const ticket_info = [0x0202, 15n];\n\n  // Create the proxy contract and use it to originate the contract\n  const addr = Test.Proxy_ticket.originate (ticket_info, create_storage, MyContract.main);\n  // ...\n"))),(0,r.kt)("p",null,"To verify that the ticket is in the contract storage, you must use the ",(0,r.kt)("inlineCode",{parentName:"p"},"Test.Proxy_ticket.get_storage")," function to retrieve the ticket from the contract storage.\nThis function provides tickets as ",(0,r.kt)("em",{parentName:"p"},"unforged tickets"),", which are tickets that you can read freely without destroying them and recreating them with the ",(0,r.kt)("inlineCode",{parentName:"p"},"Tezos.Next.Ticket.read")," function.\nIn this code, the test retrieves the ticket from the contract and verifies its contents:"),(0,r.kt)(p,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=usage_orig",group:"usage_orig"},'  // The ticket \'unforged_ticket_opt\' can be manipulated freely without being destroyed\n  let unforged_storage : MyContract.unforged_storage = Test.Proxy_ticket.get_storage addr in\n  let (_stored_value, unforged_ticket_opt) = unforged_storage in\n\n  // Verify that the ticket is in storage\n  let () = match unforged_ticket_opt with\n    Some unforged_ticket ->\n      let () = Test.Next.IO.log ("unforged_ticket",unforged_ticket) in\n      let { ticketer ; value ; amount } = unforged_ticket in\n      let () = Assert.assert (value = ticket_bytes) in\n      Assert.assert (amount = ticket_amount)\n    | None -> failwith "impossible"\n    in\n\n  // Call the entrypoint and verify that the value in storage changes\n  let _ : nat = Test.Next.Contract.transfer_exn (Test.Next.Typed_address.get_entrypoint"default" addr) unit 0tez in\n  let new_storage : MyContract.unforged_storage = Test.Proxy_ticket.get_storage addr in\n  let (new_stored_value, _unforged_ticket_opt) = new_storage in\n  Assert.assert (new_stored_value = (int ticket_amount))\n'))),(0,r.kt)(p,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=usage_orig",group:"usage_orig"},'  // The ticket \'unforged_ticket_opt\' can be manipulated freely without being destroyed\n  const [_stored_value, unforged_ticket_opt] = (Test.Proxy_ticket.get_storage(addr) as MyContract.unforged_storage);\n\n  // Verify that the ticket is in storage\n  match (unforged_ticket_opt) {\n    when(Some(x)): do {\n      Test.Next.IO.log(["unforged_ticket", x]);\n      const { ticketer: _, value, amount } = x;\n      Assert.assert(value == ticket_info[0]);\n      Assert.assert(amount == ticket_info[1]);\n      return unit\n    };\n    when(None()): failwith ("impossible")\n  };\n\n  // Call the entrypoint and verify that the value in storage changes\n  Test.Next.Contract.transfer_exn(Test.Next.Typed_address.get_entrypoint("default", addr), unit, 0tez);\n  const [new_stored_value, _unforged_ticket_opt] = Test.Proxy_ticket.get_storage(addr) as MyContract.unforged_storage;\n  Assert.assert(new_stored_value == int(ticket_info[1]));\n};\n')),(0,r.kt)("p",null,"Note that because this is a single-entrypoint contract, the LIGO compiler renames the entrypoint to ",(0,r.kt)("inlineCode",{parentName:"p"},"default"),".")),(0,r.kt)("h2",{id:"calling-entrypoints-with-tickets"},"Calling entrypoints with tickets"),(0,r.kt)("p",null,"To test entrypoints that accept tickets, you use a proxy contract to create the ticket and send the call to the entrypoint.\nThe process is similar to originating a contract with a proxy: you create a function that returns the parameter for the entrypoint and create a proxy based on that function."),(0,r.kt)("p",null,"For example, this contract has an entrypoint that receives an integer and a ticket that contains an integer.\nIt multiplies the integer in the first parameter with the integer in the ticket payload and with the ticket amount and adds the result to the integer in storage:"),(0,r.kt)(p,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=usage_entrypoint",group:"usage_entrypoint"},"module MyContract = struct\n  type storage = int\n  type param = int * int ticket\n\n  [@entry] let main (param : param) (storage : storage) : operation list * storage =\n    let (multiplier, ticket) = param in\n    // Read the ticket, destroy it, and add its amount times the multiplier to storage\n    let ((_address, (payload, amount)), _ticket) = Tezos.Next.Ticket.read ticket in\n    [], (storage + (multiplier * payload * (int amount)))\nend\n"))),(0,r.kt)(p,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=usage_entrypoint",group:"usage_entrypoint"},"namespace MyContract {\n  type storage = int;\n  export type param = [int, ticket<int>];\n\n  @entry\n  function main (param: param, storage: storage): [list<operation>, storage] {\n    const [multiplier, ticket] = param;\n    // Read the ticket, destroy it, and add its amount times the multiplier to storage\n    const [[_address, [payload, amount]], _ticket] = Tezos.Next.Ticket.read(ticket);\n    return ([[], storage + (multiplier * payload * int(amount))]);\n  };\n}\n"))),(0,r.kt)("p",null,"To test the contract, originate it as usual.\nThen create a function that returns the parameter for the entrypoint, create a proxy based on this function, and use the proxy to call the entrypoint:"),(0,r.kt)(p,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=usage_entrypoint",group:"usage_entrypoint"},'let test_transfer_to_contract =\n  // Originate the contract as usual\n  let orig = Test.Next.Originate.contract (contract_of MyContract) 0 0tez in\n  let main_addr = Test.Next.Typed_address.to_address orig.taddr in\n\n  // Create a function that the proxy runs to return the parameter\n  let create_param : int ticket -> MyContract.param = fun (t : int ticket) -> 5, t in\n\n  // Create the proxy contract\n  let proxy_taddr = Test.Proxy_ticket.init_transfer create_param in\n  let () = Test.Next.IO.log ("proxy addr:", proxy_taddr) in\n\n  // Use the proxy to call the entrypoint\n  let ticket_info = 3, 10n in\n  let _ : test_exec_result = Test.Proxy_ticket.transfer proxy_taddr (ticket_info, main_addr) in\n  Assert.assert ((Test.Next.Typed_address.get_storage orig.taddr) = 150)\n'))),(0,r.kt)(p,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=usage_entrypoint",group:"usage_entrypoint"},'const test_transfer_to_contract = do {\n  // Originate the contract as usual\n  let orig = Test.Next.Originate.contract(contract_of(MyContract), 0, 0tez);\n  let main_addr = Test.Next.Typed_address.to_address(orig.taddr);\n\n  // Create a function that the proxy runs to return the parameter\n  const create_param = (t: ticket<int>): MyContract.param => [5, t];\n\n  // Create the proxy contract\n  const proxy_taddr = Test.Proxy_ticket.init_transfer(create_param);\n  Test.Next.IO.log(["proxy addr:", proxy_taddr]);\n\n  // Use the proxy to call the entrypoint\n  const ticket_info = [3, 10n];\n  Test.Proxy_ticket.transfer(proxy_taddr, [ticket_info, main_addr]);\n\n  // Verify that the value in storage changes\n  Assert.assert(Test.Next.Typed_address.get_storage(orig.taddr) == 150);\n};\n'))))}d.isMDXComponent=!0}}]);