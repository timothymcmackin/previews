"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9087],{48720:(e,t,n)=>{n.d(t,{D:()=>i.Z,Z:()=>o});var a=n(67294),i=n(75402);const o=function(e){return a.createElement(i.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},99191:(e,t,n)=>{n.d(t,{Z:()=>y});var a=n(43164),i=n(67294),o=n(52263),l=n(48720),s=n(11506);function r(){return r=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},r.apply(this,arguments)}const{Prism:p}=n(43164);p.languages={...p.languages,cameligo:{...p.languages.ocaml,comment:[/(^|[^\\])\/\*[\s\S]*?\*\//,/\(\*[\s\S]*?\*\)/,/\/\/.*/]},jsligo:p.languages.typescript};const y=function(e){const{siteConfig:{themeConfig:{prism:t={}}}}=(0,o.Z)(),n=t.singleTheme||s.Z,[p,y]=(0,i.useState)(!1);return(0,i.useEffect)((()=>{y(!0)}),[]),i.createElement(l.D.Consumer,null,(t=>{let{syntax:o}=t;return o===e.syntax?i.createElement(a.default,r({},a.defaultProps,{key:p,language:e.syntax,code:e.children,theme:n}),(e=>{let{className:t,tokens:n,getLineProps:a,getTokenProps:o}=e;return i.createElement("h4",{className:t,style:{backgroundColor:"var(--ifm-background-color)",fontFamily:"var(--ifm-font-family-monospace)",lineHeight:"var(--ifm-pre-line-height)",fontSize:"1.1rem",fontWeight:"bold",padding:0,whiteSpace:"break-spaces",marginTop:"3rem"}},n.map(((e,t)=>i.createElement("div",a({line:e,key:t}),e.map(((e,t)=>i.createElement("span",o({token:e,key:t}))))))))})):i.createElement("div",null)}))}},30098:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>y,contentTitle:()=>r,default:()=>x,frontMatter:()=>s,metadata:()=>p,toc:()=>d});var a=n(87462),i=(n(67294),n(3905)),o=n(48720),l=n(99191);const s={id:"toplevel-reference",title:"toplevel",hide_table_of_contents:!0},r=void 0,p={unversionedId:"reference/toplevel-reference",id:"reference/toplevel-reference",title:"toplevel",description:"type string",source:"@site/../docs/reference/toplevel.md",sourceDirName:"reference",slug:"/reference/toplevel-reference",permalink:"/docs/next/reference/toplevel-reference",draft:!1,tags:[],version:"current",frontMatter:{id:"toplevel-reference",title:"toplevel",hide_table_of_contents:!0},sidebar:"API",previous:{title:"set",permalink:"/docs/next/reference/set-reference"},next:{title:"crypto",permalink:"/docs/next/reference/crypto-reference"}},y={},d=[],m={toc:d};function x(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type string"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type string"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type bytes"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type bytes"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type int"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type int"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type nat"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type nat"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type unit"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type unit"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type operation"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type operation"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type tez"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type tez"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type address"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type address"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type signature"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type signature"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type key"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type key"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type key_hash"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type key_hash"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type timestamp"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type timestamp"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type list"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type list"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type big_map"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type big_map"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type map"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type map"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type set"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type set"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type contract"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type contract"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type michelson_or"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type michelson_or"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type michelson_pair"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type michelson_pair"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type chain_id"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type chain_id"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type baker_hash"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type baker_hash"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type pvss_key"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type pvss_key"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type sapling_state"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type sapling_state"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type sapling_transaction"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type sapling_transaction"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type baker_operation"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type baker_operation"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type bls12_381_g1"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type bls12_381_g1"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type bls12_381_g2"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type bls12_381_g2"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type bls12_381_fr"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type bls12_381_fr"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type never"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type never"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type ticket"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type ticket"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type chest"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type chest"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type chest_key"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type chest_key"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type external_ediv"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type external_ediv"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type external_and"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type external_and"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type external_or"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type external_or"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type external_xor"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type external_xor"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type external_lsl"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type external_lsl"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type external_lsr"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type external_lsr"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type external_bytes"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type external_bytes"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type ('param, 'storage) entrypoint = 'param -> 'storage -> (operation list * 'storage)"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type entrypoint<param, storage> = (_: param) => (_: storage) => [list<operation>, storage]"),"Type of entrypoints",(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type bool = bool"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type bool = bool"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"Type of the booleans. Note: Values ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"false")," are\npredefined constants such that ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," equals ",(0,i.kt)("inlineCode",{parentName:"p"},"True")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),"\nequals ",(0,i.kt)("inlineCode",{parentName:"p"},"False"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"Type of the booleans. Note: Values ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"false")," are\npredefined constants.")),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type 'a option = 'a option"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type option<a> = option<a>"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"Type of optional values. They are useful, for example, when a\nfunction can fail, but the caller wants to be able to handle the\nfailure, which is then denoted by the result ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),". Note:\nAssertions and ",(0,i.kt)("inlineCode",{parentName:"p"},"failwith")," do not allow handling.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"Type of optional values. They are useful, for example, when a\nfunction can fail, but the caller wants to be able to handle the\nfailure, which is then denoted by the result ",(0,i.kt)("inlineCode",{parentName:"p"},"None()"),". Note:\nAssertions and ",(0,i.kt)("inlineCode",{parentName:"p"},"failwith")," do not allow handling.")),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val unit : unit"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let unit: unit"),"Unit type. It is useful for typing side-effects, for example failures, some iterators and implicit accounts.",(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val ignore : 'a.'a -> unit"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let ignore: <a>(_: a) => unit"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"ignore v")," evaluates ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," and ignores its value, returning\ninstead the unit value. This is useful when the argument of ",(0,i.kt)("inlineCode",{parentName:"p"},"ignore"),"\nperforms side-effects.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"ignore(v)")," evaluates ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," and ignores its value, returning\ninstead the unit value. This is useful when the argument of ",(0,i.kt)("inlineCode",{parentName:"p"},"ignore"),"\nperforms side-effects.")),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val curry : 'a 'b 'c.(('a * 'b) -> 'c) -> 'a -> 'b -> 'c"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let curry: <a, b, c>(_: (_: [a, b]) => c) => (_: a) => (_: b) => c"),"**Deprecated:** In a future version, this function will be deprecated, and using `Tuple2.curry` is encouraged for a smoother migration.",(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"curry f x y")," has the same value as ",(0,i.kt)("inlineCode",{parentName:"p"},"f (x,y)"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"curry(f,x,y)")," has the same value as ",(0,i.kt)("inlineCode",{parentName:"p"},"f(x,y)"),".")),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val uncurry : 'a 'b 'c.('a -> 'b -> 'c) -> ('a * 'b) -> 'c"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let uncurry: <a, b, c>(_: (_: a) => (_: b) => c) => (_: [a, b]) => c"),"**Deprecated:** In a future version, this function will be deprecated, and using `Tuple2.uncurry` is encouraged for a smoother migration.",(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"uncurry f (x,y)")," has the same value as ",(0,i.kt)("inlineCode",{parentName:"p"},"f x y"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"uncurry(f,[x,y])")," has the same value as ",(0,i.kt)("inlineCode",{parentName:"p"},"f(x)(y)"),".")),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val fst : 'a 'b.('a * 'b) -> 'a"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let fst: <a, b>(_: [a, b]) => a"),"**Deprecated:** In a future version, this function will be deprecated, and using `Tuple2.get1` is encouraged for a smoother migration.",(0,i.kt)("p",null,"Projecting the first component of a pair"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val snd : 'a 'b.('a * 'b) -> 'b"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let snd: <a, b>(_: [a, b]) => b"),"**Deprecated:** In a future version, this function will be deprecated, and using `Tuple2.get2` is encouraged for a smoother migration.",(0,i.kt)("p",null,"Projecting the second component of a pair."),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val failwith : 'err 'a.'err -> 'a"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let failwith: <err, a>(_: err) => a"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"failwith e")," terminates the execution with the value ",(0,i.kt)("inlineCode",{parentName:"p"},"e"),",\nstanding for an error. Note: Using a string for an error message can\nbe costly in terms of size.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"failwith(e)")," terminates the execution with the value ",(0,i.kt)("inlineCode",{parentName:"p"},"e"),",\nstanding for an error. Note: Using a string for an error message can\nbe costly in terms of size.")),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val bytes : 'a.'a -> 'a external_bytes"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let bytes: <a>(_: a) => external_bytes<a>"),"The function `bytes` encodes an integer or a natural number to bytes using the big-endian encoding. For integers, negative numbers are considered in two's complement representation.",(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val assert_with_error : bool -> string -> unit"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let assert_with_error: (_: bool) => (_: string) => unit"),"**Deprecated:** In a future version, this function will be deprecated, and using `Assert.Error.assert` is encouraged for a smoother migration.",(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"assert_with_error cond error")," terminates the execution\nwith the string ",(0,i.kt)("inlineCode",{parentName:"p"},"error")," (that is, an error message) if, and only if,\nthe boolean condition ",(0,i.kt)("inlineCode",{parentName:"p"},"cond")," is false.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"assert_with_error(cond, error)")," terminates the execution\nwith the string ",(0,i.kt)("inlineCode",{parentName:"p"},"error")," (that is, an error message) if, and only if,\nthe boolean condition ",(0,i.kt)("inlineCode",{parentName:"p"},"cond")," is false.")),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val assert : bool -> unit"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let assert: (_: bool) => unit"),"**Deprecated:** In a future version, this function will be deprecated, and using `Assert.assert` is encouraged for a smoother migration.",(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"assert cond")," terminates the execution with the string\n",(0,i.kt)("inlineCode",{parentName:"p"},'"failed assertion"')," if, and only if, the boolean condition ",(0,i.kt)("inlineCode",{parentName:"p"},"cond"),"\nis false.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"assert(cond)")," terminates the execution with the string\n",(0,i.kt)("inlineCode",{parentName:"p"},'"failed assertion"')," if, and only if, the boolean condition ",(0,i.kt)("inlineCode",{parentName:"p"},"cond"),"\nis false.")),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val assert_some_with_error : 'a.'a option -> string -> unit"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let assert_some_with_error: <a>(_: option<a>) => (_: string) => unit"),"**Deprecated:** In a future version, this function will be deprecated, and using `Assert.Error.some` is encouraged for a smoother migration.",(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"assert_some_with_error opt err")," terminates the execution\nwith the string ",(0,i.kt)("inlineCode",{parentName:"p"},"err")," (that is, an error message) if, and only if,\n",(0,i.kt)("inlineCode",{parentName:"p"},"opt")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"assert_some_with_error(opt, err)")," terminates the execution\nwith the string ",(0,i.kt)("inlineCode",{parentName:"p"},"err")," (that is, an error message) if, and only if,\n",(0,i.kt)("inlineCode",{parentName:"p"},"opt")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"None()"),".")),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val assert_some : 'a.'a option -> unit"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let assert_some: <a>(_: option<a>) => unit"),"**Deprecated:** In a future version, this function will be deprecated, and using `Assert.some` is encouraged for a smoother migration.",(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"assert_some opt")," terminates the execution with the\nstring ",(0,i.kt)("inlineCode",{parentName:"p"},'"failed assert some"')," if, and only if, ",(0,i.kt)("inlineCode",{parentName:"p"},"opt")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"assert_some(opt)")," terminates the execution with the\nstring ",(0,i.kt)("inlineCode",{parentName:"p"},'"failed assert some"')," if, and only if, ",(0,i.kt)("inlineCode",{parentName:"p"},"opt")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"None()"),".")),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val assert_none_with_error : 'a.'a option -> string -> unit"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let assert_none_with_error: <a>(_: option<a>) => (_: string) => unit"),"**Deprecated:** In a future version, this function will be deprecated, and using `Assert.Error.none` is encouraged for a smoother migration.",(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"assert_none_with_error opt err")," terminates the execution\nwith the string ",(0,i.kt)("inlineCode",{parentName:"p"},"err")," (that is, an error message) if, and only if,\n",(0,i.kt)("inlineCode",{parentName:"p"},"opt")," is an optional value different from ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"assert_none_with_error(opt, err)")," terminates the execution\nwith the string ",(0,i.kt)("inlineCode",{parentName:"p"},"err")," (that is, an error message) if, and only if,\n",(0,i.kt)("inlineCode",{parentName:"p"},"opt")," is an optional value different from ",(0,i.kt)("inlineCode",{parentName:"p"},"None()"),".")),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val assert_none : 'a.'a option -> unit"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let assert_none: <a>(_: option<a>) => unit"),"**Deprecated:** In a future version, this function will be deprecated, and using `Assert.none` is encouraged for a smoother migration.",(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"assert_none opt")," terminates the execution with the string\n",(0,i.kt)("inlineCode",{parentName:"p"},'"failed assert none"')," if, and only if, ",(0,i.kt)("inlineCode",{parentName:"p"},"opt")," is not ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"assert_none(opt)")," terminates the execution with the string\n",(0,i.kt)("inlineCode",{parentName:"p"},'"failed assert none"')," if, and only if, ",(0,i.kt)("inlineCode",{parentName:"p"},"opt")," is not ",(0,i.kt)("inlineCode",{parentName:"p"},"None()"),".")),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val abs : int -> nat"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let abs: (_: int) => nat"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"abs i")," is the absolute value of ",(0,i.kt)("inlineCode",{parentName:"p"},"i"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"abs(i)")," is the absolute value of ",(0,i.kt)("inlineCode",{parentName:"p"},"i"),".")),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val is_nat : int -> nat option"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let is_nat: (_: int) => option<nat>"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"is_nat i")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"Some n"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," is the absolute\nvalue of ",(0,i.kt)("inlineCode",{parentName:"p"},"i"),", if, and only if, ",(0,i.kt)("inlineCode",{parentName:"p"},"i")," is positive or zero.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"is_nat(i)")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"Some(n)"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," is the absolute\nvalue of ",(0,i.kt)("inlineCode",{parentName:"p"},"i"),", if, and only if, ",(0,i.kt)("inlineCode",{parentName:"p"},"i")," is positive or zero.")),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val int : 'a.'a -> int"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let int: <a>(_: a) => int"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"int v")," casts the value ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," to an integer."),(0,i.kt)("p",null,"  For natural numbers, the function ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," is the identity cast from\n",(0,i.kt)("inlineCode",{parentName:"p"},"nat")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"int"),". For BLS12-381 field elements, the returned value is\nalways between 0 (inclusive) and the order of the BLS12-381 field\n(exclusive). For bytes, the function ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," decodes the bytes using\nthe big-endian encoding, where negative numbers are considered in\ntwo's complement representation.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"int(v)")," casts the value ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," to an integer."),(0,i.kt)("p",null,"  For natural numbers, the function ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," is the identity cast from\n",(0,i.kt)("inlineCode",{parentName:"p"},"nat")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"int"),". For BLS12-381 field elements, the returned value is\nalways between 0 (inclusive) and the order of the BLS12-381 field\n(exclusive). For bytes, the function ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," decodes the bytes using\nthe big-endian encoding, where negative numbers are considered in\ntwo's complement representation.")),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val nat : bytes -> nat"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let nat: (_: bytes) => nat"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"nat b")," casts the bytes ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," into a natural number.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"nat(b)")," casts the bytes ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," into a natural number.")),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val ediv : 'a 'b.'a -> 'b -> ('a, 'b) external_ediv"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let ediv: <a, b>(_: a) => (_: b) => external_ediv<a, b>"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"ediv z1 z2"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"z1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"z2")," are either of type\n",(0,i.kt)("inlineCode",{parentName:"p"},"int")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"nat"),", returns ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," if ",(0,i.kt)("inlineCode",{parentName:"p"},"z2")," is zero; otherwise, it\nreturns the pair ",(0,i.kt)("inlineCode",{parentName:"p"},"(q,r)"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"q")," is the quotient and ",(0,i.kt)("inlineCode",{parentName:"p"},"r")," the\npositive remainder, as is the convention of the mathematical\nEuclidian division. The function ",(0,i.kt)("inlineCode",{parentName:"p"},"ediv")," is also overloaded to work\non values of type ",(0,i.kt)("inlineCode",{parentName:"p"},"tez"),". When ",(0,i.kt)("inlineCode",{parentName:"p"},"z1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"z2")," are of type ",(0,i.kt)("inlineCode",{parentName:"p"},"tez")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"z2")," is nonzero, we get a ",(0,i.kt)("inlineCode",{parentName:"p"},"nat")," quotient and a ",(0,i.kt)("inlineCode",{parentName:"p"},"tez"),"\nremainder. When ",(0,i.kt)("inlineCode",{parentName:"p"},"z1")," is a ",(0,i.kt)("inlineCode",{parentName:"p"},"tez")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"z2")," is a nonzero ",(0,i.kt)("inlineCode",{parentName:"p"},"nat"),", the\ncalls yields a quotient and a remainder both of type ",(0,i.kt)("inlineCode",{parentName:"p"},"tez"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"ediv(z1, z2)"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"z1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"z2")," are either of type\n",(0,i.kt)("inlineCode",{parentName:"p"},"int")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"nat"),", returns ",(0,i.kt)("inlineCode",{parentName:"p"},"None()")," if ",(0,i.kt)("inlineCode",{parentName:"p"},"z2")," is zero; otherwise, it\nreturns the pair ",(0,i.kt)("inlineCode",{parentName:"p"},"[q,r]"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"q")," is the quotient and ",(0,i.kt)("inlineCode",{parentName:"p"},"r")," the\npositive remainder, as is the convention of the mathematical\nEuclidian division. The function ",(0,i.kt)("inlineCode",{parentName:"p"},"ediv")," is also overloaded to work\non values of type ",(0,i.kt)("inlineCode",{parentName:"p"},"tez"),". When ",(0,i.kt)("inlineCode",{parentName:"p"},"z1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"z2")," are of type ",(0,i.kt)("inlineCode",{parentName:"p"},"tez")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"z2")," is nonzero, we get a ",(0,i.kt)("inlineCode",{parentName:"p"},"nat")," quotient and a ",(0,i.kt)("inlineCode",{parentName:"p"},"tez"),"\nremainder. When ",(0,i.kt)("inlineCode",{parentName:"p"},"z1")," is a ",(0,i.kt)("inlineCode",{parentName:"p"},"tez")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"z2")," is a nonzero ",(0,i.kt)("inlineCode",{parentName:"p"},"nat"),", the\ncalls yields a quotient and a remainder both of type ",(0,i.kt)("inlineCode",{parentName:"p"},"tez"),".")),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type 'elt big_set = 'elt Big_set.t"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type big_set<elt> = Big_set.t<elt>"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The type of the big sets is based on ",(0,i.kt)("inlineCode",{parentName:"p"},"big_map"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The type of the big sets is based on ",(0,i.kt)("inlineCode",{parentName:"p"},"big_map"),".")),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type dynamic_entrypoints = (nat, bytes) big_map"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type dynamic_entrypoints = big_map<nat, bytes>"),"Dynamic entrypoints",(0,i.kt)("p",null,"   Dynamic entrypoints are lazy entrypoints stored in the contract within\na big_map. They can then be updated or removed without deploying a new\ncontract."),(0,i.kt)("p",null,"   A contract with dynamic entrypoints must have at least one ",(0,i.kt)("inlineCode",{parentName:"p"},"@entry"),"\ndeclaration (as any other contract); it also must obey some\nconvention on storage type definition and have at least one\n",(0,i.kt)("inlineCode",{parentName:"p"},"@dyn_entry")," declaration."),(0,i.kt)("p",null,"   LIGO will then include the defined dynamic entries into the\ncontract initial storage."),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type dynamic_entrypoint"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type dynamic_entrypoint"),"A value of type `dynamic_entrypoint` denotes a typed key in an dynamic entrypoint",(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type michelson_program"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type michelson_program"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type typed_address"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type typed_address"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type mutation"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type mutation"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type michelson_contract"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type michelson_contract"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type pbt_gen"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type pbt_gen"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type int64"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type int64"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type views"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type views"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type test_exec_error_balance_too_low = { contract_balance : tez; contract_too_low : address; spend_request : tez }"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type test_exec_error_balance_too_low = { contract_balance: tez; contract_too_low: address; spend_request: tez }"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type test_exec_error = | Balance_too_low of test_exec_error_balance_too_low | Other of string | Rejected of (michelson_program * address)"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},'type test_exec_error = ["Balance_too_low", test_exec_error_balance_too_low] | ["Other", string] | ["Rejected", michelson_program, address]'),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type test_exec_result = | Fail of test_exec_error | Success of nat"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},'type test_exec_result = ["Fail", test_exec_error] | ["Success", nat]'),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type test_baker_policy = | By_account of address | By_round of int | Excluding of address list"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},'type test_baker_policy = ["By_account", address] | ["By_round", int] | ["Excluding", list<address>]'),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type 'a pbt_test = 'a pbt_gen * 'a -> bool"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type pbt_test<a> = [pbt_gen<a>, (_: a) => bool]"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type 'a pbt_result = | Fail of 'a | Success"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},'type pbt_result<a> = ["Fail", a] | ["Success"]'),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type 's unforged_ticket = { amount : nat; ticketer : address; value : 's }"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type unforged_ticket<s> = { amount: nat; ticketer: address; value: s }"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type ('param, 'storage) module_contract = ('param * 'storage) -> (operation list * 'storage) * 'storage views * dynamic_entrypoints option"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type module_contract<param, storage> = [(_: [param, storage]) => [list<operation>, storage], views<storage>, option<dynamic_entrypoints>]"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type ('param, 'storage) origination_result = { addr : ('param, 'storage) typed_address; code : ('param, 'storage) michelson_contract; size : int }"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type origination_result<param, storage> = { addr: typed_address<param, storage>; code: michelson_contract<param, storage>; size: int }"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type implicit_address = (unit, unit) typed_address"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type implicit_address = typed_address<unit, unit>"))}x.isMDXComponent=!0}}]);