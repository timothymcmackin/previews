"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[72264],{3905:(t,e,n)=>{n.d(e,{Zo:()=>c,kt:()=>y});var o=n(67294);function a(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function r(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);e&&(o=o.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,o)}return n}function i(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?r(Object(n),!0).forEach((function(e){a(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function l(t,e){if(null==t)return{};var n,o,a=function(t,e){if(null==t)return{};var n,o,a={},r=Object.keys(t);for(o=0;o<r.length;o++)n=r[o],e.indexOf(n)>=0||(a[n]=t[n]);return a}(t,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(o=0;o<r.length;o++)n=r[o],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(a[n]=t[n])}return a}var s=o.createContext({}),p=function(t){var e=o.useContext(s),n=e;return t&&(n="function"==typeof t?t(e):i(i({},e),t)),n},c=function(t){var e=p(t.components);return o.createElement(s.Provider,{value:e},t.children)},u={inlineCode:"code",wrapper:function(t){var e=t.children;return o.createElement(o.Fragment,{},e)}},d=o.forwardRef((function(t,e){var n=t.components,a=t.mdxType,r=t.originalType,s=t.parentName,c=l(t,["components","mdxType","originalType","parentName"]),d=p(n),y=a,m=d["".concat(s,".").concat(y)]||d[y]||u[y]||r;return n?o.createElement(m,i(i({ref:e},c),{},{components:n})):o.createElement(m,i({ref:e},c))}));function y(t,e){var n=arguments,a=e&&e.mdxType;if("string"==typeof t||a){var r=n.length,i=new Array(r);i[0]=d;var l={};for(var s in e)hasOwnProperty.call(e,s)&&(l[s]=e[s]);l.originalType=t,l.mdxType="string"==typeof t?t:a,i[1]=l;for(var p=2;p<r;p++)i[p]=n[p];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},93574:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>s,contentTitle:()=>i,default:()=>y,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var o=n(87462),a=(n(67294),n(3905));const r={title:"How to deal with the change of the default datatype layout to @layout comb ?",description:'Explore the challenges and solutions associated with the default datatype layout change to @layout comb in LIGO 1.0. For a comprehensive background on the change, refer to our "Why" article.',slug:"layout-comb-how",authors:["tomjack"],tags:["explainer"],image:"https://i.imgur.com/mErPwqL.png",hide_table_of_contents:!0},i=void 0,l={permalink:"/blog/layout-comb-how",source:"@site/blog/2023-09-09-layout-comb-how.md",title:"How to deal with the change of the default datatype layout to @layout comb ?",description:'Explore the challenges and solutions associated with the default datatype layout change to @layout comb in LIGO 1.0. For a comprehensive background on the change, refer to our "Why" article.',date:"2023-09-09T00:00:00.000Z",formattedDate:"September 9, 2023",tags:[{label:"explainer",permalink:"/blog/tags/explainer"}],readingTime:4.04,hasTruncateMarker:!0,authors:[{name:"Tom Jack",title:"Developer at Ligo",url:"https://gitlab.com/tomjack",email:"tom@marigold.dev",imageURL:"https://secure.gravatar.com/avatar/d62c4ef79b9ef198c43a82d555fbd5fa9510464195223b160771910eb991e6fc?s=800&d=identicon",key:"tomjack"}],frontMatter:{title:"How to deal with the change of the default datatype layout to @layout comb ?",description:'Explore the challenges and solutions associated with the default datatype layout change to @layout comb in LIGO 1.0. For a comprehensive background on the change, refer to our "Why" article.',slug:"layout-comb-how",authors:["tomjack"],tags:["explainer"],image:"https://i.imgur.com/mErPwqL.png",hide_table_of_contents:!0},prevItem:{title:"Migration to LIGO v1.0",permalink:"/blog/v1-migration-guide"},nextItem:{title:"Why did the default datatype layout change to @layout comb?",permalink:"/blog/layout-comb-why"}},s={authorsImageUrls:[void 0]},p=[{value:"Easy way out",id:"easy-way-out",level:2},{value:"What&#39;s the problem?",id:"whats-the-problem",level:2},{value:"How to deal with compatibility problems?",id:"how-to-deal-with-compatibility-problems",level:2},{value:"Type errors from layouts",id:"type-errors-from-layouts",level:2}],c=(u="Syntax",function(t){return console.warn("Component "+u+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.kt)("div",t)});var u;const d={toc:p};function y(t){let{components:e,...n}=t;return(0,a.kt)("wrapper",(0,o.Z)({},d,n,{components:e,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"See ",(0,a.kt)("a",{parentName:"p",href:"/blog/layout-comb-why"},"Why did the default datatype layout change to ",(0,a.kt)("inlineCode",{parentName:"a"},"@layout comb")," ?"),"\nfor background about this change."),(0,a.kt)("h2",{id:"easy-way-out"},"Easy way out"),(0,a.kt)("p",null,"To take the easy way out, set the ",(0,a.kt)("inlineCode",{parentName:"p"},"LIGO_LEGACY_LAYOUT_TREE"),"\nenvironment variable:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"export LIGO_LEGACY_LAYOUT_TREE=\n")),(0,a.kt)("p",null,"This will cause LIGO to undo the change, letting ",(0,a.kt)("inlineCode",{parentName:"p"},"@layout tree")," remain\nthe default."),(0,a.kt)("p",null,"This is only a temporary solution, intended to let people easily\nmigrate to LIGO 1.0, which should be considered already deprecated\nas it will eventually be removed."),(0,a.kt)("h2",{id:"whats-the-problem"},"What's the problem?"),(0,a.kt)("p",null,"If you do not take the easy way out, it's important to understand the\nproblem."),(0,a.kt)("p",null,"In theory, it is possible that after upgrading to LIGO 1.0, your\ncontracts could compile successfully, your ",(0,a.kt)("inlineCode",{parentName:"p"},"ligo run test"),' could pass,\nand even "integration" tests (e.g. using a sandbox or test Tezos\nnetwork) could pass, yet after deployment you might still find that\nyour contracts are catastrophically broken.'),(0,a.kt)("p",null,"This can happen if your contracts need to interact with other\ncontracts, which are either:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"already deployed on mainnet, or"),(0,a.kt)("li",{parentName:"ul"},"compiled using an older version of LIGO, or"),(0,a.kt)("li",{parentName:"ul"},"compiled using a non-LIGO compiler, or"),(0,a.kt)("li",{parentName:"ul"},"implementing some standardized interface")),(0,a.kt)("p",null,"If the compiled interface types (parameter, view, ...) for these\ninteractions change when you upgrade to LIGO 1.0, because you\npreviously (implicitly) used ",(0,a.kt)("inlineCode",{parentName:"p"},"@layout tree")," and now the types use\n",(0,a.kt)("inlineCode",{parentName:"p"},"@layout comb"),", this will break compatibility, and the interactions\nwill fail."),(0,a.kt)("p",null,"For example, consider the following test, involving communication\nbetween two contracts over a parameter type ",(0,a.kt)("inlineCode",{parentName:"p"},"foo"),":"),(0,a.kt)(c,{syntax:"cameligo",mdxType:"Syntax"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cameligo"},'type foo =\n  { foo : nat ;\n    bar : int ;\n    baz : string }\n\nmodule Foo = struct\n  [@entry]\n  let foo (_ : foo) (s : unit) : operation list * unit =\n    ([], s)\n\n  (* dummy entrypoint to avoid bug with single entrypoint :( *)\n  [@entry]\n  let dummy (_ : unit) (s : unit) : operation list * unit =\n    ([], s)\nend\n\nmodule Bar = struct\n  [@entry]\n  let bar (addr : address) (s : unit) : operation list * unit =\n    let arg : foo = {foo = 1n; bar = 2; baz = "three"} in\n    let amt : tez = 0tz in\n    let dst : foo contract = Tezos.get_entrypoint "%foo" addr in\n    let tx = Tezos.transaction arg amt dst in\n    ([tx], s)\n\n  (* dummy entrypoint to avoid bug with single entrypoint :( *)\n  [@entry]\n  let dummy (_ : unit) (s : unit) : operation list * unit =\n    ([], s)\nend\n\nlet test_interaction () =\n  let orig_foo = Test.originate (contract_of Foo) () 0tz in\n  let foo_addr = Test.to_address orig_foo.addr in\n  let orig_bar = Test.originate (contract_of Bar) () 0tz in\n  Test.transfer_exn orig_bar.addr (Bar foo_addr) 0tz\n'))),(0,a.kt)(c,{syntax:"jsligo",mdxType:"Syntax"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsligo"},'type foo = {\n  foo : nat,\n  bar : int,\n  baz : string\n}\n\nnamespace Foo {\n  @entry\n  const foo = (_: foo, s: unit) : [list<operation>, unit] => [[], s];\n\n  // dummy entrypoint to avoid bug with single entrypoint :(\n  @entry\n  const dummy = (_: unit, s: unit) : [list<operation>, unit] => [[], s];\n};\n\nnamespace Bar {\n  @entry\n  const bar = (addr: address, s: unit) : [list<operation>, unit] => {\n    const arg : foo = {foo: 1n, bar: 2, baz: "three"};\n    const amt : tez = 0tz;\n    const dst : contract<foo> = Tezos.get_entrypoint("%foo", addr);\n    const tx = Tezos.transaction(arg, amt, dst);\n    return [[tx], s];\n  }\n\n  // dummy entrypoint to avoid bug with single entrypoint :(\n  @entry\n  const dummy = (_: unit, s: unit) : [list<operation>, unit] => [[], s];\n};\n\nconst test_interaction = do{\n  const orig_foo = Test.originate(contract_of(Foo), unit, 0tz);\n  const foo_addr = Test.to_address (orig_foo.addr);\n  const orig_bar = Test.originate(contract_of(Bar), unit, 0tz);\n  Test.transfer_exn(orig_bar.addr, Bar(foo_addr), 0tz);\n};\n'))),(0,a.kt)("p",null,"Note that this test will pass after upgrading to LIGO 1.0, because\nwhen running the test, both ",(0,a.kt)("inlineCode",{parentName:"p"},"Foo")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Bar")," use the ",(0,a.kt)("inlineCode",{parentName:"p"},"comb")," layout for\nthe parameter type ",(0,a.kt)("inlineCode",{parentName:"p"},"foo"),". However, if there is already a ",(0,a.kt)("inlineCode",{parentName:"p"},"Foo"),"\ncontract deployed on mainnet, e.g. compiled using an older LIGO\nversion, then a newly compiled ",(0,a.kt)("inlineCode",{parentName:"p"},"Bar")," contract will be unable to\ncommunicate with it, because the new ",(0,a.kt)("inlineCode",{parentName:"p"},"foo")," type will be incompatible!"),(0,a.kt)("p",null,"So, in order to test that your contracts still work correctly, you\nmust either manually check that the interface types have changed, or\ntest interactions with the actual contracts you will need to interact\nwith."),(0,a.kt)("p",null,"In particular, if you are testing compatibility for interactions, you\nshould NOT only test interactions against contracts compiled using\nLIGO 1.0, e.g. using ",(0,a.kt)("inlineCode",{parentName:"p"},"ligo test"),", because those contracts will use the\nnew layout too!"),(0,a.kt)("p",null,"If, on the other hand, you will deploy a ",(0,a.kt)("em",{parentName:"p"},"new")," set of contracts which\nonly interact amongst themselves, then you have nothing to worry\nabout. It is only interactions with pre-existing or standardized\ncontracts that can cause trouble."),(0,a.kt)("h2",{id:"how-to-deal-with-compatibility-problems"},"How to deal with compatibility problems?"),(0,a.kt)("p",null,"If you have compatibility problems like this, and you don't take the\neasy way out with ",(0,a.kt)("inlineCode",{parentName:"p"},"LIGO_LEGACY_LAYOUT_TREE"),", you might need to switch\nsome types back to the tree layout."),(0,a.kt)("p",null,"Here are some examples of how to do that:"),(0,a.kt)(c,{syntax:"cameligo",mdxType:"Syntax"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cameligo"},"type tree_record =\n  [@layout tree]\n  { foo : nat ;\n    bar : int ;\n    baz : string }\n\ntype tree_variant =\n  [@layout tree]\n  | Foo of nat\n  | Bar of int\n  | Baz of string\n\ntype tree_tuple =\n  [@layout tree] (nat * int * string)\n  (* the parentheses are required, else the @layout attribute will\n     attach to the first tuple field instead of the tuple type *)\n\nlet anon_tree_tuple (p : [@layout tree] (nat * int * string)) : [@layout tree] (nat * int * string) = p\n"))),(0,a.kt)(c,{syntax:"jsligo",mdxType:"Syntax"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsligo"},'type tree_variant =\n  @layout("tree")\n  | ["Foo", nat]\n  | ["Bar", int]\n  | ["Baz", string];\n\ntype tree_record =\n  @layout("tree")\n  {\n    foo : int,\n    bar : int\n  };\n\n// in JsLIGO, you must assign names to tuple types in order to put\n// them back into tree layout, and then use these names at use sites instead\n// of repeating the tuple type\n\ntype tree_tuple = @layout("tree") [nat, int, string];\n'))),(0,a.kt)("h2",{id:"type-errors-from-layouts"},"Type errors from layouts"),(0,a.kt)("p",null,"In some cases, you may get type errors due to mismatched type layouts."),(0,a.kt)("p",null,"Here is an example. Before LIGO 1.0, this code worked OK:"),(0,a.kt)(c,{syntax:"cameligo",mdxType:"Syntax"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},"type record1 =\n  { foo : nat ;\n    bar : int ;\n    baz : string }\n\ntype record2 =\n  { baz : string ;\n    bar : int ;\n    foo : nat }\n\nlet id (r : record1) : record2 = r\n"))),(0,a.kt)(c,{syntax:"jsligo",mdxType:"Syntax"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},"type record1 = {\n  foo : nat,\n  bar : int,\n  baz : string\n}\n\ntype record2 = {\n  baz : string,\n  bar : int,\n  foo : nat\n}\n\nconst id = (r: record1): record2 => r;\n"))),(0,a.kt)("p",null,"However, as of LIGO 1.0, this example gives a type error:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'Invalid type(s)\nCannot unify "record1" with "record2" due to differing layouts "({ name: foo }, { name: bar }, { name: baz })" and "({ name: baz }, { name: bar }, { name: foo })"\n')),(0,a.kt)("p",null,"The reason for this is that in the old ",(0,a.kt)("inlineCode",{parentName:"p"},"tree")," layout, the fields were sorted alphabetically, but in the ",(0,a.kt)("inlineCode",{parentName:"p"},"comb")," layout they are taken in the declared order."),(0,a.kt)("p",null,"You can fix this problem either by switching back to the ",(0,a.kt)("inlineCode",{parentName:"p"},"tree")," layout (see the previous section) or by writing the fields in a consistent order."))}y.isMDXComponent=!0}}]);