"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[45379],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>d});var i=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},s=Object.keys(e);for(i=0;i<s.length;i++)n=s[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(i=0;i<s.length;i++)n=s[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var o=i.createContext({}),g=function(e){var t=i.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=g(e.components);return i.createElement(o.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,s=e.originalType,o=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=g(n),d=a,c=u["".concat(o,".").concat(d)]||u[d]||m[d]||s;return n?i.createElement(c,r(r({ref:t},p),{},{components:n})):i.createElement(c,r({ref:t},p))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=n.length,r=new Array(s);r[0]=u;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l.mdxType="string"==typeof e?e:a,r[1]=l;for(var g=2;g<s;g++)r[g]=n[g];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},48720:(e,t,n)=>{n.d(t,{D:()=>a.Z,Z:()=>s});var i=n(67294),a=n(75402);const s=function(e){return i.createElement(a.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:i.createElement(i.Fragment,null)}))}},97109:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>g,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var i=n(87462),a=(n(67294),n(3905)),s=n(48720);const r={title:"Big sets",id:"big_sets"},l=void 0,o={unversionedId:"data-types/big_sets",id:"data-types/big_sets",title:"Big sets",description:"Sets are unordered collections of values of the same type, like lists",source:"@site/../docs/data-types/big_sets.md",sourceDirName:"data-types",slug:"/data-types/big_sets",permalink:"/docs/next/data-types/big_sets",draft:!1,tags:[],version:"current",frontMatter:{title:"Big sets",id:"big_sets"},sidebar:"docs",previous:{title:"Contracts",permalink:"/docs/next/data-types/contracts-type"},next:{title:"Big maps",permalink:"/docs/next/data-types/big_maps"}},g={},p=[{value:"Searching",id:"searching",level:2},{value:"Adding",id:"adding",level:2},{value:"Removing",id:"removing",level:2},{value:"Updating",id:"updating",level:2}],m={toc:p};function u(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,i.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Sets are unordered collections of values of the same type, like lists\nare ordered collections. Like the mathematical sets and lists, sets\ncan be empty and, if not, elements of sets in LIGO are ",(0,a.kt)("em",{parentName:"p"},"unique"),",\nwhereas they can be repeated in a ",(0,a.kt)("em",{parentName:"p"},"list"),"."),(0,a.kt)("p",null,"Like lists, the type of sets is parameterised over the type of its\nelements. Like list elements, set elements must all have the same\ntype."),(0,a.kt)("p",null,"Ordinary sets are fine for contracts with a finite lifespan or a\nbounded number of users. For many contracts however, the intention is\nto have a set holding ",(0,a.kt)("em",{parentName:"p"},"many")," entries, potentially millions of\nthem. The cost of loading those entries into the environment each time\na user executes the contract would eventually become too expensive\nwere it not for ",(0,a.kt)("em",{parentName:"p"},"big sets"),". Big sets in LIGO are based on ",(0,a.kt)("em",{parentName:"p"},"big maps"),",\na data structure offered by Michelson which handles the scaling\nconcerns for us. The interface for big sets closer to that of big maps\nthan ordinary sets (for example, it would defeat the purpose to\nrequest the size of a big set)."),(0,a.kt)(s.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,a.kt)("p",null,"The type of big sets is ",(0,a.kt)("inlineCode",{parentName:"p"},"'elt big_set")," or, equivalently, ",(0,a.kt)("inlineCode",{parentName:"p"},"'elt\nBig_set."),", where ",(0,a.kt)("inlineCode",{parentName:"p"},"'elt")," is the type of the elements of the big set. It\nis defined as follows in the standard library:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=big_sets",group:"big_sets"},"type 'elt t = ('elt, unit) big_map\n")),(0,a.kt)("p",null,"The empty big set is denoted by the predefined value\n",(0,a.kt)("inlineCode",{parentName:"p"},"Big_set.empty"),". In some contexts, it is useful to annotate it with\nits type, for example: ",(0,a.kt)("inlineCode",{parentName:"p"},"(empty : int Big_set.t)"),"."),(0,a.kt)("p",null,"A non-empty big set can be built by using the function\n",(0,a.kt)("inlineCode",{parentName:"p"},"Big_set.literal")," which takes a list of ",(0,a.kt)("em",{parentName:"p"},"literal elements")," and returns\na set containing them, and only them."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=big_sets",group:"big_sets"},"let empty_big_set : int big_set = Big_set.empty\nlet big_set1 : int big_set = Big_set.literal [3; 2; 2; 1]\n")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Note: The element ",(0,a.kt)("inlineCode",{parentName:"p"},"2")," is repeated in the list, but not in the set\nmade from it.")),(0,a.kt)("p",null,"If you want to build a big set from an arbitrary list of arbitrary\nvalues (not just literal values), then you must use ",(0,a.kt)("inlineCode",{parentName:"p"},"Big_set.of_list"),"\ninstead of ",(0,a.kt)("inlineCode",{parentName:"p"},"Big_set.literal"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=big_sets",group:"big_sets"},"let two = 2\nlet big_set2 : int big_set = Big_set.of_list [3; two; two; 1]\n"))),(0,a.kt)(s.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,a.kt)("p",null,"The type of big sets is ",(0,a.kt)("inlineCode",{parentName:"p"},"big_set<elt>")," or, equivalently,\n",(0,a.kt)("inlineCode",{parentName:"p"},"Big_set.t<elt>"),", where ",(0,a.kt)("inlineCode",{parentName:"p"},"elt")," is the type of the elements of the big\nset. It is defined as follows in the standard library:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=big_sets",group:"big_sets"},"type t<elt> = big_map<elt, unit>\n")),(0,a.kt)("p",null,"The empty big set is denoted by the predefined value\n",(0,a.kt)("inlineCode",{parentName:"p"},"Big_set.empty"),". In some contexts, it is useful to annotate it with\nits type, for example: ",(0,a.kt)("inlineCode",{parentName:"p"},"(empty as Big_set.t<int>)"),"."),(0,a.kt)("p",null,"A non-empty big set can be built by using the function\n",(0,a.kt)("inlineCode",{parentName:"p"},"Big_set.literal")," which takes a list of elements and returns a set\ncontaining them, and only them."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=big_sets",group:"big_sets"},"const empty_big_set: big_set<int> = Big_set.empty;\nconst big_set1: big_set<int> = Big_set.literal([3, 2, 2, 1]);\n")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Note: The element ",(0,a.kt)("inlineCode",{parentName:"p"},"2")," is repeated in the list, but not in the set\nmade from it.")),(0,a.kt)("p",null,"If you want to build a big set from an arbitrary list of arbitrary\nvalues (not just literal values), then you must use ",(0,a.kt)("inlineCode",{parentName:"p"},"Big_set.of_list"),"\ninstead of ",(0,a.kt)("inlineCode",{parentName:"p"},"Big_set.literal"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=big_sets",group:"big_sets"},"const two = 2;\nconst big_set2 : big_set<int> = Big_set.of_list([3, two, two, 1]);\n"))),(0,a.kt)("p",null,"Set elements are internally sorted by increasing values, so the type\nof the elements must be ",(0,a.kt)("em",{parentName:"p"},"comparable"),", that is, they obey a total order\n(any two elements can be compared)."),(0,a.kt)("h2",{id:"searching"},"Searching"),(0,a.kt)("p",null,"The predicate ",(0,a.kt)("inlineCode",{parentName:"p"},"Big_set.mem")," tests for membership in a given big set."),(0,a.kt)(s.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=big_set_membership",group:"big_set_membership"},"let my_big_set : int big_set = Big_set.literal [3; 2; 2; 1]\nlet contains_3 : bool = Big_set.mem 3 my_big_set // = true\n"))),(0,a.kt)(s.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=big_set_membership",group:"big_set_membership"},"const my_big_set: big_set<int> = Big_set.literal([3, 2, 2, 1]);\nconst contains_3: bool = Big_set.mem(3, my_big_set); // == true\n"))),(0,a.kt)("h2",{id:"adding"},"Adding"),(0,a.kt)("p",null,"Adding an element to a big set is done by calling the function\n",(0,a.kt)("inlineCode",{parentName:"p"},"Big_set.add"),". If the element was already present in the given big\nset, the resulting big set is the same as the original one."),(0,a.kt)(s.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=big_set_adding",group:"big_set_adding"},"let my_big_set : int big_set = Big_set.literal [3; 2; 2; 1]\nlet with_4 : int big_set = Big_set.add 4 my_big_set\n"))),(0,a.kt)(s.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=big_set_adding",group:"big_set_adding"},"const my_big_set: big_set<int> = Big_set.literal([3, 2, 2, 1]);\nconst with_4: big_set<int> = Big_set.add(4, my_big_set);\n"))),(0,a.kt)("h2",{id:"removing"},"Removing"),(0,a.kt)("p",null,"The function ",(0,a.kt)("inlineCode",{parentName:"p"},"Big_set.remove")," creates a big set containing the\nelements of a given big set, without a given element. If the element\nis not already present, the new big set is the same as the old one, as\nexpected."),(0,a.kt)(s.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=big_set_removing",group:"big_set_removing"},"let my_big_set : int big_set = Big_set.literal [3; 2; 2; 1]\nlet new_big_set = Big_set.remove 3 my_big_set\nlet contains_3 = Big_set.mem 3 new_big_set // = false\n"))),(0,a.kt)(s.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=set_removing",group:"set_removing"},"const my_big_set: big_set<int> = Big_set.literal([3, 2, 2, 1]);\nconst new_big_set = Big_set.remove(3, my_big_set);\nconst contains_3 = Big_set.mem(3, new_big_set); // == false\n"))),(0,a.kt)("h2",{id:"updating"},"Updating"),(0,a.kt)("p",null,"Previous sections show how to add and remove an element from a given\nbig set. The function ",(0,a.kt)("inlineCode",{parentName:"p"},"Big_set.update")," can do both depending on a\nboolean value: if true, then the given value will be added to the big\nset, otherwise it will be removed (if present)."),(0,a.kt)(s.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=big_set_updating",group:"big_set_updating"},"let nats : int big_set = Big_set.literal [3; 2; 2; 1]\nlet big_set_with_5 = Big_set.update 5 true nats\nlet big_set_without_3 = Big_set.update 3 false nats\n"))),(0,a.kt)(s.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=big_set_updating",group:"big_set_updating"},"const nats: big_set<int> = Big_set.literal([3, 2, 2, 1]);\nconst big_set_with_5 = Big_set.update(5, true, nats);\nconst big_set_without_3 = Big_set.update(3, false, nats);\n"))))}u.isMDXComponent=!0}}]);