"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[66455],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>u});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=a.createContext({}),p=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(o.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,o=e.parentName,m=i(e,["components","mdxType","originalType","parentName"]),c=p(n),u=r,g=c["".concat(o,".").concat(u)]||c[u]||d[u]||l;return n?a.createElement(g,s(s({ref:t},m),{},{components:n})):a.createElement(g,s({ref:t},m))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,s=new Array(l);s[0]=c;var i={};for(var o in t)hasOwnProperty.call(t,o)&&(i[o]=t[o]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var p=2;p<l;p++)s[p]=n[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},48720:(e,t,n)=>{n.d(t,{D:()=>r.Z,Z:()=>l});var a=n(67294),r=n(75402);const l=function(e){return a.createElement(r.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},69012:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>c,frontMatter:()=>s,metadata:()=>o,toc:()=>m});var a=n(87462),r=(n(67294),n(3905)),l=n(48720);const s={title:"Sets"},i=void 0,o={unversionedId:"data-types/sets",id:"version-1.7.0/data-types/sets",title:"Sets",description:"Sets are unordered collections of values of the same type, like lists",source:"@site/versioned_docs/version-1.7.0/data-types/sets.md",sourceDirName:"data-types",slug:"/data-types/sets",permalink:"/docs/data-types/sets",draft:!1,tags:[],version:"1.7.0",frontMatter:{title:"Sets"},sidebar:"docs",previous:{title:"Records",permalink:"/docs/data-types/records"},next:{title:"Maps",permalink:"/docs/data-types/maps"}},p={},m=[{value:"Sizing",id:"sizing",level:2},{value:"Searching",id:"searching",level:2},{value:"Adding",id:"adding",level:2},{value:"Removing",id:"removing",level:2},{value:"Updating",id:"updating",level:2},{value:"Folding",id:"folding",level:2},{value:"Mapping",id:"mapping",level:2},{value:"Iterating",id:"iterating",level:2},{value:"Looping",id:"looping",level:2}],d={toc:m};function c(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Sets are unordered collections of values of the same type, like lists\nare ordered collections. Like the mathematical sets and lists, sets\ncan be empty and, if not, elements of sets in LIGO are ",(0,r.kt)("em",{parentName:"p"},"unique"),",\nwhereas they can be repeated in a ",(0,r.kt)("em",{parentName:"p"},"list"),"."),(0,r.kt)("p",null,"Like lists, the type of sets is parameterised over the type of its\nelements. Like list elements, set elements must all have the same\ntype."),(0,r.kt)("p",null,"The empty set is denoted by the predefined value ",(0,r.kt)("inlineCode",{parentName:"p"},"Set.empty"),". A\nnon-empty set can be built by using the function ",(0,r.kt)("inlineCode",{parentName:"p"},"Set.literal")," which\ntakes a list of ",(0,r.kt)("em",{parentName:"p"},"literal elements")," and returns a set containing them,\nand only them."),(0,r.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=sets",group:"sets"},"let empty_set : int set = Set.empty\nlet set1 : int set = Set.literal [3; 2; 2; 1]\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note: The element ",(0,r.kt)("inlineCode",{parentName:"p"},"2")," is repeated in the list, but not in the set\nmade from it.")),(0,r.kt)("p",null,"Note: See the predefined\n",(0,r.kt)("a",{parentName:"p",href:"../reference/set-reference/?lang=cameligo"},"module Set"))),(0,r.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=sets",group:"sets"},"const empty_set: set<int> = Set.empty;\nconst set1: set<int> = Set.literal([3, 2, 2, 1]);\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note: The element ",(0,r.kt)("inlineCode",{parentName:"p"},"2")," is repeated in the list, but not in the set\nmade from it.")),(0,r.kt)("p",null,"Note: See the predefined\n",(0,r.kt)("a",{parentName:"p",href:"../reference/set-reference/?lang=jsligo"},"namespace Set")),(0,r.kt)("p",null,"If you want to build a big set from an arbitrary list of arbitrary\nvalues (not just literal values), then you must use ",(0,r.kt)("inlineCode",{parentName:"p"},"Set.of_list"),"\ninstead of ",(0,r.kt)("inlineCode",{parentName:"p"},"Set.literal"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=sets",group:"sets"},"const two = 2;\nconst set2 : set<int> = Set.of_list([3, two, two, 1]);\n"))),(0,r.kt)("p",null,"Set elements are internally sorted by increasing values, so the type\nof the elements must be ",(0,r.kt)("em",{parentName:"p"},"comparable"),", that is, they obey a total order\n(any two elements can be compared)."),(0,r.kt)("h2",{id:"sizing"},"Sizing"),(0,r.kt)("p",null,"The predefined functions ",(0,r.kt)("inlineCode",{parentName:"p"},"Set.size")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Set.cardinal")," return the\nnumber of elements in a given set."),(0,r.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=cardinal",group:"cardinal"},"let my_set : int set = Set.literal [3; 2; 2; 1]\nlet cardinal : nat = Set.size my_set // = 3\n")),(0,r.kt)("p",null,"Note: See the predefined\n",(0,r.kt)("a",{parentName:"p",href:"../reference/set-reference/?lang=cameligo"},"module Set"))),(0,r.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=cardinal",group:"cardinal"},"const my_set: set<int> = Set.literal([3, 2, 2, 1]);\nconst cardinal : nat = Set.size(my_set); // == 3\n")),(0,r.kt)("p",null,"Note: See the predefined\n",(0,r.kt)("a",{parentName:"p",href:"../reference/set-reference/?lang=jsligo"},"namespace Set"))),(0,r.kt)("h2",{id:"searching"},"Searching"),(0,r.kt)("p",null,"The predicate ",(0,r.kt)("inlineCode",{parentName:"p"},"Set.mem")," tests for membership in a given set."),(0,r.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=set_membership",group:"set_membership"},"let my_set : int set = Set.literal [3; 2; 2; 1]\nlet contains_3 : bool = Set.mem 3 my_set // = true\n")),(0,r.kt)("p",null,"Note: See the predefined\n",(0,r.kt)("a",{parentName:"p",href:"../reference/set-reference/?lang=cameligo"},"module Set"))),(0,r.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=set_membership",group:"set_membership"},"const my_set: set<int> = Set.literal([3, 2, 2, 1]);\nconst contains_3: bool = Set.mem(3, my_set); // == true\n")),(0,r.kt)("p",null,"Note: See the predefined\n",(0,r.kt)("a",{parentName:"p",href:"../reference/set-reference/?lang=jsligo"},"namespace Set"))),(0,r.kt)("h2",{id:"adding"},"Adding"),(0,r.kt)("p",null,"Adding an element to a set is done by calling the function\n",(0,r.kt)("inlineCode",{parentName:"p"},"Set.add"),". If the element was already present in the given set, the\nresulting set is the same as the original one."),(0,r.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=set_adding",group:"set_adding"},"let my_set : int set = Set.literal [3; 2; 2; 1]\nlet with_4 : int set = Set.add 4 my_set\n")),(0,r.kt)("p",null,"Note: See the predefined\n",(0,r.kt)("a",{parentName:"p",href:"../reference/set-reference/?lang=cameligo"},"module Set"))),(0,r.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=set_adding",group:"set_adding"},"const my_set: set<int> = Set.literal([3, 2, 2, 1]);\nconst with_4: set<int> = Set.add(4, my_set);\n")),(0,r.kt)("p",null,"Note: See the predefined\n",(0,r.kt)("a",{parentName:"p",href:"../reference/set-reference/?lang=jsligo"},"namespace Set"))),(0,r.kt)("h2",{id:"removing"},"Removing"),(0,r.kt)("p",null,"The function ",(0,r.kt)("inlineCode",{parentName:"p"},"Set.remove")," creates a set containing the elements of a\ngiven set, without a given element. If the element is not already\npresent, the new set is the same as the old one, as expected."),(0,r.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=set_removing",group:"set_removing"},"let my_set : int set = Set.literal [3; 2; 2; 1]\nlet new_set = Set.remove 3 my_set\nlet contains_3 = Set.mem 3 new_set // = false\n")),(0,r.kt)("p",null,"Note: See the predefined\n",(0,r.kt)("a",{parentName:"p",href:"../reference/set-reference/?lang=cameligo"},"module Set"))),(0,r.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=set_removing",group:"set_removing"},"const my_set: set<int> = Set.literal([3, 2, 2, 1]);\nconst new_set = Set.remove(3, my_set);\nconst contains_3 = Set.mem(3, new_set); // == false\n")),(0,r.kt)("p",null,"Note: See the predefined\n",(0,r.kt)("a",{parentName:"p",href:"../reference/set-reference/?lang=jsligo"},"namespace Set"))),(0,r.kt)("h2",{id:"updating"},"Updating"),(0,r.kt)("p",null,"Previous sections show how to add and remove an element from a given\nset. The function ",(0,r.kt)("inlineCode",{parentName:"p"},"Set.update")," can do both depending on a boolean\nvalue: if true, then the given value will be added to the set,\notherwise it will be removed (if present)."),(0,r.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=set_updating",group:"set_updating"},"let nats : int set = Set.literal [3; 2; 2; 1]\nlet set_with_5 = Set.update 5 true nats\nlet set_without_3 = Set.update 3 false nats\n"))),(0,r.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=set_updating",group:"set_updating"},"const nats: set<int> = Set.literal([3, 2, 2, 1]);\nconst set_with_5 = Set.update(5, true, nats);\nconst set_without_3 = Set.update(3, false, nats);\n"))),(0,r.kt)("p",null,"The function ",(0,r.kt)("inlineCode",{parentName:"p"},"Set.update")," implements a one-value update. Sometime we\nwould like to provide a function that is applied in turn to ",(0,r.kt)("em",{parentName:"p"},"all")," the\nelements of the set, and specifies whether the element at hand has to\nbe discarded or replaced by a computed value. This is what\n",(0,r.kt)("inlineCode",{parentName:"p"},"Set.filter_map")," does."),(0,r.kt)("p",null,"As an example, let us consider a function that removes all the even\nnumbers from a set."),(0,r.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=set_updating",group:"set_updating"},"let f x = if x mod 2 = 0n then None else Some x\n// odds = Set.literal [3, 1]\nlet odds = Set.filter_map f nats\n")),(0,r.kt)("p",null,"Note: See the predefined\n",(0,r.kt)("a",{parentName:"p",href:"../reference/set-reference/?lang=cameligo"},"module Set"))),(0,r.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=set_updating",group:"set_updating"},"const f = x => x % 2 == 0n ? None() : Some(x);\n// odds == Set.literal([3, 1])\nconst odds = Set.filter_map(f, nats);\n")),(0,r.kt)("p",null,"Note: See the predefined\n",(0,r.kt)("a",{parentName:"p",href:"../reference/set-reference/?lang=jsligo"},"namespace Set"))),(0,r.kt)("h2",{id:"folding"},"Folding"),(0,r.kt)("p",null,"A ",(0,r.kt)("em",{parentName:"p"},"functional iterator")," is a function that traverses a data structure\nand calls in turn a given function over the elements of that structure\nto compute some value. Another approach is sometimes possible:\n",(0,r.kt)("em",{parentName:"p"},"loops"),"."),(0,r.kt)("p",null,"There are three kinds of functional iterations over sets: the ",(0,r.kt)("em",{parentName:"p"},"fold"),",\nthe ",(0,r.kt)("em",{parentName:"p"},"map")," (not to be confused with the ",(0,r.kt)("em",{parentName:"p"},"map data structure"),") and the\n",(0,r.kt)("em",{parentName:"p"},"iteration"),"."),(0,r.kt)("p",null,"Let us consider first here the fold, which is the most general form of\nfunctional iteration. The folded function takes two arguments: an\n",(0,r.kt)("em",{parentName:"p"},"accumulator")," and the structure ",(0,r.kt)("em",{parentName:"p"},"element")," at hand, with which it then\nproduces a new accumulator. This enables having a partial result that\nbecomes complete when the traversal of the data structure is over."),(0,r.kt)("p",null,"The function ",(0,r.kt)("inlineCode",{parentName:"p"},"Set.fold")," performs a fold over a set, in increasing\norder of its elements. The function ",(0,r.kt)("inlineCode",{parentName:"p"},"Set.fold_desc")," folds in\ndecreasing order. The different in their types is the type of the\nfolded operation: with ",(0,r.kt)("inlineCode",{parentName:"p"},"Set.fold"),", that function takes the accumulator\nfirst, whereas with ",(0,r.kt)("inlineCode",{parentName:"p"},"Set.fold_desc"),", the accumulator comes second."),(0,r.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=set_folding",group:"set_folding"},"let s : int set = Set.literal [1; 2; 3]\n// incr = [3; 2; 1]\nlet incr : int list = Set.fold (fun (a,i) -> i::a) s []\n// decr = [1; 2; 3]\nlet decr : int list = Set.fold_desc (fun (i,a) -> i::a) s []\n")),(0,r.kt)("p",null,"Note: See the predefined\n",(0,r.kt)("a",{parentName:"p",href:"../reference/set-reference/?lang=cameligo"},"module Set"))),(0,r.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=set_folding",group:"set_folding"},"const s : set<int> = Set.literal([1, 2, 3]);\n// incr == [3, 2, 1]\nconst incr : list<int> = Set.fold (([a,i]) => ([i,...a] as list<int>), s, []);\n// decr == [1, 2, 3]\nconst decr : list<int> = Set.fold_desc (([i,a]) => ([i,...a] as list<int>), s, []);\n")),(0,r.kt)("p",null,"Note: See the predefined\n",(0,r.kt)("a",{parentName:"p",href:"../reference/set-reference/?lang=jsligo"},"namespace Set"))),(0,r.kt)("h2",{id:"mapping"},"Mapping"),(0,r.kt)("p",null,"We may want to change all the elements of a given set by applying to\nthem a function. This is called a ",(0,r.kt)("em",{parentName:"p"},"map operation"),", not to be confused\nwith the map data structure. The predefined functional iterator\nimplementing the mapped operation over sets is called ",(0,r.kt)("inlineCode",{parentName:"p"},"Set.map")," and is\nused as follows."),(0,r.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=set_mapping",group:"set_mapping"},"let s : int set = Set.literal [5; 1; 2; 2]\n// plus_one = Set.literal [6; 2; 3]\nlet plus_one : int set = Set.map (fun i -> i + 1) s\n")),(0,r.kt)("p",null,"Note: See the predefined\n",(0,r.kt)("a",{parentName:"p",href:"../reference/set-reference/?lang=cameligo"},"module Set"))),(0,r.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=set_mapping",group:"set_mapping"},"const s: set<int> = Set.literal([5,1,2,2]);\n// plus_one == Set.literal([6,2,3])\nconst plus_one: set<int> = Set.map(i => i + 1, s);\n")),(0,r.kt)("p",null,"Note: See the predefined\n",(0,r.kt)("a",{parentName:"p",href:"../reference/set-reference/?lang=jsligo"},"namespace Set"))),(0,r.kt)("h2",{id:"iterating"},"Iterating"),(0,r.kt)("p",null,"An ",(0,r.kt)("em",{parentName:"p"},"iterated operation")," is a fold over a set that returns the value of\ntype ",(0,r.kt)("inlineCode",{parentName:"p"},"unit"),", that is, its only use is to produce side-effects. This\ncan be useful if, for example, you would like to check that each\nelement of a set is within a certain range, and fail with an error\notherwise."),(0,r.kt)("p",null,"The predefined functional iterator implementing the iterated operation\nover sets is called ",(0,r.kt)("inlineCode",{parentName:"p"},"Set.iter"),". In the following example, a set is\niterated to check that all its elements (integers) are greater than\n",(0,r.kt)("inlineCode",{parentName:"p"},"3"),"."),(0,r.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=set_iterating",group:"set_iterating"},"let assert_all_greater_than_3 (s : int set) : unit =\n  Set.iter (fun i -> assert (i > 3)) s\n")),(0,r.kt)("p",null,"Note: See the predefined\n",(0,r.kt)("a",{parentName:"p",href:"../reference/set-reference/?lang=cameligo"},"module Set"))),(0,r.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=set_iterating",group:"set_iterating"},"const assert_all_greater_than_3 =\n  (s: set<int>) : unit => Set.iter(i => assert(i > 3), s);\n")),(0,r.kt)("p",null,"Note: See the predefined\n",(0,r.kt)("a",{parentName:"p",href:"../reference/set-reference/?lang=jsligo"},"namespace Set"))),(0,r.kt)("h2",{id:"looping"},"Looping"),(0,r.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},"There is no loop over lists in CameLIGO.",(0,r.kt)("p",null,"Note: See the predefined\n",(0,r.kt)("a",{parentName:"p",href:"../reference/set-reference/?lang=cameligo"},"module Set"))),(0,r.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("p",null,"One can iterate through all the elements of a set, in increasing\norder, thanks to a loop of the form ",(0,r.kt)("inlineCode",{parentName:"p"},"for (const <variable> of <set>) <block>"),". It means that the ",(0,r.kt)("inlineCode",{parentName:"p"},"<block>")," of statements (or a single\nstatement) will be computed once for each ",(0,r.kt)("inlineCode",{parentName:"p"},"<variable>")," ranging over the\nelements of the set ",(0,r.kt)("inlineCode",{parentName:"p"},"<set>")," in increasing order."),(0,r.kt)("p",null,"Here is an example where the integers in a set are summed up."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=set_looping",group:"set_looping"},"function sum_elt (s: set<int>) {\n  let sum = 0;\n  for (const e of s) sum = sum + e;\n  return sum;\n};\n")),(0,r.kt)("p",null,"Note: See the predefined\n",(0,r.kt)("a",{parentName:"p",href:"../reference/set-reference/?lang=jsligo"},"namespace Set"))))}c.isMDXComponent=!0}}]);