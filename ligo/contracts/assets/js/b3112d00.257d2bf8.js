"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[89276],{48720:(e,t,n)=>{n.d(t,{D:()=>l.Z,Z:()=>i});var a=n(67294),l=n(75402);const i=function(e){return a.createElement(l.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},99191:(e,t,n)=>{n.d(t,{Z:()=>m});var a=n(43164),l=n(67294),i=n(52263),p=n(48720),o=n(11506);function s(){return s=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},s.apply(this,arguments)}const{Prism:r}=n(43164);r.languages={...r.languages,cameligo:{...r.languages.ocaml,comment:[/(^|[^\\])\/\*[\s\S]*?\*\//,/\(\*[\s\S]*?\*\)/,/\/\/.*/]},jsligo:r.languages.typescript};const m=function(e){const{siteConfig:{themeConfig:{prism:t={}}}}=(0,i.Z)(),n=t.singleTheme||o.Z,[r,m]=(0,l.useState)(!1);return(0,l.useEffect)((()=>{m(!0)}),[]),l.createElement(p.D.Consumer,null,(t=>{let{syntax:i}=t;return i===e.syntax?l.createElement(a.default,s({},a.defaultProps,{key:r,language:e.syntax,code:e.children,theme:n}),(e=>{let{className:t,tokens:n,getLineProps:a,getTokenProps:i}=e;return l.createElement("h4",{className:t,style:{backgroundColor:"var(--ifm-background-color)",fontFamily:"var(--ifm-font-family-monospace)",lineHeight:"var(--ifm-pre-line-height)",fontSize:"1.1rem",fontWeight:"bold",padding:0,whiteSpace:"break-spaces",marginTop:"3rem"}},n.map(((e,t)=>l.createElement("div",a({line:e,key:t}),e.map(((e,t)=>l.createElement("span",i({token:e,key:t}))))))))})):l.createElement("div",null)}))}},96411:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>m,contentTitle:()=>s,default:()=>y,frontMatter:()=>o,metadata:()=>r,toc:()=>d});var a=n(87462),l=(n(67294),n(3905)),i=n(48720),p=n(99191);const o={id:"list-reference",title:"list",hide_table_of_contents:!0},s=void 0,r={unversionedId:"reference/list-reference",id:"version-1.6.0/reference/list-reference",title:"list",description:"Lists",source:"@site/versioned_docs/version-1.6.0/reference/list.md",sourceDirName:"reference",slug:"/reference/list-reference",permalink:"/docs/1.6.0/reference/list-reference",draft:!1,tags:[],version:"1.6.0",frontMatter:{id:"list-reference",title:"list",hide_table_of_contents:!0},sidebar:"API",previous:{title:"bitwise",permalink:"/docs/1.6.0/reference/bitwise-reference"},next:{title:"crypto",permalink:"/docs/1.6.0/reference/crypto-reference"}},m={},d=[],k={toc:d};function y(e){let{components:t,...n}=e;return(0,l.kt)("wrapper",(0,a.Z)({},k,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"Lists"),(0,l.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type 'elt t = 'elt list"),(0,l.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type t<elt> = list<elt>"),"The type `t` is an alias for the predefined type `list`.",(0,l.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val empty : 'elt.'elt t"),(0,l.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let empty: <elt>t<elt>"),(0,l.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The value ",(0,l.kt)("inlineCode",{parentName:"p"},"empty")," is the empty list. It is a synonym for\n",(0,l.kt)("inlineCode",{parentName:"p"},"[]"),". In some contexts, it is useful to annotate it with its type,\nfor example: ",(0,l.kt)("inlineCode",{parentName:"p"},"(empty : int list)"),".")),(0,l.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The value ",(0,l.kt)("inlineCode",{parentName:"p"},"empty")," is the empty list. It is a synonym for\n",(0,l.kt)("inlineCode",{parentName:"p"},"[]"),". In some contexts, it is useful to annotate it with its\ntype, for example: ",(0,l.kt)("inlineCode",{parentName:"p"},"(empty as list<int>)"),".")),(0,l.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val length : 'elt.'elt t -> nat"),(0,l.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let length: <elt>(_: t<elt>) => nat"),(0,l.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"length l")," is the number of elements in the list\n",(0,l.kt)("inlineCode",{parentName:"p"},"l"),". Note: ",(0,l.kt)("inlineCode",{parentName:"p"},"List.length")," is another name for ",(0,l.kt)("inlineCode",{parentName:"p"},"List.size"),".")),(0,l.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"length(l)")," is the number of elements in the list\n",(0,l.kt)("inlineCode",{parentName:"p"},"l"),". Note: ",(0,l.kt)("inlineCode",{parentName:"p"},"List.length")," is another name for ",(0,l.kt)("inlineCode",{parentName:"p"},"List.size"),".")),(0,l.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val size : 'elt.'elt t -> nat"),(0,l.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let size: <elt>(_: t<elt>) => nat"),(0,l.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"size l")," is the number of elements in the list ",(0,l.kt)("inlineCode",{parentName:"p"},"l"),".")),(0,l.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"size(l)")," is the number of elements in the list ",(0,l.kt)("inlineCode",{parentName:"p"},"l"),".")),(0,l.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val head : 'elt.'elt t -> 'elt option"),(0,l.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let head: <elt>(_: t<elt>) => option<elt>"),(0,l.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"head l"),", where ",(0,l.kt)("inlineCode",{parentName:"p"},"l")," is a list, is ",(0,l.kt)("inlineCode",{parentName:"p"},"None")," if ",(0,l.kt)("inlineCode",{parentName:"p"},"l")," is\nempty; otherwise, ",(0,l.kt)("inlineCode",{parentName:"p"},"Some hd"),", where ",(0,l.kt)("inlineCode",{parentName:"p"},"hd")," is the head of the list.")),(0,l.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"head(l)"),", where ",(0,l.kt)("inlineCode",{parentName:"p"},"l")," is a list, is ",(0,l.kt)("inlineCode",{parentName:"p"},"None()")," if ",(0,l.kt)("inlineCode",{parentName:"p"},"l")," is\nempty; otherwise, ",(0,l.kt)("inlineCode",{parentName:"p"},"Some(hd)"),", where ",(0,l.kt)("inlineCode",{parentName:"p"},"hd")," is the head of the list.")),(0,l.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val head_opt : 'elt.'elt t -> 'elt option"),(0,l.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let head_opt: <elt>(_: t<elt>) => option<elt>"),"**Deprecated:** Use `List.head` instead.",(0,l.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"head_opt l"),", where ",(0,l.kt)("inlineCode",{parentName:"p"},"l")," is a list, is ",(0,l.kt)("inlineCode",{parentName:"p"},"None")," if ",(0,l.kt)("inlineCode",{parentName:"p"},"l")," is\nempty; otherwise, ",(0,l.kt)("inlineCode",{parentName:"p"},"Some hd"),", where ",(0,l.kt)("inlineCode",{parentName:"p"},"hd")," is the head of the list.")),(0,l.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"head_opt(l)"),", where ",(0,l.kt)("inlineCode",{parentName:"p"},"l")," is a list, is ",(0,l.kt)("inlineCode",{parentName:"p"},"None()")," if ",(0,l.kt)("inlineCode",{parentName:"p"},"l")," is\nempty; otherwise, ",(0,l.kt)("inlineCode",{parentName:"p"},"Some(hd)"),", where ",(0,l.kt)("inlineCode",{parentName:"p"},"hd")," is the head of the list.")),(0,l.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val tail : 'elt.'elt t -> 'elt t option"),(0,l.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let tail: <elt>(_: t<elt>) => option<t<elt>>"),(0,l.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"tail l"),", where ",(0,l.kt)("inlineCode",{parentName:"p"},"l")," is a list, is ",(0,l.kt)("inlineCode",{parentName:"p"},"None")," if ",(0,l.kt)("inlineCode",{parentName:"p"},"l")," is\nempty; otherwise, ",(0,l.kt)("inlineCode",{parentName:"p"},"Some tl"),", where ",(0,l.kt)("inlineCode",{parentName:"p"},"tl")," is the tail of the list.")),(0,l.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"tail(l)"),", where ",(0,l.kt)("inlineCode",{parentName:"p"},"l")," is a list, is ",(0,l.kt)("inlineCode",{parentName:"p"},"None()")," if ",(0,l.kt)("inlineCode",{parentName:"p"},"l")," is\nempty; otherwise, ",(0,l.kt)("inlineCode",{parentName:"p"},"Some(tl)"),", where ",(0,l.kt)("inlineCode",{parentName:"p"},"tl")," is the tail of the list.")),(0,l.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val tail_opt : 'elt.'elt t -> 'elt t option"),(0,l.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let tail_opt: <elt>(_: t<elt>) => option<t<elt>>"),"**Deprecated:** Use `List.tail` instead.",(0,l.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"tail_opt l"),", where ",(0,l.kt)("inlineCode",{parentName:"p"},"l")," is a list, is ",(0,l.kt)("inlineCode",{parentName:"p"},"None")," if ",(0,l.kt)("inlineCode",{parentName:"p"},"l")," is\nempty; otherwise, ",(0,l.kt)("inlineCode",{parentName:"p"},"Some tl"),", where ",(0,l.kt)("inlineCode",{parentName:"p"},"tl")," is the tail of the list.")),(0,l.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"tail_opt(l)"),", where ",(0,l.kt)("inlineCode",{parentName:"p"},"l")," is a list, is ",(0,l.kt)("inlineCode",{parentName:"p"},"None()")," if ",(0,l.kt)("inlineCode",{parentName:"p"},"l")," is\nempty; otherwise, ",(0,l.kt)("inlineCode",{parentName:"p"},"Some(tl)"),", where ",(0,l.kt)("inlineCode",{parentName:"p"},"tl")," is the tail of the list.")),(0,l.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val map : 'src 'dst.('src -> 'dst) -> 'src list -> 'dst list"),(0,l.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let map: <src, dst>(_: (_: src) => dst) => (_: list<src>) => list<dst>"),(0,l.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"map f [a1; ...; an]")," applies the function ",(0,l.kt)("inlineCode",{parentName:"p"},"f")," to ",(0,l.kt)("inlineCode",{parentName:"p"},"a1"),",\n..., ",(0,l.kt)("inlineCode",{parentName:"p"},"an")," (from left to right), and builds the list\n",(0,l.kt)("inlineCode",{parentName:"p"},"[f a1; ...; f an]")," with the results returned by ",(0,l.kt)("inlineCode",{parentName:"p"},"f"),".")),(0,l.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"map(f, [a1; ...; an])")," applies the function ",(0,l.kt)("inlineCode",{parentName:"p"},"f")," to\n",(0,l.kt)("inlineCode",{parentName:"p"},"a1"),", ..., ",(0,l.kt)("inlineCode",{parentName:"p"},"an")," (from left to right), and builds the list\n",(0,l.kt)("inlineCode",{parentName:"p"},"[f(a1); ...; f(an)]")," with the results returned by ",(0,l.kt)("inlineCode",{parentName:"p"},"f"),".")),(0,l.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val iter : 'elt.('elt -> unit) -> 'elt t -> unit"),(0,l.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let iter: <elt>(_: (_: elt) => unit) => (_: t<elt>) => unit"),(0,l.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"iter f [a1; ...; an]")," applies the function ",(0,l.kt)("inlineCode",{parentName:"p"},"f")," in turn\nto ",(0,l.kt)("inlineCode",{parentName:"p"},"[a1; ...; an]"),". It is equivalent to\n",(0,l.kt)("inlineCode",{parentName:"p"},"let () = f a1 in let () = f a2 in ... in f an"),".")),(0,l.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"iter(f, [a1; ...; an])")," applies the function ",(0,l.kt)("inlineCode",{parentName:"p"},"f"),"\nin turn to ",(0,l.kt)("inlineCode",{parentName:"p"},"[a1; ...; an]"),". It is equivalent to ",(0,l.kt)("inlineCode",{parentName:"p"},"{f(a1);\n    f(a2); ...; f(an)}"),".")),(0,l.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val fold_left : 'elt 'acc.(('acc * 'elt) -> 'acc) -> 'acc -> 'elt t -> 'acc"),(0,l.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let fold_left: <elt, acc>(_: (_: [acc, elt]) => acc) => (_: acc) => (_: t<elt>) => acc"),(0,l.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"fold_left f init [a1; ...; an]")," is\n",(0,l.kt)("inlineCode",{parentName:"p"},"f (... (f (f init a1) a2) ...) an"),".")),(0,l.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"fold_left(f, init, [a1; ...; an])")," is\n",(0,l.kt)("inlineCode",{parentName:"p"},"f (... (f (f(init, a1)), a2), ...), an)"),".")),(0,l.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val fold_right : 'elt 'acc.(('elt * 'acc) -> 'acc) -> 'elt t -> 'acc -> 'acc"),(0,l.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let fold_right: <elt, acc>(_: (_: [elt, acc]) => acc) => (_: t<elt>) => (_: acc) => acc"),(0,l.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"fold_right f [a1; ...; an] init")," is\n",(0,l.kt)("inlineCode",{parentName:"p"},"f a1 (f a2 (... (f an init) ...))"),".")),(0,l.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"fold_right(f, [a1; ...; an], init)")," is\n",(0,l.kt)("inlineCode",{parentName:"p"},"f (a1, f (a2, (..., f (an, init))...))"),".")),(0,l.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val fold : 'elt 'acc.(('acc * 'elt) -> 'acc) -> 'elt t -> 'acc -> 'acc"),(0,l.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let fold: <elt, acc>(_: (_: [acc, elt]) => acc) => (_: t<elt>) => (_: acc) => acc"),(0,l.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"fold f [a1; ...; an] init")," is\n",(0,l.kt)("inlineCode",{parentName:"p"},"f (... (f (f init a1) a2) ...) an"),". Note:\n",(0,l.kt)("inlineCode",{parentName:"p"},"fold_left f init list")," is the same as ",(0,l.kt)("inlineCode",{parentName:"p"},"fold f list init"),".")),(0,l.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"fold(f, [a1; ...; an], init)")," is\n",(0,l.kt)("inlineCode",{parentName:"p"},"f (... (f (f (init, a1), a2) ...), an)"),". Note:\n",(0,l.kt)("inlineCode",{parentName:"p"},"fold_left(f, init, list)")," is the same as ",(0,l.kt)("inlineCode",{parentName:"p"},"fold(f, list, init)"),".")),(0,l.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val cons : 'elt.'elt -> 'elt t -> 'elt t"),(0,l.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let cons: <elt>(_: elt) => (_: t<elt>) => t<elt>"),(0,l.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"cons e l")," is ",(0,l.kt)("inlineCode",{parentName:"p"},"e :: l"),".")),(0,l.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"cons(e, l)")," is ",(0,l.kt)("inlineCode",{parentName:"p"},"[e, ...l]"),".")),(0,l.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val find_opt : 'elt.('elt -> bool) -> 'elt t -> 'elt option"),(0,l.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let find_opt: <elt>(_: (_: elt) => bool) => (_: t<elt>) => option<elt>"),(0,l.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"find_opt pred list")," is ",(0,l.kt)("inlineCode",{parentName:"p"},"None")," if no element of the\nlist ",(0,l.kt)("inlineCode",{parentName:"p"},"list")," satisfies the predicate ",(0,l.kt)("inlineCode",{parentName:"p"},"pred"),"; otherwise, it is\n",(0,l.kt)("inlineCode",{parentName:"p"},"Some e"),", where ",(0,l.kt)("inlineCode",{parentName:"p"},"e")," is the leftmost element in ",(0,l.kt)("inlineCode",{parentName:"p"},"list")," that satisfies\n",(0,l.kt)("inlineCode",{parentName:"p"},"pred"),". The order of the calls of ",(0,l.kt)("inlineCode",{parentName:"p"},"pred")," is not specified.")),(0,l.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"find_opt(pred, list)")," is ",(0,l.kt)("inlineCode",{parentName:"p"},"None()")," if no element of the\nlist ",(0,l.kt)("inlineCode",{parentName:"p"},"list")," satisfies the predicate ",(0,l.kt)("inlineCode",{parentName:"p"},"pred"),"; otherwise, it is\n",(0,l.kt)("inlineCode",{parentName:"p"},"Some(e)"),", where ",(0,l.kt)("inlineCode",{parentName:"p"},"e")," is the leftmost element in ",(0,l.kt)("inlineCode",{parentName:"p"},"list")," that satisfies\n",(0,l.kt)("inlineCode",{parentName:"p"},"pred"),". The order of the calls of ",(0,l.kt)("inlineCode",{parentName:"p"},"pred")," is not specified.")),(0,l.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val filter_map : 'src 'dst.('src -> 'dst option) -> 'src list -> 'dst list"),(0,l.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let filter_map: <src, dst>(_: (_: src) => option<dst>) => (_: list<src>) => list<dst>"),(0,l.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"filter_map f l")," is the maximal sub-list of ",(0,l.kt)("inlineCode",{parentName:"p"},"l")," such\nthat the call of function ",(0,l.kt)("inlineCode",{parentName:"p"},"f")," on its elements is not ",(0,l.kt)("inlineCode",{parentName:"p"},"None"),". Note:\n",(0,l.kt)("inlineCode",{parentName:"p"},"f")," is called on all elements of ",(0,l.kt)("inlineCode",{parentName:"p"},"l"),". The order of the calls of\n",(0,l.kt)("inlineCode",{parentName:"p"},"f")," is not specified.")),(0,l.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"filter_map(f, l)")," is the maximal sub-list of ",(0,l.kt)("inlineCode",{parentName:"p"},"l")," such\nthat the call of function ",(0,l.kt)("inlineCode",{parentName:"p"},"f")," on its elements is not ",(0,l.kt)("inlineCode",{parentName:"p"},"None()"),". Note:\n",(0,l.kt)("inlineCode",{parentName:"p"},"f")," is called on all elements of ",(0,l.kt)("inlineCode",{parentName:"p"},"l"),". The order of the calls of\n",(0,l.kt)("inlineCode",{parentName:"p"},"f")," is not specified.")),(0,l.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val update : 'elt.('elt -> 'elt option) -> 'elt t -> 'elt t"),(0,l.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let update: <elt>(_: (_: elt) => option<elt>) => (_: t<elt>) => t<elt>"),(0,l.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"update f l")," is the list ",(0,l.kt)("inlineCode",{parentName:"p"},"l")," where the elements ",(0,l.kt)("inlineCode",{parentName:"p"},"e"),"\nsuch that ",(0,l.kt)("inlineCode",{parentName:"p"},"f e")," is ",(0,l.kt)("inlineCode",{parentName:"p"},"Some v")," have been replaced by ",(0,l.kt)("inlineCode",{parentName:"p"},"v"),".")),(0,l.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"update(f, l)")," is the list ",(0,l.kt)("inlineCode",{parentName:"p"},"l")," where the elements ",(0,l.kt)("inlineCode",{parentName:"p"},"e"),"\nsuch that ",(0,l.kt)("inlineCode",{parentName:"p"},"f(e)")," is ",(0,l.kt)("inlineCode",{parentName:"p"},"Some(v)")," have been replaced by ",(0,l.kt)("inlineCode",{parentName:"p"},"v"),".")),(0,l.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val update_with : 'elt.('elt -> bool) -> 'elt -> 'elt t -> 'elt t"),(0,l.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let update_with: <elt>(_: (_: elt) => bool) => (_: elt) => (_: t<elt>) => t<elt>"),(0,l.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"update_with p d l")," is the list ",(0,l.kt)("inlineCode",{parentName:"p"},"l")," where the elements\n",(0,l.kt)("inlineCode",{parentName:"p"},"e")," such that satisfy the predicate ",(0,l.kt)("inlineCode",{parentName:"p"},"p")," are replaced by ",(0,l.kt)("inlineCode",{parentName:"p"},"d"),".")),(0,l.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"update_with(p,d,l)")," is the list ",(0,l.kt)("inlineCode",{parentName:"p"},"l")," where the elements\n",(0,l.kt)("inlineCode",{parentName:"p"},"e")," such that satisfy the predicate ",(0,l.kt)("inlineCode",{parentName:"p"},"p")," are replaced by ",(0,l.kt)("inlineCode",{parentName:"p"},"d"),".")))}y.isMDXComponent=!0}}]);