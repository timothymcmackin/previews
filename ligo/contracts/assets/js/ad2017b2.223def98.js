"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[38047],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>u});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},g={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,m=r(e,["components","mdxType","originalType","parentName"]),c=p(n),u=i,d=c["".concat(s,".").concat(u)]||c[u]||g[u]||o;return n?a.createElement(d,l(l({ref:t},m),{},{components:n})):a.createElement(d,l({ref:t},m))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,l=new Array(o);l[0]=c;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r.mdxType="string"==typeof e?e:i,l[1]=r;for(var p=2;p<o;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},48720:(e,t,n)=>{n.d(t,{D:()=>i.Z,Z:()=>o});var a=n(67294),i=n(75402);const o=function(e){return a.createElement(i.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},89400:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>r,default:()=>c,frontMatter:()=>l,metadata:()=>s,toc:()=>m});var a=n(87462),i=(n(67294),n(3905)),o=n(48720);const l={title:"Migration to LIGO v1.0",description:"Exciting news, LIGO has released version 1.0! Please continue reading to learn which changes may affect your existing codebase.",slug:"v1-migration-guide",authors:["suzannesoy"],tags:["migration"],image:"https://i.imgur.com/mErPwqL.png",hide_table_of_contents:!0},r=void 0,s={permalink:"/previews/ligo/contracts/blog/v1-migration-guide",source:"@site/blog/2023-09-20-v1-migration-guide.md",title:"Migration to LIGO v1.0",description:"Exciting news, LIGO has released version 1.0! Please continue reading to learn which changes may affect your existing codebase.",date:"2023-09-20T00:00:00.000Z",formattedDate:"September 20, 2023",tags:[{label:"migration",permalink:"/previews/ligo/contracts/blog/tags/migration"}],readingTime:7.473333333333334,hasTruncateMarker:!0,authors:[{name:"Suzanne Soy",title:"Developer at Ligo",url:"https://gitlab.com/ligo.suzanne.soy",email:"suzanne@marigold.dev",imageURL:"https://gitlab.com/uploads/-/system/user/avatar/2923020/avatar.png?width=192",key:"suzannesoy"}],frontMatter:{title:"Migration to LIGO v1.0",description:"Exciting news, LIGO has released version 1.0! Please continue reading to learn which changes may affect your existing codebase.",slug:"v1-migration-guide",authors:["suzannesoy"],tags:["migration"],image:"https://i.imgur.com/mErPwqL.png",hide_table_of_contents:!0},nextItem:{title:"How to deal with the change of the default datatype layout to @layout comb ?",permalink:"/previews/ligo/contracts/blog/layout-comb-how"}},p={authorsImageUrls:[void 0]},m=[{value:"All syntaxes",id:"all-syntaxes",level:2},{value:"No more <code>main</code> function",id:"no-more-main-function",level:3},{value:"Uniform calling convention for views and entry points.",id:"uniform-calling-convention-for-views-and-entry-points",level:4},{value:"<code>contract_of</code> and <code>parameter_of</code>",id:"contract_of-and-parameter_of",level:4},{value:"<code>export</code> and <code>@private</code> now have the expected effect",id:"export-and-private-now-have-the-expected-effect",level:3},{value:"The comb layout is now used by default",id:"the-comb-layout-is-now-used-by-default",level:3},{value:"A small set of annotations / decorators are now supported",id:"a-small-set-of-annotations--decorators-are-now-supported",level:3},{value:"Field and tuple component access",id:"field-and-tuple-component-access",level:3},{value:"Miscellaneous",id:"miscellaneous",level:3},{value:"JsLIGO",id:"jsligo",level:2},{value:"Short notation for <code>tez</code> and <code>mutez</code>",id:"short-notation-for-tez-and-mutez",level:3},{value:"New bitwise operators",id:"new-bitwise-operators",level:3},{value:"Changes to pattern matching",id:"changes-to-pattern-matching",level:3},{value:"<code>_</code> is now a valid variable name and can&#39;t be used for its former throw-away semantics",id:"_-is-now-a-valid-variable-name-and-cant-be-used-for-its-former-throw-away-semantics",level:3},{value:"Imports are now automatically re-exported",id:"imports-are-now-automatically-re-exported",level:3},{value:"Miscellaneous",id:"miscellaneous-1",level:3},{value:"CameLIGO",id:"cameligo",level:2},{value:"Field and tuple component access",id:"field-and-tuple-component-access-1",level:3},{value:"Package management: use ligo.json instead of package.json or esy.json",id:"package-management-use-ligojson-instead-of-packagejson-or-esyjson",level:3}],g={toc:m};function c(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},g,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Exciting news, LIGO has released version 1.0! We made sure to fit in this release a number of pending breaking changes, so that our users do not need to catch up with small breaking changes every release, and can handle the migration in bulk. Please continue reading to learn which changes may affect your existing codebase."),(0,i.kt)("h2",{id:"all-syntaxes"},"All syntaxes"),(0,i.kt)("h3",{id:"no-more-main-function"},"No more ",(0,i.kt)("inlineCode",{parentName:"h3"},"main")," function"),(0,i.kt)("p",null,"You should not manually craft a ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," function that calls your entry points anymore. Instead, above each entry point function, you can now write ",(0,i.kt)("inlineCode",{parentName:"p"},"@entry")," for JsLIGO or ",(0,i.kt)("inlineCode",{parentName:"p"},"[@entry]")," for CameLIGO. This will cause a ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," function to be automatically generated behind the scenes."),(0,i.kt)("p",null,"If you need more fine-grained control, it is still possible to write a ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," function, but you will need to add ",(0,i.kt)("inlineCode",{parentName:"p"},"@entry")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"[@entry]")," above that ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," function (and only that function). See ",(0,i.kt)("a",{parentName:"p",href:"/docs/advanced/entrypoints-contracts#main-function"},"the documentation on the main function and entry points")," for more details on how to do this."),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/docs/contract/views"},"Views")," can be declared in a similar way with ",(0,i.kt)("inlineCode",{parentName:"p"},"@view")," for JsLIGO and ",(0,i.kt)("inlineCode",{parentName:"p"},"[@view]")," for CameLIGO."),(0,i.kt)("p",null,"As the use of ",(0,i.kt)("inlineCode",{parentName:"p"},"@entry")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"[@entry]")," (and ",(0,i.kt)("inlineCode",{parentName:"p"},"@view")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"[@view]"),") in the source is now mandatory, it is not possible anymore to rely on the auto-detection of the ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," function as the sole entry point, and it is not possible anymore to specify a entry points via the ",(0,i.kt)("inlineCode",{parentName:"p"},"-e")," function on the command-line or views via the ",(0,i.kt)("inlineCode",{parentName:"p"},"--views")," / ",(0,i.kt)("inlineCode",{parentName:"p"},"-v")," options."),(0,i.kt)("p",null,"Another consequence of this change is that, when originating a contract for tests, ",(0,i.kt)("inlineCode",{parentName:"p"},"Test.originate")," now take as an argument a module containing multiple entry points instead of a single function, i.e. a single entry point"),(0,i.kt)("p",null,"We are also rolling out a new feature allowing the addition, removal and update of dynamic entry points for a contract after deployment. This could be a useful feature for example when building a DAO which allows on-chain vote to upgrade its code (or a DAO which controls the code of another separate contract). For more information, see ",(0,i.kt)("a",{parentName:"p",href:"/docs/advanced/dynamic-entrypoints"},"the documentation")," and ",(0,i.kt)("a",{parentName:"p",href:"/docs/reference/dynamic-entrypoints-reference"},"the reference")," for this feature."),(0,i.kt)("p",null,"MRs:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://gitlab.com/ligolang/ligo/-/merge_requests/2818"},"https://gitlab.com/ligolang/ligo/-/merge_requests/2818")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://gitlab.com/ligolang/ligo/-/merge_requests/2814"},"https://gitlab.com/ligolang/ligo/-/merge_requests/2814")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://gitlab.com/ligolang/ligo/-/merge_requests/2810"},"https://gitlab.com/ligolang/ligo/-/merge_requests/2810")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://gitlab.com/ligolang/ligo/-/merge_requests/2805"},"https://gitlab.com/ligolang/ligo/-/merge_requests/2805")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://gitlab.com/ligolang/ligo/-/merge_requests/2831"},"https://gitlab.com/ligolang/ligo/-/merge_requests/2831")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://gitlab.com/ligolang/ligo/-/merge_requests/2885"},"https://gitlab.com/ligolang/ligo/-/merge_requests/2885"))),(0,i.kt)("h4",{id:"uniform-calling-convention-for-views-and-entry-points"},"Uniform calling convention for views and entry points."),(0,i.kt)("p",null,"Views used to be functions taking a tuple, they are now functions taking two arguments:"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},"[@entry]\nlet set_storage (new_storage, _old_storage : int * int): operation list * int = ([], new_storage)\n\n[@view]\nlet get_storage ((), storage : unit * int): int = storage\n")),(0,i.kt)("p",null,"is now written"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo"},"[@entry]\nlet set_storage (new_storage : int)  (_old_storage : int): operation list * int = ([], new_storage)\n\n[@view]\nlet get_storage () (storage : int): int = storage\n"))),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},"// @entry\nconst set_storage = ([new_storage, _old_storage] : [int, int]): [list<operation>, int] => [[], new_storage]\n\n@view\nconst get_storage = ([_, storage] : [unit, int]): int => storage\n")),(0,i.kt)("p",null,"is now written"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo"},"@entry\nconst set_storage = (new_storage: int, _old_storage: int): [list<operation>, int] => [[], new_storage]\n\n@view\nconst get_storage = (_: unit, storage: int): int => storage\n"))),(0,i.kt)("h4",{id:"contract_of-and-parameter_of"},(0,i.kt)("inlineCode",{parentName:"h4"},"contract_of")," and ",(0,i.kt)("inlineCode",{parentName:"h4"},"parameter_of")),(0,i.kt)("p",null,"The aforementioned changes to ",(0,i.kt)("inlineCode",{parentName:"p"},"@entry")," and the ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," function have affected how contracts are tested, starting from ",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.com/ligolang/ligo/-/releases/0.64.2"},"v0.64.2")," (",(0,i.kt)("a",{parentName:"p",href:"/docs/intro/changelog#0642"},"changelog"),"). See ",(0,i.kt)("a",{parentName:"p",href:"/docs/testing"},"the documentation on testing")," for examples on how to use ",(0,i.kt)("inlineCode",{parentName:"p"},"contract_of")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"parameter_of"),"."),(0,i.kt)("p",null,"MRs:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://gitlab.com/ligolang/ligo/-/merge_requests/2476"},"https://gitlab.com/ligolang/ligo/-/merge_requests/2476")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://gitlab.com/ligolang/ligo/-/merge_requests/2685"},"https://gitlab.com/ligolang/ligo/-/merge_requests/2685"))),(0,i.kt)("h3",{id:"export-and-private-now-have-the-expected-effect"},(0,i.kt)("inlineCode",{parentName:"h3"},"export")," and ",(0,i.kt)("inlineCode",{parentName:"h3"},"@private")," now have the expected effect"),(0,i.kt)("p",null,"Previously, all declarations would be exported regardless whether ",(0,i.kt)("inlineCode",{parentName:"p"},"export"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"@private")," or neither was used."),(0,i.kt)("p",null,"In LIGO v1, JsLIGO definitions which are not marked with ",(0,i.kt)("inlineCode",{parentName:"p"},"export")," are not exported, and CameLIGO definitions which are marked with ",(0,i.kt)("inlineCode",{parentName:"p"},"@private")," are not exported. In other words, the default for JsLIGO is now to make definitions private unless specified otherwise with ",(0,i.kt)("inlineCode",{parentName:"p"},"export"),", and the default for CameLIGO is now to make definitions public unless specified otherwise with ",(0,i.kt)("inlineCode",{parentName:"p"},"[@private]"),"."),(0,i.kt)("p",null,"Furthermore, in JsLIGO nested namespaces need to be exported in order to be accessed, e.g."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=namespace-export",group:"namespace-export"},"namespace Foo {\n    export namespace Bar {\n        export const x = 1\n    }\n}\n\nconst y = Foo.Bar.x\n")),(0,i.kt)("p",null,"MRs:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://gitlab.com/ligolang/ligo/-/merge_requests/2796"},"https://gitlab.com/ligolang/ligo/-/merge_requests/2796")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://gitlab.com/ligolang/ligo/-/merge_requests/2684"},"https://gitlab.com/ligolang/ligo/-/merge_requests/2684")," in ",(0,i.kt)("a",{parentName:"li",href:"https://gitlab.com/ligolang/ligo/-/releases/0.69.0"},"v0.69.0")," (",(0,i.kt)("a",{parentName:"li",href:"/docs/intro/changelog#0690"},"changelog"),")")),(0,i.kt)("h3",{id:"the-comb-layout-is-now-used-by-default"},"The comb layout is now used by default"),(0,i.kt)("p",null,"Some types can have several isomorphic representations in Michelson, and LIGO allows choosing between two of these, ",(0,i.kt)("inlineCode",{parentName:"p"},"comb")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"tree"),", via an ",(0,i.kt)("inlineCode",{parentName:"p"},"@layout")," decorator (e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},'@layout("comb")')," in JsLIGO, or ",(0,i.kt)("inlineCode",{parentName:"p"},"[@layout comb]")," in CameLIGO)."),(0,i.kt)("p",null,"Previously, the default layout was ",(0,i.kt)("inlineCode",{parentName:"p"},"tree"),", and in LIGO v1, the default becomes ",(0,i.kt)("inlineCode",{parentName:"p"},"comb"),"."),(0,i.kt)("p",null,"The rationale is that the ",(0,i.kt)("inlineCode",{parentName:"p"},"comb")," layout is usually more optimal, especially for records: records with a ",(0,i.kt)("inlineCode",{parentName:"p"},"comb")," layout are compiled to Michelson combs, which have better support and look more readable. The ",(0,i.kt)("inlineCode",{parentName:"p"},"comb")," layout is also more predictable / less surprising, because the fields are in declared order instead of alphabetical order. The ",(0,i.kt)("inlineCode",{parentName:"p"},"comb")," layout can be less efficient for variants, but the difference should not be significant in most cases. For more info on why this change happened, see ",(0,i.kt)("a",{parentName:"p",href:"/blog/layout-comb-why"},"Why did the default datatype layout change to ",(0,i.kt)("inlineCode",{parentName:"a"},"@layout comb"),"?")),(0,i.kt)("p",null,"If your project has a stable ABI that other tools rely on, you might need to manually annotate the type of entry point arguments and the entry point return types with ",(0,i.kt)("inlineCode",{parentName:"p"},'@layout("tree")')," / ",(0,i.kt)("inlineCode",{parentName:"p"},"[@layout tree]"),"."),(0,i.kt)("p",null,"Once reaching the optimization phase of your development process, youu may wish to try annotating large variants (which contain many cases) with ",(0,i.kt)("inlineCode",{parentName:"p"},'@layout("tree")')," / ",(0,i.kt)("inlineCode",{parentName:"p"},"[@layout tree]")," and comparing the size and gas consumption of the compiled contracts."),(0,i.kt)("p",null,"MRs:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://gitlab.com/ligolang/ligo/-/merge_requests/1816"},"https://gitlab.com/ligolang/ligo/-/merge_requests/1816"),".")),(0,i.kt)("h3",{id:"a-small-set-of-annotations--decorators-are-now-supported"},"A small set of annotations / decorators are now supported"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"@entry")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"@dyn_entry")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"@inline")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"@view")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"@no_mutation")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"@private")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"@public")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"@annot")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"@layout"))),(0,i.kt)("p",null,"These annotations / decorators should now be written without prefixing them with a comment, e.g."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo"},"@entry\nconst my_entry_point = (_: unit, n: int) : [list<operation>, int] => [[], n];\n")),(0,i.kt)("p",null,"instead of"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},"// @entry\nconst my_entry_point = (_: unit, n: int) : [list<operation>, int] => [[], n];\n")),(0,i.kt)("p",null,"There are also two internal annotations / decorators, which should not appear in normal source code:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"@thunk")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"@hidden"))),(0,i.kt)("p",null,"MRs:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://gitlab.com/ligolang/ligo/-/merge_requests/2619"},"https://gitlab.com/ligolang/ligo/-/merge_requests/2619")," in ",(0,i.kt)("a",{parentName:"li",href:"https://gitlab.com/ligolang/ligo/-/releases/0.67.0"},"v0.67.0")," (",(0,i.kt)("a",{parentName:"li",href:"/docs/intro/changelog#0670"},"changelog"),")")),(0,i.kt)("p",null,"MRs:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://gitlab.com/ligolang/ligo/-/merge_requests/2476"},"https://gitlab.com/ligolang/ligo/-/merge_requests/2476"))),(0,i.kt)("h3",{id:"field-and-tuple-component-access"},"Field and tuple component access"),(0,i.kt)("p",null,"Fields can be accessed with dot notation ",(0,i.kt)("inlineCode",{parentName:"p"},"stuff.y")," and brackets ",(0,i.kt)("inlineCode",{parentName:"p"},'stuff["y"]')," interchangeably:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo"},'const stuff = {\n    x : "foo",\n    y : { universe : [42, "life", true] }\n};\n\nconst part : bool = stuff.y["universe"][2];\n')),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://gitlab.com/ligolang/ligo/-/merge_requests/2661"},"https://gitlab.com/ligolang/ligo/-/merge_requests/2661"))),(0,i.kt)("h3",{id:"miscellaneous"},"Miscellaneous"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The internal command ",(0,i.kt)("inlineCode",{parentName:"li"},"ligo daemon")," has been removed in ",(0,i.kt)("a",{parentName:"li",href:"https://gitlab.com/ligolang/ligo/-/releases/0.69.0"},"v0.69.0")," (",(0,i.kt)("a",{parentName:"li",href:"/docs/intro/changelog#0690"},"changelog"),"). It was previously used by the old language server to create a persistent LIGO process, but it was hacky and offered no performance improvements. There should be no noticeable change for the user, as the new language server (used e.g. by the VsCode plug-in) does not make use of this command anymore. MR: ",(0,i.kt)("a",{parentName:"li",href:"https://gitlab.com/ligolang/ligo/-/merge_requests/2690"},"https://gitlab.com/ligolang/ligo/-/merge_requests/2690"),"."),(0,i.kt)("li",{parentName:"ul"},"The support for CST mutation testing has been dropped in ",(0,i.kt)("a",{parentName:"li",href:"https://gitlab.com/ligolang/ligo/-/releases/0.66.0"},"v0.66.0")," (",(0,i.kt)("a",{parentName:"li",href:"/docs/intro/changelog#0660"},"changelog"),"). Unfortunately, that feature was incomplete and broken. With the disappearance of this feature, the command ",(0,i.kt)("inlineCode",{parentName:"li"},"ligo mutate")," has been removed. However, AST mutation testing is still supported and part of the ",(0,i.kt)("a",{parentName:"li",href:"/docs/advanced/mutation-testing"},"testing framework"),". MRs: ",(0,i.kt)("a",{parentName:"li",href:"https://gitlab.com/ligolang/ligo/-/merge_requests/2455"},"https://gitlab.com/ligolang/ligo/-/merge_requests/2455")," and ",(0,i.kt)("a",{parentName:"li",href:"https://gitlab.com/ligolang/ligo/-/merge_requests/2607"},"https://gitlab.com/ligolang/ligo/-/merge_requests/2607"),"."),(0,i.kt)("li",{parentName:"ul"},"Starting from ",(0,i.kt)("a",{parentName:"li",href:"https://gitlab.com/ligolang/ligo/-/releases/0.64.2"},"v0.64.2")," (",(0,i.kt)("a",{parentName:"li",href:"/docs/intro/changelog#0642"},"changelog"),"), the transpilation commands now take ",(0,i.kt)("inlineCode",{parentName:"li"},"--from-syntax")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"--to-syntax"),", instead of the former, less clear use of ",(0,i.kt)("inlineCode",{parentName:"li"},"--syntax")," for the source syntax and an unnamed parameter for the destination syntax. The destination syntax can still be inferred from the filename given to ",(0,i.kt)("inlineCode",{parentName:"li"},"-o"),", e.g. ",(0,i.kt)("inlineCode",{parentName:"li"},"-o dest.jsligo"),". MR: ",(0,i.kt)("a",{parentName:"li",href:"https://gitlab.com/ligolang/ligo/-/merge_requests/2501"},"https://gitlab.com/ligolang/ligo/-/merge_requests/2501")),(0,i.kt)("li",{parentName:"ul"},"Starting from ",(0,i.kt)("a",{parentName:"li",href:"https://gitlab.com/ligolang/ligo/-/releases/0.64.2"},"v0.64.2")," (",(0,i.kt)("a",{parentName:"li",href:"/docs/intro/changelog#0642"},"changelog"),"), the Kathmandu protocol is deprecated. If you need to recompile an old LIGO contract for an outdated protocol version, you may use the compiler version that the project was developed with. MR: ",(0,i.kt)("a",{parentName:"li",href:"https://gitlab.com/ligolang/ligo/-/merge_requests/2500"},"https://gitlab.com/ligolang/ligo/-/merge_requests/2500"))),(0,i.kt)("h2",{id:"jsligo"},"JsLIGO"),(0,i.kt)("h3",{id:"short-notation-for-tez-and-mutez"},"Short notation for ",(0,i.kt)("inlineCode",{parentName:"h3"},"tez")," and ",(0,i.kt)("inlineCode",{parentName:"h3"},"mutez")),(0,i.kt)("p",null,"You can now write ",(0,i.kt)("inlineCode",{parentName:"p"},"3tez")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"3mutez")," instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"3 as tez")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"3 as mutez"),". This convenient feature was already present in CameLIGO and is now available in JsLIGO too!"),(0,i.kt)("p",null,"MRs:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://gitlab.com/ligolang/ligo/-/merge_requests/2853"},"https://gitlab.com/ligolang/ligo/-/merge_requests/2853")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://gitlab.com/ligolang/ligo/-/merge_requests/2661"},"https://gitlab.com/ligolang/ligo/-/merge_requests/2661"))),(0,i.kt)("h3",{id:"new-bitwise-operators"},"New bitwise operators"),(0,i.kt)("p",null,"The following operators have been added, and can be used with ",(0,i.kt)("inlineCode",{parentName:"p"},"nat")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"bytes"),"."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"&")," Bitwise ",(0,i.kt)("em",{parentName:"li"},"and")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"|")," Bitwise ",(0,i.kt)("em",{parentName:"li"},"or")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"^")," Bitwise ",(0,i.kt)("em",{parentName:"li"},"xor")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"<<")," Bitwise left shift (the shift amount is always a ",(0,i.kt)("inlineCode",{parentName:"li"},"nat\\, even when shifting "),"bytes`)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},">>")," Bitwise right shift (the shift amount is always a ",(0,i.kt)("inlineCode",{parentName:"li"},"nat\\, even when shifting "),"bytes`)")),(0,i.kt)("p",null,"Here are examples of these operators in context:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo"},"const zero: nat = 2n & 1n; // Bitwise and\nconst two_bytes : bytes = 0x11 & 0x10\n\nconst five: nat = 4n | 1n; // Bitwise or\nconst three_bytes : bytes = 0x11 | 0x10\n\nconst three : nat = 2n ^ 1n; // Bitwise xor\nconst one_byte : bytes = 0x11 ^ 0x10\n\nconst four : nat = 2n << 1n // Bitwise left shift\nconst five_one_two : bytes = 0x0100 << 1n\n\nconst one : nat = 2n >> 1n; // Bitwise right shift\nconst zero_bytes : bytes = 0x01 >> 1n\n")),(0,i.kt)("p",null,"MRs:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://gitlab.com/ligolang/ligo/-/merge_requests/2661"},"https://gitlab.com/ligolang/ligo/-/merge_requests/2661"))),(0,i.kt)("h3",{id:"changes-to-pattern-matching"},"Changes to pattern matching"),(0,i.kt)("p",null,"JsLIGO's pattern matchin is inspired by the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/tc39/proposal-pattern-matching"},"ECMAScript Pattern Matching proposal"),". This section covers some of the changes this implies."),(0,i.kt)("p",null,"The new ",(0,i.kt)("inlineCode",{parentName:"p"},"when")," keyword makes pattern matching more explicit."),(0,i.kt)("p",null,"Furthermore, pattern matching is now a keyword, it is not anymore a function taking an object with cases as fields."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"do { ... }")," expression is equivalent to the ",(0,i.kt)("inlineCode",{parentName:"p"},"(() => { ... }) ()")," thunk, i.e. it allows a block of code containing statements (like ",(0,i.kt)("inlineCode",{parentName:"p"},"const xyz = ...")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"return 42"),") to be used where an expression is expected."),(0,i.kt)("p",null,"Therefore, a simple pattern matching like the following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},'const force_positive = (key: string, dict: map<string, int>) => {\n  return match(Map.find_opt (key, dict), {\n    Some: (val : int) => {\n        if (val >= 0) {\n            return val;\n        } else {\n            failwith("Negative value.");\n        }\n    },\n    None: () => failwith("Not found.")\n  });\n}\n')),(0,i.kt)("p",null,"becomes:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo"},'const force_positive = (key: string, dict: map<string, int>) => {\n  return match(Map.find_opt (key, dict)) {\n    when(Some(val)): do {\n        if (val >= 0) {\n            return val;\n        } else {\n            failwith("Negative value");\n        }\n    };\n    when(None()): failwith("Not found.")\n  };\n}\n')),(0,i.kt)("p",null,"Pattern-matching on lists uses the syntaxes ",(0,i.kt)("inlineCode",{parentName:"p"},"when([])")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"when([head, ...tail])"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo"},"type storage = [int, list <int>];\ntype parameter = list <int>;\ntype returnx = [list <operation>, storage];\n\nlet main = (p : parameter, s : storage) : returnx => {\n  let storage = match (p) {\n    when([]): s;\n    when([hd, ...tl]): [s[0] + hd, tl]\n  };\n  return [([] as list<operation>), storage];\n};\n")),(0,i.kt)("p",null,"Furthermore, there are a few changes to how patterns are written:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Patterns for parameterless constructors take a ",(0,i.kt)("inlineCode",{parentName:"li"},"()")," within the ",(0,i.kt)("inlineCode",{parentName:"li"},"when(...)"),", therefore ",(0,i.kt)("inlineCode",{parentName:"li"},"Nil: () => 1")," becomes ",(0,i.kt)("inlineCode",{parentName:"li"},"when(Nil()): 1")),(0,i.kt)("li",{parentName:"ul"},"Patterns which match a constructor containing a tuple work similarly, e.g. ",(0,i.kt)("inlineCode",{parentName:"li"},"Cons: (pair) => pair.1 + f(pair.2)")," becomes ",(0,i.kt)("inlineCode",{parentName:"li"},"when(Cons(pair)) => pair.1 + f(pair.2)")),(0,i.kt)("li",{parentName:"ul"},"Patterns with one variable per parameter are written as expected: ",(0,i.kt)("inlineCode",{parentName:"li"},"Foo: (a, b) => a + b")," becomes ",(0,i.kt)("inlineCode",{parentName:"li"},"when(Foo(a, b)): a + b"))),(0,i.kt)("p",null,"MRs:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://gitlab.com/ligolang/ligo/-/merge_requests/2661"},"https://gitlab.com/ligolang/ligo/-/merge_requests/2661"))),(0,i.kt)("h3",{id:"_-is-now-a-valid-variable-name-and-cant-be-used-for-its-former-throw-away-semantics"},(0,i.kt)("inlineCode",{parentName:"h3"},"_")," is now a valid variable name and can't be used for its former throw-away semantics"),(0,i.kt)("p",null,"Previously, following the tradition of some functional languages, ",(0,i.kt)("inlineCode",{parentName:"p"},"_")," was used to discard the value bound to it, e.g."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},'// don\'t do this anymore\nconst f = () => {\n  let _ = some_check();\n  return match (foobar) {\n    when([]) : "empty list";\n    when([_, ..._]): "non-empty list";\n  };\n}\n')),(0,i.kt)("p",null,"Instead, ",(0,i.kt)("inlineCode",{parentName:"p"},"_")," is now a normal variable name, following the JavaScript and TypeScript tradition, where ",(0,i.kt)("inlineCode",{parentName:"p"},"_")," is used as a short\nname for a namespace containing many utilities, e.g. as an alias for the ",(0,i.kt)("inlineCode",{parentName:"p"},"lodash")," library. This means that the code above should now assign unique names to the discarded value, like so:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},'// don\'t do this anymore\nconst f = () => {\n  let _chk = some_check();\n  return match (foobar) {\n    when([]) : "empty list";\n    when([_hd, ..._tl]): "non-empty list";\n  };\n}\n')),(0,i.kt)("p",null,"If multiple ",(0,i.kt)("em",{parentName:"p"}," variable are bound in the same scope, it will result in an error (duplicate block-scoped variable) just as in TypeScript. However, it is still possible to shadow a `"),(0,i.kt)("inlineCode",{parentName:"p"},"within a smaller scope, e.g. if"),(0,i.kt)("em",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"em"},"is globally defined as an alias for another module, a function can still specify")),"` as an argument name and shadow the global definition, which could cause issues. It is wise to skim over existing code for such cases."),(0,i.kt)("p",null,"MRs:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://gitlab.com/ligolang/ligo/-/merge_requests/2674"},"https://gitlab.com/ligolang/ligo/-/merge_requests/2674"))),(0,i.kt)("h3",{id:"imports-are-now-automatically-re-exported"},"Imports are now automatically re-exported"),(0,i.kt)("p",null,"When a module is imported e.g. with ",(0,i.kt)("inlineCode",{parentName:"p"},'#import "foo.jsligo" "Foo"')," inside the file ",(0,i.kt)("inlineCode",{parentName:"p"},"bar.jsligo"),", it is automatically re-exported."),(0,i.kt)("p",null,"For example, a third file importing ",(0,i.kt)("inlineCode",{parentName:"p"},"bar.jsligo")," as ",(0,i.kt)("inlineCode",{parentName:"p"},"Bar")," can write ",(0,i.kt)("inlineCode",{parentName:"p"},"Bar.Foo.x")," to access the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," defined in ",(0,i.kt)("inlineCode",{parentName:"p"},"foo.jsligo")),(0,i.kt)("p",null,"MRs:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://gitlab.com/ligolang/ligo/-/merge_requests/2815"},"https://gitlab.com/ligolang/ligo/-/merge_requests/2815"))),(0,i.kt)("h3",{id:"miscellaneous-1"},"Miscellaneous"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"true")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"false")," are now keywords (not variables), and cannot be shadowed by a local variable declaration. ",(0,i.kt)("a",{parentName:"li",href:"https://gitlab.com/ligolang/ligo/-/merge_requests/2661"},"https://gitlab.com/ligolang/ligo/-/merge_requests/2661"))),(0,i.kt)("h2",{id:"cameligo"},"CameLIGO"),(0,i.kt)("h3",{id:"field-and-tuple-component-access-1"},"Field and tuple component access"),(0,i.kt)("p",null,"Fields and tuple components can be accessed with the same dot notation:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo"},'let stuff = {\n    x = "foo";\n    y = (42, "life", { universe = true });\n}\n\nlet part : bool = stuff.y.2.universe\n')),(0,i.kt)("p",null,"MRs:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://gitlab.com/ligolang/ligo/-/merge_requests/2661"},"https://gitlab.com/ligolang/ligo/-/merge_requests/2661"))),(0,i.kt)("h3",{id:"package-management-use-ligojson-instead-of-packagejson-or-esyjson"},"Package management: use ligo.json instead of package.json or esy.json"),(0,i.kt)("p",null,"Users often work with JaveScript toolchain alongside ours. Using package.json to manage both is tricky. It's better to have a separate manfiest to manage ligo dependencies. We therefore now use a separate ",(0,i.kt)("inlineCode",{parentName:"p"},"ligo.json")," maninfest to manage LIGO packages."),(0,i.kt)("p",null,"As part of this change, we are no longer using the ",(0,i.kt)("inlineCode",{parentName:"p"},"esy")," tool for package management, and the ",(0,i.kt)("inlineCode",{parentName:"p"},"installation.json")," file, formerly located at ",(0,i.kt)("inlineCode",{parentName:"p"},"_esy/ligo/installation.json"),", should now be moved to ",(0,i.kt)("inlineCode",{parentName:"p"},"_ligo/ligo/installation.json"),"."),(0,i.kt)("p",null,"MRs:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://gitlab.com/ligolang/ligo/-/merge_requests/2817"},"https://gitlab.com/ligolang/ligo/-/merge_requests/2817")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://gitlab.com/ligolang/ligo/-/merge_requests/2785"},"https://gitlab.com/ligolang/ligo/-/merge_requests/2785")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://gitlab.com/ligolang/ligo/-/merge_requests/2883"},"https://gitlab.com/ligolang/ligo/-/merge_requests/2883"))))}c.isMDXComponent=!0}}]);