"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[16120],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>c});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},f={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),u=p(n),c=i,m=u["".concat(s,".").concat(c)]||u[c]||f[c]||r;return n?a.createElement(m,l(l({ref:t},d),{},{components:n})):a.createElement(m,l({ref:t},d))}));function c(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=u;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var p=2;p<r;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},48720:(e,t,n)=>{n.d(t,{D:()=>i.Z,Z:()=>r});var a=n(67294),i=n(75402);const r=function(e){return a.createElement(i.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},65465:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>u,frontMatter:()=>l,metadata:()=>s,toc:()=>d});var a=n(87462),i=(n(67294),n(3905)),r=n(48720);const l={id:"folding",title:"Folding"},o=void 0,s={unversionedId:"lists/folding",id:"version-1.5.0/lists/folding",title:"Folding",description:"A functional iterator is a function that traverses a data structure",source:"@site/versioned_docs/version-1.5.0/lists/folding.md",sourceDirName:"lists",slug:"/lists/folding",permalink:"/docs/1.5.0/lists/folding",draft:!1,tags:[],version:"1.5.0",frontMatter:{id:"folding",title:"Folding"},sidebar:"docs",previous:{title:"Updating",permalink:"/docs/1.5.0/lists/updating"},next:{title:"Mapping",permalink:"/docs/1.5.0/lists/mapping"}},p={},d=[],f={toc:d};function u(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},f,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"functional iterator")," is a function that traverses a data structure\nand calls in turn a given function over the elements of that structure\nto compute some value. Another approach is sometimes possible: ",(0,i.kt)("em",{parentName:"p"},"loops"),"\n(see sections loops, sets and maps)."),(0,i.kt)("p",null,"There are three kinds of functional iterations over lists: the ",(0,i.kt)("em",{parentName:"p"},"fold"),",\nthe ",(0,i.kt)("em",{parentName:"p"},"map")," (not to be confused with the ",(0,i.kt)("em",{parentName:"p"},"map data structure"),") and the\n",(0,i.kt)("em",{parentName:"p"},"iteration"),"."),(0,i.kt)("p",null,"Let us consider first here the fold, which is the most general form of\nfunctional iteration. The folded function takes two arguments: an\n",(0,i.kt)("em",{parentName:"p"},"accumulator")," and the structure ",(0,i.kt)("em",{parentName:"p"},"element")," at hand, with which it then\nproduces a new accumulator. This enables having a partial result that\nbecomes complete when the traversal of the data structure is over."),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The module ",(0,i.kt)("inlineCode",{parentName:"p"},"List")," exports the functions ",(0,i.kt)("inlineCode",{parentName:"p"},"fold_left")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"fold_right"),",\nso folds have either the form:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"List.fold_left folded init list\n")),(0,i.kt)("p",null,"or"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"List.fold_right folded list init\n")),(0,i.kt)("p",null,"which means that the folding can be done leftwards or rightwards on\nthe list. One way to tell them apart is to look where the folded\nfunction, and the fold itself, keep the accumulator in their\nsignatures. Take for example a function ",(0,i.kt)("inlineCode",{parentName:"p"},"f"),", a list ",(0,i.kt)("inlineCode",{parentName:"p"},"[1; 2; 3]"),", and\nan initial accumulator ",(0,i.kt)("inlineCode",{parentName:"p"},"init"),". Then"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"List.fold_left f init [1; 2; 3] = f (f (f (init, 1), 2), 3)\n")),(0,i.kt)("p",null,"and"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"List.fold_right f [1; 2; 3] init = f (1, f (2, f (3, init)))\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The type of ",(0,i.kt)("inlineCode",{parentName:"p"},"List.fold_left")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"('a * 'b -> 'a) -> 'a -> 'b list\n-> 'a"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The type of ",(0,i.kt)("inlineCode",{parentName:"p"},"List.fold_right")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"('b * 'a -> 'a) -> 'b list ->\n'a -> 'a"),"."))),(0,i.kt)("p",null,"For example, let us compute the sum of integers in a list, assuming\nthat the empty list yields ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=folding_lists",group:"folding_lists"},"let sum1 = List.fold_left (fun (a,i) -> a + i) 0 [1; 2; 3]\nlet sum2 = List.fold_right (fun (i,a) -> i + a) [1; 2; 3] 0\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"For OCaml users: In OCaml, the folded functions are curryfied, so\ntheir types are ",(0,i.kt)("inlineCode",{parentName:"p"},"('a -> 'b -> 'a)")," ",(0,i.kt)("inlineCode",{parentName:"p"},"List.fold_left"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"('b -> 'a\n-> 'a)")," with ",(0,i.kt)("inlineCode",{parentName:"p"},"List.fold_right"),".")),(0,i.kt)("p",null,"See predefined\n",(0,i.kt)("a",{parentName:"p",href:"../reference/list-reference/?lang=cameligo"},"module List"),".")),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The module ",(0,i.kt)("inlineCode",{parentName:"p"},"List")," exports the functions ",(0,i.kt)("inlineCode",{parentName:"p"},"fold_left")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"fold_right"),",\nso folds have either the form:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"List.fold_left (folded, init, list)\n")),(0,i.kt)("p",null,"or"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"List.fold_right (folded, list, init)\n")),(0,i.kt)("p",null,"which mean that the folding can be done leftwards or rightwards on the\nlist. One way to tell them apart is to look where the folded function,\nand the fold itself, keep the accumulator in their signatures. Take\nfor example a function ",(0,i.kt)("inlineCode",{parentName:"p"},"f"),", a list ",(0,i.kt)("inlineCode",{parentName:"p"},"list([1, 2, 3])"),", and an initial\naccumulator ",(0,i.kt)("inlineCode",{parentName:"p"},"init"),". Then"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"List.fold_left (f, init, list([1;2;3])) = f (f (f (init, 1), 2), 3)\n")),(0,i.kt)("p",null,"and"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"List.fold_right (f, list([1;2;3]), init) = f (1, (f (2, (f (3, init)))))\n")),(0,i.kt)("p",null,"The type of ",(0,i.kt)("inlineCode",{parentName:"p"},"List.fold_left")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"(p : [a * b => a, a, b list]) => a"),"."),(0,i.kt)("p",null,"The type of ",(0,i.kt)("inlineCode",{parentName:"p"},"List.fold_right")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"(p : [b * a => a, b list, a]) => a"),"."),(0,i.kt)("p",null,"For example, let us compute the sum of integers in a list, assuming\nthat the empty list yields ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=folding_lists",group:"folding_lists"},"const add1 = ([a, i]) => a + i;\nconst sum1 = List.fold_left (add1, 0, list([1, 2, 3]));\nconst add2 = ([i, a]) => i + a;\nconst sum2 = List.fold_right (add2, list([1, 2, 3]), 0);\n")),(0,i.kt)("p",null,"See predefined\n",(0,i.kt)("a",{parentName:"p",href:"../reference/list-reference/?lang=jsligo"},"namespace List"),".")))}u.isMDXComponent=!0}}]);