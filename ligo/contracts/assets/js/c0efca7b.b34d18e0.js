"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[78164],{3905:(n,t,e)=>{e.d(t,{Zo:()=>d,kt:()=>m});var a=e(67294);function i(n,t,e){return t in n?Object.defineProperty(n,t,{value:e,enumerable:!0,configurable:!0,writable:!0}):n[t]=e,n}function r(n,t){var e=Object.keys(n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(n,t).enumerable}))),e.push.apply(e,a)}return e}function o(n){for(var t=1;t<arguments.length;t++){var e=null!=arguments[t]?arguments[t]:{};t%2?r(Object(e),!0).forEach((function(t){i(n,t,e[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)):r(Object(e)).forEach((function(t){Object.defineProperty(n,t,Object.getOwnPropertyDescriptor(e,t))}))}return n}function l(n,t){if(null==n)return{};var e,a,i=function(n,t){if(null==n)return{};var e,a,i={},r=Object.keys(n);for(a=0;a<r.length;a++)e=r[a],t.indexOf(e)>=0||(i[e]=n[e]);return i}(n,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);for(a=0;a<r.length;a++)e=r[a],t.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(n,e)&&(i[e]=n[e])}return i}var s=a.createContext({}),p=function(n){var t=a.useContext(s),e=t;return n&&(e="function"==typeof n?n(t):o(o({},t),n)),e},d=function(n){var t=p(n.components);return a.createElement(s.Provider,{value:t},n.children)},c={inlineCode:"code",wrapper:function(n){var t=n.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(n,t){var e=n.components,i=n.mdxType,r=n.originalType,s=n.parentName,d=l(n,["components","mdxType","originalType","parentName"]),u=p(e),m=i,g=u["".concat(s,".").concat(m)]||u[m]||c[m]||r;return e?a.createElement(g,o(o({ref:t},d),{},{components:e})):a.createElement(g,o({ref:t},d))}));function m(n,t){var e=arguments,i=t&&t.mdxType;if("string"==typeof n||i){var r=e.length,o=new Array(r);o[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=n,l.mdxType="string"==typeof n?n:i,o[1]=l;for(var p=2;p<r;p++)o[p]=e[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,e)}u.displayName="MDXCreateElement"},48720:(n,t,e)=>{e.d(t,{D:()=>i.Z,Z:()=>r});var a=e(67294),i=e(75402);const r=function(n){return a.createElement(i.Z.Consumer,null,(t=>{let{syntax:e}=t;return e===n.syntax?n.children:a.createElement(a.Fragment,null)}))}},39753:(n,t,e)=>{e.r(t),e.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var a=e(87462),i=(e(67294),e(3905)),r=e(48720);const o={title:"Numbers"},l=void 0,s={unversionedId:"data-types/numbers",id:"data-types/numbers",title:"Numbers",description:"In LIGO, there are two types of numbers: integers and natural",source:"@site/../docs/data-types/numbers.md",sourceDirName:"data-types",slug:"/data-types/numbers",permalink:"/previews/ligo/contracts/docs/next/data-types/numbers",draft:!1,tags:[],version:"current",frontMatter:{title:"Numbers"},sidebar:"docs",previous:{title:"Escaped variables",permalink:"/previews/ligo/contracts/docs/next/keywords/escaped_vars"},next:{title:"Booleans",permalink:"/previews/ligo/contracts/docs/next/data-types/booleans"}},p={},d=[{value:"Casting",id:"casting",level:2},{value:"Adding",id:"adding",level:2},{value:"Subtracting",id:"subtracting",level:2},{value:"Negating",id:"negating",level:2},{value:"Multiplying",id:"multiplying",level:2},{value:"Dividing",id:"dividing",level:2}],c={toc:d};function u(n){let{components:t,...e}=n;return(0,i.kt)("wrapper",(0,a.Z)({},c,e,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"In LIGO, there are two types of numbers: integers and natural\nnumbers."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Integer literals are the same found in mainstream programming\nlanguages, for example, ",(0,i.kt)("inlineCode",{parentName:"p"},"10"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"-6")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),", but there is only one\ncanonical zero: ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," (so, for instance, ",(0,i.kt)("inlineCode",{parentName:"p"},"-0")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"00")," are invalid).")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Natural numbers are written as digits followed by the suffix ",(0,i.kt)("inlineCode",{parentName:"p"},"n"),",\nlike so: ",(0,i.kt)("inlineCode",{parentName:"p"},"12n"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"0n"),", and the same restriction on zero as integers\napplies: ",(0,i.kt)("inlineCode",{parentName:"p"},"0n")," is the only way to specify the natural zero."))),(0,i.kt)("p",null,"Contrary to integral numbers in other programming languages, numbers\nin LIGO have arbitrary-precision, that is, they do not overflow or\nunderflow."),(0,i.kt)("p",null,"Digits of large numbers can be separated by an underscore, to increase\nreadability."),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=int_and_nat",group:"int_and_nat"},"// The following are integers\nlet zero = 0\nlet million = 1_000_000 // Grouping in French\nlet baekman = 100_0000 // Grouping in Korean\n\n// The following are natural numbers\nlet zero_nat = 0n\nlet million_nat = 1_000_000n\nlet baekman_nat = 100_0000n\n")),(0,i.kt)("p",null,"As a form of documentation, a type can be ascribed to each constant:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=typed_int_and_nat",group:"typed_int_and_nat"},"let zero : int = 0\nlet million : int = 1_000_000\nlet baekman : int = 100_0000\n\nlet zero_nat : nat = 0n\nlet million_nat : nat = 1_000_000n\nlet baekman_nat : nat = 100_0000n\n"))),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=int_and_nat",group:"int_and_nat"},"// The following are integers\nconst zero = 0\nconst million = 1_000_000 // Grouping in French\nconst baekman = 100_0000 // Grouping in Korean\n\n// The following are natural numbers\nconst zero_nat = 0n\nconst million_nat = 1_000_000n\nconst baekman_nat = 100_0000n\n")),(0,i.kt)("p",null,"As a form of documentation, a type can be ascribed to each constant:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=typed_int_and_nat",group:"typed_int_and_nat"},"const zero : int = 0\nconst million : int = 1_000_000\nconst baekman : int = 100_0000\n\nconst zero_nat : nat = 0n\nconst million_nat : nat = 1_000_000n\nconst baekman_nat : nat = 100_0000n\n"))),(0,i.kt)("h2",{id:"casting"},"Casting"),(0,i.kt)("p",null,"In mathematics, natural numbers are a strict subset of integers, and\ncan be used in any context where an integer is expected. In LIGO, this\nproperty does not hold true in general. Instead, a given binary\narithmetic operation, say, is defined four times, so it can apply to\nany combination of natural numbers and integers: this is called\n",(0,i.kt)("em",{parentName:"p"},"overloading"),", and some programming languages extend it to\nuser-defined functions (e.g. members in C++) -- but not LIGO."),(0,i.kt)("p",null,"So there are no implicit type casts in LIGO, but we can ",(0,i.kt)("em",{parentName:"p"},"explicitly\ncast")," natural numbers to integers (this is safe in all contexts where\nan integer is valid) by calling the predefined function ",(0,i.kt)("inlineCode",{parentName:"p"},"int"),". The\ninverse cast, from ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"nat")," is called in mathematics the\n",(0,i.kt)("em",{parentName:"p"},"absolute value"),", or ",(0,i.kt)("inlineCode",{parentName:"p"},"abs")," in LIGO."),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=casting",group:"casting"},"let one : int = int 1n // Explicit cast from nat to int\nlet two : nat = abs 2  // Explicit cast from int to nat\n"))),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=casting",group:"casting"},"const one : int = int(1n); // Explicit cast from nat to int\nconst two : nat = abs(2);  // Explicit cast from int to nat\n"))),(0,i.kt)("h2",{id:"adding"},"Adding"),(0,i.kt)("p",null,"Addition in LIGO is accomplished by means of the ",(0,i.kt)("inlineCode",{parentName:"p"},"+")," binary operator,\nwhich is overloaded to apply to any combination of natural numbers and\nintegers, as shown in the following examples. Note that adding an\ninteger to a natural number produces an integer, because the compiler\ncannot determine, in general, whether the result would be always a\nnatural number for all inputs."),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=additing",group:"additing"},"let a : int = 5 + 10    // int + int yields int\nlet b : nat = 5n + 10n  // nat + nat yields nat\nlet c : int = 5n + 10   // nat + int yields int\nlet d : int = 10 + 5n   // int + nat yields int\n// let error : nat = 5n + 10\n"))),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=additing",group:"additing"},"const a : int = 5 + 10;    // int + int yields int\nconst b : nat = 5n + 10n;  // nat + nat yields nat\nconst c : int = 5n + 10;   // nat + int yields int\nconst d : int = 10 + 5n;   // int + nat yields int\n// const error : nat = 5n + 10;\n"))),(0,i.kt)("h2",{id:"subtracting"},"Subtracting"),(0,i.kt)("p",null,"Subtraction in LIGO is accomplished by means of the ",(0,i.kt)("inlineCode",{parentName:"p"},"-")," binary\noperator which is overloaded to apply to any combination of natural\nnumbers and integers, as shown in the following examples. The rule\nwhen subtracting two natural numbers is that the result is an integer\nbecause, in general, the compiler cannot determine whether the value\nof an expression is positive or zero for all inputs."),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=subtracting",group:"subtracting"},"let a : int = 5 - 10   // int - int yields int\nlet b : int = 5n - 2n  // nat - nat yields int\nlet c : int = 10n - 5  // nat - int yields int\nlet d : int = 5 - 10n  // int - nat yields int\n// let error : nat = 5n - 2n\n"))),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=subtracting",group:"subtracting"},"const a : int = 5 - 10;   // int - int yields int\nconst b : int = 5n - 2n;  // nat - nat yields int\nconst c : int = 10n - 5;  // nat - int yields int\nconst d : int = 5 - 10n;  // int - nat yields int\n// const error : nat = 5n - 2n;\n"))),(0,i.kt)("h2",{id:"negating"},"Negating"),(0,i.kt)("p",null,"The arithmetic negation of a number is the same as subtracting that\nnumber from zero, so the negation of a natural numbers yields an\ninteger:"),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=negating",group:"negating"},"let a : int = -5  // - int yields int\nlet b : int = -5n // - nat yields int\n// let error : nat = -5n\n"))),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=negating",group:"negating"},"const a : int = -5;  // - int yields int\nconst b : int = -5n; // - nat yields int\n// const error : nat = -5n;\n"))),(0,i.kt)("h2",{id:"multiplying"},"Multiplying"),(0,i.kt)("p",null,"Multiplication in LIGO is accomplished by means of the ",(0,i.kt)("inlineCode",{parentName:"p"},"*")," binary\noperator which is overloaded to apply to any combination of natural\nnumbers and integers, as shown in the following examples. The type\nrules for multiplication are the same as for the addition:"),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=multiplying",group:"multiplying"},"let a : int = 5 * 10   // int * int yields int\nlet b : nat = 5n * 2n  // nat * nat yields nat\nlet c : int = 10n * 5  // nat * int yields int\nlet d : int = 5 * 10n  // int * nat yields int\n"))),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=multiplying",group:"multiplying"},"const a : int = 5 * 10;   // int * int yields int\nconst b : nat = 5n * 2n;  // nat * nat yields nat\nconst c : int = 10n * 5;  // nat * int yields int\nconst d : int = 5 * 10n;  // int * nat yields int\n"))),(0,i.kt)("h2",{id:"dividing"},"Dividing"),(0,i.kt)("p",null,"Because LIGO features neither floating-point nor fixed-point\narithmetic, division in LIGO is Euclidean. The predefined binary\noperator ",(0,i.kt)("inlineCode",{parentName:"p"},"/")," returns the quotient and is overloaded like the\nmultiplication. Of course, division by zero triggers an exception that\ninterrups the execution, so the programmer must make sure this case\ncannot happen because the compiler cannot determine, in general, if a\nvariable will have a given value (or not) for all inputs."),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=dividing",group:"dividing"},"let a : int = 10 / 3    // int / int yields int\nlet b : nat = 10n / 3n  // nat / nat yields nat\nlet c : int = 10n / 3   // nat / int yields int\nlet d : int = 10 / 3n   // int / nat yields int\n"))),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=dividing",group:"dividing"},"const a : int = 10 / 3;    // int / int yields int\nconst b : nat = 10n / 3n;  // nat / nat yields nat\nconst c : int = 10n / 3;   // nat / int yields int\nconst d : int = 10 / 3n;   // int / nat yields int\n"))),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The binary operator ",(0,i.kt)("inlineCode",{parentName:"p"},"mod")," returns the ",(0,i.kt)("em",null,"positive modulo")," of the\nEuclidean division, that is, the following holds:"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"(n*(a/n)+(a%n) == a) && (0n <= a % n) && (a % n < abs(n))")),(0,i.kt)("p",null,"It is overloaded as the Euclidean division ",(0,i.kt)("inlineCode",{parentName:"p"},"/")," to allow for\nall four combinations of natural numbers and integers."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=mod",group:"mod"},"let a : nat = 120  mod 9  // int mod int yields nat\nlet b : nat = 120n mod 9  // nat mod int yields nat\nlet b : nat = 120n mod 9n // nat mod nat yields nat\nlet c : nat = 120  mod 9n // int mod nat yields nat\n"))),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The binary operator ",(0,i.kt)("inlineCode",{parentName:"p"},"%")," returns the ",(0,i.kt)("em",null,"positive modulo")," of the\nEuclidean division, that is, the following holds:"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"(n*(a/n)+(a%n) == a) && (0n <= a % n) && (a % n < abs(n))")),(0,i.kt)("p",null,"It is overloaded as the Euclidean division ",(0,i.kt)("inlineCode",{parentName:"p"},"/")," to allow for all four\ncombinations of natural numbers and integers."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=mod",group:"mod"},"const a : nat = 120  % 9;  // int % int yields nat\nconst b : nat = 120n % 9;  // nat % int yields nat\nconst c : nat = 120n % 9n; // nat % nat yields nat\nconst d : nat = 120  % 9n; // int % nat yields nat\n"))),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"It is possible to obtain both the quotient and remainder together, by\nmeans of the predefined function ",(0,i.kt)("inlineCode",{parentName:"p"},"ediv"),": See ",(0,i.kt)("a",{parentName:"p",href:"./variants#euclidean-division"},"Euclidean division"),".")))}u.isMDXComponent=!0}}]);