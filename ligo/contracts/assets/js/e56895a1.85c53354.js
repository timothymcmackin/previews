"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[19512],{3905:(t,n,e)=>{e.d(n,{Zo:()=>c,kt:()=>y});var a=e(67294);function o(t,n,e){return n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}function r(t,n){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(t,n).enumerable}))),e.push.apply(e,a)}return e}function i(t){for(var n=1;n<arguments.length;n++){var e=null!=arguments[n]?arguments[n]:{};n%2?r(Object(e),!0).forEach((function(n){o(t,n,e[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):r(Object(e)).forEach((function(n){Object.defineProperty(t,n,Object.getOwnPropertyDescriptor(e,n))}))}return t}function l(t,n){if(null==t)return{};var e,a,o=function(t,n){if(null==t)return{};var e,a,o={},r=Object.keys(t);for(a=0;a<r.length;a++)e=r[a],n.indexOf(e)>=0||(o[e]=t[e]);return o}(t,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(a=0;a<r.length;a++)e=r[a],n.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(t,e)&&(o[e]=t[e])}return o}var s=a.createContext({}),p=function(t){var n=a.useContext(s),e=n;return t&&(e="function"==typeof t?t(n):i(i({},n),t)),e},c=function(t){var n=p(t.components);return a.createElement(s.Provider,{value:n},t.children)},u={inlineCode:"code",wrapper:function(t){var n=t.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(t,n){var e=t.components,o=t.mdxType,r=t.originalType,s=t.parentName,c=l(t,["components","mdxType","originalType","parentName"]),m=p(e),y=o,h=m["".concat(s,".").concat(y)]||m[y]||u[y]||r;return e?a.createElement(h,i(i({ref:n},c),{},{components:e})):a.createElement(h,i({ref:n},c))}));function y(t,n){var e=arguments,o=n&&n.mdxType;if("string"==typeof t||o){var r=e.length,i=new Array(r);i[0]=m;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=t,l.mdxType="string"==typeof t?t:o,i[1]=l;for(var p=2;p<r;p++)i[p]=e[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,e)}m.displayName="MDXCreateElement"},48720:(t,n,e)=>{e.d(n,{D:()=>o.Z,Z:()=>r});var a=e(67294),o=e(75402);const r=function(t){return a.createElement(o.Z.Consumer,null,(n=>{let{syntax:e}=n;return e===t.syntax?t.children:a.createElement(a.Fragment,null)}))}},2666:(t,n,e)=>{e.r(n),e.d(n,{assets:()=>p,contentTitle:()=>l,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var a=e(87462),o=(e(67294),e(3905)),r=e(48720);const i={id:"interop",title:"Interoperability"},l=void 0,s={unversionedId:"syntax/contracts/interop",id:"syntax/contracts/interop",title:"Interoperability",description:"LIGO can work together with other smart contract languages on Tezos. However,",source:"@site/../docs/syntax/contracts/interop.md",sourceDirName:"syntax/contracts",slug:"/syntax/contracts/interop",permalink:"/previews/ligo/contracts/docs/next/syntax/contracts/interop",draft:!1,tags:[],version:"current",frontMatter:{id:"interop",title:"Interoperability"}},p={},c=[{value:"Michelson types and annotations",id:"michelson-types-and-annotations",level:2},{value:"Michelson layout of LIGO data structures",id:"michelson-layout-of-ligo-data-structures",level:2},{value:"Right-comb tree by default",id:"right-comb-tree-by-default",level:3},{value:"Alternative alphabetically ordered left-balanced tree layout",id:"alternative-alphabetically-ordered-left-balanced-tree-layout",level:3},{value:"Different Michelson annotations",id:"different-michelson-annotations",level:2},{value:"Advanced interoperability with Michelson",id:"advanced-interoperability-with-michelson",level:2},{value:"Manual data structure conversion",id:"manual-data-structure-conversion",level:2},{value:"Entrypoints and annotations",id:"entrypoints-and-annotations",level:2},{value:"Amendment",id:"amendment",level:2}],u={toc:c};function m(t){let{components:n,...e}=t;return(0,o.kt)("wrapper",(0,a.Z)({},u,e,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"LIGO can work together with other smart contract languages on Tezos. However,\ndata structures might have different representations in Michelson and not\ncorrectly match the standard LIGO types."),(0,o.kt)("h2",{id:"michelson-types-and-annotations"},"Michelson types and annotations"),(0,o.kt)("p",null,"Michelson types consist of ",(0,o.kt)("inlineCode",{parentName:"p"},"or"),"'s and ",(0,o.kt)("inlineCode",{parentName:"p"},"pair"),"'s, combined with field\nannotations.  Field annotations add constraints on a Michelson type,\nfor example a pair of ",(0,o.kt)("inlineCode",{parentName:"p"},"(pair (int %foo) (string %bar))")," will only work\nwith the exact equivalence or the same type without the field\nannotations."),(0,o.kt)("p",null,"To clarify:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-michelson"},"(pair (int %foo) (string %bar))\n")),(0,o.kt)("p",null,"works with"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-michelson"},"(pair (int %foo) (string %bar))\n")),(0,o.kt)("p",null,"works with"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-michelson"},"(pair int string)\n")),(0,o.kt)("p",null,"works not with"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-michelson"},"(pair (int %bar) (string %foo))\n")),(0,o.kt)("p",null,"works not with"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-michelson"},"(pair (string %bar) (int %foo))\n")),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"In the case of annotated entrypoints --- the annotated ",(0,o.kt)("inlineCode",{parentName:"p"},"or")," tree\ndirectly under ",(0,o.kt)("inlineCode",{parentName:"p"},"parameter")," in a contract --- you should use\nannotations, as otherwise it is unclear which entrypoint you are\nreferring to.")),(0,o.kt)("h2",{id:"michelson-layout-of-ligo-data-structures"},"Michelson layout of LIGO data structures"),(0,o.kt)("h3",{id:"right-comb-tree-by-default"},"Right-comb tree by default"),(0,o.kt)("p",null,"By default, the Michelson data representation of LIGO data structures is a\nlocation retaining right combed tree, like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"  (or\n    (unit %elephant)\n    (or (unit %dog)\n        (unit %cat)))\n")),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("p",null,"You can use the attribute ",(0,o.kt)("inlineCode",{parentName:"p"},"[@layout comb]")," to make this choice\nexplicitly:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo"},"type animal =\n[@layout comb]\n| Elephant\n| Dog\n| Cat\n"))),(0,o.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("p",null,"You can use the decorator ",(0,o.kt)("inlineCode",{parentName:"p"},'@layout("comb")')," to make this choice explicitly:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo"},'type animal =\n@layout("comb")\n| ["Elephant"]\n| ["Dog"]\n| ["Cat"];\n'))),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("p",null,"The attribute ",(0,o.kt)("inlineCode",{parentName:"p"},"[@layout comb]")," can also be used on record types:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo"},"type artist =\n  [@layout comb] {\n  genre : string;\n  since : timestamp;\n  name  : string\n}\n"))),(0,o.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},'The decorator `@layout("comb")` can also be used on record types:',(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo"},'type artist =\n@layout("comb")\n{\n  genre : string,\n  since : timestamp,\n  name  : string\n};\n'))),(0,o.kt)("p",null,"The next section discusses an alternative layout, which used to be the\ndefault one until LIGO version 1.0."),(0,o.kt)("h3",{id:"alternative-alphabetically-ordered-left-balanced-tree-layout"},"Alternative alphabetically ordered left-balanced tree layout"),(0,o.kt)("p",null,"Before version 1.0, LIGO used to translate its datatypes into an\nalphabetically ordered left balanced tree by default. So, for example:"),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=orig",group:"orig"},"type animal = Elephant | Dog | Cat\n"))),(0,o.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=orig",group:"orig"},'type animal = | ["Elephant"] | ["Dog"] | ["Cat"];\n'))),(0,o.kt)("p",null,"will translate to:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-michelson"},"(or\n  (or\n    (unit %cat)\n    (unit %dog))\n  (unit %elephant))\n")),(0,o.kt)("p",null,"This behaviour can be obtained using ",(0,o.kt)("inlineCode",{parentName:"p"},'@layout("tree")'),"."),(0,o.kt)("h2",{id:"different-michelson-annotations"},"Different Michelson annotations"),(0,o.kt)("p",null,"If the Michelson annotation should be different from the LIGO\nattribute, give it as an argument to the LIGO attribute. For\nexample:"),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=annot",group:"annot"},"type animal =\n| [@annot memory] Elephant\n| [@annot face] Dog\n| [@annot fish] Cat\n"))),(0,o.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=annot",group:"annot"},'type animal =\n| @annot("memory") ["Elephant"]\n| @annot("face") ["Dog"]\n| @annot("fish") ["Cat"]\n'))),(0,o.kt)("p",null,"will result into:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-michelson"},"(or\n  (or\n    (unit %fish)\n    (unit %face))\n  (unit %memory))\n")),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("p",null,"The attribute ",(0,o.kt)("inlineCode",{parentName:"p"},"[@annot <name>]")," can also be used on record field\nannotations:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=annot",group:"annot"},"type artist = {\n  [@annot style] genre: string;\n  [@annot from] since: timestamp;\n  [@annot performer] name: string;\n}\n")),(0,o.kt)("p",null,"If the ",(0,o.kt)("inlineCode",{parentName:"p"},"[@layout comb]")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"[@annot <name>]")," attributes are not\nadequate enough for your use-case, LIGO has more advanced advanced\ninteroperability features, which we will we discuss next.")),(0,o.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("p",null,"The decorator ",(0,o.kt)("inlineCode",{parentName:"p"},'@annot("<name>")')," can also be used on record field\nannotations:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=annot",group:"annot"},'type artist = {\n  @annot("style") genre: string,\n  @annot("from") since: timestamp,\n  @annot("performer") name: string\n}\n')),(0,o.kt)("p",null,"If the decorators ",(0,o.kt)("inlineCode",{parentName:"p"},'@layout("comb")')," and ",(0,o.kt)("inlineCode",{parentName:"p"},'@annot("<name>")')," are not\nadequate enough for your use-case, LIGO has more advanced advanced\ninteroperability features, which we will we discuss next.")),(0,o.kt)("h2",{id:"advanced-interoperability-with-michelson"},"Advanced interoperability with Michelson"),(0,o.kt)("p",null,"To interoperate with existing Michelson code or to be compatible with\ncertain development tooling, LIGO has two special interoperation\ntypes: ",(0,o.kt)("inlineCode",{parentName:"p"},"michelson_or")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"michelson_pair"),". These types give the\nflexibility to model the exact Michelson output, including field\nannotations."),(0,o.kt)("p",null,"Take for example the following Michelson type that we want to\ninteroperate with:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-michelson"},"(or\n  (unit %z)\n  (or %other\n    (unit %y)\n    (pair %other\n      (string %x)\n      (pair %other\n        (int %w)\n        (nat %v)))))\n")),(0,o.kt)("p",null,"To reproduce this type we can use the following LIGO code:"),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo"},'type w_and_v = (int, "w", nat, "v") michelson_pair\ntype x_and = (string, "x", w_and_v, "other") michelson_pair\ntype y_or = (unit, "y", x_and, "other") michelson_or\ntype z_or = (unit, "z", y_or, "other") michelson_or\n'))),(0,o.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo"},'type w_and_v = michelson_pair<[int, "w", nat, "v"]>;\ntype x_and = michelson_pair<[string, "x", w_and_v, "other"]>;\ntype y_or = michelson_or<[unit, "y", x_and, "other"]>;\ntype z_or = michelson_or<[unit, "z", y_or, "other"]>;\n'))),(0,o.kt)("p",null,"If you do not want to inject a Michelson annotation, the you simply\nprovide an empty string."),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"Alternatively, if annotations are not important you can also use plain\ntuples for pairs instead. Plain tuples do not have any annotations.")),(0,o.kt)("p",null,"To use variables of type ",(0,o.kt)("inlineCode",{parentName:"p"},"michelson_or")," you have to use ",(0,o.kt)("inlineCode",{parentName:"p"},"M_left")," and\n",(0,o.kt)("inlineCode",{parentName:"p"},"M_right"),".  ",(0,o.kt)("inlineCode",{parentName:"p"},"M_left")," picks the left ",(0,o.kt)("inlineCode",{parentName:"p"},"or")," case while ",(0,o.kt)("inlineCode",{parentName:"p"},"M_right")," picks\nthe right ",(0,o.kt)("inlineCode",{parentName:"p"},"or")," case.  For ",(0,o.kt)("inlineCode",{parentName:"p"},"michelson_pair")," you need to use tuples."),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo"},'let z : z_or = M_left unit\n\nlet y_1 : y_or = M_left unit\nlet y   : z_or = M_right y_1\n\nlet x_pair = "foo", (2, 3n)\nlet x_1 : y_or = M_right x_pair\nlet x : z_or = M_right y_1\n'))),(0,o.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo"},'let z : z_or = M_left(unit);\n\nlet y_1 : y_or = M_left(unit);\nlet y : z_or = M_right(y_1);\n\nlet x_pair = ["foo", [2, 3n]];\nlet x_1 : y_or = M_right (x_pair);\nlet x : z_or = M_right (y_1);\n'))),(0,o.kt)("h2",{id:"manual-data-structure-conversion"},"Manual data structure conversion"),(0,o.kt)("p",null,"If you want to get your hands dirty, it is also possible to do manual\ndata structure conversion. The following code can be used as\ninspiration:"),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=helper_functions",group:"helper_functions"},'type z_to_v =\n  Z\n| Y\n| X\n| W\n| V\n\ntype w_or_v = (unit, "w", unit, "v") michelson_or\ntype x_or = (unit, "x", w_or_v, "other") michelson_or\ntype y_or = (unit, "y", x_or, "other") michelson_or\ntype z_or = (unit, "z", y_or, "other") michelson_or\n\ntype test = {\n  z: string;\n  y: int;\n  x: string;\n  w: bool;\n  v: int\n}\n\nlet make_concrete_sum (r: z_to_v) : z_or =\n  match r with\n    Z -> M_left (unit)\n  | Y -> M_right (M_left (unit))\n  | X -> M_right (M_right (M_left (unit)))\n  | W -> M_right (M_right (M_right (M_left (unit))))\n  | V -> M_right (M_right (M_right (M_right (unit))))\n\nlet make_concrete_record (r: test) =\n  (r.z, r.y, r.x, r.w, r.v)\n\nlet make_abstract_sum (z_or: z_or) =\n  match z_or with\n  | M_left n -> Z\n  | M_right y_or ->\n    (match y_or with\n    | M_left n -> Y\n    | M_right x_or -> (\n        match x_or with\n        | M_left n -> X\n        | M_right w_or -> (\n            match w_or with\n            | M_left n -> W\n            | M_right n -> V)))\n\nlet make_abstract_record z y x w v = {z; y; x; w; v}\n'))),(0,o.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=helper_functions",group:"helper_functions"},'type z_to_v =\n  ["Z"]\n| ["Y"]\n| ["X"]\n| ["W"]\n| ["V"];\n\ntype w_or_v = michelson_or<[unit, "w", unit, "v"]>;\ntype x_or = michelson_or<[unit, "x", w_or_v, "other"]>;\ntype y_or = michelson_or<[unit, "y", x_or, "other"]>;\ntype z_or = michelson_or<[unit, "z", y_or, "other"]>;\n\ntype test = {\n  z: string,\n  y: int,\n  x: string,\n  w: bool,\n  v: int\n};\n\nconst make_concrete_sum = (r: z_to_v): z_or =>\n  match(r) {\n    when(Z()): M_left(unit);\n    when(Y()): M_right(M_left(unit));\n    when(X()): M_right (M_right (M_left(unit)));\n    when(W()): M_right (M_right (M_right(M_left(unit))));\n    when(V()): M_right (M_right (M_right(M_right(unit))))\n  };\n\n\nconst make_concrete_record = (r: test) =>\n  [r.z, r.y, r.x, r.w, r.v];\n\nconst make_abstract_sum = (z_or: z_or): z_to_v =>\n  match(z_or) {\n    when(M_left(n)): Z();\n    when(M_right(y_or)): match(y_or) {\n        when(M_left(n)): Y();\n        when(M_right(x_or)): match(x_or) {\n            when(M_left(n)): X();\n            when(M_right(w_or)): match(w_or) {\n                when(M_left(n)): W();\n                when(M_right(n)): V()\n            }\n        }\n    }\n  };\n\nconst make_abstract_record =\n  (z: string, y: int, x: string, w: bool, v: int) => ({z,y,x,w,v});\n'))),(0,o.kt)("h2",{id:"entrypoints-and-annotations"},"Entrypoints and annotations"),(0,o.kt)("p",null,"It is possible for a contract to have multiple entrypoints, which is\nimplicitly translated in LIGO to a ",(0,o.kt)("inlineCode",{parentName:"p"},"parameter")," with a variant type as\nshown below. The following contract:"),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=entrypoints_and_annotations",group:"entrypoints_and_annotations"},"type storage = int\n\n[@entry]\nlet left (i : int) (x : storage) : operation list * storage = [], x - i\n\n[@entry]\nlet right (i : int) (x : storage) : operation list * storage = [], x + i\n"))),(0,o.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=entrypoints_and_annotations",group:"entrypoints_and_annotations"},"type storage = int\n\n@entry\nconst left = (i: int, x: storage) : [list<operation>, storage] =>\n  [[], x - i]\n\n@entry\nconst right = (i: int, x: storage) : [list<operation>, storage] =>\n  [[], x + i]\n"))),(0,o.kt)("p",null,"is translated internally to a contract similar to this one:"),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo"},"type storage = int\n\ntype parameter =\n | Left of int\n | Right of int\n\n[@entry]\nlet main (p : parameter) (x : storage) : operation list * storage =\n  [],\n  (match p with\n  | Left i -> x - i\n  | Right i -> x + i\n  )\n"))),(0,o.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo"},'type storage = int;\n\ntype parameter =\n   ["Left", int]\n | ["Right", int];\n\nlet main = (p: parameter, x: storage): [list<operation>, storage] =>\n  [list ([]), match(p) {\n    when(Left(i)): x - i;\n    when(Right(i)): x + i\n   }\n  ];\n\n'))),(0,o.kt)("p",null,"This contract can be called by another contract, like this one:"),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=get_entrypoint_opt",group:"get_entrypoint_opt"},'type storage = int\n\ntype parameter = int\n\ntype x = Left of int\n\n[@entry]\nlet main (p : parameter) (s : storage): operation list * storage =\n  let contract =\n    match Tezos.get_entrypoint_opt "%left" ("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx": address) with\n    | Some c -> c\n    | None -> failwith "contract does not match"\n  in\n  [Tezos.transaction (Left 2) 2mutez contract], s\n'))),(0,o.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=get_entrypoint_opt",group:"get_entrypoint_opt"},'type storage = int;\n\ntype parameter = int;\n\ntype x = | ["Left", int];\n\n@entry\nconst main = (p: parameter, s: storage): [list<operation>, storage] => {\n  let contract =\n    match (Tezos.get_entrypoint_opt("%left", "tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx")) {\n      when(Some(c)): c;\n      when(None()): failwith ("contract does not match")\n    };\n  return [\n    [Tezos.transaction(Left(2), 2mutez, contract)],\n    s];\n};\n'))),(0,o.kt)("p",null,"Notice how we directly use the ",(0,o.kt)("inlineCode",{parentName:"p"},"%left")," entrypoint without mentioning\nthe ",(0,o.kt)("inlineCode",{parentName:"p"},"%right")," entrypoint. This is done with the help of\nannotations. Without annotations it wouldn't be clear what our ",(0,o.kt)("inlineCode",{parentName:"p"},"int"),"\nwould be referring to."),(0,o.kt)("p",null,"This currently only works for ",(0,o.kt)("inlineCode",{parentName:"p"},"or"),"'s or variant types in LIGO."),(0,o.kt)("h2",{id:"amendment"},"Amendment"),(0,o.kt)("p",null,"With amendment 007 to Tezos this is changed though, and also ",(0,o.kt)("inlineCode",{parentName:"p"},"pair"),"s\ncan be ordered differently."))}m.isMDXComponent=!0}}]);