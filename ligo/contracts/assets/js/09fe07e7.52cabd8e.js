"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6626],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>d});var a=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function p(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=a.createContext({}),s=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},u=function(e){var n=s(e.components);return a.createElement(l.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,u=p(e,["components","mdxType","originalType","parentName"]),m=s(t),d=i,g=m["".concat(l,".").concat(d)]||m[d]||c[d]||o;return t?a.createElement(g,r(r({ref:n},u),{},{components:t})):a.createElement(g,r({ref:n},u))}));function d(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,r=new Array(o);r[0]=m;var p={};for(var l in n)hasOwnProperty.call(n,l)&&(p[l]=n[l]);p.originalType=e,p.mdxType="string"==typeof e?e:i,r[1]=p;for(var s=2;s<o;s++)r[s]=t[s];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},48720:(e,n,t)=>{t.d(n,{D:()=>i.Z,Z:()=>o});var a=t(67294),i=t(75402);const o=function(e){return a.createElement(i.Z.Consumer,null,(n=>{let{syntax:t}=n;return t===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},43792:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>p,default:()=>m,frontMatter:()=>r,metadata:()=>l,toc:()=>u});var a=t(87462),i=(t(67294),t(3905)),o=t(48720);const r={title:"Variants"},p=void 0,l={unversionedId:"data-types/variants",id:"data-types/variants",title:"Variants",description:"A variant type is a type that defines a type by the union of",source:"@site/../docs/data-types/variants.md",sourceDirName:"data-types",slug:"/data-types/variants",permalink:"/previews/ligo/contracts/docs/next/data-types/variants",draft:!1,tags:[],version:"current",frontMatter:{title:"Variants"},sidebar:"docs",previous:{title:"Tuples",permalink:"/previews/ligo/contracts/docs/next/data-types/tuples"},next:{title:"Lists",permalink:"/previews/ligo/contracts/docs/next/data-types/lists"}},s={},u=[{value:"Unit",id:"unit",level:2},{value:"Options",id:"options",level:2},{value:"Euclidean Division",id:"euclidean-division",level:3},{value:"Checking positivity",id:"checking-positivity",level:3},{value:"Matching",id:"matching",level:2}],c={toc:u};function m(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A variant type is a type that defines a type by the union of\nnon-overlapping cases, so a value of a variant type is either this, or\nthat or... The simplest variant type is equivalent to the enumerated\ntypes found in Java, C++, JavaScript etc."),(0,i.kt)("p",null,"Here is how we define a coin as being either head or tail (and nothing\nelse):"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=variants",group:"variants"},"type coin = Head | Tail\nlet head : coin = Head\nlet tail : coin = Tail\n"))),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=variants",group:"variants"},'type coin = ["Head"] | ["Tail"];\nlet head: coin = Head();\nlet tail: coin = Tail();\n'))),(0,i.kt)("p",null,"The names ",(0,i.kt)("inlineCode",{parentName:"p"},"Head")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Tail")," in the definition of the type ",(0,i.kt)("inlineCode",{parentName:"p"},"coin")," are\ncalled ",(0,i.kt)("em",{parentName:"p"},"data constructors"),", or ",(0,i.kt)("em",{parentName:"p"},"variants"),". In this particular case,\nthey carry no information beyond their names, so they are called\n",(0,i.kt)("em",{parentName:"p"},"constant constructors"),"."),(0,i.kt)("p",null,"In general, it is interesting for variants to carry some information,\nand thus go beyond enumerated types. In the following, we show how to\ndefine different kinds of users of a system."),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=variants",group:"variants"},"type id = nat\n\ntype user =\n  Admin   of id\n| Manager of id\n| Guest\n\nlet bob : user = Admin 1000n\nlet carl : user = Guest\n")),(0,i.kt)("p",null,"A constant constructor is equivalent to the same constructor taking an\nargument of type ",(0,i.kt)("inlineCode",{parentName:"p"},"unit"),", so, for example, ",(0,i.kt)("inlineCode",{parentName:"p"},"Guest")," is the same value as\n",(0,i.kt)("inlineCode",{parentName:"p"},"Guest ()"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=variants",group:"variants"},'type id = nat;\n\ntype user =\n  ["Admin", id]\n| ["Manager", id]\n| ["Guest"];\n\nconst bob : user = Admin(1000n);\nconst carl : user = Guest();\n')),(0,i.kt)("p",null,"A constant constructor is equivalent to the same constructor taking an\nargument of type ",(0,i.kt)("inlineCode",{parentName:"p"},"unit"),", so, for example, ",(0,i.kt)("inlineCode",{parentName:"p"},"Guest()")," is the same value\nas ",(0,i.kt)("inlineCode",{parentName:"p"},"Guest([])")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"Guest(unit)"),".")),(0,i.kt)("h2",{id:"unit"},"Unit"),(0,i.kt)("p",null,"The type ",(0,i.kt)("inlineCode",{parentName:"p"},"unit")," is a predefined type that contains only one value that\ncarries no information. It is used when no relevant information is\nrequired or produced."),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The unique value of type ",(0,i.kt)("inlineCode",{parentName:"p"},"unit")," is written ",(0,i.kt)("inlineCode",{parentName:"p"},"()"),", like an empty tuple,\nfollowing the OCaml convention."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=unit",group:"unit"},"let x : unit = ()\n")),(0,i.kt)("p",null,"Imperative statements, like statements and loops, will have type\n",(0,i.kt)("inlineCode",{parentName:"p"},"unit"),", and that is why it is documented here.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The unique value of type ",(0,i.kt)("inlineCode",{parentName:"p"},"unit")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"[]"),", like an empty tuple."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=unit",group:"unit"},"const x : unit = [];\n"))),(0,i.kt)("h2",{id:"options"},"Options"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"option")," type is a parametric, predefined variant type that is\nused to express whether there is a value of some type or none. This is\nespecially useful when calling a ",(0,i.kt)("em",{parentName:"p"},"partial function"),", that is, a\nfunction that is not defined for some inputs. In that case, the value\nof the ",(0,i.kt)("inlineCode",{parentName:"p"},"option")," type would be ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),", otherwise ",(0,i.kt)("inlineCode",{parentName:"p"},"Some (v)"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"v"),"\nis some meaningful value ",(0,i.kt)("em",{parentName:"p"},"of any type"),". A typical example from\narithmetics is the division:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=options",group:"options"},"let div (a, b : nat * nat) : nat option =\n  if b = 0n then None else Some (a/b)\n")),(0,i.kt)("p",null,"Note: See the predefined\n",(0,i.kt)("a",{parentName:"p",href:"../reference/option-reference/?lang=cameligo"},"module Option"))),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"option")," type is a parametric, predefined variant type that is\nused to express whether there is a value of some type or none. This is\nespecially useful when calling a ",(0,i.kt)("em",{parentName:"p"},"partial function"),", that is, a\nfunction that is not defined for some inputs. In that case, the value\nof the ",(0,i.kt)("inlineCode",{parentName:"p"},"option")," type would be ",(0,i.kt)("inlineCode",{parentName:"p"},"None()"),", otherwise ",(0,i.kt)("inlineCode",{parentName:"p"},"Some(v)"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"v"),"\nis some meaningful value ",(0,i.kt)("em",{parentName:"p"},"of any type"),". A typical example from\narithmetics is the division:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=options",group:"options"},"function div (a: nat, b: nat): option<nat> {\n  if (b == 0n) return None() else return Some(a/b)\n};\n")),(0,i.kt)("p",null,"Note: See the predefined\n",(0,i.kt)("a",{parentName:"p",href:"../reference/option-reference/?lang=jsligo"},"namespace Option"))),(0,i.kt)("h3",{id:"euclidean-division"},"Euclidean Division"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"For cases when you need both the quotient and the remainder, LIGO\nprovides the ",(0,i.kt)("inlineCode",{parentName:"p"},"ediv")," operation. ",(0,i.kt)("inlineCode",{parentName:"p"},"ediv x y")," returns ",(0,i.kt)("inlineCode",{parentName:"p"},"Some (quotient,\nremainder)"),", unless ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," is zero, in which case it returns ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),". The\nfunction ",(0,i.kt)("inlineCode",{parentName:"p"},"ediv")," is overloaded to accept all the combinations (4) of\nnatural and integer numbers:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=options_euclidean",group:"options_euclidean"},"// All below equal Some (7,2)\nlet ediv1 : (int * nat) option = ediv 37  5\nlet ediv2 : (int * nat) option = ediv 37n 5\nlet ediv3 : (nat * nat) option = ediv 37n 5n\nlet ediv4 : (int * nat) option = ediv 37  5n\n"))),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"For cases when you need both the quotient and the remainder, LIGO\nprovides the ",(0,i.kt)("inlineCode",{parentName:"p"},"ediv")," operation. ",(0,i.kt)("inlineCode",{parentName:"p"},"ediv(x,y)")," returns ",(0,i.kt)("inlineCode",{parentName:"p"},"Some (quotient,\nremainder)"),", unless ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," is zero, in which case it returns ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),". The\nfunction ",(0,i.kt)("inlineCode",{parentName:"p"},"ediv")," is overloaded to accept all the combinations (4) of\nnatural and integer numbers:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=options_euclidean",group:"options_euclidean"},"// All below equal Some (7,2)\nconst ediv1: option<[int, nat]> = ediv(37,  5);\nconst ediv2: option<[int, nat]> = ediv(37n, 5);\nconst ediv3: option<[nat, nat]> = ediv(37n, 5n);\nconst ediv4: option<[int, nat]> = ediv(37,  5n);\n"))),(0,i.kt)("h3",{id:"checking-positivity"},"Checking positivity"),(0,i.kt)("p",null,"You can check if a value is a natural number (",(0,i.kt)("inlineCode",{parentName:"p"},"nat"),") by using a\npredefined cast function which accepts an integer (",(0,i.kt)("inlineCode",{parentName:"p"},"int"),") and returns\nan optional natural number (",(0,i.kt)("inlineCode",{parentName:"p"},"nat"),"): if the result is ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),", then the\ngiven integer was positive, otherwise the corresponding natural number\n",(0,i.kt)("inlineCode",{parentName:"p"},"n")," is given with ",(0,i.kt)("inlineCode",{parentName:"p"},"Some(n)"),"."),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=options_positive",group:"options_positive"},"let one_is_nat : nat option = is_nat (1)\n"))),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=options_positive",group:"options_positive"},"const one_is_nat : option<nat> = is_nat(1);\n"))),(0,i.kt)("h2",{id:"matching"},"Matching"),(0,i.kt)("p",null,"Variant types being, in essence, the disjunctive union of cases akin\nto types, values of such types need to be examined case by case: this\nis what ",(0,i.kt)("em",{parentName:"p"},"pattern matching")," does."),(0,i.kt)("p",null,"Here is a function that transforms a colour variant type to an integer."),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=variant_matching",group:"variant_matching"},"type colour =\n  | RGB of int * int * int\n  | Gray of int\n  | Default\n\nlet int_of_colour (c : colour) : int =\n  match c with\n  | RGB (r,g,b) -> 16 + b + g * 6 + r * 36\n  | Gray i -> 232 + i\n  | Default -> 0\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Note: This is the same construct as in OCaml."))),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=variant_matching",group:"variant_matching"},'type colour =\n| ["RGB", [int, int, int]]\n| ["Gray", int]\n| ["Default"];\n\nconst int_of_colour = (c : colour) : int =>\n  match(c) {\n    when(RGB([r,g,b])): 16 + b + g * 6 + r * 36;\n    when(Gray(i)): 232 + i;\n    when(Default): 0;\n  };\n')),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Note: The ",(0,i.kt)("inlineCode",{parentName:"p"},"when"),"-clauses must cover all the variants of the type\n",(0,i.kt)("inlineCode",{parentName:"p"},"colour"),". When the constructor has no argument, which is equivalent\nto having a ",(0,i.kt)("inlineCode",{parentName:"p"},"[]")," (unit) argument, it can be omitted, hence\n",(0,i.kt)("inlineCode",{parentName:"p"},"when(Default)")," instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"when(Default())"),".")),(0,i.kt)("p",null,"The right-hand sides of each ",(0,i.kt)("inlineCode",{parentName:"p"},"when"),"-clause is an expression. Sometimes\nwe might need statements to be processed before a value is given to\nthe clause. In that case, the ",(0,i.kt)("inlineCode",{parentName:"p"},"do")," expression comes handy. It enables\nthe opening of a block of statements like a function body, that is, a\nblock ended with a ",(0,i.kt)("inlineCode",{parentName:"p"},"return")," statement whose argument has the value of\nthe block, like so:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=match_with_block",group:"match_with_block"},"function match_with_block (x : option<int>) : int {\n  return\n    match(x) {\n      when(None): 0;\n      when(Some(n)): do {\n        let y = n + 1;\n        return y\n      }\n    };\n};\n"))),(0,i.kt)("p",null,"Another example is matching on whether an integer is a natural number\nor not:"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=nat_matching",group:"nat_matching"},"let is_it_a_nat (i : int) =\n  match is_nat i with\n    None   -> false\n  | Some _ -> true\n"))),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=nat_matching",group:"nat_matching"},"const is_it_a_nat = (i : int) =>\n  match (is_nat(i)) {\n    when(None): false;\n    when(Some(n)): do {ignore(n); return true; }\n  }\n"))))}m.isMDXComponent=!0}}]);