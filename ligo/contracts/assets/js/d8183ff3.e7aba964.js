"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[58262],{48720:(e,t,n)=>{n.d(t,{D:()=>i.Z,Z:()=>l});var a=n(67294),i=n(75402);const l=function(e){return a.createElement(i.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},99191:(e,t,n)=>{n.d(t,{Z:()=>m});var a=n(43164),i=n(67294),l=n(52263),p=n(48720),o=n(11506);function r(){return r=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},r.apply(this,arguments)}const{Prism:k}=n(43164);k.languages={...k.languages,cameligo:{...k.languages.ocaml,comment:[/(^|[^\\])\/\*[\s\S]*?\*\//,/\(\*[\s\S]*?\*\)/,/\/\/.*/]},jsligo:k.languages.typescript};const m=function(e){const{siteConfig:{themeConfig:{prism:t={}}}}=(0,l.Z)(),n=t.singleTheme||o.Z,[k,m]=(0,i.useState)(!1);return(0,i.useEffect)((()=>{m(!0)}),[]),i.createElement(p.D.Consumer,null,(t=>{let{syntax:l}=t;return l===e.syntax?i.createElement(a.default,r({},a.defaultProps,{key:k,language:e.syntax,code:e.children,theme:n}),(e=>{let{className:t,tokens:n,getLineProps:a,getTokenProps:l}=e;return i.createElement("h4",{className:t,style:{backgroundColor:"var(--ifm-background-color)",fontFamily:"var(--ifm-font-family-monospace)",lineHeight:"var(--ifm-pre-line-height)",fontSize:"1.1rem",fontWeight:"bold",padding:0,whiteSpace:"break-spaces",marginTop:"3rem"}},n.map(((e,t)=>i.createElement("div",a({line:e,key:t}),e.map(((e,t)=>i.createElement("span",l({token:e,key:t}))))))))})):i.createElement("div",null)}))}},53184:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>m,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>k,toc:()=>y});var a=n(87462),i=(n(67294),n(3905)),l=n(48720),p=n(99191);const o={id:"big-map-reference",title:"big_map",hide_table_of_contents:!0},r=void 0,k={unversionedId:"reference/big-map-reference",id:"version-1.5.0/reference/big-map-reference",title:"big_map",description:"Maps from keys to values, lazily accessed and where the bindings",source:"@site/versioned_docs/version-1.5.0/reference/big_map.md",sourceDirName:"reference",slug:"/reference/big-map-reference",permalink:"/docs/1.5.0/reference/big-map-reference",draft:!1,tags:[],version:"1.5.0",frontMatter:{id:"big-map-reference",title:"big_map",hide_table_of_contents:!0},sidebar:"API",previous:{title:"string",permalink:"/docs/1.5.0/reference/string-reference"},next:{title:"bitwise",permalink:"/docs/1.5.0/reference/bitwise-reference"}},m={},y=[],s={toc:y};function d(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Maps from keys to values, lazily accessed and where the bindings\nkey/value are ordered by increasing keys."),(0,i.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type ('key, 'value) t = ('key, 'value) big_map"),(0,i.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type t<key, value> = big_map<key, value>"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The type ",(0,i.kt)("inlineCode",{parentName:"p"},"('key,'value) t")," is an alias for\n",(0,i.kt)("inlineCode",{parentName:"p"},"('key,'value) big_map"),".")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The type ",(0,i.kt)("inlineCode",{parentName:"p"},"t<key, value>")," is an alias for ",(0,i.kt)("inlineCode",{parentName:"p"},"big_map<key, value>"),".")),(0,i.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val empty : 'key 'value.('key, 'value) t"),(0,i.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let empty: <key, value>t<key, value>"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The value ",(0,i.kt)("inlineCode",{parentName:"p"},"empty")," is the empty big map. In some contexts, it is\nuseful to annotate it with its type, for example:\n",(0,i.kt)("inlineCode",{parentName:"p"},"(empty : (int, string) big_map)"),".")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The value ",(0,i.kt)("inlineCode",{parentName:"p"},"empty")," is the empty big map. In some contexts, it is\nuseful to annotate it with its type, for example:\n",(0,i.kt)("inlineCode",{parentName:"p"},"(empty as big_map<int, string>"),".")),(0,i.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_and_update : 'key 'value.'key -> 'value option -> ('key, 'value) t -> ('value option * ('key, 'value) t)"),(0,i.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let get_and_update: <key, value>(_: key) => (_: option<value>) => (_: t<key, value>) => [option<value>, t<key, value>]"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"get_and_update key None map")," returns a copy of the map\n",(0,i.kt)("inlineCode",{parentName:"p"},"map")," without the entry for the key ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," (no change if\nthe key is absent). The call ",(0,i.kt)("inlineCode",{parentName:"p"},"get_and_update key (Some value) map"),"\nreturns a copy of the map ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," where there is an entry for the\nkey ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," associated with the value ",(0,i.kt)("inlineCode",{parentName:"p"},"value"),". In both cases, if\nthere was already a value ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," bound to ",(0,i.kt)("inlineCode",{parentName:"p"},"key"),", it is returned as\n",(0,i.kt)("inlineCode",{parentName:"p"},"Some v"),", otherwise ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),".")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"get_and_update(key, None(), map)")," returns a copy of the map\n",(0,i.kt)("inlineCode",{parentName:"p"},"map")," without the entry for the key ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," (no change if\nthe key is absent). The call ",(0,i.kt)("inlineCode",{parentName:"p"},"get_and_update(key, Some(value), map)"),"\nreturns a copy of the map ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," where there is an entry for the\nkey ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," associated with the value ",(0,i.kt)("inlineCode",{parentName:"p"},"value"),". In both cases, if\nthere was already a value ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," bound to ",(0,i.kt)("inlineCode",{parentName:"p"},"key"),", it is returned as\n",(0,i.kt)("inlineCode",{parentName:"p"},"Some(v)"),", otherwise ",(0,i.kt)("inlineCode",{parentName:"p"},"None()"),".")),(0,i.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val update : 'key 'value.'key -> 'value option -> ('key, 'value) t -> ('key, 'value) t"),(0,i.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let update: <key, value>(_: key) => (_: option<value>) => (_: t<key, value>) => t<key, value>"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"update key None map")," returns a copy of the map ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),"\nwithout the entry for the key ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," (no change if the key\nis absent). The call ",(0,i.kt)("inlineCode",{parentName:"p"},"update key (Some value) map")," returns the map\n",(0,i.kt)("inlineCode",{parentName:"p"},"map")," where there is an entry for the key ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," associated with\nthe value ",(0,i.kt)("inlineCode",{parentName:"p"},"value"),". In both cases, the value originally bound to\n",(0,i.kt)("inlineCode",{parentName:"p"},"key")," is lost. See ",(0,i.kt)("inlineCode",{parentName:"p"},"get_and_update"),".")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"update(key, None(), map)")," returns a copy of the map ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),"\nwithout the entry for the key ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," (no change if the key\nis absent). The call ",(0,i.kt)("inlineCode",{parentName:"p"},"update(key, Some(value), map)")," returns the map\n",(0,i.kt)("inlineCode",{parentName:"p"},"map")," where there is an entry for the key ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," associated with\nthe value ",(0,i.kt)("inlineCode",{parentName:"p"},"value"),". In both cases, the value originally bound to\n",(0,i.kt)("inlineCode",{parentName:"p"},"key")," is lost. See ",(0,i.kt)("inlineCode",{parentName:"p"},"get_and_update"),".")),(0,i.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val add : 'key 'value.'key -> 'value -> ('key, 'value) t -> ('key, 'value) t"),(0,i.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let add: <key, value>(_: key) => (_: value) => (_: t<key, value>) => t<key, value>"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"add key value map")," returns a copy of the ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," where\nthere is a binding of key ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," to value ",(0,i.kt)("inlineCode",{parentName:"p"},"value"),". If there is a\nbinding for ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),", then it is lost.")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"add(key, value, map)")," returns a copy of the ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," where\nthere is a binding of key ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," to value ",(0,i.kt)("inlineCode",{parentName:"p"},"value"),". If there is a\nbinding for ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),", then it is lost.")),(0,i.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val remove : 'key 'value.'key -> ('key, 'value) t -> ('key, 'value) t"),(0,i.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let remove: <key, value>(_: key) => (_: t<key, value>) => t<key, value>"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"remove key map")," returns a copy of the map ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," where\nthe binding for key ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," is absent.")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"remove(key, map)")," returns a copy of the map ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," where\nthe binding for key ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," is absent.")),(0,i.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val literal : 'key 'value.('key * 'value) list -> ('key, 'value) t"),(0,i.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let literal: <key, value>(_: list<[key, value]>) => t<key, value>"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"literal [(k1,v1); ...; (kn,vn)]")," returns a big map from\nthe pairs of key/value in the list. Note: The list must be a\nliteral, not an expression (compile-time list of values).")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"literal(list[[k1,v1], ..., [kn,vn]])")," returns a big map\nfrom the pairs of key/value in the list. Note: The list must be a\nliteral, not an expression (compile-time list of values).")),(0,i.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val of_list : 'key 'value.('key * 'value) list -> ('key, 'value) t"),(0,i.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let of_list: <key, value>(_: list<[key, value]>) => t<key, value>"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"of_list bindings")," returns a big map from the pairs of\nkey/value in the list ",(0,i.kt)("inlineCode",{parentName:"p"},"bindings"),". Note: Use ",(0,i.kt)("inlineCode",{parentName:"p"},"literal")," instead if\nusing a literal list.")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"of_list(bindings)")," returns a big map from the pairs of\nkey/value in the list ",(0,i.kt)("inlineCode",{parentName:"p"},"bindings"),". Note: Use ",(0,i.kt)("inlineCode",{parentName:"p"},"literal")," instead if\nusing a literal list.")),(0,i.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val mem : 'key 'value.'key -> ('key, 'value) t -> bool"),(0,i.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let mem: <key, value>(_: key) => (_: t<key, value>) => bool"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"mem key map")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," if, and only if, the key ",(0,i.kt)("inlineCode",{parentName:"p"},"key"),"\nis in the big map ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),".")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"mem(key, map)")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," if, and only if, the key ",(0,i.kt)("inlineCode",{parentName:"p"},"key"),"\nis in the big map ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),".")),(0,i.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val find_opt : 'key 'value.'key -> ('key, 'value) t -> 'value option"),(0,i.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let find_opt: <key, value>(_: key) => (_: t<key, value>) => option<value>"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"find_opt key map")," returns ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," if the key ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," is\npresent in the big map ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),"; otherwise, it is ",(0,i.kt)("inlineCode",{parentName:"p"},"Some v"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"v"),"\nis the value associated to ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),".")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"find_opt(key, map)")," returns ",(0,i.kt)("inlineCode",{parentName:"p"},"None()")," if the key ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," is\npresent in the big map ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),"; otherwise, it is ",(0,i.kt)("inlineCode",{parentName:"p"},"Some(v)"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"v"),"\nis the value associated to ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),".")),(0,i.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val find : 'key 'value.'key -> ('key, 'value) t -> 'value"),(0,i.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let find: <key, value>(_: key) => (_: t<key, value>) => value"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"find key map")," returns the value associated to ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," in\n",(0,i.kt)("inlineCode",{parentName:"p"},"map"),". If the key is absent, the execution fails with the string\n",(0,i.kt)("inlineCode",{parentName:"p"},'"MAP FIND"'),".")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"find(key, map)")," returns the value associated to ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," in\n",(0,i.kt)("inlineCode",{parentName:"p"},"map"),". If the key is absent, the execution fails with the string\n",(0,i.kt)("inlineCode",{parentName:"p"},'"MAP FIND"'),".")))}d.isMDXComponent=!0}}]);