"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[65895],{48720:(e,t,n)=>{n.d(t,{D:()=>i.Z,Z:()=>o});var a=n(67294),i=n(75402);const o=function(e){return a.createElement(i.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},99191:(e,t,n)=>{n.d(t,{Z:()=>c});var a=n(43164),i=n(67294),o=n(52263),r=n(48720),s=n(11506);function l(){return l=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},l.apply(this,arguments)}const{Prism:p}=n(43164);p.languages={...p.languages,cameligo:{...p.languages.ocaml,comment:[/(^|[^\\])\/\*[\s\S]*?\*\//,/\(\*[\s\S]*?\*\)/,/\/\/.*/]},jsligo:p.languages.typescript};const c=function(e){const{siteConfig:{themeConfig:{prism:t={}}}}=(0,o.Z)(),n=t.singleTheme||s.Z,[p,c]=(0,i.useState)(!1);return(0,i.useEffect)((()=>{c(!0)}),[]),i.createElement(r.D.Consumer,null,(t=>{let{syntax:o}=t;return o===e.syntax?i.createElement(a.default,l({},a.defaultProps,{key:p,language:e.syntax,code:e.children,theme:n}),(e=>{let{className:t,tokens:n,getLineProps:a,getTokenProps:o}=e;return i.createElement("h4",{className:t,style:{backgroundColor:"var(--ifm-background-color)",fontFamily:"var(--ifm-font-family-monospace)",lineHeight:"var(--ifm-pre-line-height)",fontSize:"1.1rem",fontWeight:"bold",padding:0,whiteSpace:"break-spaces",marginTop:"3rem"}},n.map(((e,t)=>i.createElement("div",a({line:e,key:t}),e.map(((e,t)=>i.createElement("span",o({token:e,key:t}))))))))})):i.createElement("div",null)}))}},36013:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>p,toc:()=>d});var a=n(87462),i=(n(67294),n(3905)),o=n(48720),r=n(99191);const s={id:"tezos-reference",title:"tezos",hide_table_of_contents:!0},l=void 0,p={unversionedId:"reference/tezos-reference",id:"version-1.7.0/reference/tezos-reference",title:"tezos",description:"Tezos-specific functions",source:"@site/versioned_docs/version-1.7.0/reference/tezos.md",sourceDirName:"reference",slug:"/reference/tezos-reference",permalink:"/previews/ligo/modules/docs/reference/tezos-reference",draft:!1,tags:[],version:"1.7.0",frontMatter:{id:"tezos-reference",title:"tezos",hide_table_of_contents:!0},sidebar:"API",previous:{title:"tuple2",permalink:"/previews/ligo/modules/docs/reference/tuple2-reference"},next:{title:"sapling",permalink:"/previews/ligo/modules/docs/reference/tezos.next.sapling-reference"}},c={},d=[],m={toc:d};function h(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Tezos-specific functions"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/previews/ligo/modules/docs/reference/tezos.next-reference"},"module next")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_sender : unit -> address"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let get_sender: (_: unit) => address"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_sender ()")," is the address of the contract (that\nis, a smart contract or an implicit account) that initiated the\ncurrent internal transaction. Note that, if transactions have been\nchained, that address could be different from ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_source ()"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_sender()")," is the address of the contract (that\nis, a smart contract or an implicit account) that initiated the\ncurrent internal transaction. Note that, if transactions have been\nchained, that address could be different from ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_source()"),".")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_source : unit -> address"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let get_source: (_: unit) => address"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_source ()")," is the address of the implicit account\nthat initiated the current transaction. If transactions have been\nchained, that address is different from ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_sender ()"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_source()")," is the address of the implicit account\nthat initiated the current transaction. If transactions have been\nchained, that address is different from ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_sender()"),".")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val self : 'a.string -> 'a contract"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let self: <a>(_: string) => contract<a>"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.self entrypoint")," is the address of the current smart\ncontract, that is, the smart contract containing the call. For the\naddress of the smart contract actually ",(0,i.kt)("em",{parentName:"p"},"executing")," the call,\nbecause it is embedded in a lambda sent to another smart contract,\nuse ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_self_address")," instead. The string ",(0,i.kt)("inlineCode",{parentName:"p"},"entrypoint")," is the\nname of a valid entrypoint such that ",(0,i.kt)("inlineCode",{parentName:"p"},"entrypoint")," is not\n",(0,i.kt)("inlineCode",{parentName:"p"},'"%default"'),", or the empty string denoting the ",(0,i.kt)("inlineCode",{parentName:"p"},'"%default"'),"\nentrypoint (which is the root of the smart contract parameter if\nno ",(0,i.kt)("inlineCode",{parentName:"p"},'"%default"')," entrypoint is explicitly defined). If the contract\ndoes not have the specified entrypoint, the call results in an\ntype checking error.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.self(entrypoint)")," is the address of the current smart\ncontract, that is, the smart contract containing the call. For the\naddress of the smart contract actually ",(0,i.kt)("em",{parentName:"p"},"executing")," the call,\nbecause it is embedded in a lambda sent to another smart contract,\nuse ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_self_address")," instead. The string ",(0,i.kt)("inlineCode",{parentName:"p"},"entrypoint")," is the\nname of a valid entrypoint such that ",(0,i.kt)("inlineCode",{parentName:"p"},"entrypoint")," is not\n",(0,i.kt)("inlineCode",{parentName:"p"},'"%default"'),", or the empty string denoting the ",(0,i.kt)("inlineCode",{parentName:"p"},'"%default"'),"\nentrypoint (which is the root of the smart contract parameter if\nno ",(0,i.kt)("inlineCode",{parentName:"p"},'"%default"')," entrypoint is explicitly defined). If the contract\ndoes not have the specified entrypoint, the call results in an\ntype checking error.")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_self_address : unit -> address"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let get_self_address: (_: unit) => address"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_self_address ()")," is the address of the smart\ncontract actually executing the call, as a value of type\n",(0,i.kt)("inlineCode",{parentName:"p"},"address"),". That contract can be different from the one containing\nthe call if the call is in a lambda transmitted to another smart\ncontract. Therefore, it is assumed that, in general, the type of\nthe executing contract is statically unknown, so the return type\nof ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_self_address")," is not ",(0,i.kt)("inlineCode",{parentName:"p"},"'a contract"),", but ",(0,i.kt)("inlineCode",{parentName:"p"},"address"),". (See\n",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.self"),".)")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_self_address()")," is the address of the smart\ncontract actually executing the call, as a value of type\n",(0,i.kt)("inlineCode",{parentName:"p"},"address"),". That contract can be different from the one containing\nthe call if the call is in a lambda transmitted to another smart\ncontract. Therefore, it is assumed that, in general, the type of\nthe executing contract is statically unknown, so the return type\nof ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_self_address")," is not ",(0,i.kt)("inlineCode",{parentName:"p"},"'a contract"),", but ",(0,i.kt)("inlineCode",{parentName:"p"},"address"),". (See\n",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.self"),".)")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val address : 'a.'a contract -> address"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let address: <a>(_: contract<a>) => address"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.address contract")," casts the address of the smart\ncontract ",(0,i.kt)("inlineCode",{parentName:"p"},"contract")," into the more general value of type\n",(0,i.kt)("inlineCode",{parentName:"p"},"address"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.address(contract)")," casts the address of the smart\ncontract ",(0,i.kt)("inlineCode",{parentName:"p"},"contract")," into the more general value of type\n",(0,i.kt)("inlineCode",{parentName:"p"},"address"),".")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val implicit_account : key_hash -> unit contract"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let implicit_account: (_: key_hash) => contract<unit>"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.implicit_account kh")," casts the public key hash ",(0,i.kt)("inlineCode",{parentName:"p"},"kh"),"\ninto the address of its implicit account. Note that addresses of\nimplicit accounts always have the type ",(0,i.kt)("inlineCode",{parentName:"p"},"unit contract"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.implicit_account(kh)")," casts the public key hash ",(0,i.kt)("inlineCode",{parentName:"p"},"kh"),"\ninto the address of its implicit account. Note that addresses of\nimplicit accounts always have the type ",(0,i.kt)("inlineCode",{parentName:"p"},"contract<unit>"),".")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_contract_opt : 'param.address -> 'param contract option"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let get_contract_opt: <param>(_: address) => option<contract<param>>"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_contract_opt addr")," casts the address ",(0,i.kt)("inlineCode",{parentName:"p"},"addr")," into\nthat of a contract address, if such contract exists. The value of\nthe call is ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," if no such contract exists, otherwise ",(0,i.kt)("inlineCode",{parentName:"p"},"Some\n    contract"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"contract")," is the contract's address. Note: The\naddress of an implicit account has type ",(0,i.kt)("inlineCode",{parentName:"p"},"unit contract"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_contract_opt(addr)")," casts the address ",(0,i.kt)("inlineCode",{parentName:"p"},"addr")," into\nthat of a contract address, if such contract exists. The value of\nthe call is ",(0,i.kt)("inlineCode",{parentName:"p"},"None()")," if no such contract exists, otherwise ",(0,i.kt)("inlineCode",{parentName:"p"},"Some\n    contract"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"contract")," is the contract's address. Note: The\naddress of an implicit account has type ",(0,i.kt)("inlineCode",{parentName:"p"},"unit contract"),".")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_contract_with_error : 'param.address -> string -> 'param contract"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let get_contract_with_error: <param>(_: address) => (_: string) => contract<param>"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_contract_with_error addr error")," casts the address\n",(0,i.kt)("inlineCode",{parentName:"p"},"addr")," into that of a contract address, if such contract\nexists. If not, the execution fails with the error message\n",(0,i.kt)("inlineCode",{parentName:"p"},"error"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_contract_with_error(addr, error)")," casts the address\n",(0,i.kt)("inlineCode",{parentName:"p"},"addr")," into that of a contract address, if such contract\nexists. If not, the execution fails with the error message\n",(0,i.kt)("inlineCode",{parentName:"p"},"error"),".")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_contract : 'param.address -> 'param contract"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let get_contract: <param>(_: address) => contract<param>"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_contract addr")," casts the address ",(0,i.kt)("inlineCode",{parentName:"p"},"addr")," into that\nof a smart contract address, if such contract exists. The call\nfails with the message ",(0,i.kt)("inlineCode",{parentName:"p"},'"bad address for get_contract"')," if no\nsuch smart contract exists. Note: The address of an implicit\naccount has type ",(0,i.kt)("inlineCode",{parentName:"p"},"unit contract"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_contract(addr)")," casts the address ",(0,i.kt)("inlineCode",{parentName:"p"},"addr")," into that\nof a smart contract address, if such contract exists. The call\nfails with the message ",(0,i.kt)("inlineCode",{parentName:"p"},'"bad address for get_contract"')," if no\nsuch smart contract exists. Note: The address of an implicit\naccount has type ",(0,i.kt)("inlineCode",{parentName:"p"},"contract<unit>"),".")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_entrypoint_opt : 'param.string -> address -> 'param contract option"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let get_entrypoint_opt: <param>(_: string) => (_: address) => option<contract<param>>"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_entrypoint_opt entrypoint addr")," has the same\nbehaviour as ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_contract_opt addr"),", with the additional\nconstraint that the contract must have an entrypoint named\n",(0,i.kt)("inlineCode",{parentName:"p"},"entrypoint"),". In other words, ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_entrypoint_opt entrypoint addr"),"\ncasts the address ",(0,i.kt)("inlineCode",{parentName:"p"},"addr")," into that of a smart contract\naddress, if such contract exists and has an entrypoint named\n",(0,i.kt)("inlineCode",{parentName:"p"},"entrypoint"),". The value of the call is ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," if no such smart\ncontract exists, otherwise ",(0,i.kt)("inlineCode",{parentName:"p"},"Some contract"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"contract")," is\nthe smart contract's address. Note: The address of an implicit\naccount has type ",(0,i.kt)("inlineCode",{parentName:"p"},"unit contract"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_entrypoint_opt(entrypoint, addr)")," has the same\nbehaviour as ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_contract_opt(addr)"),", with the additional\nconstraint that the contract must have an entrypoint named\n",(0,i.kt)("inlineCode",{parentName:"p"},"entrypoint"),". In other words, ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_entrypoint_opt(entrypoint, addr)"),"\ncasts the address ",(0,i.kt)("inlineCode",{parentName:"p"},"addr")," into that of a smart contract\naddress, if such contract exists and has an entrypoint named\n",(0,i.kt)("inlineCode",{parentName:"p"},"entrypoint"),". The value of the call is ",(0,i.kt)("inlineCode",{parentName:"p"},"None()")," if no such smart\ncontract exists, otherwise ",(0,i.kt)("inlineCode",{parentName:"p"},"Some(contract)"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"contract")," is\nthe smart contract's address. Note: The address of an implicit\naccount has type ",(0,i.kt)("inlineCode",{parentName:"p"},"contract<unit>"),".")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_entrypoint : 'param.string -> address -> 'param contract"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let get_entrypoint: <param>(_: string) => (_: address) => contract<param>"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_entrypoint entrypoint addr")," casts the address\n",(0,i.kt)("inlineCode",{parentName:"p"},"addr")," into that of a smart contract address, if such contract\nexists and has an entrypoint named ",(0,i.kt)("inlineCode",{parentName:"p"},"entrypoint"),". If no such smart\ncontract exists, the execution fails with the error message\n",(0,i.kt)("inlineCode",{parentName:"p"},'"bad address for get_entrypoint"'),". Note: The address of an implicit\naccount has type ",(0,i.kt)("inlineCode",{parentName:"p"},"unit contract"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_entrypoint(entrypoint, addr)")," casts the address\n",(0,i.kt)("inlineCode",{parentName:"p"},"addr")," into that of a smart contract address, if such contract\nexists and has an entrypoint named ",(0,i.kt)("inlineCode",{parentName:"p"},"entrypoint"),". If no such smart\ncontract exists, the execution fails with the error message\n",(0,i.kt)("inlineCode",{parentName:"p"},'"bad address for get_entrypoint"'),". Note: The address of an implicit\naccount has type ",(0,i.kt)("inlineCode",{parentName:"p"},"contract<unit>"),".")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val create_contract : 'param 'storage.('param, 'storage) entrypoint -> key_hash option -> tez -> 'storage -> (operation * address)"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let create_contract: <param, storage>(_: entrypoint<param, storage>) => (_: option<key_hash>) => (_: tez) => (_: storage) => [ operation, address ]"),"**Deprecated:** In a future version, `Tezos` will be replaced by `Tezos.Next`, and using `Operation.create_contract` from `Tezos.Next` is encouraged for a smoother migration.",(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.create_contract e d a s")," returns a contract creation\noperation (origination) for the entrypoint ",(0,i.kt)("inlineCode",{parentName:"p"},"e")," (as a function)\nwith optional delegate ",(0,i.kt)("inlineCode",{parentName:"p"},"d"),", initial amount ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," and initial\nstorage ",(0,i.kt)("inlineCode",{parentName:"p"},"s"),", together with the address of the created\ncontract. Note that the created contract cannot be called\nimmediately afterwards (that is, ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_contract_opt")," on that\naddress would return ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),"), as the origination must be\nperformed successfully first, for example by calling a proxy\ncontract or itself.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.create_contract(e,d,a,s)")," returns a contract creation\noperation (origination) for the entrypoint ",(0,i.kt)("inlineCode",{parentName:"p"},"e")," (as a function)\nwith optional delegate ",(0,i.kt)("inlineCode",{parentName:"p"},"d"),", initial amount ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," and initial\nstorage ",(0,i.kt)("inlineCode",{parentName:"p"},"s"),", together with the address of the created\ncontract. Note that the created contract cannot be called\nimmediately afterwards (that is, ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_contract_opt")," on that\naddress would return ",(0,i.kt)("inlineCode",{parentName:"p"},"None()"),"), as the origination must be\nperformed successfully first, for example by calling a proxy\ncontract or itself.")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val set_delegate : key_hash option -> operation"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let set_delegate: (_: option<key_hash>) => operation"),"**Deprecated:** In a future version, `Tezos` will be replaced by `Tezos.Next`, and using `Operation.set_delegate` from `Tezos.Next` is encouraged for a smoother migration.",(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.set_delegate d")," evaluates in an operation that sets\nthe delegate of the current smart contract to be ",(0,i.kt)("inlineCode",{parentName:"p"},"d"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"d")," is\nan optional key hash. If ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),", the delegation is withdrawn. If\nthe contract has no delegation, then no change occurs. If ",(0,i.kt)("inlineCode",{parentName:"p"},"d")," is\n",(0,i.kt)("inlineCode",{parentName:"p"},"Some kh"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"kh")," is the key hash of a registered delegate\nthat is not the current delegate of the contract, then this\noperation sets the delegate of the contract to this registered\ndelegate. A failure occurs if ",(0,i.kt)("inlineCode",{parentName:"p"},"kh")," is the current delegate of the\ncontract or if ",(0,i.kt)("inlineCode",{parentName:"p"},"kh")," is not a registered delegate. However, the\ninstruction in itself does not fail; it produces an operation that\nwill fail when applied.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.set_delegate(d)")," evaluates in an operation that sets\nthe delegate of the current smart contract to be ",(0,i.kt)("inlineCode",{parentName:"p"},"d"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"d")," is\nan optional key hash. If ",(0,i.kt)("inlineCode",{parentName:"p"},"None()"),", the delegation is withdrawn. If\nthe contract has no delegation, then no change occurs. If ",(0,i.kt)("inlineCode",{parentName:"p"},"d")," is\n",(0,i.kt)("inlineCode",{parentName:"p"},"Some(kh)"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"kh")," is the key hash of a registered delegate\nthat is not the current delegate of the contract, then this\noperation sets the delegate of the contract to this registered\ndelegate. A failure occurs if ",(0,i.kt)("inlineCode",{parentName:"p"},"kh")," is the current delegate of the\ncontract or if ",(0,i.kt)("inlineCode",{parentName:"p"},"kh")," is not a registered delegate. However, the\ninstruction in itself does not fail; it produces an operation that\nwill fail when applied.")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val transaction : 'param.'param -> tez -> 'param contract -> operation"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let transaction: <param>(_: param) => (_: tez) => (_: contract<param>) => operation"),"**Deprecated:** In a future version, `Tezos` will be replaced by `Tezos.Next`, and using `Operation.transaction` from `Tezos.Next` is encouraged for a smoother migration.",(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.transaction param amount contract_addr")," evaluates in\nan operation that will send the amount ",(0,i.kt)("inlineCode",{parentName:"p"},"amount")," in mutez to the\ncontract at the valid address ",(0,i.kt)("inlineCode",{parentName:"p"},"contract_addr"),", with parameter\n",(0,i.kt)("inlineCode",{parentName:"p"},"param"),". If the contract is an implicit account, the parameter\nmust be ",(0,i.kt)("inlineCode",{parentName:"p"},"unit"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.transaction(param, amount, contract_addr)")," evaluates in\nan operation that will send the amount ",(0,i.kt)("inlineCode",{parentName:"p"},"amount")," in mutez to the\ncontract at the valid address ",(0,i.kt)("inlineCode",{parentName:"p"},"contract_addr"),", with parameter\n",(0,i.kt)("inlineCode",{parentName:"p"},"param"),". If the contract is an implicit account, the parameter\nmust be ",(0,i.kt)("inlineCode",{parentName:"p"},"unit"),".")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val call_view : 'param 'return.string -> 'param -> address -> 'return option"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let call_view: <param, return>(_: string) => (_: param) => (_: address) => option<return>"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.call_view v p a")," calls the view ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," with parameter\n",(0,i.kt)("inlineCode",{parentName:"p"},"param")," at the contract whose address is ",(0,i.kt)("inlineCode",{parentName:"p"},"a"),". The value returned\nis ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," if the view does not exist, or has a different type of\nparameter, or if the contract does not exist at that\naddress. Otherwise, it is ",(0,i.kt)("inlineCode",{parentName:"p"},"Some v"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," is the return value\nof the view. Note: the storage of the view is the same as when the\nexecution of the contract calling the view started.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.call_view(v, p, a)")," calls the view ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," with parameter\n",(0,i.kt)("inlineCode",{parentName:"p"},"param")," at the contract whose address is ",(0,i.kt)("inlineCode",{parentName:"p"},"a"),". The value returned\nis ",(0,i.kt)("inlineCode",{parentName:"p"},"None()")," if the view does not exist, or has a different type of\nparameter, or if the contract does not exist at that\naddress. Otherwise, it is ",(0,i.kt)("inlineCode",{parentName:"p"},"Some(v)"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," is the return value\nof the view. Note: the storage of the view is the same as when the\nexecution of the contract calling the view started.")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val create_ticket : 'a.'a -> nat -> 'a ticket option"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let create_ticket: <a>(_: a) => (_: nat) => option<ticket<a>>"),"**Deprecated:** In a future version, `Tezos` will be replaced by `Tezos.Next`, and using `Ticket.create` from `Tezos.Next` is encouraged for a smoother migration.",(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.create_ticket v a")," creates a ticket with value ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," and\namount ",(0,i.kt)("inlineCode",{parentName:"p"},"a"),". If the creation is a success, the value ",(0,i.kt)("inlineCode",{parentName:"p"},"Some t")," is\nreturned, where ",(0,i.kt)("inlineCode",{parentName:"p"},"t")," is the ticket; otherwise, ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," is the\nresult. Note: Tickets cannot be duplicated.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.create_ticket(v, a)")," creates a ticket with value ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," and\namount ",(0,i.kt)("inlineCode",{parentName:"p"},"a"),". If the creation is a success, the value ",(0,i.kt)("inlineCode",{parentName:"p"},"Some(t)")," is\nreturned, where ",(0,i.kt)("inlineCode",{parentName:"p"},"t")," is the ticket; otherwise, ",(0,i.kt)("inlineCode",{parentName:"p"},"None()")," is the\nresult. Note: Tickets cannot be duplicated.")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val split_ticket : 'a.'a ticket -> (nat * nat) -> ('a ticket * 'a ticket) option"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let split_ticket: <a>(_: ticket<a>) => (_: [nat, nat]) => option<[ticket<a>, ticket<a>]>"),"**Deprecated:** In a future version, `Tezos` will be replaced by `Tezos.Next`, and using `Ticket.split` from `Tezos.Next` is encouraged for a smoother migration.",(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.split_ticket t (a1, a2)")," results in a pair of tickets\n",(0,i.kt)("inlineCode",{parentName:"p"},"t1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"t2")," such that the former owns the amount ",(0,i.kt)("inlineCode",{parentName:"p"},"a1")," and the\nlater ",(0,i.kt)("inlineCode",{parentName:"p"},"a2"),". More precisely, the value of the call is\n",(0,i.kt)("inlineCode",{parentName:"p"},"Some (t1, t2)")," because signifying to the callee the failure of\nthe splitting is achieved by returning the value ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.split_ticket(t, [a1, a2])")," results in a pair of tickets\n",(0,i.kt)("inlineCode",{parentName:"p"},"t1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"t2")," such that the former owns the amount ",(0,i.kt)("inlineCode",{parentName:"p"},"a1")," and the\nlater ",(0,i.kt)("inlineCode",{parentName:"p"},"a2"),". More precisely, the value of the call is\n",(0,i.kt)("inlineCode",{parentName:"p"},"Some([t1, t2])")," because signifying to the callee the failure of\nthe splitting is achieved by returning the value ",(0,i.kt)("inlineCode",{parentName:"p"},"None()"),".")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val join_tickets : 'a.('a ticket * 'a ticket) -> 'a ticket option"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let join_tickets: <a>(_: [ticket<a>, ticket<a>]) => option<ticket<a>>"),"**Deprecated:** In a future version, `Tezos` will be replaced by `Tezos.Next`, and using `Ticket.join` from `Tezos.Next` is encouraged for a smoother migration.",(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.join_tickets (t1, t2)")," joins the tickets ",(0,i.kt)("inlineCode",{parentName:"p"},"t1")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"t2"),", which must have the same type of value.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.join_tickets(t1, t2)")," joins the tickets ",(0,i.kt)("inlineCode",{parentName:"p"},"t1")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"t2"),", which must have the same type of value.")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val read_ticket : 'a.'a ticket -> (address * 'a * nat * 'a ticket)"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let read_ticket: <a>(_: ticket<a>) => [[address, [a, nat]], ticket<a>]"),"**Deprecated:** In a future version, `Tezos` will be replaced by `Tezos.Next`, and using `Ticket.read` from `Tezos.Next` is encouraged for a smoother migration.",(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.read_ticket t")," returns ",(0,i.kt)("inlineCode",{parentName:"p"},"t")," itself and the contents of\n",(0,i.kt)("inlineCode",{parentName:"p"},"t")," which is a pair ",(0,i.kt)("inlineCode",{parentName:"p"},"(address, (value, amount))"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"address")," is\nthe address of the smart contract that created it.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.read_ticket(t)")," returns ",(0,i.kt)("inlineCode",{parentName:"p"},"t")," itself and the contents of\n",(0,i.kt)("inlineCode",{parentName:"p"},"t")," which is a pair ",(0,i.kt)("inlineCode",{parentName:"p"},"[address, [value, amount]]"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"address")," is\nthe address of the smart contract that created it.")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val sapling_empty_state : 'sap_t.'sap_t sapling_state"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let sapling_empty_state: <sap_t>sapling_state<sap_t>"),"**Deprecated:** In a future version, `Tezos` will be replaced by `Tezos.Next`, and using `Sapling.empty_state` from `Tezos.Next` is encouraged for a smoother migration.",(0,i.kt)("p",null,"The evaluation of the constant ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.sapling_empty_state")," is an empty\nsapling state, that is, no one can spend tokens from it."),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val sapling_verify_update : 'sap_a.'sap_a sapling_transaction -> 'sap_a sapling_state -> (bytes * int * 'sap_a sapling_state) option"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let sapling_verify_update: <sap_a>(_: sapling_transaction<sap_a>) => (_: sapling_state<sap_a>) => option<[bytes, [int, sapling_state<sap_a>]]>"),"**Deprecated:** In a future version, `Tezos` will be replaced by `Tezos.Next`, and using `Sapling.verify_update` from `Tezos.Next` is encouraged for a smoother migration.",(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.sapling_verify_update trans state"),", where the\ntransaction ",(0,i.kt)("inlineCode",{parentName:"p"},"trans")," can be applied to the state ",(0,i.kt)("inlineCode",{parentName:"p"},"state"),", returns\n",(0,i.kt)("inlineCode",{parentName:"p"},"Some (data, (delta, new_state))"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"data")," is the bound data\n(as bytes), ",(0,i.kt)("inlineCode",{parentName:"p"},"delta")," is the difference between the outputs and the\ninputs of the transaction, and ",(0,i.kt)("inlineCode",{parentName:"p"},"new_state")," is the updated\nstate.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.sapling_verify_update(trans, state)"),", where the\ntransaction ",(0,i.kt)("inlineCode",{parentName:"p"},"trans")," can be applied to the state ",(0,i.kt)("inlineCode",{parentName:"p"},"state"),", returns\n",(0,i.kt)("inlineCode",{parentName:"p"},"Some ([data, [delta, new_state]])"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"data")," is the bound data\n(as bytes), ",(0,i.kt)("inlineCode",{parentName:"p"},"delta")," is the difference between the outputs and the\ninputs of the transaction, and ",(0,i.kt)("inlineCode",{parentName:"p"},"new_state")," is the updated\nstate.")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val emit : 'event_type.string -> 'event_type -> operation"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let emit: <event_type>(_: string) => (_: event_type) => operation"),"**Deprecated:** In a future version, `Tezos` will be replaced by `Tezos.Next`, and using `Operation.emit` from `Tezos.Next` is encouraged for a smoother migration.",(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.emit event_tag event_type")," evaluates in an operation\nthat will write an event into the transaction receipt after the\nsuccessful execution of this contract. The event is annotated by\nthe string ",(0,i.kt)("inlineCode",{parentName:"p"},"event_tag")," if it is not empty. The argument\n",(0,i.kt)("inlineCode",{parentName:"p"},"event_type")," is used only to specify the type of data attachment.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.emit(event_tag, event_type)")," evaluates in an operation\nthat will write an event into the transaction receipt after the\nsuccessful execution of this contract. The event is annotated by\nthe string ",(0,i.kt)("inlineCode",{parentName:"p"},"event_tag")," if it is not empty. The argument\n",(0,i.kt)("inlineCode",{parentName:"p"},"event_type")," is used only to specify the type of data attachment.")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val open_chest : chest_key -> chest -> nat -> bytes option"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let open_chest: (_: chest_key) => (_: chest) => (_: nat) => option<bytes>"),"The function [open_chest] opens a timelocked chest given its key and the time. The result is a byte option depending if the opening is correct or not.",(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_balance : unit -> tez"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let get_balance: (_: unit) => tez"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_balance ()")," returns the balance in mutez of the\naccount associated to the currently executed smart contract,\nincluding any mutez added by the calling transaction.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_balance()")," returns the balance in mutez of the\naccount associated to the currently executed smart contract,\nincluding any mutez added by the calling transaction.")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_amount : unit -> tez"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let get_amount: (_: unit) => tez"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_amount ()")," returns the amount in mutez of the\ncurrent transaction.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_amount()")," returns the amount in mutez of the\ncurrent transaction.")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_now : unit -> timestamp"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let get_now: (_: unit) => timestamp"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_now ()"),' returns the minimal injection time for the\ncurrent block, namely the block whose application triggered this\nexecution. The minimal injection time constitutes an estimate of\nthe moment when the current block is injected, hence the name\n"now".')),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_now()"),' returns the minimal injection time for the\ncurrent block, namely the block whose application triggered this\nexecution. The minimal injection time constitutes an estimate of\nthe moment when the current block is injected, hence the name\n"now".')),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_min_block_time : unit -> nat"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let get_min_block_time: (_: unit) => nat"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_min_block_time ()")," returns the minimal delay\nbetween two consecutive blocks in the chain.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_min_block_time()")," returns the minimal delay\nbetween two consecutive blocks in the chain.")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_level : unit -> nat"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let get_level: (_: unit) => nat"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_level ()")," returns the current block level.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_level()")," returns the current block level.")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_chain_id : unit -> chain_id"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let get_chain_id: (_: unit) => chain_id"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_chain_id ()")," returns the identifier of the chain\non which the smart contract is executed.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_chain_id ()")," returns the identifier of the chain\non which the smart contract is executed.")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_total_voting_power : unit -> nat"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let get_total_voting_power: (_: unit) => nat"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_total_voting_power ()")," returns the total voting\npower of all contracts. The total voting power coincides with the\nsum of the stake of every contract in the voting listings. The\nvoting listings is calculated at the beginning of every voting\nperiod.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_total_voting_power()")," returns the total voting\npower of all contracts. The total voting power coincides with the\nsum of the stake of every contract in the voting listings. The\nvoting listings is calculated at the beginning of every voting\nperiod.")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val voting_power : key_hash -> nat"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let voting_power: (_: key_hash) => nat"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.voting_power contract_kh")," returns the voting power of\na given contract specified by the key hash ",(0,i.kt)("inlineCode",{parentName:"p"},"contract_kh"),". This\nvoting power coincides with the weight of the contract in the\nvoting listings (that is, the stake) which is calculated at the\nbeginning of every voting period.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.voting_power(contract_kh)")," returns the voting power of\na given contract specified by the key hash ",(0,i.kt)("inlineCode",{parentName:"p"},"contract_kh"),". This\nvoting power coincides with the weight of the contract in the\nvoting listings (that is, the stake) which is calculated at the\nbeginning of every voting period.")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val never : 'a.never -> 'a"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let never: <a>(_: never) => a"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.never n")," is never meant to be executed, as the type\n",(0,i.kt)("inlineCode",{parentName:"p"},"never")," is inhabited, but to instruct the typechecker that a\nbranch in the control flow, for example, in a pattern matching, is\ndead.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.never(n)")," is never meant to be executed, as the type\n",(0,i.kt)("inlineCode",{parentName:"p"},"never")," is inhabited, but to instruct the typechecker that a\nbranch in the control flow, for example, in a pattern matching, is\ndead.")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val pairing_check : (bls12_381_g1 * bls12_381_g2) list -> bool"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let pairing_check: (_: list<[bls12_381_g1, bls12_381_g2]>) => bool"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.pairing_check pairings")," verifies that the product of\npairings of the given list of points ",(0,i.kt)("inlineCode",{parentName:"p"},"pairings")," is equal to 1 in\nthe field Fq12. It evaluates in ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," if the list is empty. This\nfunction can be used to verify if two pairings P1 and P2 are equal\nby verifying P1 * P2^(-1) = 1.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.pairing_check(pairings)")," verifies that the product of\npairings of the given list of points ",(0,i.kt)("inlineCode",{parentName:"p"},"pairings")," is equal to 1 in\nthe field Fq12. It evaluates in ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," if the list is empty. This\nfunction can be used to verify if two pairings P1 and P2 are equal\nby verifying P1 * P2^(-1) = 1.")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val constant : 'a.string -> 'a"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let constant: <a>(_: string) => a"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call to ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.constant hash")," returns the value stored on-chain\nwhose hash value is ",(0,i.kt)("inlineCode",{parentName:"p"},"hash")," (global constants). This call can fail\nwhen the contract is originated if the hash is invalid or the\nexpansion of the global constant is ill-typed, or too large (gas\nconsumption).")),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call to ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.constant(hash)")," returns the value stored on-chain\nwhose hash value is ",(0,i.kt)("inlineCode",{parentName:"p"},"hash")," (global constants). This call can fail\nwhen the contract is originated if the hash is invalid or the\nexpansion of the global constant is ill-typed, or too large (gas\nconsumption).")))}h.isMDXComponent=!0}}]);