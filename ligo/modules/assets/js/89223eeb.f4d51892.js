"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[47022],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>m});var a=t(67294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=a.createContext({}),p=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},u=function(e){var n=p(e.components);return a.createElement(l.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=p(t),m=o,h=d["".concat(l,".").concat(m)]||d[m]||c[m]||i;return t?a.createElement(h,r(r({ref:n},u),{},{components:t})):a.createElement(h,r({ref:n},u))}));function m(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var i=t.length,r=new Array(i);r[0]=d;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,r[1]=s;for(var p=2;p<i;p++)r[p]=t[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},48720:(e,n,t)=>{t.d(n,{D:()=>o.Z,Z:()=>i});var a=t(67294),o=t(75402);const i=function(e){return a.createElement(o.Z.Consumer,null,(n=>{let{syntax:t}=n;return t===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},85225:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>s,default:()=>d,frontMatter:()=>r,metadata:()=>l,toc:()=>u});var a=t(87462),o=(t(67294),t(3905)),i=t(48720);const r={id:"modules",title:"Modules",jsligoTitle:"Namespaces"},s=void 0,l={unversionedId:"syntax/modules",id:"syntax/modules",title:"Modules",description:"Modules are collections of related definitions that make them modular and help them avoid name collisions.",source:"@site/../docs/syntax/modules.md",sourceDirName:"syntax",slug:"/syntax/modules",permalink:"/previews/ligo/modules/docs/next/syntax/modules",draft:!1,tags:[],version:"current",frontMatter:{id:"modules",title:"Modules",jsligoTitle:"Namespaces"},sidebar:"docs",previous:{title:"Variables and constants",permalink:"/previews/ligo/modules/docs/next/syntax/variables"},next:{title:"Declaring",permalink:"/previews/ligo/modules/docs/next/functions/declaring"}},p={},u=[{value:"Creating modules",id:"creating-modules",level:2},{value:"Creating namespaces",id:"creating-namespaces",level:2},{value:"Nesting modules",id:"nesting-modules",level:2},{value:"Nesting namespaces",id:"nesting-namespaces",level:2},{value:"Aliasing modules",id:"aliasing-modules",level:2},{value:"Aliasing namespaces",id:"aliasing-namespaces",level:2},{value:"Including modules",id:"including-modules",level:2},{value:"Importing modules",id:"importing-modules",level:2}],c={toc:u};function d(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("p",null,"Modules are collections of related definitions that make them modular and help them avoid name collisions.\nA common example of a module is a data type and associated operations over it, such as stacks or queues.\nA module can contain the declaration of a type that represents a currency with functions that manipulate the currency and constants that apply to it.\nOther pieces of code can access these definitions, providing maintainability, reusability and safety."),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"Developers often put a single smart contract in a module, but LIGO does not require you to put a contract in a module and it does not limit modules to contain a single contract.")),(0,o.kt)("p",null,"Modules have some similarities with records because they can both contain multiple definitions.\nHowever, there are significant differences between records and modules:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Records are expressions and therefore can be used as values, and modules are not expressions and can't be used as values.\nFor example, you can pass a record as an argument to a function, but you cannot pass a module in this way except in specific circumstances, such using the ",(0,o.kt)("inlineCode",{parentName:"p"},"contract_of")," function to create a contract from a module to use in ",(0,o.kt)("a",{parentName:"p",href:"../testing"},"Testing"),".")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Records cannot package type and value definitions together like modules can."))),(0,o.kt)("p",null,"Which construct you use depends on your design and strategy: modules behave like libraries and records behave like individual units of computation."),(0,o.kt)("h2",{id:"creating-modules"},"Creating modules"),(0,o.kt)("p",null,"To create a module, declare it with the keyword ",(0,o.kt)("inlineCode",{parentName:"p"},"module")," and a name that starts with a capital letter.\nThen put the type, function, value, and nested module definitions in a block between the keyword ",(0,o.kt)("inlineCode",{parentName:"p"},"struct")," and the keyword ",(0,o.kt)("inlineCode",{parentName:"p"},"end"),"."),(0,o.kt)("p",null,"For example, the following code defines a module named ",(0,o.kt)("inlineCode",{parentName:"p"},"Euro")," to represent the Euro currency.\nIt includes a type (internally called ",(0,o.kt)("inlineCode",{parentName:"p"},"t"),"), an operation ",(0,o.kt)("inlineCode",{parentName:"p"},"add")," that sums two values of the given currency, and constants for one and two Euros."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=euro",group:"euro"},"(* This is euro.mligo *)\n\nmodule Euro =\n  struct\n    type t = nat\n    let add (a, b : t * t) : t = a + b\n    let one : t = 1n\n    let two : t = 2n\n  end\n")),(0,o.kt)("p",null,'To access the contents of a module, use the name of the module and the selection operator "',(0,o.kt)("inlineCode",{parentName:"p"},"."),'", as with records.\nFor example, this piece of code in the same file defines a value of the ',(0,o.kt)("inlineCode",{parentName:"p"},"Euro")," type and uses the functions and constants in the module to manipulate it:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=euro",group:"euro"},"type euro_balance = Euro.t\n\nlet add_tip (s : euro_balance) : euro_balance =\n  Euro.add (s, Euro.one)\n")),(0,o.kt)("p",null,"In principle, you could change the internal implementation of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Euro")," module without having to change the ",(0,o.kt)("inlineCode",{parentName:"p"},"euro_balance")," type or the ",(0,o.kt)("inlineCode",{parentName:"p"},"add_tip")," function.\nFor example, if you decide to support manipulating negative values, you could change the ",(0,o.kt)("inlineCode",{parentName:"p"},"Euro.t")," type to an integer:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=euro_sub",group:"euro_sub"},"module Euro =\n  struct\n    type t = int\n    let add (a, b : t * t) : t = a + b\n    let sub (a, b : t * t) : t = a - b\n    let one : t = 1\n    let two : t = 2\n  end\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"add_tip")," function still works, and no change is needed.\nAbstraction accomplished!"),(0,o.kt)("p",null,"However, clients that use the ",(0,o.kt)("inlineCode",{parentName:"p"},"Euro")," module might still break the abstraction if they directly use the underlying representation of ",(0,o.kt)("inlineCode",{parentName:"p"},"Euro.t"),".\nFor example, the type ",(0,o.kt)("inlineCode",{parentName:"p"},"Euro.t")," is a transparent alias of ",(0,o.kt)("inlineCode",{parentName:"p"},"nat")," (or ",(0,o.kt)("inlineCode",{parentName:"p"},"int"),").\nIn this case, other code might break if it performs operations that are valid on nats but not on integers.\nClient code should always try to respect the interface provided by the module and not make assumptions on its current underlying representation."),(0,o.kt)("p",null,'By default, all the definitions in a module are "exported", that is, they are accessible from outside the module.\nIn order to hide the representation of a type in a module, you can constrain the module with a module type, or ',(0,o.kt)("a",{parentName:"p",href:"../signatures/declaring"},(0,o.kt)("em",{parentName:"a"},"signature")),".")),(0,o.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("p",null,"Namespaces are collections of related definitions that make them modular and help them avoid name collisions.\nA common example of a namespace is a data type and associated operations over it, such as stacks or queues.\nA namespace can contain the declaration of a type that represents a currency with functions that manipulate the currency and constants that apply to it.\nOther pieces of code can access these definitions, providing maintainability, reusability and safety."),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"Developers often put a single smart contract in a namespace, but LIGO does not require you to put a contract in a namespace and it does not limit namespaces to contain a single contract.")),(0,o.kt)("p",null,"Namespaces have some similarities with records because they can both contain multiple definitions.\nHowever, there are significant differences between records and namespaces:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Records are expressions and therefore can be used as values, and namespaces are not expressions and can't be used as values.\nFor example, you can pass a record as an argument to a function, but you cannot pass a namespace in this way except in specific circumstances, such using the ",(0,o.kt)("inlineCode",{parentName:"p"},"contract_of")," function to create a contract from a namespace to use in ",(0,o.kt)("a",{parentName:"p",href:"../testing"},"Testing"),".")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Records cannot package type and value definitions together like namespaces can."))),(0,o.kt)("p",null,"Which construct you use depends on your design and strategy: namespaces behave like libraries and records behave like individual units of computation."),(0,o.kt)("h2",{id:"creating-namespaces"},"Creating namespaces"),(0,o.kt)("p",null,"To create a namespace, declare it with the keyword ",(0,o.kt)("inlineCode",{parentName:"p"},"namespace"),' and a name that starts with a capital letter.\nThen put the type, function, value, and nested namespace definitions in a block opened by "',(0,o.kt)("inlineCode",{parentName:"p"},"{"),'" and closed by "',(0,o.kt)("inlineCode",{parentName:"p"},"}"),'"'),(0,o.kt)("p",null,"For example, the following code defines a namespace named ",(0,o.kt)("inlineCode",{parentName:"p"},"Euro")," to represent the Euro currency.\nIt packages together a type (internally called ",(0,o.kt)("inlineCode",{parentName:"p"},"t"),"), an operation ",(0,o.kt)("inlineCode",{parentName:"p"},"add")," that sums two values of the given currency, and constants for one and two Euros."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=euro",group:"euro"},"// This is euro.jsligo\n\nnamespace Euro {\n  export type t = nat;\n  export const add = (a: t, b: t) : t => a + b;\n  export const one: t = 1n;\n  export const two: t = 2n;\n};\n")),(0,o.kt)("p",null,'To access the contents of a namespace, use the name of the namespace and the selection operator "',(0,o.kt)("inlineCode",{parentName:"p"},"."),'", as with records.\nFor example, this piece of code in the same file defines a value of the ',(0,o.kt)("inlineCode",{parentName:"p"},"Euro")," type and uses the functions and constants in the namespace to manipulate it:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=euro",group:"euro"},"type euro_balance = Euro.t;\n\nconst add_tip = (s: euro_balance): euro_balance =>\n  Euro.add(s, Euro.one);\n")),(0,o.kt)("p",null,"In principle, you could change the internal implementation of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Euro")," namespace without having to change the ",(0,o.kt)("inlineCode",{parentName:"p"},"euro_balance")," type or the ",(0,o.kt)("inlineCode",{parentName:"p"},"add_tip")," function.\nFor example, if you decide to support manipulating negative values, you could change the ",(0,o.kt)("inlineCode",{parentName:"p"},"Euro.t")," type to an integer:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=euro_sub",group:"euro_sub"},"namespace Euro {\n  export type t = int;\n  export const add = (a: t, b: t) : t => a + b;\n  export const sub = (a: t, b: t) : t => a - b;\n  export const one: t = 1;\n  export const two: t = 2;\n};\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"add_tip")," function still works, and no change is needed.\nAbstraction accomplished!"),(0,o.kt)("p",null,"However, clients that use the ",(0,o.kt)("inlineCode",{parentName:"p"},"Euro")," namespace might still break the abstraction if they directly use the underlying representation of ",(0,o.kt)("inlineCode",{parentName:"p"},"Euro.t"),".\nFor example, the type ",(0,o.kt)("inlineCode",{parentName:"p"},"Euro.t")," is a transparent alias of ",(0,o.kt)("inlineCode",{parentName:"p"},"nat")," (or ",(0,o.kt)("inlineCode",{parentName:"p"},"int"),").\nIn this case, other code might break if it performs operations that are valid on nats but not on integers.\nClient code should always try to respect the interface provided by the namespace and not make assumptions on its current underlying representation.")),(0,o.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("h2",{id:"nesting-modules"},"Nesting modules"),(0,o.kt)("p",null,"You can define a module inside another module.\nFor example, this version of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Euro")," module groups constants in a sub-module:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=module_nesting",group:"module_nesting"},"module Euro =\n  struct\n    type t = nat\n\n    let add (a, b : t * t) : t = a + b\n\n    module Coin =\n      struct\n        let one : t = 1n\n        let two : t = 2n\n      end\n  end\n")),(0,o.kt)("p",null,"To access nested modules, use the selection operator as many times as necessary:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=module_nesting",group:"module_nesting"},"type euro_balance = Euro.t\n\nlet increment (s : euro_balance) : euro_balance =\n  Euro.add (s, Euro.Coin.one)\n"))),(0,o.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("h2",{id:"nesting-namespaces"},"Nesting namespaces"),(0,o.kt)("p",null,"You can define a namespace inside another namespace.\nFor example, this version of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Euro")," namespace groups constants in a sub-namespace:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=namespace_nesting",group:"namespace_nesting"},"namespace Euro {\n  export type t = nat;\n\n  export let add = (a: t, b: t): t => a + b;\n\n  export namespace Coin {\n    export let one: t = 1n;\n    export let two: t = 2n;\n  };\n};\n")),(0,o.kt)("p",null,"To access nested namespaces, use the selection operator as many times as necessary:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=namespace_nesting",group:"namespace_nesting"},"type euro_balance = Euro.t;\n\nconst increment = (s: euro_balance): euro_balance =>\n  Euro.add(s, Euro.Coin.one);\n")),(0,o.kt)("p",null,"Note that the sub-namespace ",(0,o.kt)("inlineCode",{parentName:"p"},"Coin")," must be prefixed by the keyword ",(0,o.kt)("inlineCode",{parentName:"p"},"export")," to make its contents available outside the namespace.")),(0,o.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("h2",{id:"aliasing-modules"},"Aliasing modules"),(0,o.kt)("p",null,"You can apply an alias to a module to create modules that work as synonyms of previously defined modules.\nCreating a synonym of a module can be useful to implement a module that is currently the same as another module for now but may need to change in the future.\nFor example, until 2025, the Bulgarian Lev is pegged to the euro currency, so the ",(0,o.kt)("inlineCode",{parentName:"p"},"Bulgarian_Lev")," module is an alias of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Euro")," module:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=Lev",group:"Lev"},"module Euro =\n  struct\n    type t = nat\n    let add (a, b : t * t) : t = a + b\n    let one : t = 1n\n    let two : t = 2n\n  end\n\nmodule Bulgarian_Lev = Euro\n")),(0,o.kt)("p",null,"Now other code can use the Lev just like it is a Euro for now, and you can change how the Lev works later.")),(0,o.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("h2",{id:"aliasing-namespaces"},"Aliasing namespaces"),(0,o.kt)("p",null,"You can apply an alias to a namespace to create namespaces that work as synonyms of previously defined namespaces.\nCreating a synonym of a namespace can be useful to implement a namespace that is currently the same as another namespace for now but may need to change in the future.\nFor example, until 2025, the Bulgarian Lev is pegged to the euro currency, so the ",(0,o.kt)("inlineCode",{parentName:"p"},"Bulgarian_Lev")," namespace is an alias of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Euro")," namespace:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=Lev",group:"Lev"},"namespace Euro {\n  export type t = nat;\n  export const add = (a: t, b: t) : t => a + b;\n  export const one: t = 1n;\n  export const two: t = 2n;\n};\n\nimport Bulgarian_Lev = Euro;\n")),(0,o.kt)("p",null,"Now other code can use the Lev just like it is a Euro for now, and you can change how the Lev works later."),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"You must use the ",(0,o.kt)("inlineCode",{parentName:"p"},"import")," keyword to alias the namespace, even if it is in the same file."))),(0,o.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("h2",{id:"including-modules"},"Including modules"),(0,o.kt)("p",null,"You can include the content of one module inside another with the ",(0,o.kt)("inlineCode",{parentName:"p"},"include")," keyword.\nIncluding another module in this way can be another way to nest and organize code.\nIt can also allow you to upgrade or extend a module, such as by adding new types, functions, and values."),(0,o.kt)("p",null,"This example extends the ",(0,o.kt)("inlineCode",{parentName:"p"},"Euro")," module by including it in a new ",(0,o.kt)("inlineCode",{parentName:"p"},"NewEuro")," module that has a constant for a 10 Euro note:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=including",group:"including"},"module Euro =\n  struct\n    type t = nat\n    let add (a, b : t * t) : t = a + b\n    let one : t = 1n\n    let two : t = 2n\n  end\n\nmodule NewEuro =\n  struct\n    include Euro\n    let ten : t = 10n\n  end\n")),(0,o.kt)("p",null,"Including modules is not possible in JsLIGO.")),(0,o.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("h2",{id:"importing-modules"},"Importing modules"),(0,o.kt)("p",null,"You can import modules from other files with the ",(0,o.kt)("inlineCode",{parentName:"p"},"#import")," directive.\nSee ",(0,o.kt)("a",{parentName:"p",href:"../preprocessor/import"},(0,o.kt)("inlineCode",{parentName:"a"},"#import")),".")),(0,o.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("p",null,"You can import namespaces from other files with the ",(0,o.kt)("inlineCode",{parentName:"p"},"#import")," directive, but only if the namespaces have the ",(0,o.kt)("inlineCode",{parentName:"p"},"@public")," decorator.\nSee ",(0,o.kt)("a",{parentName:"p",href:"../preprocessor/import"},(0,o.kt)("inlineCode",{parentName:"a"},"#import")),".")))}d.isMDXComponent=!0}}]);