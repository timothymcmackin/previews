"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8699],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=c(n),m=o,h=u["".concat(l,".").concat(m)]||u[m]||p[m]||i;return n?a.createElement(h,r(r({ref:t},d),{},{components:n})):a.createElement(h,r({ref:t},d))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,r[1]=s;for(var c=2;c<i;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},48720:(e,t,n)=>{n.d(t,{D:()=>o.Z,Z:()=>i});var a=n(67294),o=n(75402);const i=function(e){return a.createElement(o.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},30462:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>l,toc:()=>d});var a=n(87462),o=(n(67294),n(3905)),i=n(48720);const r={id:"decorators",title:"Attributes or Decorators"},s=void 0,l={unversionedId:"advanced/decorators",id:"advanced/decorators",title:"Attributes or Decorators",description:'Attributes (also known as "decorators" in JsLIGO, annotations or pragmas in other languages) are markers that can affect how the code immediately after is compiled or interpreted. Depending on the attribute, that code can be a definition, variable, statement block and so on. The sections below describe the attributes supported by CameLIGO.',source:"@site/../docs/advanced/attributes-decorators.md",sourceDirName:"advanced",slug:"/advanced/decorators",permalink:"/previews/ligo/modules/docs/next/advanced/decorators",draft:!1,tags:[],version:"current",frontMatter:{id:"decorators",title:"Attributes or Decorators"}},c={},d=[{value:"@entry to mark a function as a Smart Contract entry point",id:"entry-to-mark-a-function-as-a-smart-contract-entry-point",level:2},{value:"@dyn_entry to mark a function as a dynamic entry point",id:"dyn_entry-to-mark-a-function-as-a-dynamic-entry-point",level:2},{value:"@inline to ensure a function is inlined at its call sites",id:"inline-to-ensure-a-function-is-inlined-at-its-call-sites",level:2},{value:"@view to mark a function as a Smart Contract on-chain view",id:"view-to-mark-a-function-as-a-smart-contract-on-chain-view",level:2},{value:"@no_mutation",id:"no_mutation",level:2},{value:"@private to prevent an identifier from being accessed outside of its defining module",id:"private-to-prevent-an-identifier-from-being-accessed-outside-of-its-defining-module",level:2},{value:"@annot to ornate the generated code with Michelson annotations",id:"annot-to-ornate-the-generated-code-with-michelson-annotations",level:2},{value:"@layout to specify the Michelson layout of composite data types (structures and variants)",id:"layout-to-specify-the-michelson-layout-of-composite-data-types-structures-and-variants",level:2},{value:"@tzip16_compatible to enable TZIP-16 storage checks",id:"tzip16_compatible-to-enable-tzip-16-storage-checks",level:2},{value:"Internal attributes",id:"internal-attributes",level:2},{value:"@entry to mark a function as a Smart Contract entry point",id:"entry-to-mark-a-function-as-a-smart-contract-entry-point-1",level:2},{value:"@dyn_entry to mark a function as a dynamic entry point",id:"dyn_entry-to-mark-a-function-as-a-dynamic-entry-point-1",level:2},{value:"@inline to ensure a function is inlined at its call sites",id:"inline-to-ensure-a-function-is-inlined-at-its-call-sites-1",level:2},{value:"@view to mark a function as a Smart Contract on-chain view",id:"view-to-mark-a-function-as-a-smart-contract-on-chain-view-1",level:2},{value:"@no_mutation",id:"no_mutation-1",level:2},{value:"@private to prevent an identifier from being accessed outside of its defining module",id:"private-to-prevent-an-identifier-from-being-accessed-outside-of-its-defining-module-1",level:2},{value:"@annot to ornate the generated code with Michelson annotations",id:"annot-to-ornate-the-generated-code-with-michelson-annotations-1",level:2},{value:"@layout to specify the Michelson layout of composite data types (structures and variants)",id:"layout-to-specify-the-michelson-layout-of-composite-data-types-structures-and-variants-1",level:2},{value:"@tzip16_compatible to enable TZIP-16 storage checks",id:"tzip16_compatible-to-enable-tzip-16-storage-checks-1",level:2},{value:"export to mark an identifier as accessible outside its defining module",id:"export-to-mark-an-identifier-as-accessible-outside-its-defining-module",level:2},{value:"Internal decorators",id:"internal-decorators",level:2}],p={toc:d};function u(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("h1",{id:"attributes"},"Attributes"),(0,o.kt)("p",null,'Attributes (also known as "decorators" in JsLIGO, annotations or pragmas in other languages) are markers that can affect how the code immediately after is compiled or interpreted. Depending on the attribute, that code can be a definition, variable, statement block and so on. The sections below describe the attributes supported by CameLIGO.'),(0,o.kt)("p",null,"It is possible to specify multiple attributes as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo"},"type storage = int\ntype result = operation list * storage\n\n[@entry] [@no_mutation]\nlet sub (delta : int) (store : storage) : result =\n  [], store - delta\n")),(0,o.kt)("h2",{id:"entry-to-mark-a-function-as-a-smart-contract-entry-point"},"@entry to mark a function as a Smart Contract entry point"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"@entry"),' attribute is used to indicate that a function should be available as an entry point of the smart contract. It is essentially declaring that function as one of the several "main" functions. For more information, see ',(0,o.kt)("a",{parentName:"p",href:"../tezos/contracts/entrypoints"},"Entrypoints"),"."),(0,o.kt)("h2",{id:"dyn_entry-to-mark-a-function-as-a-dynamic-entry-point"},"@dyn_entry to mark a function as a dynamic entry point"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"@dyn_entry")," attribute is used to indicate that a function should be available as a dynamic entry point of the smart contract. Dynamic entry points can be removed or updated without deploying a new contract, unlike entry points marked with ",(0,o.kt)("inlineCode",{parentName:"p"},"@entry"),", which cannot be modified after the contract is originated. Dynamic entry points can be used for example to implement a DAO (Decentralized Autonomous Organization) with a built-in update mechanism that allows participants to vote on upgrades to the contract, somewhat akin to the process which allows to amend the Tezos protocol. For more information, see ",(0,o.kt)("a",{parentName:"p",href:"/previews/ligo/modules/docs/next/advanced/dynamic-entrypoints"},"Dynamic entrypoints"),"."),(0,o.kt)("h2",{id:"inline-to-ensure-a-function-is-inlined-at-its-call-sites"},"@inline to ensure a function is inlined at its call sites"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"@inline")," attribute indicates that the code of the function it annotates must be inlined wherever it is called. This allows some optimizations to be performed, possibly at the expense of a larger compiled code. Benchmarks and profiling can help decide whether a function should be inlined or nor. For more information, see ",(0,o.kt)("a",{parentName:"p",href:"/previews/ligo/modules/docs/next/advanced/inline"},"Inlining")),(0,o.kt)("h2",{id:"view-to-mark-a-function-as-a-smart-contract-on-chain-view"},"@view to mark a function as a Smart Contract on-chain view"),(0,o.kt)("p",null,"Views are a form of read-only entry points, that can be called synchronously. For more information, see ",(0,o.kt)("a",{parentName:"p",href:"/previews/ligo/modules/docs/next/contract/views"},"LIGO views"),"."),(0,o.kt)("h2",{id:"no_mutation"},"@no_mutation"),(0,o.kt)("p",null,"See ",(0,o.kt)("a",{parentName:"p",href:"/previews/ligo/modules/docs/next/testing/mutation-testing#preventing-mutation"},"the documentation on mutation testing"),"."),(0,o.kt)("h2",{id:"private-to-prevent-an-identifier-from-being-accessed-outside-of-its-defining-module"},"@private to prevent an identifier from being accessed outside of its defining module"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"[@private]")," decorator can be used on a top-level declaration, to prevent that value from being used outside the declaring module."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=module-with-private",group:"module-with-private"},"(* This is gitlab-pages/docs/advanced/src/attributes-decorators/module-with-private.mligo *)\n[@private] let stuff = 42\n[@private] let g x = x * stuff\nlet f x = (g x) + 1\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=import-module-with-private",group:"import-module-with-private"},'(* This is gitlab-pages/docs/advanced/src/attributes-decorators/import-module-with-private.mligo *)\n#import "gitlab-pages/docs/advanced/src/attributes-decorators/module-with-private.mligo" "ModuleWithPrivate"\n\n(* foo = 5167 = (123 * 42) + 1 *)\nlet foo = ModuleWithPrivate.f 123\n\n(*\n  The following lines cause errors because g and stuff are private:\n\n  let bad_1 = ModuleWithPrivate.g 123\n  let bad_2 = ModuleWithPrivate.stuff\n*)\n')),(0,o.kt)("h2",{id:"annot-to-ornate-the-generated-code-with-michelson-annotations"},"@annot to ornate the generated code with Michelson annotations"),(0,o.kt)("p",null,"This attribute can be used to choose the name of the Michelson equivalent of record fields or variant constructors. By default, a variant is compiled to a comb of Michelson ",(0,o.kt)("inlineCode",{parentName:"p"},"or"),", and each leaf in the nested tree of ",(0,o.kt)("inlineCode",{parentName:"p"},"or")," that corresponds to a constructor is annotated with that constructor's name. Similarly, a record is compiled to a comb of Michelson ",(0,o.kt)("inlineCode",{parentName:"p"},"pair"),", and each leaf in the nested tree of ",(0,o.kt)("inlineCode",{parentName:"p"},"pair")," that corresponds to a field is annotated with that field's name."),(0,o.kt)("p",null,"Using ",(0,o.kt)("inlineCode",{parentName:"p"},"@annot"),", the Michelson annotation for a given field or constructor can be customized. This is useful for interoperability, where a third-party program or contract expects specific Michelson annotations, even if the LIGO code might not use these names internally."),(0,o.kt)("p",null,"For more information, see ",(0,o.kt)("a",{parentName:"p",href:"/previews/ligo/modules/docs/next/tezos/contracts/interop#different-michelson-annotations"},"Interop: Different Michelson annotations"),"?"),(0,o.kt)("h2",{id:"layout-to-specify-the-michelson-layout-of-composite-data-types-structures-and-variants"},"@layout to specify the Michelson layout of composite data types (structures and variants)"),(0,o.kt)("p",null,"Michelson does not natively support records or variants. These have to be encoded using nested ",(0,o.kt)("inlineCode",{parentName:"p"},"pair"),"s or nested ",(0,o.kt)("inlineCode",{parentName:"p"},"or"),"s. Many tree representations could translate to the same linear sequence of fields or constructors. LIGO makes it possible to choose between a right comb which preserves the order or the fields or constructors as declared in the source code, and a left-balanced, alphabetically ordered binary tree. The attributes ",(0,o.kt)("inlineCode",{parentName:"p"},"[@layout comb]")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"[@layout tree]")," can be placed before the ",(0,o.kt)("inlineCode",{parentName:"p"},"{ ... }")," for records and before the first constructor or leading ",(0,o.kt)("inlineCode",{parentName:"p"},"|")," for variants, in order to explicitly choose the desired layout."),(0,o.kt)("p",null,"For more information, see ",(0,o.kt)("a",{parentName:"p",href:"/previews/ligo/modules/docs/next/tezos/contracts/interop##michelson-layout-of-ligo-data-structures"},"Interop: Michelson layout of LIGO data structures"),"."),(0,o.kt)("h2",{id:"tzip16_compatible-to-enable-tzip-16-storage-checks"},"@tzip16_compatible to enable TZIP-16 storage checks"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"@tzip16_compatible")," attribute is used to indicate a storage variable that is expected to contain metadata compliant with ",(0,o.kt)("a",{parentName:"p",href:"https://gitlab.com/tezos/tzip/-/blob/master/proposals/tzip-16/tzip-16.md"},"TZIP-16 specification"),". Values marked with this attribute are subject to automatic checks verifying that the storage indeed satisfies TZIP-16 rules."),(0,o.kt)("p",null,"Note that at the moment there is no support for thus feature from the LIGO compiler; IDEs however can recognize the attribute and provide additional verification."),(0,o.kt)("p",null,"The attribute works only on variables that are not functions. In case a function returning storage needs to be verified, one can create one or several sample storages out of it and apply the attribute to them."),(0,o.kt)("h2",{id:"internal-attributes"},"Internal attributes"),(0,o.kt)("p",null,"Furthermore, the following attributes are used internally by the compiler, you may encounter them when exporting the AST after a certain compilation pass, but they should not appear in normal source code."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"@thunk")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"@hidden")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"@public")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"@deprecated")))),(0,o.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("h1",{id:"decorators"},"Decorators"),(0,o.kt)("p",null,'Decorators (also known as "attributes" in CameLIGO, annotations or pragmas in other languages) are markers that can affect how the code immediately after is compiled or interpreted. Depending on the decorator, that code can be a definition, variable, statement block and so on. The sections below describe the decorators supported by JsLIGO.'),(0,o.kt)("p",null,"It is possible to specify multiple decorators as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo"},"type storage = int;\ntype result = [list<operation>, storage];\n\n@entry @no_mutation\nconst sub = (delta : int, store : storage) : result =>\n  [[], store - delta]\n")),(0,o.kt)("h2",{id:"entry-to-mark-a-function-as-a-smart-contract-entry-point-1"},"@entry to mark a function as a Smart Contract entry point"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"@entry"),' decorator is used to indicate that a function should be available as an entry point of the smart contract. It is essentially declaring that function as one of the several "main" functions. For more information, see ',(0,o.kt)("a",{parentName:"p",href:"../tezos/contracts/entrypoints"},"Entrypoints"),"."),(0,o.kt)("h2",{id:"dyn_entry-to-mark-a-function-as-a-dynamic-entry-point-1"},"@dyn_entry to mark a function as a dynamic entry point"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"@dyn_entry")," decorator is used to indicate that a function should be available as a dynamic entry point of the smart contract. Dynamic entry points can be removed or updated without deploying a new contract, unlike entry points marked with ",(0,o.kt)("inlineCode",{parentName:"p"},"@entry"),", which cannot be modified after the contract is originated. Dynamic entry points can be used for example to implement a DAO (Decentralized Autonomous Organization) with a built-in update mechanism that allows participants to vote on upgrades to the contract, somewhat akin to the process which allows to amend the Tezos protocol. For more information, see ",(0,o.kt)("a",{parentName:"p",href:"/previews/ligo/modules/docs/next/advanced/dynamic-entrypoints"},"Dynamic entrypoints"),"."),(0,o.kt)("h2",{id:"inline-to-ensure-a-function-is-inlined-at-its-call-sites-1"},"@inline to ensure a function is inlined at its call sites"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"@inline")," decorator indicates that the code of the function it annotates must be inlined wherever it is called. This allows some optimizations to be performed, possibly at the expense of a larger compiled code. Benchmarks and profiling can help decide whether a function should be inlined or nor. For more information, see ",(0,o.kt)("a",{parentName:"p",href:"/previews/ligo/modules/docs/next/advanced/inline"},"Inlining")),(0,o.kt)("h2",{id:"view-to-mark-a-function-as-a-smart-contract-on-chain-view-1"},"@view to mark a function as a Smart Contract on-chain view"),(0,o.kt)("p",null,"Views are a form of read-only entry points, that can be called synchronously. For more information, see ",(0,o.kt)("a",{parentName:"p",href:"/previews/ligo/modules/docs/next/contract/views"},"LIGO views"),"."),(0,o.kt)("h2",{id:"no_mutation-1"},"@no_mutation"),(0,o.kt)("p",null,"See ",(0,o.kt)("a",{parentName:"p",href:"/previews/ligo/modules/docs/next/testing/mutation-testing#preventing-mutation"},"the documentation on mutation testing"),"."),(0,o.kt)("h2",{id:"private-to-prevent-an-identifier-from-being-accessed-outside-of-its-defining-module-1"},"@private to prevent an identifier from being accessed outside of its defining module"),(0,o.kt)("p",null,"This decorator is meant to be used in CameLIGO, where definitions are public/exported by default. It has no use in JsLIGO."),(0,o.kt)("h2",{id:"annot-to-ornate-the-generated-code-with-michelson-annotations-1"},"@annot to ornate the generated code with Michelson annotations"),(0,o.kt)("p",null,"This decorator can be used to choose the name of the Michelson equivalent of record fields or variant constructors. By default, a variant is compiled to a comb of Michelson ",(0,o.kt)("inlineCode",{parentName:"p"},"or"),", and each leaf in the nested tree of ",(0,o.kt)("inlineCode",{parentName:"p"},"or")," that corresponds to a constructor is annotated with that constructor's name. Similarly, a record is compiled to a comb of Michelson ",(0,o.kt)("inlineCode",{parentName:"p"},"pair"),", and each leaf in the nested tree of ",(0,o.kt)("inlineCode",{parentName:"p"},"pair")," that corresponds to a field is annotated with that field's name."),(0,o.kt)("p",null,"Using ",(0,o.kt)("inlineCode",{parentName:"p"},"@annot"),", the Michelson annotation for a given field or constructor can be customized. This is useful for interoperability, where a third-party program or contract expects specific Michelson annotations, even if the LIGO code might not use these names internally."),(0,o.kt)("p",null,"For more information, see ",(0,o.kt)("a",{parentName:"p",href:"/previews/ligo/modules/docs/next/tezos/contracts/interop#different-michelson-annotations"},"Interop: Different Michelson annotations"),"?"),(0,o.kt)("h2",{id:"layout-to-specify-the-michelson-layout-of-composite-data-types-structures-and-variants-1"},"@layout to specify the Michelson layout of composite data types (structures and variants)"),(0,o.kt)("p",null,"Michelson does not natively support records or variants. These have to be encoded using nested ",(0,o.kt)("inlineCode",{parentName:"p"},"pair"),"s or nested ",(0,o.kt)("inlineCode",{parentName:"p"},"or"),"s. Many tree representations could translate to the same linear sequence of fields or constructors. LIGO makes it possible to choose between a right comb which preserves the order or the fields or constructors as declared in the source code, and a left-balanced, alphabetically ordered binary tree. The decorators ",(0,o.kt)("inlineCode",{parentName:"p"},'@layout("comb")')," and ",(0,o.kt)("inlineCode",{parentName:"p"},'@layout("tree")')," can be placed before the ",(0,o.kt)("inlineCode",{parentName:"p"},"{ ... }")," for records and before the first constructor or leading ",(0,o.kt)("inlineCode",{parentName:"p"},"|")," for variants, in order to explicitly choose the desired layout."),(0,o.kt)("p",null,"For more information, see ",(0,o.kt)("a",{parentName:"p",href:"/previews/ligo/modules/docs/next/tezos/contracts/interop##michelson-layout-of-ligo-data-structures"},"Interop: Michelson layout of LIGO data structures"),"."),(0,o.kt)("h2",{id:"tzip16_compatible-to-enable-tzip-16-storage-checks-1"},"@tzip16_compatible to enable TZIP-16 storage checks"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"@tzip16_compatible")," decorator is used to indicate a storage variable that is expected to contain metadata compliant with ",(0,o.kt)("a",{parentName:"p",href:"https://gitlab.com/tezos/tzip/-/blob/master/proposals/tzip-16/tzip-16.md"},"TZIP-16 specification"),". Values marked with this decorator are subject to automatic checks verifying that the storage indeed satisfies TZIP-16 rules."),(0,o.kt)("p",null,"Note that at the moment there is no support for thus feature from the LIGO compiler; IDEs however can recognize the decorator and provide additional verification."),(0,o.kt)("p",null,"The decorator works only on variables that are not functions. In case a function returning storage needs to be verified, one can create one or several sample constant storages out of it and apply the decorator to them."),(0,o.kt)("h2",{id:"export-to-mark-an-identifier-as-accessible-outside-its-defining-module"},"export to mark an identifier as accessible outside its defining module"),(0,o.kt)("p",null,"This decorator is slightly different from the others in that it does not need ",(0,o.kt)("inlineCode",{parentName:"p"},"@")," and simply appears as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo"},"namespace MathPi {\n  export const pi_millionth_numerator : int = 3141593\n  export const pi_millionth_denominator : nat = 1000000n\n}\n")),(0,o.kt)("h2",{id:"internal-decorators"},"Internal decorators"),(0,o.kt)("p",null,"Furthermore, the following attributes are used internally by the compiler, you may encounter them when exporting the AST after a certain compilation pass, but they should not appear in normal source code."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"@thunk")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"@hidden")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"@public")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"@deprecated")))))}u.isMDXComponent=!0}}]);