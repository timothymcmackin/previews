"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[55603],{24167:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"v1-migration-guide","metadata":{"permalink":"/previews/ligo/modules/blog/v1-migration-guide","source":"@site/blog/2023-09-20-v1-migration-guide.md","title":"Migration to LIGO v1.0","description":"Exciting news, LIGO has released version 1.0! Please continue reading to learn which changes may affect your existing codebase.","date":"2023-09-20T00:00:00.000Z","formattedDate":"September 20, 2023","tags":[{"label":"migration","permalink":"/previews/ligo/modules/blog/tags/migration"}],"readingTime":7.473333333333334,"hasTruncateMarker":true,"authors":[{"name":"Suzanne Soy","title":"Developer at Ligo","url":"https://gitlab.com/ligo.suzanne.soy","email":"suzanne@marigold.dev","imageURL":"https://gitlab.com/uploads/-/system/user/avatar/2923020/avatar.png?width=192","key":"suzannesoy"}],"frontMatter":{"title":"Migration to LIGO v1.0","description":"Exciting news, LIGO has released version 1.0! Please continue reading to learn which changes may affect your existing codebase.","slug":"v1-migration-guide","authors":["suzannesoy"],"tags":["migration"],"image":"https://i.imgur.com/mErPwqL.png","hide_table_of_contents":true},"nextItem":{"title":"How to deal with the change of the default datatype layout to @layout comb ?","permalink":"/previews/ligo/modules/blog/layout-comb-how"}},"content":"import Syntax from \'@theme/Syntax\';\\n\\nExciting news, LIGO has released version 1.0! We made sure to fit in this release a number of pending breaking changes, so that our users do not need to catch up with small breaking changes every release, and can handle the migration in bulk. Please continue reading to learn which changes may affect your existing codebase.\\n\\n\x3c!--truncate--\x3e\\n\\n## All syntaxes\\n\\n### No more `main` function\\n\\nYou should not manually craft a `main` function that calls your entry points anymore. Instead, above each entry point function, you can now write `@entry` for JsLIGO or `[@entry]` for CameLIGO. This will cause a `main` function to be automatically generated behind the scenes.\\n\\nIf you need more fine-grained control, it is still possible to write a `main` function, but you will need to add `@entry` or `[@entry]` above that `main` function (and only that function). See [the documentation on the main function and entry points](/docs/advanced/entrypoints-contracts#main-function) for more details on how to do this.\\n\\n[Views](/docs/contract/views) can be declared in a similar way with `@view` for JsLIGO and `[@view]` for CameLIGO.\\n\\nAs the use of `@entry` or `[@entry]` (and `@view` or `[@view]`) in the source is now mandatory, it is not possible anymore to rely on the auto-detection of the `main` function as the sole entry point, and it is not possible anymore to specify a entry points via the `-e` function on the command-line or views via the `--views` / `-v` options.\\n\\nAnother consequence of this change is that, when originating a contract for tests, `Test.originate` now take as an argument a module containing multiple entry points instead of a single function, i.e. a single entry point\\n\\nWe are also rolling out a new feature allowing the addition, removal and update of dynamic entry points for a contract after deployment. This could be a useful feature for example when building a DAO which allows on-chain vote to upgrade its code (or a DAO which controls the code of another separate contract). For more information, see [the documentation](/docs/advanced/dynamic-entrypoints) and [the reference](/docs/reference/dynamic-entrypoints-reference) for this feature.\\n\\nMRs:\\n\\n- https://gitlab.com/ligolang/ligo/-/merge_requests/2818\\n- https://gitlab.com/ligolang/ligo/-/merge_requests/2814\\n- https://gitlab.com/ligolang/ligo/-/merge_requests/2810\\n- https://gitlab.com/ligolang/ligo/-/merge_requests/2805\\n- https://gitlab.com/ligolang/ligo/-/merge_requests/2831\\n- https://gitlab.com/ligolang/ligo/-/merge_requests/2885\\n\\n#### Uniform calling convention for views and entry points.\\n\\nViews used to be functions taking a tuple, they are now functions taking two arguments:\\n\\n<Syntax syntax=\\"cameligo\\">\\n\\n```cameligo skip\\n[@entry]\\nlet set_storage (new_storage, _old_storage : int * int): operation list * int = ([], new_storage)\\n\\n[@view]\\nlet get_storage ((), storage : unit * int): int = storage\\n```\\n\\nis now written\\n\\n```cameligo\\n[@entry]\\nlet set_storage (new_storage : int)  (_old_storage : int): operation list * int = ([], new_storage)\\n\\n[@view]\\nlet get_storage () (storage : int): int = storage\\n```\\n\\n</Syntax>\\n\\n<Syntax syntax=\\"jsligo\\">\\n\\n```jsligo skip\\n// @entry\\nconst set_storage = ([new_storage, _old_storage] : [int, int]): [list<operation>, int] => [[], new_storage]\\n\\n@view\\nconst get_storage = ([_, storage] : [unit, int]): int => storage\\n```\\n\\nis now written\\n\\n```jsligo\\n@entry\\nconst set_storage = (new_storage: int, _old_storage: int): [list<operation>, int] => [[], new_storage]\\n\\n@view\\nconst get_storage = (_: unit, storage: int): int => storage\\n```\\n\\n</Syntax>\\n\\n#### `contract_of` and `parameter_of`\\n\\nThe aforementioned changes to `@entry` and the `main` function have affected how contracts are tested, starting from [v0.64.2](https://gitlab.com/ligolang/ligo/-/releases/0.64.2) ([changelog](/docs/intro/changelog#0642)). See [the documentation on testing](/docs/testing) for examples on how to use `contract_of` and `parameter_of`.\\n\\nMRs:\\n\\n- https://gitlab.com/ligolang/ligo/-/merge_requests/2476\\n- https://gitlab.com/ligolang/ligo/-/merge_requests/2685\\n\\n### `export` and `@private` now have the expected effect\\n\\nPreviously, all declarations would be exported regardless whether `export`, `@private` or neither was used.\\n\\nIn LIGO v1, JsLIGO definitions which are not marked with `export` are not exported, and CameLIGO definitions which are marked with `@private` are not exported. In other words, the default for JsLIGO is now to make definitions private unless specified otherwise with `export`, and the default for CameLIGO is now to make definitions public unless specified otherwise with `[@private]`.\\n\\nFurthermore, in JsLIGO nested namespaces need to be exported in order to be accessed, e.g.\\n\\n```jsligo group=namespace-export\\nnamespace Foo {\\n    export namespace Bar {\\n        export const x = 1\\n    }\\n}\\n\\nconst y = Foo.Bar.x\\n```\\n\\nMRs:\\n\\n- https://gitlab.com/ligolang/ligo/-/merge_requests/2796\\n- https://gitlab.com/ligolang/ligo/-/merge_requests/2684 in [v0.69.0](https://gitlab.com/ligolang/ligo/-/releases/0.69.0) ([changelog](/docs/intro/changelog#0690))\\n\\n### The comb layout is now used by default\\n\\nSome types can have several isomorphic representations in Michelson, and LIGO allows choosing between two of these, `comb` and `tree`, via an `@layout` decorator (e.g. `@layout(\\"comb\\")` in JsLIGO, or `[@layout comb]` in CameLIGO).\\n\\nPreviously, the default layout was `tree`, and in LIGO v1, the default becomes `comb`.\\n\\nThe rationale is that the `comb` layout is usually more optimal, especially for records: records with a `comb` layout are compiled to Michelson combs, which have better support and look more readable. The `comb` layout is also more predictable / less surprising, because the fields are in declared order instead of alphabetical order. The `comb` layout can be less efficient for variants, but the difference should not be significant in most cases. For more info on why this change happened, see [Why did the default datatype layout change to `@layout comb`?](/blog/layout-comb-why)\\n\\nIf your project has a stable ABI that other tools rely on, you might need to manually annotate the type of entry point arguments and the entry point return types with `@layout(\\"tree\\")` / `[@layout tree]`.\\n\\nOnce reaching the optimization phase of your development process, youu may wish to try annotating large variants (which contain many cases) with `@layout(\\"tree\\")` / `[@layout tree]` and comparing the size and gas consumption of the compiled contracts.\\n\\nMRs:\\n\\n- https://gitlab.com/ligolang/ligo/-/merge_requests/1816.\\n\\n### A small set of annotations / decorators are now supported\\n\\n- `@entry`\\n- `@dyn_entry`\\n- `@inline`\\n- `@view`\\n- `@no_mutation`\\n- `@private`\\n- `@public`\\n- `@annot`\\n- `@layout`\\n\\nThese annotations / decorators should now be written without prefixing them with a comment, e.g.\\n\\n```jsligo\\n@entry\\nconst my_entry_point = (_: unit, n: int) : [list<operation>, int] => [[], n];\\n```\\n\\ninstead of\\n\\n```jsligo skip\\n// @entry\\nconst my_entry_point = (_: unit, n: int) : [list<operation>, int] => [[], n];\\n```\\n\\nThere are also two internal annotations / decorators, which should not appear in normal source code:\\n\\n- `@thunk`\\n- `@hidden`\\n\\nMRs:\\n\\n- https://gitlab.com/ligolang/ligo/-/merge_requests/2619 in [v0.67.0](https://gitlab.com/ligolang/ligo/-/releases/0.67.0) ([changelog](/docs/intro/changelog#0670))\\n\\nMRs:\\n\\n- https://gitlab.com/ligolang/ligo/-/merge_requests/2476\\n\\n### Field and tuple component access\\n\\nFields can be accessed with dot notation `stuff.y` and brackets `stuff[\\"y\\"]` interchangeably:\\n\\n```jsligo\\nconst stuff = {\\n    x : \\"foo\\",\\n    y : { universe : [42, \\"life\\", true] }\\n};\\n\\nconst part : bool = stuff.y[\\"universe\\"][2];\\n```\\n\\n- https://gitlab.com/ligolang/ligo/-/merge_requests/2661\\n\\n### Miscellaneous\\n\\n- The internal command `ligo daemon` has been removed in [v0.69.0](https://gitlab.com/ligolang/ligo/-/releases/0.69.0) ([changelog](/docs/intro/changelog#0690)). It was previously used by the old language server to create a persistent LIGO process, but it was hacky and offered no performance improvements. There should be no noticeable change for the user, as the new language server (used e.g. by the VsCode plug-in) does not make use of this command anymore. MR: https://gitlab.com/ligolang/ligo/-/merge_requests/2690.\\n- The support for CST mutation testing has been dropped in [v0.66.0](https://gitlab.com/ligolang/ligo/-/releases/0.66.0) ([changelog](/docs/intro/changelog#0660)). Unfortunately, that feature was incomplete and broken. With the disappearance of this feature, the command `ligo mutate` has been removed. However, AST mutation testing is still supported and part of the [testing framework](/docs/advanced/mutation-testing). MRs: https://gitlab.com/ligolang/ligo/-/merge_requests/2455 and https://gitlab.com/ligolang/ligo/-/merge_requests/2607.\\n- Starting from [v0.64.2](https://gitlab.com/ligolang/ligo/-/releases/0.64.2) ([changelog](/docs/intro/changelog#0642)), the transpilation commands now take `--from-syntax` and `--to-syntax`, instead of the former, less clear use of `--syntax` for the source syntax and an unnamed parameter for the destination syntax. The destination syntax can still be inferred from the filename given to `-o`, e.g. `-o dest.jsligo`. MR: https://gitlab.com/ligolang/ligo/-/merge_requests/2501\\n- Starting from [v0.64.2](https://gitlab.com/ligolang/ligo/-/releases/0.64.2) ([changelog](/docs/intro/changelog#0642)), the Kathmandu protocol is deprecated. If you need to recompile an old LIGO contract for an outdated protocol version, you may use the compiler version that the project was developed with. MR: https://gitlab.com/ligolang/ligo/-/merge_requests/2500\\n\\n## JsLIGO\\n\\n### Short notation for `tez` and `mutez`\\n\\nYou can now write `3tez` or `3mutez` instead of `3 as tez` or `3 as mutez`. This convenient feature was already present in CameLIGO and is now available in JsLIGO too!\\n\\nMRs:\\n\\n- https://gitlab.com/ligolang/ligo/-/merge_requests/2853\\n- https://gitlab.com/ligolang/ligo/-/merge_requests/2661\\n\\n### New bitwise operators\\n\\nThe following operators have been added, and can be used with `nat` and `bytes`.\\n\\n- `&` Bitwise _and_\\n- `|` Bitwise _or_\\n- `^` Bitwise _xor_\\n- `<<` Bitwise left shift (the shift amount is always a `nat\\\\, even when shifting `bytes`)\\n- `>>` Bitwise right shift (the shift amount is always a `nat\\\\, even when shifting `bytes`)\\n\\nHere are examples of these operators in context:\\n\\n```jsligo\\nconst zero: nat = 2n & 1n; // Bitwise and\\nconst two_bytes : bytes = 0x11 & 0x10\\n\\nconst five: nat = 4n | 1n; // Bitwise or\\nconst three_bytes : bytes = 0x11 | 0x10\\n\\nconst three : nat = 2n ^ 1n; // Bitwise xor\\nconst one_byte : bytes = 0x11 ^ 0x10\\n\\nconst four : nat = 2n << 1n // Bitwise left shift\\nconst five_one_two : bytes = 0x0100 << 1n\\n\\nconst one : nat = 2n >> 1n; // Bitwise right shift\\nconst zero_bytes : bytes = 0x01 >> 1n\\n```\\n\\nMRs:\\n\\n- https://gitlab.com/ligolang/ligo/-/merge_requests/2661\\n\\n### Changes to pattern matching\\n\\nJsLIGO\'s pattern matchin is inspired by the [ECMAScript Pattern Matching proposal](https://github.com/tc39/proposal-pattern-matching). This section covers some of the changes this implies.\\n\\nThe new `when` keyword makes pattern matching more explicit.\\n\\nFurthermore, pattern matching is now a keyword, it is not anymore a function taking an object with cases as fields.\\n\\nThe `do { ... }` expression is equivalent to the `(() => { ... }) ()` thunk, i.e. it allows a block of code containing statements (like `const xyz = ...` or `return 42`) to be used where an expression is expected.\\n\\nTherefore, a simple pattern matching like the following:\\n\\n```jsligo skip\\nconst force_positive = (key: string, dict: map<string, int>) => {\\n  return match(Map.find_opt (key, dict), {\\n    Some: (val : int) => {\\n        if (val >= 0) {\\n            return val;\\n        } else {\\n            failwith(\\"Negative value.\\");\\n        }\\n    },\\n    None: () => failwith(\\"Not found.\\")\\n  });\\n}\\n```\\n\\nbecomes:\\n\\n```jsligo\\nconst force_positive = (key: string, dict: map<string, int>) => {\\n  return match(Map.find_opt (key, dict)) {\\n    when(Some(val)): do {\\n        if (val >= 0) {\\n            return val;\\n        } else {\\n            failwith(\\"Negative value\\");\\n        }\\n    };\\n    when(None()): failwith(\\"Not found.\\")\\n  };\\n}\\n```\\n\\nPattern-matching on lists uses the syntaxes `when([])` and `when([head, ...tail])`:\\n\\n```jsligo\\ntype storage = [int, list <int>];\\ntype parameter = list <int>;\\ntype returnx = [list <operation>, storage];\\n\\nlet main = (p : parameter, s : storage) : returnx => {\\n  let storage = match (p) {\\n    when([]): s;\\n    when([hd, ...tl]): [s[0] + hd, tl]\\n  };\\n  return [([] as list<operation>), storage];\\n};\\n```\\n\\nFurthermore, there are a few changes to how patterns are written:\\n\\n- Patterns for parameterless constructors take a `()` within the `when(...)`, therefore `Nil: () => 1` becomes `when(Nil()): 1`\\n- Patterns which match a constructor containing a tuple work similarly, e.g. `Cons: (pair) => pair.1 + f(pair.2)` becomes `when(Cons(pair)) => pair.1 + f(pair.2)`\\n- Patterns with one variable per parameter are written as expected: `Foo: (a, b) => a + b` becomes `when(Foo(a, b)): a + b`\\n\\nMRs:\\n\\n- https://gitlab.com/ligolang/ligo/-/merge_requests/2661\\n\\n### `_` is now a valid variable name and can\'t be used for its former throw-away semantics\\n\\nPreviously, following the tradition of some functional languages, `_` was used to discard the value bound to it, e.g.\\n\\n```jsligo skip\\n// don\'t do this anymore\\nconst f = () => {\\n  let _ = some_check();\\n  return match (foobar) {\\n    when([]) : \\"empty list\\";\\n    when([_, ..._]): \\"non-empty list\\";\\n  };\\n}\\n```\\n\\nInstead, `_` is now a normal variable name, following the JavaScript and TypeScript tradition, where `_` is used as a short\\nname for a namespace containing many utilities, e.g. as an alias for the `lodash` library. This means that the code above should now assign unique names to the discarded value, like so:\\n\\n```jsligo skip\\n// don\'t do this anymore\\nconst f = () => {\\n  let _chk = some_check();\\n  return match (foobar) {\\n    when([]) : \\"empty list\\";\\n    when([_hd, ..._tl]): \\"non-empty list\\";\\n  };\\n}\\n```\\n\\nIf multiple _ variable are bound in the same scope, it will result in an error (duplicate block-scoped variable) just as in TypeScript. However, it is still possible to shadow a `_`within a smaller scope, e.g. if`_`is globally defined as an alias for another module, a function can still specify`_` as an argument name and shadow the global definition, which could cause issues. It is wise to skim over existing code for such cases.\\n\\nMRs:\\n\\n- https://gitlab.com/ligolang/ligo/-/merge_requests/2674\\n\\n### Imports are now automatically re-exported\\n\\nWhen a module is imported e.g. with `#import \\"foo.jsligo\\" \\"Foo\\"` inside the file `bar.jsligo`, it is automatically re-exported.\\n\\nFor example, a third file importing `bar.jsligo` as `Bar` can write `Bar.Foo.x` to access the `x` defined in `foo.jsligo`\\n\\nMRs:\\n\\n- https://gitlab.com/ligolang/ligo/-/merge_requests/2815\\n\\n### Miscellaneous\\n\\n- `true` and `false` are now keywords (not variables), and cannot be shadowed by a local variable declaration. https://gitlab.com/ligolang/ligo/-/merge_requests/2661\\n\\n## CameLIGO\\n\\n### Field and tuple component access\\n\\nFields and tuple components can be accessed with the same dot notation:\\n\\n```cameligo\\nlet stuff = {\\n    x = \\"foo\\";\\n    y = (42, \\"life\\", { universe = true });\\n}\\n\\nlet part : bool = stuff.y.2.universe\\n```\\n\\nMRs:\\n\\n- https://gitlab.com/ligolang/ligo/-/merge_requests/2661\\n\\n### Package management: use ligo.json instead of package.json or esy.json\\n\\nUsers often work with JaveScript toolchain alongside ours. Using package.json to manage both is tricky. It\'s better to have a separate manfiest to manage ligo dependencies. We therefore now use a separate `ligo.json` maninfest to manage LIGO packages.\\n\\nAs part of this change, we are no longer using the `esy` tool for package management, and the `installation.json` file, formerly located at `_esy/ligo/installation.json`, should now be moved to `_ligo/ligo/installation.json`.\\n\\nMRs:\\n\\n- https://gitlab.com/ligolang/ligo/-/merge_requests/2817\\n- https://gitlab.com/ligolang/ligo/-/merge_requests/2785\\n- https://gitlab.com/ligolang/ligo/-/merge_requests/2883\\n\\n\x3c!-- updated use of entry --\x3e"},{"id":"layout-comb-how","metadata":{"permalink":"/previews/ligo/modules/blog/layout-comb-how","source":"@site/blog/2023-09-09-layout-comb-how.md","title":"How to deal with the change of the default datatype layout to @layout comb ?","description":"Explore the challenges and solutions associated with the default datatype layout change to @layout comb in LIGO 1.0. For a comprehensive background on the change, refer to our \\"Why\\" article.","date":"2023-09-09T00:00:00.000Z","formattedDate":"September 9, 2023","tags":[{"label":"explainer","permalink":"/previews/ligo/modules/blog/tags/explainer"}],"readingTime":4.04,"hasTruncateMarker":true,"authors":[{"name":"Tom Jack","title":"Developer at Ligo","url":"https://gitlab.com/tomjack","email":"tom@marigold.dev","imageURL":"https://secure.gravatar.com/avatar/d62c4ef79b9ef198c43a82d555fbd5fa9510464195223b160771910eb991e6fc?s=800&d=identicon","key":"tomjack"}],"frontMatter":{"title":"How to deal with the change of the default datatype layout to @layout comb ?","description":"Explore the challenges and solutions associated with the default datatype layout change to @layout comb in LIGO 1.0. For a comprehensive background on the change, refer to our \\"Why\\" article.","slug":"layout-comb-how","authors":["tomjack"],"tags":["explainer"],"image":"https://i.imgur.com/mErPwqL.png","hide_table_of_contents":true},"prevItem":{"title":"Migration to LIGO v1.0","permalink":"/previews/ligo/modules/blog/v1-migration-guide"},"nextItem":{"title":"Why did the default datatype layout change to @layout comb?","permalink":"/previews/ligo/modules/blog/layout-comb-why"}},"content":"See [Why did the default datatype layout change to `@layout comb` ?](/blog/layout-comb-why)\\nfor background about this change.\\n\\n\x3c!--truncate--\x3e\\n\\n## Easy way out\\n\\nTo take the easy way out, set the `LIGO_LEGACY_LAYOUT_TREE`\\nenvironment variable:\\n\\n```shell\\nexport LIGO_LEGACY_LAYOUT_TREE=\\n```\\n\\nThis will cause LIGO to undo the change, letting `@layout tree` remain\\nthe default.\\n\\nThis is only a temporary solution, intended to let people easily\\nmigrate to LIGO 1.0, which should be considered already deprecated\\nas it will eventually be removed.\\n\\n## What\'s the problem?\\n\\nIf you do not take the easy way out, it\'s important to understand the\\nproblem.\\n\\nIn theory, it is possible that after upgrading to LIGO 1.0, your\\ncontracts could compile successfully, your `ligo run test` could pass,\\nand even \\"integration\\" tests (e.g. using a sandbox or test Tezos\\nnetwork) could pass, yet after deployment you might still find that\\nyour contracts are catastrophically broken.\\n\\nThis can happen if your contracts need to interact with other\\ncontracts, which are either:\\n\\n- already deployed on mainnet, or\\n- compiled using an older version of LIGO, or\\n- compiled using a non-LIGO compiler, or\\n- implementing some standardized interface\\n\\nIf the compiled interface types (parameter, view, ...) for these\\ninteractions change when you upgrade to LIGO 1.0, because you\\npreviously (implicitly) used `@layout tree` and now the types use\\n`@layout comb`, this will break compatibility, and the interactions\\nwill fail.\\n\\nFor example, consider the following test, involving communication\\nbetween two contracts over a parameter type `foo`:\\n\\n<Syntax syntax=\\"cameligo\\">\\n\\n```cameligo\\ntype foo =\\n  { foo : nat ;\\n    bar : int ;\\n    baz : string }\\n\\nmodule Foo = struct\\n  [@entry]\\n  let foo (_ : foo) (s : unit) : operation list * unit =\\n    ([], s)\\n\\n  (* dummy entrypoint to avoid bug with single entrypoint :( *)\\n  [@entry]\\n  let dummy (_ : unit) (s : unit) : operation list * unit =\\n    ([], s)\\nend\\n\\nmodule Bar = struct\\n  [@entry]\\n  let bar (addr : address) (s : unit) : operation list * unit =\\n    let arg : foo = {foo = 1n; bar = 2; baz = \\"three\\"} in\\n    let amt : tez = 0tz in\\n    let dst : foo contract = Tezos.get_entrypoint \\"%foo\\" addr in\\n    let tx = Tezos.transaction arg amt dst in\\n    ([tx], s)\\n\\n  (* dummy entrypoint to avoid bug with single entrypoint :( *)\\n  [@entry]\\n  let dummy (_ : unit) (s : unit) : operation list * unit =\\n    ([], s)\\nend\\n\\nlet test_interaction () =\\n  let orig_foo = Test.originate (contract_of Foo) () 0tz in\\n  let foo_addr = Test.to_address orig_foo.addr in\\n  let orig_bar = Test.originate (contract_of Bar) () 0tz in\\n  Test.transfer_exn orig_bar.addr (Bar foo_addr) 0tz\\n```\\n\\n</Syntax>\\n\\n<Syntax syntax=\\"jsligo\\">\\n\\n```jsligo\\ntype foo = {\\n  foo : nat,\\n  bar : int,\\n  baz : string\\n}\\n\\nnamespace Foo {\\n  @entry\\n  const foo = (_: foo, s: unit) : [list<operation>, unit] => [[], s];\\n\\n  // dummy entrypoint to avoid bug with single entrypoint :(\\n  @entry\\n  const dummy = (_: unit, s: unit) : [list<operation>, unit] => [[], s];\\n};\\n\\nnamespace Bar {\\n  @entry\\n  const bar = (addr: address, s: unit) : [list<operation>, unit] => {\\n    const arg : foo = {foo: 1n, bar: 2, baz: \\"three\\"};\\n    const amt : tez = 0tz;\\n    const dst : contract<foo> = Tezos.get_entrypoint(\\"%foo\\", addr);\\n    const tx = Tezos.transaction(arg, amt, dst);\\n    return [[tx], s];\\n  }\\n\\n  // dummy entrypoint to avoid bug with single entrypoint :(\\n  @entry\\n  const dummy = (_: unit, s: unit) : [list<operation>, unit] => [[], s];\\n};\\n\\nconst test_interaction = do{\\n  const orig_foo = Test.originate(contract_of(Foo), unit, 0tz);\\n  const foo_addr = Test.to_address (orig_foo.addr);\\n  const orig_bar = Test.originate(contract_of(Bar), unit, 0tz);\\n  Test.transfer_exn(orig_bar.addr, Bar(foo_addr), 0tz);\\n};\\n```\\n\\n</Syntax>\\n\\nNote that this test will pass after upgrading to LIGO 1.0, because\\nwhen running the test, both `Foo` and `Bar` use the `comb` layout for\\nthe parameter type `foo`. However, if there is already a `Foo`\\ncontract deployed on mainnet, e.g. compiled using an older LIGO\\nversion, then a newly compiled `Bar` contract will be unable to\\ncommunicate with it, because the new `foo` type will be incompatible!\\n\\nSo, in order to test that your contracts still work correctly, you\\nmust either manually check that the interface types have changed, or\\ntest interactions with the actual contracts you will need to interact\\nwith.\\n\\nIn particular, if you are testing compatibility for interactions, you\\nshould NOT only test interactions against contracts compiled using\\nLIGO 1.0, e.g. using `ligo test`, because those contracts will use the\\nnew layout too!\\n\\nIf, on the other hand, you will deploy a _new_ set of contracts which\\nonly interact amongst themselves, then you have nothing to worry\\nabout. It is only interactions with pre-existing or standardized\\ncontracts that can cause trouble.\\n\\n## How to deal with compatibility problems?\\n\\nIf you have compatibility problems like this, and you don\'t take the\\neasy way out with `LIGO_LEGACY_LAYOUT_TREE`, you might need to switch\\nsome types back to the tree layout.\\n\\nHere are some examples of how to do that:\\n\\n<Syntax syntax=\\"cameligo\\">\\n\\n```cameligo\\ntype tree_record =\\n  [@layout tree]\\n  { foo : nat ;\\n    bar : int ;\\n    baz : string }\\n\\ntype tree_variant =\\n  [@layout tree]\\n  | Foo of nat\\n  | Bar of int\\n  | Baz of string\\n\\ntype tree_tuple =\\n  [@layout tree] (nat * int * string)\\n  (* the parentheses are required, else the @layout attribute will\\n     attach to the first tuple field instead of the tuple type *)\\n\\nlet anon_tree_tuple (p : [@layout tree] (nat * int * string)) : [@layout tree] (nat * int * string) = p\\n```\\n\\n</Syntax>\\n\\n<Syntax syntax=\\"jsligo\\">\\n\\n```jsligo\\ntype tree_variant =\\n  @layout(\\"tree\\")\\n  | [\\"Foo\\", nat]\\n  | [\\"Bar\\", int]\\n  | [\\"Baz\\", string];\\n\\ntype tree_record =\\n  @layout(\\"tree\\")\\n  {\\n    foo : int,\\n    bar : int\\n  };\\n\\n// in JsLIGO, you must assign names to tuple types in order to put\\n// them back into tree layout, and then use these names at use sites instead\\n// of repeating the tuple type\\n\\ntype tree_tuple = @layout(\\"tree\\") [nat, int, string];\\n```\\n\\n</Syntax>\\n\\n## Type errors from layouts\\n\\nIn some cases, you may get type errors due to mismatched type layouts.\\n\\nHere is an example. Before LIGO 1.0, this code worked OK:\\n\\n<Syntax syntax=\\"cameligo\\">\\n\\n```cameligo skip\\ntype record1 =\\n  { foo : nat ;\\n    bar : int ;\\n    baz : string }\\n\\ntype record2 =\\n  { baz : string ;\\n    bar : int ;\\n    foo : nat }\\n\\nlet id (r : record1) : record2 = r\\n```\\n\\n</Syntax>\\n\\n<Syntax syntax=\\"jsligo\\">\\n\\n```jsligo skip\\ntype record1 = {\\n  foo : nat,\\n  bar : int,\\n  baz : string\\n}\\n\\ntype record2 = {\\n  baz : string,\\n  bar : int,\\n  foo : nat\\n}\\n\\nconst id = (r: record1): record2 => r;\\n```\\n\\n</Syntax>\\n\\nHowever, as of LIGO 1.0, this example gives a type error:\\n\\n```\\nInvalid type(s)\\nCannot unify \\"record1\\" with \\"record2\\" due to differing layouts \\"({ name: foo }, { name: bar }, { name: baz })\\" and \\"({ name: baz }, { name: bar }, { name: foo })\\"\\n```\\n\\nThe reason for this is that in the old `tree` layout, the fields were sorted alphabetically, but in the `comb` layout they are taken in the declared order.\\n\\nYou can fix this problem either by switching back to the `tree` layout (see the previous section) or by writing the fields in a consistent order.\\n\\n\x3c!-- updated use of entry --\x3e"},{"id":"layout-comb-why","metadata":{"permalink":"/previews/ligo/modules/blog/layout-comb-why","source":"@site/blog/2023-09-09-layout-comb-why.md","title":"Why did the default datatype layout change to @layout comb?","description":"Discover the evolution of Michelson data type layouts in LIGO and the shift to @layout comb as the default choice in version 1.0. Explore the benefits, including improved performance and code size reduction.","date":"2023-09-09T00:00:00.000Z","formattedDate":"September 9, 2023","tags":[{"label":"explainer","permalink":"/previews/ligo/modules/blog/tags/explainer"}],"readingTime":1.5766666666666667,"hasTruncateMarker":true,"authors":[{"name":"Tom Jack","title":"Developer at Ligo","url":"https://gitlab.com/tomjack","email":"tom@marigold.dev","imageURL":"https://secure.gravatar.com/avatar/d62c4ef79b9ef198c43a82d555fbd5fa9510464195223b160771910eb991e6fc?s=800&d=identicon","key":"tomjack"}],"frontMatter":{"title":"Why did the default datatype layout change to @layout comb?","description":"Discover the evolution of Michelson data type layouts in LIGO and the shift to @layout comb as the default choice in version 1.0. Explore the benefits, including improved performance and code size reduction.","slug":"layout-comb-why","authors":["tomjack"],"tags":["explainer"],"image":"https://i.imgur.com/mErPwqL.png","hide_table_of_contents":true},"prevItem":{"title":"How to deal with the change of the default datatype layout to @layout comb ?","permalink":"/previews/ligo/modules/blog/layout-comb-how"}},"content":"When compiling to Michelson, LIGO must choose a \\"layout\\" for record\\nand variant data types. Unfortunately, Michelson only has binary\\n`pair`/`or` types, for esoteric theoretical reasons.\\n\\nThis means that for each record or variant type, LIGO must pick one of\\nthe many isomorphic binary tree structures which can represent it in\\nMichelson. This choice needs to be consistent (else we will get type\\nerrors) and ideally it should be flexible (so that users can\\ninteroperate with Michelson types defined in standards or emitted by\\nother compilers.)\\n\\n\x3c!--truncate--\x3e\\n\\n## Background\\n\\nIn early versions of LIGO, two layouts were supported: `tree` and\\n`comb`.\\n\\nLayout `tree` was made the default, primarily because this layout\\nsupports record field access and update with cost O(log n), where n is\\nthe number of fields in the record type. This layout also sorted\\nfields alphabetically by name, which made it compatible with LIGO\'s\\nstructural handling of record and variant types at the time, where\\norder doesn\'t matter.\\n\\nThe `tree` layout was also used for tuple types, and originally this\\ncould not be changed.\\n\\nThe `comb` layout was also supported because it was expected that it\\nwould show up in standards and in interop with Michelson generated by\\nother compilers (and indeed it did.) At some point, LIGO was modified\\nto preserve the order of comb layout record fields and variant cases,\\nsince this is useful for interop. (The order now also matters for\\nthese types; two comb-layout record types are equal in LIGO only if\\ntheir fields are in the same order.)\\n\\nOriginally, the comb layout had worse performance, with cost O(n) for\\nrecord field access and updates.\\n\\n## Why change the default?\\n\\nSince then, Michelson has added native O(log n) record field accesses\\nand updates with the `comb` layout. Additionally, there is an n-ary\\n`pair x y z ...` notation for comb layout, which makes large comb pair\\ntypes cheaper and more readable.\\n\\nThus, current best practice is for LIGO developers to almost always\\nmark record and tuple types as `@layout comb`. This generally leads to\\nsmaller code size, and so less gas and storage burn.\\n\\nIt would be more convenient if this were the default. Unfortunately,\\nchanging the default is a breaking change. But with 1.0, we are taking\\nthe chance to finally make this breaking change...\\n\\nVariant types still do not have any special comb support in Michelson\\n(again, for esoteric theoretical reasons.) However, for consistency\\nand simplicity, we are making comb layout the default always. We\\nbelieve that in most cases, the difference will not be\\nsignificant. Users can explicitly mark variants as `@layout tree` if\\ndesired.\\n\\n## What do I do?\\n\\nSee the [How to deal with the change of the default datatype layout to `@layout comb` ?](/blog/layout-comb-how) doc for advice on how to deal\\nwith this breaking change.\\n\\n\x3c!-- updated use of entry --\x3e"}]}')}}]);