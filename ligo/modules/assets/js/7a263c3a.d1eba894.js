"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[17377],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=c(n),h=o,d=m["".concat(l,".").concat(h)]||m[h]||u[h]||i;return n?a.createElement(d,r(r({ref:t},p),{},{components:n})):a.createElement(d,r({ref:t},p))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,r[1]=s;for(var c=2;c<i;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},26596:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var a=n(87462),o=(n(67294),n(3905));const i={id:"michelson",title:"Michelson"},r=void 0,s={unversionedId:"tezos/contracts/michelson",id:"version-1.5.0/tezos/contracts/michelson",title:"Michelson",description:"Currently LIGO compiles to",source:"@site/versioned_docs/version-1.5.0/tezos/contracts/michelson.md",sourceDirName:"tezos/contracts",slug:"/tezos/contracts/michelson",permalink:"/previews/ligo/modules/docs/1.5.0/tezos/contracts/michelson",draft:!1,tags:[],version:"1.5.0",frontMatter:{id:"michelson",title:"Michelson"},sidebar:"docs",previous:{title:"Contract of module/namespace",permalink:"/previews/ligo/modules/docs/1.5.0/tezos/contracts/contract_of"},next:{title:"Michelson injection",permalink:"/previews/ligo/modules/docs/1.5.0/tezos/contracts/michelson-injection"}},l={},c=[{value:"Stack versus variables",id:"stack-versus-variables",level:3}],p={toc:c};function u(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Currently LIGO compiles to\n",(0,o.kt)("a",{parentName:"p",href:"https://tezos.gitlab.io/whitedoc/michelson.html"},"Michelson"),", the\nnative smart contract language supported by Tezos. This page explains\nthe relationship between LIGO and the underlying Michelson it compiles\nto. Understanding Michelson is not a requirement to use LIGO, but it\ndoes become important if you want to tune the performance of contracts\noutputted by the LIGO compiler."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"The rationale and design of Michelson")),(0,o.kt)("p",null,"Michelson is a Domain-Specific Language (DSL) for writing Tezos smart\ncontracts inspired by Lisp and Forth. This unusual lineage aims at\nsatisfying unusual constraints, but entails some tensions in the\ndesign."),(0,o.kt)("p",null,"First, to measure step-wise gas consumption, ",(0,o.kt)("em",{parentName:"p"},"Michelson is\ninterpreted"),"."),(0,o.kt)("p",null,"On the one hand, to assess gas usage per instruction, instructions\nshould be simple, which points to low-level features (a RISC-like\nlanguage). On the other hand, it was originally thought that users\nwill want to write in Michelson instead of lowering a language to\nMichelson, because the gas cost would otherwise be harder to\npredict. This means that ",(0,o.kt)("em",{parentName:"p"},"high-level features")," were deemed necessary\n(like a restricted variant of Lisp lambdas, a way to encode algebraic\ndata types, as well as built-in sets, maps and lists)."),(0,o.kt)("p",null,"To avoid ambiguous and otherwise misleading contracts, the layout of\nMichelson contracts has been constrained (e.g., indentation, no\nUTF-8), and a ",(0,o.kt)("em",{parentName:"p"},"canonical form")," was designed and enforced when storing\ncontracts on the chain."),(0,o.kt)("p",null,"To reduce the size of the code, Michelson was designed as ",(0,o.kt)("em",{parentName:"p"},"a\nstack-based language"),", whence the lineage from Forth and other\nconcatenative languages like PostScript, Joy, Cat, Factor etc. (Java\nbyte-code would count too.)"),(0,o.kt)("p",null,"Programs in those languages are ",(0,o.kt)("em",{parentName:"p"},"compact")," because they assume an\nimplicit stack in which some input values are popped, and output\nvalues are pushed, according to the current instruction being\nexecuted."),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Each Michelson instruction modifies a prefix of the stack"),", that is,\na segment starting at the top."),(0,o.kt)("p",null,"Whilst the types of Michelson instructions can be polymorphic, their\ninstantiations must be monomorphic, hence ",(0,o.kt)("em",{parentName:"p"},"Michelson instructions are\nnot first-class values")," and cannot be partially interpreted."),(0,o.kt)("p",null,"This enables a simple ",(0,o.kt)("em",{parentName:"p"},"static type checking"),", as opposed to a complex\ntype inference. It can be performed efficiently: ",(0,o.kt)("em",{parentName:"p"},"contract type\nchecking consumes gas"),". Basically, type checking aims at validating\nthe composition of instructions, therefore is key to safely composing\ncontracts (concatenation, activations). Once a contract passes type\nchecking, it cannot fail due to inconsistent assumptions on the\nstorage and other values (there are no null values, no casts), but it\ncan still fail for other reasons: division by zero, token exhaustion,\ngas exhaustion, or an explicit ",(0,o.kt)("inlineCode",{parentName:"p"},"FAILWITH")," instruction. This property\nis called ",(0,o.kt)("em",{parentName:"p"},"type safety"),". Also, such a contract cannot remain stuck:\nthis is the ",(0,o.kt)("em",{parentName:"p"},"progress property"),"."),(0,o.kt)("p",null,"The existence of a formal type system for Michelson, of a formal\nspecification of its dynamic semantics (evaluation), of a Michelson\ninterpreter in Coq, of proofs in Coq of properties of some typical\ncontracts, all those achievements are instances of ",(0,o.kt)("em",{parentName:"p"},"formal methods in\nTezos"),"."),(0,o.kt)("p",null,"Here is an example of a Michelson contract."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"counter.tz"))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-michelson"},"{ parameter (or (or (nat %add) (nat %sub)) (unit %default)) ;\n  storage int ;\n  code { AMOUNT ; PUSH mutez 0 ; ASSERT_CMPEQ ; UNPAIR ;\n         IF_LEFT\n           { IF_LEFT { ADD } { SWAP ; SUB } }\n           { DROP ; DROP ; PUSH int 0 } ;\n         NIL operation ; PAIR } }\n")),(0,o.kt)("p",null,"The contract above maintains an ",(0,o.kt)("inlineCode",{parentName:"p"},"int")," as its storage. It has two\n",(0,o.kt)("a",{parentName:"p",href:"https://tezos.gitlab.io/whitedoc/michelson.html#entrypoints"},"entrypoints"),",\n",(0,o.kt)("inlineCode",{parentName:"p"},"add")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"sub"),", to modify it, and the ",(0,o.kt)("inlineCode",{parentName:"p"},"default")," entrypoint of type\n",(0,o.kt)("inlineCode",{parentName:"p"},"unit")," will reset it to ",(0,o.kt)("inlineCode",{parentName:"p"},"0"),"."),(0,o.kt)("p",null,"The contract itself contains three sections:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"parameter")," - The argument provided by a transaction invoking the contract."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"storage")," - The type definition for the contract's data storage."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"code")," - Actual Michelson code that has the provided parameter and\nthe current storage value in its initial stack. It outputs in the\nresulting stack a pair made of a list of operations and a new\nstorage value.")),(0,o.kt)("p",null,"Michelson code consists of ",(0,o.kt)("em",{parentName:"p"},"instructions")," like ",(0,o.kt)("inlineCode",{parentName:"p"},"IF_LEFT"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"PUSH ..."),",\n",(0,o.kt)("inlineCode",{parentName:"p"},"UNPAIR")," etc. that are composed sequentially in what is called a\n",(0,o.kt)("em",{parentName:"p"},"sequence"),". The implicit stack contains at all times the state of the\nevaluation of the program, whilst the storage represents the\npersistent state. If the contract execution is successful, the new\nstorage state will be committed to the chain and become visible to all\nthe nodes. Instructions are used to transform a prefix of the stack,\nthat is, the topmost part of it, for example, by duplicating its top\nelement, dropping it, subtracting the first two etc."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"A Michelson program running on the Tezos blockchain is meant to\noutput a pair of values including a ",(0,o.kt)("inlineCode",{parentName:"p"},"list of operations")," to include\nin a transaction, and a new ",(0,o.kt)("inlineCode",{parentName:"p"},"storage")," value to persist on the chain.")),(0,o.kt)("h3",{id:"stack-versus-variables"},"Stack versus variables"),(0,o.kt)("p",null,"Perhaps the biggest challenge when programming in Michelson is the\nlack of ",(0,o.kt)("em",{parentName:"p"},"variables")," to denote the data: the stack layout has to be\nkept in mind when retrieving and storing data. For example, let us\nimplement a program in JavaScript that is similar to the Michelson\nabove:"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"counter.js"))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},'var storage = 0;\n\nfunction add (a) { storage += a; }\nfunction sub (a) { storage -= a; }\n\n// We are calling this function "reset" instead of "default"\n// because `default` is a Javascript keyword\n\nfunction reset () { storage = 0; }\n')),(0,o.kt)("p",null,"In our JavaScript program the initial ",(0,o.kt)("inlineCode",{parentName:"p"},"storage")," value is ",(0,o.kt)("inlineCode",{parentName:"p"},"0")," and it\ncan be modified by calling ",(0,o.kt)("inlineCode",{parentName:"p"},"add (a)"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"sub (a)")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"reset ()"),"."),(0,o.kt)("p",null,"We cannot run JavaScript on the Tezos blockchain, but we can choose\nLIGO, which will abstract the stack management and allow us to create\nreadable, type-safe, and efficient smart contracts."),(0,o.kt)("p",null,"The JsLIGO program is very similar to the above naive JavaScript example.\nThe notable differences are:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"the main functions return the new storage, instead of updating it"),(0,o.kt)("li",{parentName:"ul"},"the main functions also return a list of operations, this is used to transfer tokens out of the contract to other addresses"),(0,o.kt)("li",{parentName:"ul"},"As in TypeScript, we need to specify the input / output type of some functions, where the compiler cannot guess them. This helps the compiler perform extra checks and weed off some bugs before they ever happen.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo"},"type t_storage = int\ntype result = [list<operation>, t_storage]\n\n@entry\nfunction add (a, storage) : result { return [list([]), storage + a]; }\n\n@entry\nfunction sub (a, storage) : result { return [list([]), storage - a]; }\n\n@entry\nfunction reset (_: unit, _storage: t_storage) : result { return [list([]), 0]; }\n")))}u.isMDXComponent=!0}}]);