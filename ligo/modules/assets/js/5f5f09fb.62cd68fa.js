"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[29707],{48720:(e,t,n)=>{n.d(t,{D:()=>l.Z,Z:()=>a});var i=n(67294),l=n(75402);const a=function(e){return i.createElement(l.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:i.createElement(i.Fragment,null)}))}},99191:(e,t,n)=>{n.d(t,{Z:()=>r});var i=n(43164),l=n(67294),a=n(52263),p=n(48720),s=n(11506);function o(){return o=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var i in n)Object.prototype.hasOwnProperty.call(n,i)&&(e[i]=n[i])}return e},o.apply(this,arguments)}const{Prism:m}=n(43164);m.languages={...m.languages,cameligo:{...m.languages.ocaml,comment:[/(^|[^\\])\/\*[\s\S]*?\*\//,/\(\*[\s\S]*?\*\)/,/\/\/.*/]},jsligo:m.languages.typescript};const r=function(e){const{siteConfig:{themeConfig:{prism:t={}}}}=(0,a.Z)(),n=t.singleTheme||s.Z,[m,r]=(0,l.useState)(!1);return(0,l.useEffect)((()=>{r(!0)}),[]),l.createElement(p.D.Consumer,null,(t=>{let{syntax:a}=t;return a===e.syntax?l.createElement(i.default,o({},i.defaultProps,{key:m,language:e.syntax,code:e.children,theme:n}),(e=>{let{className:t,tokens:n,getLineProps:i,getTokenProps:a}=e;return l.createElement("h4",{className:t,style:{backgroundColor:"var(--ifm-background-color)",fontFamily:"var(--ifm-font-family-monospace)",lineHeight:"var(--ifm-pre-line-height)",fontSize:"1.1rem",fontWeight:"bold",padding:0,whiteSpace:"break-spaces",marginTop:"3rem"}},n.map(((e,t)=>l.createElement("div",i({line:e,key:t}),e.map(((e,t)=>l.createElement("span",a({token:e,key:t}))))))))})):l.createElement("div",null)}))}},337:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>o,default:()=>y,frontMatter:()=>s,metadata:()=>m,toc:()=>d});var i=n(87462),l=(n(67294),n(3905)),a=n(48720),p=n(99191);const s={id:"list-reference",title:"list",hide_table_of_contents:!0},o=void 0,m={unversionedId:"reference/list-reference",id:"reference/list-reference",title:"list",description:"Lists",source:"@site/../docs/reference/list.md",sourceDirName:"reference",slug:"/reference/list-reference",permalink:"/previews/ligo/modules/docs/next/reference/list-reference",draft:!1,tags:[],version:"current",frontMatter:{id:"list-reference",title:"list",hide_table_of_contents:!0},sidebar:"API",previous:{title:"big_map",permalink:"/previews/ligo/modules/docs/next/reference/big-map-reference"},next:{title:"bitwise",permalink:"/previews/ligo/modules/docs/next/reference/bitwise-reference"}},r={},d=[],k={toc:d};function y(e){let{components:t,...n}=e;return(0,l.kt)("wrapper",(0,i.Z)({},k,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"Lists"),(0,l.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type 'elt t = 'elt list"),(0,l.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type t<elt> = list<elt>"),"The type `t` is an alias for the predefined type `list`.",(0,l.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val empty : 'elt.'elt t"),(0,l.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let empty: <elt>t<elt>"),(0,l.kt)(a.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The value ",(0,l.kt)("inlineCode",{parentName:"p"},"List.empty")," is the empty list. It is a synonym for\n",(0,l.kt)("inlineCode",{parentName:"p"},"[]"),". In some contexts, it is useful to annotate it with its type,\nfor example: ",(0,l.kt)("inlineCode",{parentName:"p"},"(empty : int list)"),".")),(0,l.kt)(a.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The value ",(0,l.kt)("inlineCode",{parentName:"p"},"List.empty")," is the empty list. It is a synonym for\n",(0,l.kt)("inlineCode",{parentName:"p"},"list([])"),". In some contexts, it is useful to annotate it with its\ntype, for example: ",(0,l.kt)("inlineCode",{parentName:"p"},"(empty as list<int>)"),".")),(0,l.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val length : 'elt.'elt t -> nat"),(0,l.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let length: <elt>(_: t<elt>) => nat"),(0,l.kt)(a.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"List.length l")," is the number of elements in the list\n",(0,l.kt)("inlineCode",{parentName:"p"},"l"),". Note: ",(0,l.kt)("inlineCode",{parentName:"p"},"List.length")," is another name for ",(0,l.kt)("inlineCode",{parentName:"p"},"List.size"),".")),(0,l.kt)(a.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"List.length(l)")," is the number of elements in the list\n",(0,l.kt)("inlineCode",{parentName:"p"},"l"),". Note: ",(0,l.kt)("inlineCode",{parentName:"p"},"List.length")," is another name for ",(0,l.kt)("inlineCode",{parentName:"p"},"List.size"),".")),(0,l.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val size : 'elt.'elt t -> nat"),(0,l.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let size: <elt>(_: t<elt>) => nat"),(0,l.kt)(a.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"List.size l")," is the number of elements in the list ",(0,l.kt)("inlineCode",{parentName:"p"},"l"),".")),(0,l.kt)(a.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"List.size(l)")," is the number of elements in the list ",(0,l.kt)("inlineCode",{parentName:"p"},"l"),".")),(0,l.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val head : 'elt.'elt t -> 'elt option"),(0,l.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let head: <elt>(_: t<elt>) => option<elt>"),(0,l.kt)(a.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"List.head l"),", where ",(0,l.kt)("inlineCode",{parentName:"p"},"l")," is a list, is ",(0,l.kt)("inlineCode",{parentName:"p"},"None")," if ",(0,l.kt)("inlineCode",{parentName:"p"},"l")," is\nempty; otherwise, ",(0,l.kt)("inlineCode",{parentName:"p"},"Some hd"),", where ",(0,l.kt)("inlineCode",{parentName:"p"},"hd")," is the head of the list.")),(0,l.kt)(a.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"List.head(l)"),", where ",(0,l.kt)("inlineCode",{parentName:"p"},"l")," is a list, is ",(0,l.kt)("inlineCode",{parentName:"p"},"None()")," if ",(0,l.kt)("inlineCode",{parentName:"p"},"l")," is\nempty; otherwise, ",(0,l.kt)("inlineCode",{parentName:"p"},"Some(hd)"),", where ",(0,l.kt)("inlineCode",{parentName:"p"},"hd")," is the head of the list.")),(0,l.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val head_opt : 'elt.'elt t -> 'elt option"),(0,l.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let head_opt: <elt>(_: t<elt>) => option<elt>"),"**Deprecated:** Use `List.head` instead.",(0,l.kt)(a.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"List.head_opt l"),", where ",(0,l.kt)("inlineCode",{parentName:"p"},"l")," is a list, is ",(0,l.kt)("inlineCode",{parentName:"p"},"None")," if ",(0,l.kt)("inlineCode",{parentName:"p"},"l")," is\nempty; otherwise, ",(0,l.kt)("inlineCode",{parentName:"p"},"Some hd"),", where ",(0,l.kt)("inlineCode",{parentName:"p"},"hd")," is the head of the list.")),(0,l.kt)(a.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"List.head_opt(l)"),", where ",(0,l.kt)("inlineCode",{parentName:"p"},"l")," is a list, is ",(0,l.kt)("inlineCode",{parentName:"p"},"None()")," if ",(0,l.kt)("inlineCode",{parentName:"p"},"l")," is\nempty; otherwise, ",(0,l.kt)("inlineCode",{parentName:"p"},"Some(hd)"),", where ",(0,l.kt)("inlineCode",{parentName:"p"},"hd")," is the head of the list.")),(0,l.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val tail : 'elt.'elt t -> 'elt t option"),(0,l.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let tail: <elt>(_: t<elt>) => option<t<elt>>"),(0,l.kt)(a.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"List.tail l"),", where ",(0,l.kt)("inlineCode",{parentName:"p"},"l")," is a list, is ",(0,l.kt)("inlineCode",{parentName:"p"},"None")," if ",(0,l.kt)("inlineCode",{parentName:"p"},"l")," is\nempty; otherwise, ",(0,l.kt)("inlineCode",{parentName:"p"},"Some tl"),", where ",(0,l.kt)("inlineCode",{parentName:"p"},"tl")," is the tail of the list.")),(0,l.kt)(a.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"List.tail(l)"),", where ",(0,l.kt)("inlineCode",{parentName:"p"},"l")," is a list, is ",(0,l.kt)("inlineCode",{parentName:"p"},"None()")," if ",(0,l.kt)("inlineCode",{parentName:"p"},"l")," is\nempty; otherwise, ",(0,l.kt)("inlineCode",{parentName:"p"},"Some(tl)"),", where ",(0,l.kt)("inlineCode",{parentName:"p"},"tl")," is the tail of the list.")),(0,l.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val tail_opt : 'elt.'elt t -> 'elt t option"),(0,l.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let tail_opt: <elt>(_: t<elt>) => option<t<elt>>"),"**Deprecated:** Use `List.tail` instead.",(0,l.kt)(a.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"List.tail_opt l"),", where ",(0,l.kt)("inlineCode",{parentName:"p"},"l")," is a list, is ",(0,l.kt)("inlineCode",{parentName:"p"},"None")," if ",(0,l.kt)("inlineCode",{parentName:"p"},"l")," is\nempty; otherwise, ",(0,l.kt)("inlineCode",{parentName:"p"},"Some tl"),", where ",(0,l.kt)("inlineCode",{parentName:"p"},"tl")," is the tail of the list.")),(0,l.kt)(a.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"List.tail_opt(l)"),", where ",(0,l.kt)("inlineCode",{parentName:"p"},"l")," is a list, is ",(0,l.kt)("inlineCode",{parentName:"p"},"None()")," if ",(0,l.kt)("inlineCode",{parentName:"p"},"l")," is\nempty; otherwise, ",(0,l.kt)("inlineCode",{parentName:"p"},"Some(tl)"),", where ",(0,l.kt)("inlineCode",{parentName:"p"},"tl")," is the tail of the list.")),(0,l.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val map : 'src 'dst.('src -> 'dst) -> 'src list -> 'dst list"),(0,l.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let map: <src, dst>(_: (_: src) => dst) => (_: list<src>) => list<dst>"),(0,l.kt)(a.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"List.map f [a1; ...; an]")," applies the function ",(0,l.kt)("inlineCode",{parentName:"p"},"f")," to ",(0,l.kt)("inlineCode",{parentName:"p"},"a1"),",\n..., ",(0,l.kt)("inlineCode",{parentName:"p"},"an")," (from left to right), and builds the list\n",(0,l.kt)("inlineCode",{parentName:"p"},"[f a1; ...; f an]")," with the results returned by ",(0,l.kt)("inlineCode",{parentName:"p"},"f"),".")),(0,l.kt)(a.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"List.map(f, list([a1; ...; an]))")," applies the function ",(0,l.kt)("inlineCode",{parentName:"p"},"f")," to\n",(0,l.kt)("inlineCode",{parentName:"p"},"a1"),", ..., ",(0,l.kt)("inlineCode",{parentName:"p"},"an")," (from left to right), and builds the list\n",(0,l.kt)("inlineCode",{parentName:"p"},"list([f(a1); ...; f(an)])")," with the results returned by ",(0,l.kt)("inlineCode",{parentName:"p"},"f"),".")),(0,l.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val iter : 'elt.('elt -> unit) -> 'elt t -> unit"),(0,l.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let iter: <elt>(_: (_: elt) => unit) => (_: t<elt>) => unit"),(0,l.kt)(a.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"List.iter f [a1; ...; an]")," applies the function ",(0,l.kt)("inlineCode",{parentName:"p"},"f")," in turn\nto ",(0,l.kt)("inlineCode",{parentName:"p"},"[a1; ...; an]"),". It is equivalent to\n",(0,l.kt)("inlineCode",{parentName:"p"},"let () = f a1 in let () = f a2 in ... in f an"),".")),(0,l.kt)(a.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"List.iter(f, list([a1; ...; an]))")," applies the function ",(0,l.kt)("inlineCode",{parentName:"p"},"f"),"\nin turn to ",(0,l.kt)("inlineCode",{parentName:"p"},"list([a1; ...; an])"),". It is equivalent to ",(0,l.kt)("inlineCode",{parentName:"p"},"{f(a1);\n    f(a2); ...; f(an)}"),".")),(0,l.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val fold_left : 'elt 'acc.(('acc * 'elt) -> 'acc) -> 'acc -> 'elt t -> 'acc"),(0,l.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let fold_left: <elt, acc>(_: (_: [acc, elt]) => acc) => (_: acc) => (_: t<elt>) => acc"),(0,l.kt)(a.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"List.fold_left f init [a1; ...; an]")," is\n",(0,l.kt)("inlineCode",{parentName:"p"},"f (... (f (f init a1) a2) ...) an"),".")),(0,l.kt)(a.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"List.fold_left(f, init, list([a1; ...; an]))")," is\n",(0,l.kt)("inlineCode",{parentName:"p"},"f (... (f (f(init, a1)), a2), ...), an)"),".")),(0,l.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val fold_right : 'elt 'acc.(('elt * 'acc) -> 'acc) -> 'elt t -> 'acc -> 'acc"),(0,l.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let fold_right: <elt, acc>(_: (_: [elt, acc]) => acc) => (_: t<elt>) => (_: acc) => acc"),(0,l.kt)(a.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"List.fold_right f [a1; ...; an] init")," is\n",(0,l.kt)("inlineCode",{parentName:"p"},"f a1 (f a2 (... (f an init) ...))"),".")),(0,l.kt)(a.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"List.fold_right(f, list([a1; ...; an]), init)")," is\n",(0,l.kt)("inlineCode",{parentName:"p"},"f (a1, f (a2, (..., f (an, init))...))"),".")),(0,l.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val fold : 'elt 'acc.(('acc * 'elt) -> 'acc) -> 'elt t -> 'acc -> 'acc"),(0,l.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let fold: <elt, acc>(_: (_: [acc, elt]) => acc) => (_: t<elt>) => (_: acc) => acc"),(0,l.kt)(a.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"List.fold f [a1; ...; an] init")," is\n",(0,l.kt)("inlineCode",{parentName:"p"},"f (... (f (f init a1) a2) ...) an"),". Note:\n",(0,l.kt)("inlineCode",{parentName:"p"},"List.fold_left f init list")," is the same as ",(0,l.kt)("inlineCode",{parentName:"p"},"List.fold f list init"),".")),(0,l.kt)(a.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"List.fold(f, list([a1; ...; an]), init)")," is\n",(0,l.kt)("inlineCode",{parentName:"p"},"f (... (f (f (init, a1), a2) ...), an)"),". Note:\n",(0,l.kt)("inlineCode",{parentName:"p"},"List.fold_left(f, init, list)")," is the same as ",(0,l.kt)("inlineCode",{parentName:"p"},"List.fold(f, list, init)"),".")),(0,l.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val cons : 'elt.'elt -> 'elt t -> 'elt t"),(0,l.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let cons: <elt>(_: elt) => (_: t<elt>) => t<elt>"),(0,l.kt)(a.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"List.cons e l")," is ",(0,l.kt)("inlineCode",{parentName:"p"},"e :: l"),".")),(0,l.kt)(a.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"List.cons(e, l)")," is ",(0,l.kt)("inlineCode",{parentName:"p"},"list([e, ...l])"),".")),(0,l.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val find_opt : 'elt.('elt -> bool) -> 'elt t -> 'elt option"),(0,l.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let find_opt: <elt>(_: (_: elt) => bool) => (_: t<elt>) => option<elt>"),(0,l.kt)(a.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"List.find_opt pred list")," is ",(0,l.kt)("inlineCode",{parentName:"p"},"None")," if no element of the\nlist ",(0,l.kt)("inlineCode",{parentName:"p"},"list")," satisfies the predicate ",(0,l.kt)("inlineCode",{parentName:"p"},"pred"),"; otherwise, it is\n",(0,l.kt)("inlineCode",{parentName:"p"},"Some e"),", where ",(0,l.kt)("inlineCode",{parentName:"p"},"e")," is the leftmost element in ",(0,l.kt)("inlineCode",{parentName:"p"},"list")," that satisfies\n",(0,l.kt)("inlineCode",{parentName:"p"},"pred"),". The order of the calls of ",(0,l.kt)("inlineCode",{parentName:"p"},"pred")," is not specified.")),(0,l.kt)(a.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"List.find_opt(pred, list)")," is ",(0,l.kt)("inlineCode",{parentName:"p"},"None()")," if no element of the\nlist ",(0,l.kt)("inlineCode",{parentName:"p"},"list")," satisfies the predicate ",(0,l.kt)("inlineCode",{parentName:"p"},"pred"),"; otherwise, it is\n",(0,l.kt)("inlineCode",{parentName:"p"},"Some(e)"),", where ",(0,l.kt)("inlineCode",{parentName:"p"},"e")," is the leftmost element in ",(0,l.kt)("inlineCode",{parentName:"p"},"list")," that satisfies\n",(0,l.kt)("inlineCode",{parentName:"p"},"pred"),". The order of the calls of ",(0,l.kt)("inlineCode",{parentName:"p"},"pred")," is not specified.")),(0,l.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val filter_map : 'src 'dst.('src -> 'dst option) -> 'src list -> 'dst list"),(0,l.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let filter_map: <src, dst>(_: (_: src) => option<dst>) => (_: list<src>) => list<dst>"),(0,l.kt)(a.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"List.filter_map f l")," is the maximal sub-list of ",(0,l.kt)("inlineCode",{parentName:"p"},"l")," such\nthat the call of function ",(0,l.kt)("inlineCode",{parentName:"p"},"f")," on its elements is not ",(0,l.kt)("inlineCode",{parentName:"p"},"None"),". Note:\n",(0,l.kt)("inlineCode",{parentName:"p"},"f")," is called on all elements of ",(0,l.kt)("inlineCode",{parentName:"p"},"l"),". The order of the calls of\n",(0,l.kt)("inlineCode",{parentName:"p"},"f")," is not specified.")),(0,l.kt)(a.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"List.filter_map(f, l)")," is the maximal sub-list of ",(0,l.kt)("inlineCode",{parentName:"p"},"l")," such\nthat the call of function ",(0,l.kt)("inlineCode",{parentName:"p"},"f")," on its elements is not ",(0,l.kt)("inlineCode",{parentName:"p"},"None()"),". Note:\n",(0,l.kt)("inlineCode",{parentName:"p"},"f")," is called on all elements of ",(0,l.kt)("inlineCode",{parentName:"p"},"l"),". The order of the calls of\n",(0,l.kt)("inlineCode",{parentName:"p"},"f")," is not specified.")),(0,l.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val update : 'elt.('elt -> 'elt option) -> 'elt t -> 'elt t"),(0,l.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let update: <elt>(_: (_: elt) => option<elt>) => (_: t<elt>) => t<elt>"),(0,l.kt)(a.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"List.update f l")," is the list ",(0,l.kt)("inlineCode",{parentName:"p"},"l")," where the elements ",(0,l.kt)("inlineCode",{parentName:"p"},"e"),"\nsuch that ",(0,l.kt)("inlineCode",{parentName:"p"},"f e")," is ",(0,l.kt)("inlineCode",{parentName:"p"},"Some v")," have been replaced by ",(0,l.kt)("inlineCode",{parentName:"p"},"v"),".")),(0,l.kt)(a.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"List.update(f, l)")," is the list ",(0,l.kt)("inlineCode",{parentName:"p"},"l")," where the elements ",(0,l.kt)("inlineCode",{parentName:"p"},"e"),"\nsuch that ",(0,l.kt)("inlineCode",{parentName:"p"},"f(e)")," is ",(0,l.kt)("inlineCode",{parentName:"p"},"Some(v)")," have been replaced by ",(0,l.kt)("inlineCode",{parentName:"p"},"v"),".")),(0,l.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val update_with : 'elt.('elt -> bool) -> 'elt -> 'elt t -> 'elt t"),(0,l.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let update_with: <elt>(_: (_: elt) => bool) => (_: elt) => (_: t<elt>) => t<elt>"),(0,l.kt)(a.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"List.update_with p d l")," is the list ",(0,l.kt)("inlineCode",{parentName:"p"},"l")," where the elements\n",(0,l.kt)("inlineCode",{parentName:"p"},"e")," such that satisfy the predicate ",(0,l.kt)("inlineCode",{parentName:"p"},"p")," are replaced by ",(0,l.kt)("inlineCode",{parentName:"p"},"d"),".")),(0,l.kt)(a.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,l.kt)("p",null,"The call ",(0,l.kt)("inlineCode",{parentName:"p"},"List.update_with(p,d,l)")," is the list ",(0,l.kt)("inlineCode",{parentName:"p"},"l")," where the elements\n",(0,l.kt)("inlineCode",{parentName:"p"},"e")," such that satisfy the predicate ",(0,l.kt)("inlineCode",{parentName:"p"},"p")," are replaced by ",(0,l.kt)("inlineCode",{parentName:"p"},"d"),".")))}y.isMDXComponent=!0}}]);