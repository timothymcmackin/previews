"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[23749],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>d});var o=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,o,r=function(e,n){if(null==e)return{};var t,o,r={},i=Object.keys(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=o.createContext({}),p=function(e){var n=o.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},u=function(e){var n=p(e.components);return o.createElement(s.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},m=o.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),m=p(t),d=r,g=m["".concat(s,".").concat(d)]||m[d]||c[d]||i;return t?o.createElement(g,a(a({ref:n},u),{},{components:t})):o.createElement(g,a({ref:n},u))}));function d(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,a=new Array(i);a[0]=m;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,a[1]=l;for(var p=2;p<i;p++)a[p]=t[p];return o.createElement.apply(null,a)}return o.createElement.apply(null,t)}m.displayName="MDXCreateElement"},48720:(e,n,t)=>{t.d(n,{D:()=>r.Z,Z:()=>i});var o=t(67294),r=t(75402);const i=function(e){return o.createElement(r.Z.Consumer,null,(n=>{let{syntax:t}=n;return t===e.syntax?e.children:o.createElement(o.Fragment,null)}))}},31973:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>l,default:()=>m,frontMatter:()=>a,metadata:()=>s,toc:()=>u});var o=t(87462),r=(t(67294),t(3905)),i=t(48720);const a={id:"looping",title:"Looping"},l=void 0,s={unversionedId:"imperative/looping",id:"imperative/looping",title:"Looping",description:"The programming style promoted by CameLIGO is functional, that is,",source:"@site/../docs/imperative/looping.md",sourceDirName:"imperative",slug:"/imperative/looping",permalink:"/previews/ligo/modules/docs/next/imperative/looping",draft:!1,tags:[],version:"current",frontMatter:{id:"looping",title:"Looping"},sidebar:"docs",previous:{title:"Recursion",permalink:"/previews/ligo/modules/docs/next/functions/recursion"},next:{title:"Asserting",permalink:"/previews/ligo/modules/docs/next/imperative/asserting"}},p={},u=[{value:"for-of loops",id:"for-of-loops",level:2}],c={toc:u};function m(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,o.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("p",null,"The programming style promoted by CameLIGO is functional, that is,\nuser-defined values are constant and the preferred way to write\niterations is by means of recursive functions."),(0,r.kt)("p",null,"Here is how to compute the greatest common divisors of two natural\nnumbers by means of Euclid's algorithm:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=looping",group:"looping"},"let rec iter (x, y : nat * nat) : nat =\n  if y = 0n then x else iter (y, x mod y)\n\nlet gcd (x, y : nat * nat) : nat =\n  iter (if x < y then y,x else x,y)\n")),(0,r.kt)("p",null,"CameLIGO is not purely functional though: it also features ",(0,r.kt)("em",{parentName:"p"},"loops"),",\nwhich we understand as syntactic constructs where the state of a\nstopping condition is mutated until it becomes true and the loop is\nexited. There are two kinds of loops: ",(0,r.kt)("inlineCode",{parentName:"p"},"for")," loops and the more general\n",(0,r.kt)("inlineCode",{parentName:"p"},"while")," loops. Here is again Euclid's algorithm, but using mutation\n(a.k.a. side effects) and a ",(0,r.kt)("inlineCode",{parentName:"p"},"while")," loop:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=looping",group:"looping"},"let gcd (a, b : nat * nat) =\n  let mut x, y = a, b in // We will modify x and y\n  let () =\n    if x < y then\n      let z = x in\n      begin\n        x := y; y := z // Swapping x and y\n      end in\n  let mut r : nat = 0n in\n  let () =\n    while y <> 0n do\n      r := x mod y;\n      x := y;\n      y := r\n    done\n  in x\n")),(0,r.kt)("p",null,"Here is how to check if a string is a palindrome or not using a ",(0,r.kt)("inlineCode",{parentName:"p"},"for")," loop:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=looping",group:"looping"},'let get_char s idx = String.sub idx 1n s\n\nlet is_palindrome s =\n  let mut p = "" in\n  let length = String.length s in\n  let () =\n    for i = length - 1 downto 0 do\n      p := p ^ get_char s (abs i)\n    done\n  in p = s\n'))),(0,r.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("p",null,"JsLIGO currently supports iteration through ",(0,r.kt)("em",{parentName:"p"},"loops"),", which we\nunderstand as syntactic constructs where the state of a stopping\ncondition is mutated until it becomes true and the loop is\nexited. There are two kinds of loops: ",(0,r.kt)("inlineCode",{parentName:"p"},"for")," loops and the more general\n",(0,r.kt)("inlineCode",{parentName:"p"},"while")," loops."),(0,r.kt)("p",null,"Here is how to compute the greatest common divisors of two natural\nnumbers by means of Euclid's algorithm and a ",(0,r.kt)("inlineCode",{parentName:"p"},"while")," loop:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=looping",group:"looping"},"function gcd (a: nat, b: nat) {\n  let [x,y] = [a,b]; // We will modify x and y\n  if (x < y) {\n    const z = x;\n    x = y; y = z; // Swapping x and y\n  }\n  let r: nat = 0n\n  while (y != 0n) {\n    r = x % y;\n    x = y;\n    y = r;\n  }\n  return x;\n};\n")),(0,r.kt)("p",null,"Note the use of a conditional statement to swap ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),"."),(0,r.kt)("p",null,"Conditional logic enables forking the control flow depending on the\nstate, that is, the values available at a given point in the code. Put\nin a less technical manner, conditionals enable decision making."),(0,r.kt)("p",null,"A conditional statement is made of three parts:"),(0,r.kt)("ol",null,(0,r.kt)("li",null," a condition, that is, a boolean expression;"),(0,r.kt)("li",null," a statement evaluated if, and only if, the condition is true;"),(0,r.kt)("li",null," a statement evaluated if, and only if, the condition is false.")),(0,r.kt)("p",null,"The syntax uses the keyword ",(0,r.kt)("inlineCode",{parentName:"p"},"if")," to introduce the condition, a\nstatement or block of statements between ",(0,r.kt)("inlineCode",{parentName:"p"},"{")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"}")," for the second\npart, and the keyword ",(0,r.kt)("inlineCode",{parentName:"p"},"else")," introduces the last statement or block of\nstatements. The last part can be omitted, as in the example above."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note: Currently JsLIGO does not support the keywords ",(0,r.kt)("inlineCode",{parentName:"p"},"break")," &\n",(0,r.kt)("inlineCode",{parentName:"p"},"continue")," in the context of loops.")),(0,r.kt)("p",null,"By comparison, here is how to compute the greatest common divisors of\ntwo natural numbers by means of Euclid's algorithm using tail\nrecursion (no loops):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=looping",group:"looping"},"function iter (x: nat,y: nat): nat {\n  if (y == 0n) return x else return iter (y, x % y)\n};\n\nfunction gcd2 (x: nat,y: nat) : nat {\n  if (x < y) return iter (y, x) else return iter (x, y)\n};\n")),(0,r.kt)("p",null,"Note: The conditional statements are complete: they both feature an\n",(0,r.kt)("inlineCode",{parentName:"p"},"else")," statement."),(0,r.kt)("p",null,"Finally, here is how to check if a string is a palindrome using a\n",(0,r.kt)("inlineCode",{parentName:"p"},"for")," loop:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=looping",group:"looping"},'const getChar = (s: string, idx: nat) : string => String.sub(idx, 1n, s);\n\nfunction isPalindrome (s: string): bool {\n  let p = "";\n  let length = String.length(s);\n  for (let i = length - 1 ; i >= 0 ; i--)\n    p += getChar(s, abs(i));\n  return p == s;\n};\n')),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note: The ",(0,r.kt)("inlineCode",{parentName:"p"},"return"),' statement ("early exit") is not valid in loops.')),(0,r.kt)("h2",{id:"for-of-loops"},"for-of loops"),(0,r.kt)("p",null,"JsLIGO ",(0,r.kt)("inlineCode",{parentName:"p"},"for-of")," loops can iterate through the contents of a\ncollection, that is, a list, a set or a map. This is done with a loop\nof the form ",(0,r.kt)("inlineCode",{parentName:"p"},"for (const <element var> of <collection var>) <block>"),"."),(0,r.kt)("p",null,"Here is an example where the integers in a list are summed up."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=looping",group:"looping"},"function sum_list (l : list<int>) {\n  let acc = 0;\n  for (const i of l) acc += i;\n  return acc; // total\n};\n")),(0,r.kt)("p",null,"See the relevant sections on maps and sets for their loops.")))}m.isMDXComponent=!0}}]);