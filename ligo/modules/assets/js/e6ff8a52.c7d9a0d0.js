"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3397],{3905:(e,t,n)=>{n.d(t,{Zo:()=>l,kt:()=>d});var o=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function m(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=o.createContext({}),i=function(e){var t=o.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},l=function(e){var t=i(e.components);return o.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},u=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,c=e.parentName,l=m(e,["components","mdxType","originalType","parentName"]),u=i(n),d=r,f=u["".concat(c,".").concat(d)]||u[d]||p[d]||a;return n?o.createElement(f,s(s({ref:t},l),{},{components:n})):o.createElement(f,s({ref:t},l))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,s=new Array(a);s[0]=u;var m={};for(var c in t)hasOwnProperty.call(t,c)&&(m[c]=t[c]);m.originalType=e,m.mdxType="string"==typeof e?e:r,s[1]=m;for(var i=2;i<a;i++)s[i]=n[i];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}u.displayName="MDXCreateElement"},48720:(e,t,n)=>{n.d(t,{D:()=>r.Z,Z:()=>a});var o=n(67294),r=n(75402);const a=function(e){return o.createElement(r.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:o.createElement(o.Fragment,null)}))}},19947:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>m,default:()=>u,frontMatter:()=>s,metadata:()=>c,toc:()=>l});var o=n(87462),r=(n(67294),n(3905)),a=n(48720);const s={id:"comments",title:"Comments"},m=void 0,c={unversionedId:"comments/comments",id:"comments/comments",title:"Comments",description:"CameLIGO features the same comments as those of OCaml:",source:"@site/../docs/comments/comments.md",sourceDirName:"comments",slug:"/comments/",permalink:"/previews/ligo/modules/docs/next/comments/",draft:!1,tags:[],version:"current",frontMatter:{id:"comments",title:"Comments"},sidebar:"docs",previous:{title:"Start a project from a template",permalink:"/previews/ligo/modules/docs/next/tutorials/start-a-project-from-a-template"},next:{title:"Variables and constants",permalink:"/previews/ligo/modules/docs/next/syntax/variables"}},i={},l=[],p={toc:l};function u(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,o.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)(a.Z,{syntax:"cameligo",mdxType:"Syntax"},"CameLIGO features the same comments as those of OCaml:",(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=comments",group:"comments"},'(* This is a block comment\n   (* and one "nested" *)*)\n')),(0,r.kt)("p",null,"The contents of comments are scanned, and therefore strings and\ncomments in comments, like ",(0,r.kt)("inlineCode",{parentName:"p"},'"nested"')," and ",(0,r.kt)("inlineCode",{parentName:"p"},'(* and one "nested" *)'),",\nneed to be valid (properly closed). This enables commenting out a\nrandom piece of contract that may already contain comments. The\ndownside is that you can only comment code or text whose strings and\ncomments are valid.")),(0,r.kt)(a.Z,{syntax:"jsligo",mdxType:"Syntax"},"JsLIGO features multi-line comments like JavaScript, but additionally accepts their nesting:",(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=comments",group:"comments"},'/* This is a multi-line comment\n   /* and one "nested" */*/\n')),(0,r.kt)("p",null,"The contents of comments are scanned, and therefore strings and\ncomments in comments, like ",(0,r.kt)("inlineCode",{parentName:"p"},'"nested"')," and ",(0,r.kt)("inlineCode",{parentName:"p"},'/* and one "nested" */'),",\nneed to be valid (properly closed). This enables commenting out a\nrandom piece of contract that may already contain comments. The\ndownside is that you can only comment code or text whose strings and\ncomments are valid.")),(0,r.kt)("p",null,"LIGO also offers ",(0,r.kt)("em",{parentName:"p"},"single line comments")," \xe0 la JavaScript:"),(0,r.kt)(a.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=comments",group:"comments"},"let x = 10 // This is a single line comment\n"))),(0,r.kt)(a.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=comments",group:"comments"},"const x = 10; // This is a single line comment\n"))),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Comments can contain UTF-8 glyphs. Given that the generated\nMichelson does not contain comments, UTF-8 may matter for\ndocumentation of the source, and error messages display line offsets\nin the source as numbers of such glyphs, not bytes.")))}u.isMDXComponent=!0}}]);