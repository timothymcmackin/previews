"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7581],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>u});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),m=c(n),u=o,h=m["".concat(s,".").concat(u)]||m[u]||d[u]||r;return n?a.createElement(h,i(i({ref:t},p),{},{components:n})):a.createElement(h,i({ref:t},p))}));function u(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var c=2;c<r;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},48720:(e,t,n)=>{n.d(t,{D:()=>o.Z,Z:()=>r});var a=n(67294),o=n(75402);const r=function(e){return a.createElement(o.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},90371:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var a=n(87462),o=(n(67294),n(3905)),r=n(48720);const i={id:"inter-contract-calls",title:"Inter-contract invocations"},l=void 0,s={unversionedId:"tutorials/inter-contract-calls/inter-contract-calls",id:"version-1.7.0/tutorials/inter-contract-calls/inter-contract-calls",title:"Inter-contract invocations",description:'In this guide, we will look into contract interactions on Tezos. We will provide examples of how one contract can invoke and create other contracts on the same chain. We will also describe the execution model Tezos contracts live in and see how it is different from a more conventional "direct calls" model.',source:"@site/versioned_docs/version-1.7.0/tutorials/inter-contract-calls/inter-contract-calls.md",sourceDirName:"tutorials/inter-contract-calls",slug:"/tutorials/inter-contract-calls/",permalink:"/previews/ligo/modules/docs/tutorials/inter-contract-calls/",draft:!1,tags:[],version:"1.7.0",frontMatter:{id:"inter-contract-calls",title:"Inter-contract invocations"}},c={},p=[{value:"Internal operations",id:"internal-operations",level:2},{value:"A note on complexity",id:"a-note-on-complexity",level:2},{value:"Internal transactions in LIGO",id:"internal-transactions-in-ligo",level:2},{value:"Interoperability and standards compliance",id:"interoperability-and-standards-compliance",level:2},{value:"Execution order",id:"execution-order",level:2},{value:"Returning values",id:"returning-values",level:2},{value:"Contract factories",id:"contract-factories",level:2}],d={toc:p};function m(e){let{components:t,...i}=e;return(0,o.kt)("wrapper",(0,a.Z)({},d,i,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,'In this guide, we will look into contract interactions on Tezos. We will provide examples of how one contract can invoke and create other contracts on the same chain. We will also describe the execution model Tezos contracts live in and see how it is different from a more conventional "direct calls" model.'),(0,o.kt)("h2",{id:"internal-operations"},"Internal operations"),(0,o.kt)("p",null,'When you make a transaction to a contract, this contract may, in turn, emit other operations. Those operations are called "internal". There are three kinds of internal operations:'),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Transaction \u2013 an operation that transfers value and, if the callee is an originated contract, executes the code of the callee."),(0,o.kt)("li",{parentName:"ol"},"Origination \u2013 creates a new smart contract."),(0,o.kt)("li",{parentName:"ol"},"Delegation \u2013 sets a delegate for the current contract.")),(0,o.kt)("p",null,"We will mainly focus on internal ",(0,o.kt)("em",{parentName:"p"},"transactions,")," as this is the most common type of internal operations. We will also show how contracts can originate other contracts."),(0,o.kt)("h2",{id:"a-note-on-complexity"},"A note on complexity"),(0,o.kt)("p",null,"Usually, you do not want to have overly-complex contract interactions when you develop your Tezos contracts. There are several reasons for this:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Transactions between contracts are expensive. Tezos bakers need to fetch the callee from the context (this is how internal blockchain storage is called in Tezos), deserialise and type-check it, then perform the requested operation and store the result. Among these actions, code execution is the cheapest one in terms of gas."),(0,o.kt)("li",{parentName:"ol"},"Transactions between contracts are hard and error-prone. When you split your business logic across several contracts, you need to think of how these contracts interact. This may cause unforeseen vulnerabilities if you do not give it enough attention."),(0,o.kt)("li",{parentName:"ol"},"Tezos most probably has other means to achieve what you want. Lambdas make it possible to alter the behaviour of the contract after origination, new cryptographic primitives get introduced via protocol upgrades, separation of concerns can be achieved by splitting your business logic into LIGO modules that will eventually get compiled into a single contract, etc.")),(0,o.kt)("p",null,"However, there are legit reasons for using internal operations, including the following:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"You communicate with an external entity, e.g., transfer a third-party FA2 token."),(0,o.kt)("li",{parentName:"ol"},"You develop a universal caller contract, e.g., a multisig contract."),(0,o.kt)("li",{parentName:"ol"},"You implement a standard that explicitly forbids you to extend the functionality.")),(0,o.kt)("h2",{id:"internal-transactions-in-ligo"},"Internal transactions in LIGO"),(0,o.kt)("p",null,"The simplest example of an internal transaction is sending Tez to a contract. Note that in Tezos, implicit accounts owned by people holding private keys are contracts as well. Implicit accounts have no code and accept ",(0,o.kt)("em",{parentName:"p"},"unit")," as the parameter. Consider the following code snippet:"),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo"},'type parameter = address\n\ntype storage = unit\n\n[@entry]\nlet main (destination_addr : parameter) (_ : storage) =\n  let maybe_contract = Tezos.get_contract_opt destination_addr in\n  let destination_contract =\n    match maybe_contract with\n      Some contract -> contract\n    | None -> failwith "Contract does not exist" in\n  let op = Tezos.transaction () (Tezos.get_amount ()) destination_contract in\n  [op], ()\n'))),(0,o.kt)("p",null,"It accepts a destination address as the parameter. Then we need to check whether the address points to a contract that accepts a unit. We do this with ",(0,o.kt)("inlineCode",{parentName:"p"},"Tezos.get_contract_opt"),". This function returns ",(0,o.kt)("inlineCode",{parentName:"p"},"Some (value)")," if the contract exists and the parameter type is correct. Otherwise, it returns ",(0,o.kt)("inlineCode",{parentName:"p"},"None"),". In case it is ",(0,o.kt)("inlineCode",{parentName:"p"},"None"),", we fail with an error, otherwise we use ",(0,o.kt)("inlineCode",{parentName:"p"},"Tezos.transaction")," to forge the internal transaction to the destination contract."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Note: since ",(0,o.kt)("inlineCode",{parentName:"p"},"Tezos.transaction")," is called with unit as its first argument, LIGO infer that ",(0,o.kt)("inlineCode",{parentName:"p"},"destination_addr")," has to point to a contract that accepts unit")),(0,o.kt)("p",null,'Let us also examine a contract that stores the address of another contract and passes an argument to it. Here is how this "proxy" can look like:'),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=proxy",group:"proxy"},'(* examples/contracts/mligo/Proxy.mligo *)\n\ntype parameter = int\n\ntype storage = address\n\nlet get_contract (addr : address) =\n  match Tezos.get_contract_opt addr with\n    Some contract -> contract\n  | None -> failwith "Callee does not exist"\n\n[@entry]\nlet main (param : parameter) (callee_addr : storage) =\n  let callee = get_contract (callee_addr) in\n  let op = Tezos.transaction param 0mutez callee in\n  [op], callee_addr\n'))),(0,o.kt)("p",null,"To call a contract, we need to add a type annotation ",(0,o.kt)("inlineCode",{parentName:"p"},": int contract\noption")," for ",(0,o.kt)("inlineCode",{parentName:"p"},"Tezos.get_contract_opt"),". LIGO knows that\n",(0,o.kt)("inlineCode",{parentName:"p"},"Tezos.get_contract_opt")," returns a ",(0,o.kt)("inlineCode",{parentName:"p"},"contract option")," but at the time\nof type inference it does not know that the callee accepts an\n",(0,o.kt)("inlineCode",{parentName:"p"},"int"),". In this case, we expect the callee to accept an ",(0,o.kt)("inlineCode",{parentName:"p"},"int"),". Such a\ncallee can be implemented like this:"),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=simplecounter",group:"simplecounter"},"(* examples/contracts/mligo/SimpleCounter.mligo *)\n\n[@entry]\nlet main (param : int) (storage : int) : operation list * int = [], param + storage\n"))),(0,o.kt)("p",null,"But what if we want to make a transaction to a contract but do not know the full type of its parameter? For example, we may know that some contract accepts ",(0,o.kt)("inlineCode",{parentName:"p"},"Add 5")," as its parameter, but we do not know what other entrypoints are there."),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=advancedcounter",group:"advancedcounter"},"(* examples/contracts/mligo/AdvancedCounter.mligo *)\n\nlet nop : operation list = []\n\n[@entry] let set      (n : int)  (_storage : int) = nop, n\n[@entry] let add      (n : int)  (storage : int)  = nop, storage + n\n[@entry] let subtract (n : int)  (storage : int)  = nop, storage + n\n[@entry] let multiply (n : int)  (storage : int)  = nop, storage * n\n[@entry] let reset    (_ : unit) (_storage : int) = nop, 0\n"))),(0,o.kt)("p",null,"LIGO compiler generates the following Michelson type for the parameter of this contract:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"(or (or (or (int %add)\n            (int %multiply))\n        (or (unit %reset)\n            (int %set)))\n    (int %subtract));\n")),(0,o.kt)("p",null,"The type got transformed to an annotated tree of Michelson union types (denoted with ",(0,o.kt)("inlineCode",{parentName:"p"},"or typeA typeB"),"). The annotations (",(0,o.kt)("inlineCode",{parentName:"p"},"%add"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"%multiply"),", etc.) here represent ",(0,o.kt)("em",{parentName:"p"},"entrypoints")," \u2013 a construct Tezos has special support for."),(0,o.kt)("p",null,"In Tezos, we are not required to provide the ",(0,o.kt)("em",{parentName:"p"},"full")," type of the contract parameter if we specify an entrypoint. In this case, we just need to know the type of the ",(0,o.kt)("em",{parentName:"p"},"entrypoint")," parameter \u2013 in case of ",(0,o.kt)("inlineCode",{parentName:"p"},"%add"),", it is an ",(0,o.kt)("inlineCode",{parentName:"p"},"int")," \u2013 not the full type."),(0,o.kt)("p",null,"To specify an entrypoint, we can use ",(0,o.kt)("inlineCode",{parentName:"p"},"Tezos.get_entrypoint_opt")," instead of ",(0,o.kt)("inlineCode",{parentName:"p"},"Tezos.get_contract_opt"),". It accepts an extra argument with an entrypoint name:"),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=entrypointproxy",group:"entrypointproxy"},'(* contracts/examples/mligo/EntrypointProxy.mligo *)\n\ntype parameter = int\n\ntype storage = address\n\nlet get_add_entrypoint (addr : address) =\n  match Tezos.get_entrypoint_opt "%add" addr with\n    Some contract -> contract\n  | None -> failwith "The entrypoint does not exist"\n\n[@entry]\nlet main (param : parameter) (callee_addr : storage) =\n  let add : int contract = get_add_entrypoint (callee_addr) in\n  let op = Tezos.transaction param 0mutez add in\n  [op], callee_addr\n'))),(0,o.kt)("p",null,"To get the entrypoint names from parameter constructors, you should make the first letters lowercase and prepend a percent sign: ",(0,o.kt)("inlineCode",{parentName:"p"},"Add")," -> ",(0,o.kt)("inlineCode",{parentName:"p"},"%add"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"CallThePolice")," -> ",(0,o.kt)("inlineCode",{parentName:"p"},"%callThePolice"),". LIGO does this transformation internally when it compiles your code into Michelson."),(0,o.kt)("p",null,"Entrypoints are especially useful for standardisation. For example, FA2 token standard does not force the contracts to have some specific parameter type \u2013\xa0it would be too limiting for tokens that want to have additional functionality. Instead, the standard requires the tokens to have some predefined set of entrypoints, and other contracts may expect these entrypoints to be present in FA2-compliant tokens."),(0,o.kt)("h2",{id:"interoperability-and-standards-compliance"},"Interoperability and standards compliance"),(0,o.kt)("p",null,"There are several high-level languages for Tezos, and you should not expect that all the contracts you interact with are written in LIGO."),(0,o.kt)("p",null,"Internally, Tezos stores and operates on contracts in Michelson. Currently, Michelson does not support record and variant types of arbitrary length natively. It only has ",(0,o.kt)("inlineCode",{parentName:"p"},"pair a b")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"or a b"),", each containing just ",(0,o.kt)("em",{parentName:"p"},"two")," type parameters."),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("p",null,"LIGO automatically converts a complex type ",(0,o.kt)("inlineCode",{parentName:"p"},"type t = Hello | L | I | G | O")," into an annotated left-balanced tree with items sorted alphabetically: ",(0,o.kt)("inlineCode",{parentName:"p"},"(or (or (or (unit %g) (unit %hello)) (or (unit %i) (unit %l))) (unit %o))"),". LIGO applies the same transformation to record types:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo"},"type t = {hello : int; l : nat; i : bytes; g : string; o : address}\n"))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"(pair (pair (pair (string %g)\n                  (int %hello))\n            (pair (bytes %i)\n                  (nat %l)))\n      (address %o))\n")),(0,o.kt)("p",null,"However, other languages may use a different representation. For example, they can use a right-hand comb:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"(pair (int %hello)\n      (pair (nat %l)\n            (pair (bytes %i)\n                  (pair (string %g)\n                        (address %o)))))\n")),(0,o.kt)("p",null,"It is not a problem for top-level parameter types: we can expect the callers to specify an entrypoint. But if we pass structures and values of variant types as entrypoint arguments, we need to make sure their internal representation is the same."),(0,o.kt)("p",null,"If you interact with other contracts, or expect other contracts to interact with your contract, we strongly advise you to consider using special types and annotations described in the ",(0,o.kt)("a",{parentName:"p",href:"https://ligolang.org/docs/advanced/interop"},"Interop")," section of the documentation."),(0,o.kt)("h2",{id:"execution-order"},"Execution order"),(0,o.kt)("p",null,"When you emit an internal operation, Tezos puts it into the ",(0,o.kt)("em",{parentName:"p"},"internal operations queue."),"\nHere is how this queue looks like when you have one contract that emits two internal operations:"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Current call"),(0,o.kt)("th",{parentName:"tr",align:null},"Queue before"),(0,o.kt)("th",{parentName:"tr",align:null},"Queue after"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"A %doSomething")),(0,o.kt)("td",{parentName:"tr",align:null},"[]"),(0,o.kt)("td",{parentName:"tr",align:null},"[",(0,o.kt)("inlineCode",{parentName:"td"},"B %foo"),", ",(0,o.kt)("inlineCode",{parentName:"td"},"C %bar"),"]")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"B %foo")),(0,o.kt)("td",{parentName:"tr",align:null},"[",(0,o.kt)("inlineCode",{parentName:"td"},"C %bar"),"]"),(0,o.kt)("td",{parentName:"tr",align:null},"[",(0,o.kt)("inlineCode",{parentName:"td"},"C %bar"),"]")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"C %bar")),(0,o.kt)("td",{parentName:"tr",align:null},"[]"),(0,o.kt)("td",{parentName:"tr",align:null},"[]")))),(0,o.kt)("p",null,"Now imagine that ",(0,o.kt)("inlineCode",{parentName:"p"},"B %foo")," emits another operation, e.g. it calls back to ",(0,o.kt)("inlineCode",{parentName:"p"},"A %fooCallback"),". Tezos will put this internal operation to the end of the queue:"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Current call"),(0,o.kt)("th",{parentName:"tr",align:null},"Queue before"),(0,o.kt)("th",{parentName:"tr",align:null},"Queue after"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"A %doSomething")),(0,o.kt)("td",{parentName:"tr",align:null},"[]"),(0,o.kt)("td",{parentName:"tr",align:null},"[",(0,o.kt)("inlineCode",{parentName:"td"},"B %foo"),", ",(0,o.kt)("inlineCode",{parentName:"td"},"C %bar"),"]")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"B %foo")),(0,o.kt)("td",{parentName:"tr",align:null},"[",(0,o.kt)("inlineCode",{parentName:"td"},"C %bar"),"]"),(0,o.kt)("td",{parentName:"tr",align:null},"[",(0,o.kt)("inlineCode",{parentName:"td"},"C %bar"),", ",(0,o.kt)("inlineCode",{parentName:"td"},"A %fooCallback"),"]")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"C %bar")),(0,o.kt)("td",{parentName:"tr",align:null},"[",(0,o.kt)("inlineCode",{parentName:"td"},"A %fooCallback"),"]"),(0,o.kt)("td",{parentName:"tr",align:null},"[",(0,o.kt)("inlineCode",{parentName:"td"},"A %fooCallback"),"]")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"A %fooCallback")),(0,o.kt)("td",{parentName:"tr",align:null},"[]"),(0,o.kt)("td",{parentName:"tr",align:null},"[]")))),(0,o.kt)("p",null,"Notice how this callback gets executed ",(0,o.kt)("em",{parentName:"p"},"after")," ",(0,o.kt)("inlineCode",{parentName:"p"},"C %bar"),". If we construct a tree of internal operations, such queuing would be analogous to a breadth-first search (BFS):"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"BFS order of execution",src:n(26823).Z,width:"376",height:"201"})),(0,o.kt)("p",null,"This BFS execution order is very different from Ethereum's direct synchronous method calls, which are analogous to depth-first search. Here is how the transactions would be ordered in Ethereum:"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"DFS order of execution",src:n(78906).Z,width:"385",height:"201"})),(0,o.kt)("p",null,"Here is a more complex scenario featuring a graph of 12 different operations. We omit the contract and entrypoint names and use lowercase letters and numbers to identify operations."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"BFS order (Tezos):")),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"BFS order of execution",src:n(77515).Z,width:"466",height:"343"})),(0,o.kt)("ol",{start:2},(0,o.kt)("li",{parentName:"ol"},"DFS order (Ethereum):")),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"DFS order of execution",src:n(61948).Z,width:"464",height:"349"})),(0,o.kt)("p",null,"In practice, you should always bear in mind that the internal operations are queued and not executed immediately. It means that:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"There is no guarantee that there would be no operations in between the current transaction and an emitted operation (e.g., on the BFS graph above, ",(0,o.kt)("inlineCode",{parentName:"li"},"b2")," emits ",(0,o.kt)("inlineCode",{parentName:"li"},"b2a"),", but 4 operations are executed in between these two)."),(0,o.kt)("li",{parentName:"ul"},"If you emit a sequence of operations, they will be executed one after the other, with no operations in between. In other words, it is guaranteed that ",(0,o.kt)("inlineCode",{parentName:"li"},"b"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"c"),", and ",(0,o.kt)("inlineCode",{parentName:"li"},"d"),", emitted by ",(0,o.kt)("inlineCode",{parentName:"li"},"a"),", will not be interleaved by other operations. This property holds true even if ",(0,o.kt)("inlineCode",{parentName:"li"},"a")," is not the root of the call graph."),(0,o.kt)("li",{parentName:"ul"},"If you emit a sequence of operations, the whole sequence will be executed ",(0,o.kt)("em",{parentName:"li"},"before")," any possible internal operations that may arise as a result of any of these operations.")),(0,o.kt)("h2",{id:"returning-values"},"Returning values"),(0,o.kt)("p",null,"When trying to port an existing distributed application to Tezos, you may want to ",(0,o.kt)("em",{parentName:"p"},"read")," the storage of another contract or call some entrypoint to get a computed value. In Tezos, entrypoints can only update storage and emit other operations."),(0,o.kt)("p",null,"In theory, one can use a callback \u2013 the callee could emit an operation back to the caller with the computed value. However, this pattern is often insecure:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"You should somehow make sure that the response matches the request. Due to the breadth-first order of execution, you cannot assume that there have been no other requests in between."),(0,o.kt)("li",{parentName:"ul"},"Some contracts use ",(0,o.kt)("inlineCode",{parentName:"li"},"Tezos.get_sender")," value for authorisation. If a third-party contract can make a contract emit an operation, the dependent contracts may no longer be sure that the operation coming from the sender is indeed ",(0,o.kt)("em",{parentName:"li"},"authorised")," by the sender.")),(0,o.kt)("p",null,'Let us look at a simple access control contract with a "view" entrypoint:'),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=accesscontroller",group:"accesscontroller"},'(* examples/contracts/mligo/AccessController.mligo *)\n\ntype storage = {senders_whitelist : address set}\n\n[@entry]\nlet call (op : unit -> operation) (s : storage) : operation list * storage =\n  if Set.mem (Tezos.get_sender ()) s.senders_whitelist\n  then [op ()], s\n  else failwith "Sender is not whitelisted"\n\n[@entry]\nlet iswhitelisted (arg : address * (bool contract)) (s : storage) : operation list * storage =\n  let addr, callback_contract = arg in\n  let whitelisted = Set.mem addr s.senders_whitelist in\n  let op = Tezos.transaction whitelisted 0mutez callback_contract in\n  [op], s\n'))),(0,o.kt)("p",null,"Now imagine we want to control a contract with the following interface (we omit the full code of the contract for clarity; you can find it in the ",(0,o.kt)("a",{parentName:"p",href:"https://gitlab.com/ligolang/ligo/-/tree/dev/gitlab-pages/docs/tutorials/inter-contract-calls/examples"},"examples folder"),"):"),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},'(* examples/contracts/mligo/PausableToken.mligo *)\n\ntype storage = {ledger : (address, nat) big_map; owner : address; paused : bool}\ntype result = operation list * storage\n\nlet do_transfer (src, dst, amount_, storage : address * address * nat * storage) : storage =\n  (* ... *)\n\n[@entry]\nlet transfer (arg : address * address * nat) (s : storage) : result =\n  if s.paused\n  then failwith "The contract is paused"\n  else\n    let src, dst, amount_ = arg in\n    [], transfer (src, dst, amount_, s)\n\n[@entry]\nlet setpaused (paused : bool) (s : storage) : result =\n  if (Tezos.get_sender ()) <> s.owner\n  then failwith "Access denied"\n  else [], {s with paused = paused}\n'))),(0,o.kt)("p",null,"You may notice that we can abuse the ",(0,o.kt)("inlineCode",{parentName:"p"},"IsWhitelisted")," entrypoint to pause and unpause the token, even if we are not among the whitelisted senders. Try it out:"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},'tezos-client call "$ACCESS_CONTROLLER" from "$EVA" --entrypoint "%isWhitelisted" --arg "Pair ($WHITELISTED_ADDRESS, $TARGET %setPaused)"')),(0,o.kt)("h2",{id:"contract-factories"},"Contract factories"),(0,o.kt)("p",null,"So far, we have covered only one type of operation \u2013 transaction. But we can ",(0,o.kt)("em",{parentName:"p"},"originate")," contracts from LIGO a well! There is a special instruction ",(0,o.kt)("inlineCode",{parentName:"p"},"Tezos.create_contract"),". It accepts four arguments:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Contract code. Note that the code must be an inline function that does not use any existing bindings."),(0,o.kt)("li",{parentName:"ol"},"Optional delegate."),(0,o.kt)("li",{parentName:"ol"},"The amount of Tez to send to the contract upon origination."),(0,o.kt)("li",{parentName:"ol"},"The initial storage value.")),(0,o.kt)("p",null,"For example, we can create a new counter contract with"),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=solo_create_contract",group:"solo_create_contract"},"let op = Tezos.create_contract\n  (fun (p : int) (s : int) -> [], p + s)\n  None\n  0mutez\n  1\n"))),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Tezos.create_contract")," returns a pair of ",(0,o.kt)("em",{parentName:"p"},"origination operation")," and the ",(0,o.kt)("em",{parentName:"p"},"address")," of the new contract. Note that, at this stage, the contract has not been originated yet! That is why you cannot forge a transaction to the newly-created contract: ",(0,o.kt)("inlineCode",{parentName:"p"},"Tezos.get_{contract, entrypoint}_opt")," would fail if called before the origination operation has been processed."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"CreateAndCall")," contract in the examples folder shows how we can call the created contract with a callback mechanism:"),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo"},'(* examples/contracts/mligo/CreateAndCall.mligo *)\n\n// Here we create two operations: the one that will originate\n// the contract, and an operation to self, that will continue\n// the execution after the contract is originated.\n\nlet create_and_call (storage : address list) =\n  let create_op, addr =\n    Tezos.create_contract\n      (fun (p : int) (s : int) -> [], p + s)\n      None\n      0tez\n      1 in\n  let call_op =\n    Tezos.transaction (addr, 41) 0tez (Tezos.self "%callback") in\n  [create_op; call_op], addr :: storage\n'))),(0,o.kt)("p",null,"By the time ",(0,o.kt)("inlineCode",{parentName:"p"},"%callback")," is called, the ",(0,o.kt)("inlineCode",{parentName:"p"},"create_op")," would be completed. Thus, the factory ",(0,o.kt)("inlineCode",{parentName:"p"},"%callback")," can forge yet another operation to call the default entrypoint of the new contract:"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Current call"),(0,o.kt)("th",{parentName:"tr",align:null},"Queue before"),(0,o.kt)("th",{parentName:"tr",align:null},"Queue after"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"A %createAndCall")),(0,o.kt)("td",{parentName:"tr",align:null},"[]"),(0,o.kt)("td",{parentName:"tr",align:null},"[Originate ",(0,o.kt)("inlineCode",{parentName:"td"},"B"),", ",(0,o.kt)("inlineCode",{parentName:"td"},"A %callback"),"]")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Originate ",(0,o.kt)("inlineCode",{parentName:"td"},"B")),(0,o.kt)("td",{parentName:"tr",align:null},"[",(0,o.kt)("inlineCode",{parentName:"td"},"A %callback"),"]"),(0,o.kt)("td",{parentName:"tr",align:null},"[",(0,o.kt)("inlineCode",{parentName:"td"},"A %callback"),"]")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"A %callback")),(0,o.kt)("td",{parentName:"tr",align:null},"[]"),(0,o.kt)("td",{parentName:"tr",align:null},"[",(0,o.kt)("inlineCode",{parentName:"td"},"B %default"),"]")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"B %default")),(0,o.kt)("td",{parentName:"tr",align:null},"[]"),(0,o.kt)("td",{parentName:"tr",align:null},"[]")))),(0,o.kt)("p",null,"If you use this pattern, please mind the execution model and check whether the guarantees it provides are enough for security of your application."))}m.isMDXComponent=!0},26823:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/bfs_order-bc7495c58c94e66c33ea2dfcc1378549.png"},77515:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/complex_bfs-5e7d9a3a5159a0d4204358cfd61086ee.png"},61948:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/complex_dfs-3f05f083f075ce1820f043d323d2e32b.png"},78906:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/dfs_order-2c97346462af8f73720db7e4103cbb61.png"}}]);