"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[51344],{3905:(e,a,t)=>{t.d(a,{Zo:()=>s,kt:()=>c});var n=t(67294);function p(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function r(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function i(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?r(Object(t),!0).forEach((function(a){p(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function o(e,a){if(null==e)return{};var t,n,p=function(e,a){if(null==e)return{};var t,n,p={},r=Object.keys(e);for(n=0;n<r.length;n++)t=r[n],a.indexOf(t)>=0||(p[t]=e[t]);return p}(e,a);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)t=r[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(p[t]=e[t])}return p}var m=n.createContext({}),l=function(e){var a=n.useContext(m),t=a;return e&&(t="function"==typeof e?e(a):i(i({},a),e)),t},s=function(e){var a=l(e.components);return n.createElement(m.Provider,{value:a},e.children)},d={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},u=n.forwardRef((function(e,a){var t=e.components,p=e.mdxType,r=e.originalType,m=e.parentName,s=o(e,["components","mdxType","originalType","parentName"]),u=l(t),c=p,g=u["".concat(m,".").concat(c)]||u[c]||d[c]||r;return t?n.createElement(g,i(i({ref:a},s),{},{components:t})):n.createElement(g,i({ref:a},s))}));function c(e,a){var t=arguments,p=a&&a.mdxType;if("string"==typeof e||p){var r=t.length,i=new Array(r);i[0]=u;var o={};for(var m in a)hasOwnProperty.call(a,m)&&(o[m]=a[m]);o.originalType=e,o.mdxType="string"==typeof e?e:p,i[1]=o;for(var l=2;l<r;l++)i[l]=t[l];return n.createElement.apply(null,i)}return n.createElement.apply(null,t)}u.displayName="MDXCreateElement"},96896:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>m,contentTitle:()=>i,default:()=>c,frontMatter:()=>r,metadata:()=>o,toc:()=>l});var n=t(87462),p=(t(67294),t(3905));const r={title:"Maps"},i=void 0,o={unversionedId:"data-types/maps",id:"data-types/maps",title:"Maps",description:"Maps are a data structure which associates values of the same type to",source:"@site/../docs/data-types/maps.md",sourceDirName:"data-types",slug:"/data-types/maps",permalink:"/previews/ligo/modules/docs/next/data-types/maps",draft:!1,tags:[],version:"current",frontMatter:{title:"Maps"},sidebar:"docs",previous:{title:"Sets",permalink:"/previews/ligo/modules/docs/next/data-types/sets"},next:{title:"tez",permalink:"/previews/ligo/modules/docs/next/data-types/tez"}},m={},l=[{value:"Sizing",id:"sizing",level:2},{value:"Searching",id:"searching",level:2},{value:"Adding",id:"adding",level:2},{value:"Removing",id:"removing",level:2},{value:"Updating",id:"updating",level:2},{value:"Folding",id:"folding",level:2},{value:"Mapping",id:"mapping",level:2},{value:"Iterating",id:"iterating",level:2},{value:"Looping",id:"looping",level:2}],s=(d="Syntax",function(e){return console.warn("Component "+d+" was not imported, exported, or provided by MDXProvider as global scope"),(0,p.kt)("div",e)});var d;const u={toc:l};function c(e){let{components:a,...t}=e;return(0,p.kt)("wrapper",(0,n.Z)({},u,t,{components:a,mdxType:"MDXLayout"}),(0,p.kt)("p",null,(0,p.kt)("em",{parentName:"p"},"Maps")," are a data structure which associates values of the same type to\nvalues of the same type. The former are called ",(0,p.kt)("em",{parentName:"p"},"key")," and the latter\n",(0,p.kt)("em",{parentName:"p"},"values"),". Together they make up a ",(0,p.kt)("em",{parentName:"p"},"binding"),". An additional requirement\nis that the type of the keys must be ",(0,p.kt)("em",{parentName:"p"},"comparable"),", in the Michelson\nsense."),(0,p.kt)("p",null,"As a consequence, the predefined type ",(0,p.kt)("inlineCode",{parentName:"p"},"map")," has two parameters: the\nfirst is the type of the keys, and the second the type of the\nassociated values."),(0,p.kt)("p",null,"The empty map is denoted by the predefined value ",(0,p.kt)("inlineCode",{parentName:"p"},"Map.empty"),". A\nnon-empty map can be built by using the function ",(0,p.kt)("inlineCode",{parentName:"p"},"Map.literal")," which\ntakes a list of pairs of key and values, and returns a map containing\nthem as bindings, and only them."),(0,p.kt)(s,{syntax:"cameligo",mdxType:"Syntax"},(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=maps",group:"maps"},'type word       = string\ntype definition = string list\ntype dictionary = (word, definition) map\n\nlet empty_dict : dictionary = Map.empty\n\nlet dictionary : dictionary =\n  Map.literal [\n    ("one", ["The number 1."; "A member of a group."]);\n    ("two", ["The number 2"])]\n')),(0,p.kt)("p",null,"The ",(0,p.kt)("inlineCode",{parentName:"p"},"Map.literal")," predefined function builds a map from a list of\nkey-value pairs, ",(0,p.kt)("inlineCode",{parentName:"p"},"(<key>, <value>)"),'.  Note also the "',(0,p.kt)("inlineCode",{parentName:"p"},";"),'" to separate\nindividual map bindings. Note that ',(0,p.kt)("inlineCode",{parentName:"p"},'("<string value>": address)')," means\nthat we type-cast a string into an address."),(0,p.kt)("p",null,"Note: See the predefined\n",(0,p.kt)("a",{parentName:"p",href:"../reference/map-reference"},"module Map"))),(0,p.kt)(s,{syntax:"jsligo",mdxType:"Syntax"},(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=maps",group:"maps"},'type word       = string;\ntype definition = list<string>;\ntype dictionary = map<word, definition>;\n\nconst empty_dict: dictionary = Map.empty;\n\nconst dictionary : dictionary =\n  Map.literal([\n    ["one", (["The number 1.", "A member of a group."] as definition)],\n    ["two", (["The number 2."] as definition)]]);\n')),(0,p.kt)("p",null,"The ",(0,p.kt)("inlineCode",{parentName:"p"},"Map.literal")," predefined function builds a map from a list of\nkey-value pairs, ",(0,p.kt)("inlineCode",{parentName:"p"},"[<key>, <value>]"),'.  Note also the "',(0,p.kt)("inlineCode",{parentName:"p"},","),'" to separate\nindividual map bindings. Note that ',(0,p.kt)("inlineCode",{parentName:"p"},'"<string value>" as address')," means\nthat we type-cast a string into an address."),(0,p.kt)("p",null,"Note: See the predefined\n",(0,p.kt)("a",{parentName:"p",href:"../reference/map-reference"},"namespace Map"))),(0,p.kt)("blockquote",null,(0,p.kt)("p",{parentName:"blockquote"},"Note: Map keys are internally sorted by increasing values, so the\ntype of the keys be ",(0,p.kt)("em",{parentName:"p"},"comparable"),", that is, they obey a total order\n(any two keys can be compared).")),(0,p.kt)("h2",{id:"sizing"},"Sizing"),(0,p.kt)("p",null,"The predefined function ",(0,p.kt)("inlineCode",{parentName:"p"},"Map.size")," returns the number of bindings\n(entries) in a given map."),(0,p.kt)(s,{syntax:"cameligo",mdxType:"Syntax"},(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=map_size",group:"map_size"},'let my_map : (int, string) map =\n  Map.literal [(1,"one"); (2,"two")]\nlet size : nat = Map.size my_map // = 2\n')),(0,p.kt)("p",null,"Note: See the predefined\n",(0,p.kt)("a",{parentName:"p",href:"../reference/map-reference"},"module Map"))),(0,p.kt)(s,{syntax:"jsligo",mdxType:"Syntax"},(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=map_size",group:"map_size"},'const my_map: map<int,string> =\n  Map.literal([[1,"one"],[2,"two"]]);\nconst size: nat = Map.size(my_map); // == 2\n')),(0,p.kt)("p",null,"Note: See the predefined\n",(0,p.kt)("a",{parentName:"p",href:"../reference/map-reference"},"namespace Map"))),(0,p.kt)("h2",{id:"searching"},"Searching"),(0,p.kt)("p",null,"The predicate ",(0,p.kt)("inlineCode",{parentName:"p"},"Map.mem")," tests for membership in a given map, given a\npurported key."),(0,p.kt)(s,{syntax:"cameligo",mdxType:"Syntax"},(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=map_searching",group:"map_searching"},'let my_map : (int, string) map =\n  Map.literal [(1,"one"); (2,"two")]\nlet contains_2 : bool = Map.mem 2 my_map // = true\n'))),(0,p.kt)(s,{syntax:"jsligo",mdxType:"Syntax"},(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=map_searching",group:"map_searching"},'const my_map: map<int,string> =\n  Map.literal([[1,"one"],[2,"two"]]);\nconst contains_2: bool = Map.mem(2, my_map); // == true\n'))),(0,p.kt)("p",null,"In practice, however, we would like to get the value associated to the\nkey we searched. This is achieved by means of ",(0,p.kt)("inlineCode",{parentName:"p"},"Map.find_opt"),"."),(0,p.kt)(s,{syntax:"cameligo",mdxType:"Syntax"},(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=map_searching",group:"map_searching"},"let v : string option = Map.find_opt 2 my_map\n"))),(0,p.kt)(s,{syntax:"jsligo",mdxType:"Syntax"},(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=map_searching",group:"map_searching"},"const v : option<string> = Map.find_opt(2, my_map);\n"))),(0,p.kt)("p",null,"Notice how the value we read is an optional value: this is to force\nthe reader to account for a missing key in the map. This requires\n",(0,p.kt)("em",{parentName:"p"},"pattern matching"),"."),(0,p.kt)(s,{syntax:"cameligo",mdxType:"Syntax"},(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=map_searching",group:"map_searching"},'let force_access key map =\n  match Map.find_opt key map with\n    Some value -> value\n  | None -> failwith "No value."\n'))),(0,p.kt)(s,{syntax:"jsligo",mdxType:"Syntax"},(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=map_searching",group:"map_searching"},'let force_access = (key, map) => {\n  return match(Map.find_opt (key, map)) {\n    when(Some(value)): value;\n    when(None): failwith("No value.")\n  };\n};\n'))),(0,p.kt)("p",null,"In fact, the predefined function ",(0,p.kt)("inlineCode",{parentName:"p"},"Map.find")," does exactly that, except\nthat the exception raised by ",(0,p.kt)("inlineCode",{parentName:"p"},"failwith")," carries the default string\n",(0,p.kt)("inlineCode",{parentName:"p"},'"MAP FIND"'),"."),(0,p.kt)(s,{syntax:"cameligo",mdxType:"Syntax"},(0,p.kt)("p",null,"Note: See the predefined\n",(0,p.kt)("a",{parentName:"p",href:"../reference/map-reference"},"module Map"))),(0,p.kt)(s,{syntax:"jsligo",mdxType:"Syntax"},(0,p.kt)("p",null,"Note: See the predefined\n",(0,p.kt)("a",{parentName:"p",href:"../reference/map-reference"},"namespace Map"))),(0,p.kt)("h2",{id:"adding"},"Adding"),(0,p.kt)("p",null,"Adding a binding to a map is done by calling the function\n",(0,p.kt)("inlineCode",{parentName:"p"},"Map.add"),". If the key was already present in the given map, the\ncorresponding value is updated."),(0,p.kt)(s,{syntax:"cameligo",mdxType:"Syntax"},(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=map_adding",group:"map_adding"},'let my_map : (int, string) map = Map.literal [(1,"one"); (2,"two")]\nlet new_map = Map.add 3 "three" my_map\nlet contains_3 = Map.mem 3 new_map // = true\n')),(0,p.kt)("p",null,"Note: See the predefined\n",(0,p.kt)("a",{parentName:"p",href:"../reference/map-reference"},"module Map"))),(0,p.kt)(s,{syntax:"jsligo",mdxType:"Syntax"},(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=map_adding",group:"map_adding"},'const my_map : map<int,string> = Map.literal([[1,"one"],[2,"two"]]);\nconst new_map = Map.add(3, "three", my_map);\nconst contains_3 = Map.mem(3, new_map); // == true\n')),(0,p.kt)("p",null,"Note: See the predefined\n",(0,p.kt)("a",{parentName:"p",href:"../reference/map-reference"},"namespace Map"))),(0,p.kt)("h2",{id:"removing"},"Removing"),(0,p.kt)("p",null,"The function ",(0,p.kt)("inlineCode",{parentName:"p"},"Map.remove")," creates a map containing the elements of a\ngiven map, without a given element. If the element is not already\npresent, the new map is the same as the old one, as expected."),(0,p.kt)(s,{syntax:"cameligo",mdxType:"Syntax"},(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=map_removing",group:"map_removing"},'let my_map : (int, string) map = Map.literal [(1,"one"); (2,"two")]\nlet new_map = Map.remove 2 my_map\nlet contains_3 = Map.mem 2 new_map // = false\n')),(0,p.kt)("p",null,"Note: See the predefined\n",(0,p.kt)("a",{parentName:"p",href:"../reference/map-reference"},"module Map"))),(0,p.kt)(s,{syntax:"jsligo",mdxType:"Syntax"},(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=map_removing",group:"map_removing"},'const my_map : map<int,string> = Map.literal([[1,"one"],[2,"two"]]);\nconst new_map = Map.remove(2, my_map);\nconst contains_3 = Map.mem(2, new_map); // == false\n')),(0,p.kt)("p",null,"Note: See the predefined\n",(0,p.kt)("a",{parentName:"p",href:"../reference/map-reference"},"namespace Map"))),(0,p.kt)("h2",{id:"updating"},"Updating"),(0,p.kt)("p",null,"Previous sections show how to add and remove a binding from a given\nmap. The function ",(0,p.kt)("inlineCode",{parentName:"p"},"Map.update")," can do both depending whether some\nvalue is given for the new binding or not: in the former case, a new\nbinding is added (and replaces any previous binding with the same\nkey); in the latter case, any binding with the same key is removed and\na new map is returned."),(0,p.kt)(s,{syntax:"cameligo",mdxType:"Syntax"},(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=map_updating",group:"map_updating"},'let my_map : (int, string) map = Map.literal [(1,"one"); (2,"two")]\nlet map_with_3 = Map.update 3 (Some "three") my_map\nlet contains_3 = Map.mem 3 map_with_3 // = true\nlet map_without_2 = Map.update 2 None my_map\nlet contains_2 = Map.mem 2 map_without_2 // = false\n'))),(0,p.kt)(s,{syntax:"jsligo",mdxType:"Syntax"},(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=map_updating",group:"map_updating"},'const my_map: map<int,string> = Map.literal([[1,"one"],[2,"two"]]);\nconst map_with_3 = Map.update (3, Some("three"), my_map);\nconst contains_3 = Map.mem(3, map_with_3); // == true\nconst map_without_2 = Map.update(2, None(), my_map);\nconst contains_2 = Map.mem (2, map_without_2); // == false\n'))),(0,p.kt)("p",null,"When we want to update a map, but also obtain the value of the updated\nbinding, we can use ",(0,p.kt)("inlineCode",{parentName:"p"},"Map.get_and_update"),"."),(0,p.kt)(s,{syntax:"cameligo",mdxType:"Syntax"},(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=map_updating",group:"map_updating"},'// three = Some "three"\nlet three, map_without_3 = Map.get_and_update 3 None map_with_3\n')),(0,p.kt)("p",null,"Note: See the predefined\n",(0,p.kt)("a",{parentName:"p",href:"../reference/map-reference"},"module Map"))),(0,p.kt)(s,{syntax:"jsligo",mdxType:"Syntax"},(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=map_updating",group:"map_updating"},'// three == Some("three")\nconst [three, map_without_3] = Map.get_and_update(3, None(), map_with_3);\n')),(0,p.kt)("p",null,"Note: See the predefined\n",(0,p.kt)("a",{parentName:"p",href:"../reference/map-reference"},"namespace Map"))),(0,p.kt)("h2",{id:"folding"},"Folding"),(0,p.kt)("p",null,"A ",(0,p.kt)("em",{parentName:"p"},"functional iterator")," is a function that traverses a data structure\nand calls in turn a given function over the elements of that structure\nto compute some value. Another approach is sometimes possible:\n",(0,p.kt)("em",{parentName:"p"},"loops"),"."),(0,p.kt)("p",null,"There are three kinds of functional iterations over maps: the ",(0,p.kt)("em",{parentName:"p"},"fold"),",\nthe ",(0,p.kt)("em",{parentName:"p"},"map")," (not to be confused with the ",(0,p.kt)("em",{parentName:"p"},"map data structure"),") and the\n",(0,p.kt)("em",{parentName:"p"},"iteration"),"."),(0,p.kt)("p",null,"Let us consider first here the fold, which is the most general form of\nfunctional iteration. The folded function takes two arguments: an\n",(0,p.kt)("em",{parentName:"p"},"accumulator")," and the structure ",(0,p.kt)("em",{parentName:"p"},"element")," at hand, with which it then\nproduces a new accumulator. This enables having a partial result that\nbecomes complete when the traversal of the data structure is over."),(0,p.kt)("p",null,"The function ",(0,p.kt)("inlineCode",{parentName:"p"},"Map.fold")," performs a fold over the binding of a map, in\nincreasing order of its keys."),(0,p.kt)(s,{syntax:"cameligo",mdxType:"Syntax"},(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=map_folding",group:"map_folding"},"type player = string\ntype abscissa = int\ntype ordinate = int\ntype move = abscissa * ordinate\ntype game = (player, move) map\n\nlet horizontal_offset (g : game) : int =\n  let folded = fun (acc, j : int * (player * move)) -> acc + j.1.0\n  in Map.fold folded g 0\n")),(0,p.kt)("p",null,"Note: See the predefined\n",(0,p.kt)("a",{parentName:"p",href:"../reference/map-reference"},"module Map"))),(0,p.kt)(s,{syntax:"jsligo",mdxType:"Syntax"},(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=map_folding",group:"map_folding"},"type player = string\ntype abscissa = int\ntype ordinate = int\ntype move = [abscissa, ordinate]\ntype game = map<player, move>\n\nconst horizontal_offset = (g: game): int => {\n  let folded = ([acc, j]: [int, [player, move]]) => acc + j[1][0];\n  return Map.fold(folded, g, 0);\n};\n")),(0,p.kt)("p",null,"Note: See the predefined\n",(0,p.kt)("a",{parentName:"p",href:"../reference/map-reference"},"namespace Map"))),(0,p.kt)("h2",{id:"mapping"},"Mapping"),(0,p.kt)("p",null,"We may want to change all the values of a given map by applying to\nthem a function. This is called a ",(0,p.kt)("em",{parentName:"p"},"map operation"),", not to be confused\nwith the map data structure. The predefined functional iterator\nimplementing the mapped operation over maps is called ",(0,p.kt)("inlineCode",{parentName:"p"},"Map.map"),". It\ntakes a binding, that is, a key and its associated value in the map,\nand computes a new value for that key."),(0,p.kt)("p",null,"In the following example, from a map from integers to integers is made\na map whose values are the sum of the keys and values of each binding."),(0,p.kt)(s,{syntax:"cameligo",mdxType:"Syntax"},(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=map_mapping",group:"map_mapping"},"let my_map : (int, int) map = Map.literal [(0,0); (1,1); (2,2)]\n// plus_one = Map.literal [(0,0); (1,2); (2,4)]\nlet plus_one = Map.map (fun (k,v) -> k + v) my_map\n")),(0,p.kt)("p",null,"Note: See the predefined\n",(0,p.kt)("a",{parentName:"p",href:"../reference/map-reference"},"module Map"))),(0,p.kt)(s,{syntax:"jsligo",mdxType:"Syntax"},(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=map_mapping",group:"map_mapping"},"const my_map : map<int,int> = Map.literal([[0,0], [1,1], [2,2]]);\n// plus_one == Map.literal([[0,0],[1,2],[2,4]])\nconst plus_one = Map.map(([k,v]) => k + v, my_map);\n")),(0,p.kt)("p",null,"Note: See the predefined\n",(0,p.kt)("a",{parentName:"p",href:"../reference/map-reference"},"namespace Map"))),(0,p.kt)("h2",{id:"iterating"},"Iterating"),(0,p.kt)("p",null,"An ",(0,p.kt)("em",{parentName:"p"},"iterated operation")," is a fold over the map that returns the value\nof type ",(0,p.kt)("inlineCode",{parentName:"p"},"unit"),", that is, its only use is to produce side-effects. This\ncan be useful if, for example, you would like to check that each value\nof a map is within a certain range, and fail with an error otherwise."),(0,p.kt)("p",null,"The predefined functional iterator implementing the iterated operation\nover maps is called ",(0,p.kt)("inlineCode",{parentName:"p"},"Map.iter"),". It\ntakes a binding, that is, a key and its associated value in the map,\nperforms some side-effect and returns the unit value."),(0,p.kt)("p",null,"In the following example, a map is iterated to check that all its\ninteger values are greater than ",(0,p.kt)("inlineCode",{parentName:"p"},"3"),"."),(0,p.kt)(s,{syntax:"cameligo",mdxType:"Syntax"},(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=map_iterating",group:"map_iterating"},"let assert_all_greater_than_3 (m : (int, int) map) : unit =\n  Map.iter (fun (_,v) -> assert (v > 3)) m  // The key is discarded\n")),(0,p.kt)("p",null,"Note: See the predefined\n",(0,p.kt)("a",{parentName:"p",href:"../reference/map-reference"},"module Map"))),(0,p.kt)(s,{syntax:"jsligo",mdxType:"Syntax"},(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=map_iterating",group:"map_iterating"},"const assert_all_greater_than_3 =\n  (m: map<int,int>) : unit => Map.iter(([_k,v]) => assert(v > 3), m);\n")),(0,p.kt)("p",null,"Note: See the predefined\n",(0,p.kt)("a",{parentName:"p",href:"../reference/map-reference"},"namespace Map"))),(0,p.kt)("h2",{id:"looping"},"Looping"),(0,p.kt)(s,{syntax:"cameligo",mdxType:"Syntax"},"There is no loop over maps in CameLIGO.",(0,p.kt)("p",null,"Note: See the predefined\n",(0,p.kt)("a",{parentName:"p",href:"../reference/map-reference"},"module Map"))),(0,p.kt)(s,{syntax:"jsligo",mdxType:"Syntax"},(0,p.kt)("p",null,"One can iterate through all the bindings of a map, in increasing order\nof the keys, thanks to a loop of the form ",(0,p.kt)("inlineCode",{parentName:"p"},"for (const <variable> of <map>) <block>"),". It means that the ",(0,p.kt)("inlineCode",{parentName:"p"},"<block>")," of statements (or a\nsingle statement) will be computed once for each ",(0,p.kt)("inlineCode",{parentName:"p"},"<variable>")," ranging\nover the bindings (as pairs of keys and values) of the map ",(0,p.kt)("inlineCode",{parentName:"p"},"<map>")," in\nincreasing order."),(0,p.kt)("p",null,"Here is an example where the values in a map are summed up."),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=map_looping",group:"map_looping"},"function sum_val (m: map<int,int>) {\n  let sum = 0;\n  // The key is discarded.\n  for (const [_key, val] of m) sum = sum + val;\n  return sum;\n};\n")),(0,p.kt)("p",null,"Note: See the predefined\n",(0,p.kt)("a",{parentName:"p",href:"../reference/map-reference"},"namespace Map"))))}c.isMDXComponent=!0}}]);