"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[53499],{48720:(e,t,n)=>{n.d(t,{D:()=>i.Z,Z:()=>o});var a=n(67294),i=n(75402);const o=function(e){return a.createElement(i.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},99191:(e,t,n)=>{n.d(t,{Z:()=>c});var a=n(43164),i=n(67294),o=n(52263),r=n(48720),l=n(11506);function s(){return s=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},s.apply(this,arguments)}const{Prism:p}=n(43164);p.languages={...p.languages,cameligo:{...p.languages.ocaml,comment:[/(^|[^\\])\/\*[\s\S]*?\*\//,/\(\*[\s\S]*?\*\)/,/\/\/.*/]},jsligo:p.languages.typescript};const c=function(e){const{siteConfig:{themeConfig:{prism:t={}}}}=(0,o.Z)(),n=t.singleTheme||l.Z,[p,c]=(0,i.useState)(!1);return(0,i.useEffect)((()=>{c(!0)}),[]),i.createElement(r.D.Consumer,null,(t=>{let{syntax:o}=t;return o===e.syntax?i.createElement(a.default,s({},a.defaultProps,{key:p,language:e.syntax,code:e.children,theme:n}),(e=>{let{className:t,tokens:n,getLineProps:a,getTokenProps:o}=e;return i.createElement("h4",{className:t,style:{backgroundColor:"var(--ifm-background-color)",fontFamily:"var(--ifm-font-family-monospace)",lineHeight:"var(--ifm-pre-line-height)",fontSize:"1.1rem",fontWeight:"bold",padding:0,whiteSpace:"break-spaces",marginTop:"3rem"}},n.map(((e,t)=>i.createElement("div",a({line:e,key:t}),e.map(((e,t)=>i.createElement("span",o({token:e,key:t}))))))))})):i.createElement("div",null)}))}},22757:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>l,metadata:()=>p,toc:()=>d});var a=n(87462),i=(n(67294),n(3905)),o=n(48720),r=n(99191);const l={id:"tezos.next.operation-reference",title:"operation",hide_table_of_contents:!0},s=void 0,p={unversionedId:"reference/tezos.next.operation-reference",id:"version-1.7.0/reference/tezos.next.operation-reference",title:"operation",description:"val create&#95;contract :",source:"@site/versioned_docs/version-1.7.0/reference/tezos.next.operation.md",sourceDirName:"reference",slug:"/reference/tezos.next.operation-reference",permalink:"/previews/ligo/modules/docs/reference/tezos.next.operation-reference",draft:!1,tags:[],version:"1.7.0",frontMatter:{id:"tezos.next.operation-reference",title:"operation",hide_table_of_contents:!0},sidebar:"API",previous:{title:"view",permalink:"/previews/ligo/modules/docs/reference/tezos.next.view-reference"},next:{title:"ticket",permalink:"/previews/ligo/modules/docs/reference/tezos.next.ticket-reference"}},c={},d=[],m={toc:d};function h(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val create_contract : 'param 'storage.('param, 'storage) entrypoint -> key_hash option -> tez -> 'storage -> (operation * address)"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let create_contract: <param, storage>(_: entrypoint<param, storage>) => (_: option<key_hash>) => (_: tez) => (_: storage) => [ operation, address ]"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"create_contract e d a s")," returns a contract creation\noperation (origination) for the entrypoint ",(0,i.kt)("inlineCode",{parentName:"p"},"e")," (as a function)\nwith optional delegate ",(0,i.kt)("inlineCode",{parentName:"p"},"d"),", initial amount ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," and initial\nstorage ",(0,i.kt)("inlineCode",{parentName:"p"},"s"),", together with the address of the created\ncontract. Note that the created contract cannot be called\nimmediately afterwards (that is, ",(0,i.kt)("inlineCode",{parentName:"p"},"get_contract_opt")," on that\naddress would return ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),"), as the origination must be\nperformed successfully first, for example by calling a proxy\ncontract or itself.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"create_contract(e,d,a,s)")," returns a contract creation\noperation (origination) for the entrypoint ",(0,i.kt)("inlineCode",{parentName:"p"},"e")," (as a function)\nwith optional delegate ",(0,i.kt)("inlineCode",{parentName:"p"},"d"),", initial amount ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," and initial\nstorage ",(0,i.kt)("inlineCode",{parentName:"p"},"s"),", together with the address of the created\ncontract. Note that the created contract cannot be called\nimmediately afterwards (that is, ",(0,i.kt)("inlineCode",{parentName:"p"},"get_contract_opt")," on that\naddress would return ",(0,i.kt)("inlineCode",{parentName:"p"},"None()"),"), as the origination must be\nperformed successfully first, for example by calling a proxy\ncontract or itself.")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val set_delegate : key_hash option -> operation"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let set_delegate: (_: option<key_hash>) => operation"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"set_delegate d")," evaluates in an operation that sets\nthe delegate of the current smart contract to be ",(0,i.kt)("inlineCode",{parentName:"p"},"d"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"d")," is\nan optional key hash. If ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),", the delegation is withdrawn. If\nthe contract has no delegation, then no change occurs. If ",(0,i.kt)("inlineCode",{parentName:"p"},"d")," is\n",(0,i.kt)("inlineCode",{parentName:"p"},"Some kh"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"kh")," is the key hash of a registered delegate\nthat is not the current delegate of the contract, then this\noperation sets the delegate of the contract to this registered\ndelegate. A failure occurs if ",(0,i.kt)("inlineCode",{parentName:"p"},"kh")," is the current delegate of the\ncontract or if ",(0,i.kt)("inlineCode",{parentName:"p"},"kh")," is not a registered delegate. However, the\ninstruction in itself does not fail; it produces an operation that\nwill fail when applied.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"set_delegate(d)")," evaluates in an operation that sets\nthe delegate of the current smart contract to be ",(0,i.kt)("inlineCode",{parentName:"p"},"d"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"d")," is\nan optional key hash. If ",(0,i.kt)("inlineCode",{parentName:"p"},"None()"),", the delegation is withdrawn. If\nthe contract has no delegation, then no change occurs. If ",(0,i.kt)("inlineCode",{parentName:"p"},"d")," is\n",(0,i.kt)("inlineCode",{parentName:"p"},"Some(kh)"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"kh")," is the key hash of a registered delegate\nthat is not the current delegate of the contract, then this\noperation sets the delegate of the contract to this registered\ndelegate. A failure occurs if ",(0,i.kt)("inlineCode",{parentName:"p"},"kh")," is the current delegate of the\ncontract or if ",(0,i.kt)("inlineCode",{parentName:"p"},"kh")," is not a registered delegate. However, the\ninstruction in itself does not fail; it produces an operation that\nwill fail when applied.")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val transaction : 'param.'param -> tez -> 'param contract -> operation"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let transaction: <param>(_: param) => (_: tez) => (_: contract<param>) => operation"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"transaction param amount contract_addr")," evaluates in\nan operation that will send the amount ",(0,i.kt)("inlineCode",{parentName:"p"},"amount")," in mutez to the\ncontract at the valid address ",(0,i.kt)("inlineCode",{parentName:"p"},"contract_addr"),", with parameter\n",(0,i.kt)("inlineCode",{parentName:"p"},"param"),". If the contract is an implicit account, the parameter\nmust be ",(0,i.kt)("inlineCode",{parentName:"p"},"unit"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"transaction(param, amount, contract_addr)")," evaluates in\nan operation that will send the amount ",(0,i.kt)("inlineCode",{parentName:"p"},"amount")," in mutez to the\ncontract at the valid address ",(0,i.kt)("inlineCode",{parentName:"p"},"contract_addr"),", with parameter\n",(0,i.kt)("inlineCode",{parentName:"p"},"param"),". If the contract is an implicit account, the parameter\nmust be ",(0,i.kt)("inlineCode",{parentName:"p"},"unit"),".")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val emit : 'event_type.string -> 'event_type -> operation"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let emit: <event_type>(_: string) => (_: event_type) => operation"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"emit event_tag event_type")," evaluates in an operation\nthat will write an event into the transaction receipt after the\nsuccessful execution of this contract. The event is annotated by\nthe string ",(0,i.kt)("inlineCode",{parentName:"p"},"event_tag")," if it is not empty. The argument\n",(0,i.kt)("inlineCode",{parentName:"p"},"event_type")," is used only to specify the type of data attachment.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"emit event_tag(event_type)")," evaluates in an operation\nthat will write an event into the transaction receipt after the\nsuccessful execution of this contract. The event is annotated by\nthe string ",(0,i.kt)("inlineCode",{parentName:"p"},"event_tag")," if it is not empty. The argument\n",(0,i.kt)("inlineCode",{parentName:"p"},"event_type")," is used only to specify the type of data attachment.")))}h.isMDXComponent=!0}}]);