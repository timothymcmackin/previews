"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[25433],{48720:(t,e,n)=>{n.d(e,{D:()=>i.Z,Z:()=>o});var a=n(67294),i=n(75402);const o=function(t){return a.createElement(i.Z.Consumer,null,(e=>{let{syntax:n}=e;return n===t.syntax?t.children:a.createElement(a.Fragment,null)}))}},99191:(t,e,n)=>{n.d(e,{Z:()=>p});var a=n(43164),i=n(67294),o=n(52263),r=n(48720),s=n(11506);function l(){return l=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(t[a]=n[a])}return t},l.apply(this,arguments)}const{Prism:c}=n(43164);c.languages={...c.languages,cameligo:{...c.languages.ocaml,comment:[/(^|[^\\])\/\*[\s\S]*?\*\//,/\(\*[\s\S]*?\*\)/,/\/\/.*/]},jsligo:c.languages.typescript};const p=function(t){const{siteConfig:{themeConfig:{prism:e={}}}}=(0,o.Z)(),n=e.singleTheme||s.Z,[c,p]=(0,i.useState)(!1);return(0,i.useEffect)((()=>{p(!0)}),[]),i.createElement(r.D.Consumer,null,(e=>{let{syntax:o}=e;return o===t.syntax?i.createElement(a.default,l({},a.defaultProps,{key:c,language:t.syntax,code:t.children,theme:n}),(t=>{let{className:e,tokens:n,getLineProps:a,getTokenProps:o}=t;return i.createElement("h4",{className:e,style:{backgroundColor:"var(--ifm-background-color)",fontFamily:"var(--ifm-font-family-monospace)",lineHeight:"var(--ifm-pre-line-height)",fontSize:"1.1rem",fontWeight:"bold",padding:0,whiteSpace:"break-spaces",marginTop:"3rem"}},n.map(((t,e)=>i.createElement("div",a({line:t,key:e}),t.map(((t,e)=>i.createElement("span",o({token:t,key:e}))))))))})):i.createElement("div",null)}))}},83571:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>p,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>c,toc:()=>d});var a=n(87462),i=(n(67294),n(3905)),o=n(48720),r=n(99191);const s={id:"tezos.next-reference",title:"next",hide_table_of_contents:!0},l=void 0,c={unversionedId:"reference/tezos.next-reference",id:"reference/tezos.next-reference",title:"next",description:"module operation",source:"@site/../docs/reference/tezos.next.md",sourceDirName:"reference",slug:"/reference/tezos.next-reference",permalink:"/previews/ligo/modules/docs/next/reference/tezos.next-reference",draft:!1,tags:[],version:"current",frontMatter:{id:"tezos.next-reference",title:"next",hide_table_of_contents:!0},sidebar:"API",previous:{title:"ticket",permalink:"/previews/ligo/modules/docs/next/reference/tezos.next.ticket-reference"},next:{title:"pbt",permalink:"/previews/ligo/modules/docs/next/reference/test.pbt-reference"}},p={},d=[],m={toc:d};function h(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,a.Z)({},m,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/previews/ligo/modules/docs/next/reference/tezos.next.operation-reference"},"module operation")),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/previews/ligo/modules/docs/next/reference/tezos.next.view-reference"},"module view")),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/previews/ligo/modules/docs/next/reference/tezos.next.ticket-reference"},"module ticket")),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/previews/ligo/modules/docs/next/reference/tezos.next.sapling-reference"},"module sapling")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_sender : unit -> address"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let get_sender: (_: unit) => address"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"get_sender ()")," is the address of the contract (that\nis, a smart contract or an implicit account) that initiated the\ncurrent internal transaction. Note that, if transactions have been\nchained, that address could be different from ",(0,i.kt)("inlineCode",{parentName:"p"},"get_source ()"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"get_sender()")," is the address of the contract (that\nis, a smart contract or an implicit account) that initiated the\ncurrent internal transaction. Note that, if transactions have been\nchained, that address could be different from ",(0,i.kt)("inlineCode",{parentName:"p"},"get_source()"),".")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_source : unit -> address"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let get_source: (_: unit) => address"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"get_source ()")," is the address of the implicit account\nthat initiated the current transaction. If transactions have been\nchained, that address is different from ",(0,i.kt)("inlineCode",{parentName:"p"},"get_sender ()"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"get_source()")," is the address of the implicit account\nthat initiated the current transaction. If transactions have been\nchained, that address is different from ",(0,i.kt)("inlineCode",{parentName:"p"},"get_sender()"),".")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val self : 'a.string -> 'a contract"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let self: <a>(_: string) => contract<a>"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"self entrypoint")," is the address of the current smart\ncontract, that is, the smart contract containing the call. For the\naddress of the smart contract actually ",(0,i.kt)("em",{parentName:"p"},"executing")," the call,\nbecause it is embedded in a lambda sent to another smart contract,\nuse ",(0,i.kt)("inlineCode",{parentName:"p"},"get_self_address")," instead. The string ",(0,i.kt)("inlineCode",{parentName:"p"},"entrypoint")," is the\nname of a valid entrypoint such that ",(0,i.kt)("inlineCode",{parentName:"p"},"entrypoint")," is not\n",(0,i.kt)("inlineCode",{parentName:"p"},'"default"'),", or the empty string denoting the ",(0,i.kt)("inlineCode",{parentName:"p"},'"default"'),"\nentrypoint (which is the root of the smart contract parameter if\nno ",(0,i.kt)("inlineCode",{parentName:"p"},'"default"')," entrypoint is explicitly defined). If the contract\ndoes not have the specified entrypoint, the call results in an\ntype checking error.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"self(entrypoint)")," is the address of the current smart\ncontract, that is, the smart contract containing the call. For the\naddress of the smart contract actually ",(0,i.kt)("em",{parentName:"p"},"executing")," the call,\nbecause it is embedded in a lambda sent to another smart contract,\nuse ",(0,i.kt)("inlineCode",{parentName:"p"},"get_self_address")," instead. The string ",(0,i.kt)("inlineCode",{parentName:"p"},"entrypoint")," is the\nname of a valid entrypoint such that ",(0,i.kt)("inlineCode",{parentName:"p"},"entrypoint")," is not\n",(0,i.kt)("inlineCode",{parentName:"p"},'"default"'),", or the empty string denoting the ",(0,i.kt)("inlineCode",{parentName:"p"},'"default"'),"\nentrypoint (which is the root of the smart contract parameter if\nno ",(0,i.kt)("inlineCode",{parentName:"p"},'"default"')," entrypoint is explicitly defined). If the contract\ndoes not have the specified entrypoint, the call results in an\ntype checking error.")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_self_address : unit -> address"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let get_self_address: (_: unit) => address"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"get_self_address ()")," is the address of the smart\ncontract actually executing the call, as a value of type\n",(0,i.kt)("inlineCode",{parentName:"p"},"address"),". That contract can be different from the one containing\nthe call if the call is in a lambda transmitted to another smart\ncontract. Therefore, it is assumed that, in general, the type of\nthe executing contract is statically unknown, so the return type\nof ",(0,i.kt)("inlineCode",{parentName:"p"},"get_self_address")," is not ",(0,i.kt)("inlineCode",{parentName:"p"},"'a contract"),", but ",(0,i.kt)("inlineCode",{parentName:"p"},"address"),". (See\n",(0,i.kt)("inlineCode",{parentName:"p"},"self"),".)")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"get_self_address()")," is the address of the smart\ncontract actually executing the call, as a value of type\n",(0,i.kt)("inlineCode",{parentName:"p"},"address"),". That contract can be different from the one containing\nthe call if the call is in a lambda transmitted to another smart\ncontract. Therefore, it is assumed that, in general, the type of\nthe executing contract is statically unknown, so the return type\nof ",(0,i.kt)("inlineCode",{parentName:"p"},"get_self_address")," is not ",(0,i.kt)("inlineCode",{parentName:"p"},"'a contract"),", but ",(0,i.kt)("inlineCode",{parentName:"p"},"address"),". (See\n",(0,i.kt)("inlineCode",{parentName:"p"},"self"),".)")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val address : 'a.'a contract -> address"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let address: <a>(_: contract<a>) => address"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"address contract")," casts the address of the smart\ncontract ",(0,i.kt)("inlineCode",{parentName:"p"},"contract")," into the more general value of type\n",(0,i.kt)("inlineCode",{parentName:"p"},"address"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"address(contract)")," casts the address of the smart\ncontract ",(0,i.kt)("inlineCode",{parentName:"p"},"contract")," into the more general value of type\n",(0,i.kt)("inlineCode",{parentName:"p"},"address"),".")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val implicit_account : key_hash -> unit contract"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let implicit_account: (_: key_hash) => contract<unit>"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"implicit_account kh")," casts the public key hash ",(0,i.kt)("inlineCode",{parentName:"p"},"kh"),"\ninto the address of its implicit account. Note that addresses of\nimplicit accounts always have the type ",(0,i.kt)("inlineCode",{parentName:"p"},"unit contract"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"implicit_account(kh)")," casts the public key hash ",(0,i.kt)("inlineCode",{parentName:"p"},"kh"),"\ninto the address of its implicit account. Note that addresses of\nimplicit accounts always have the type ",(0,i.kt)("inlineCode",{parentName:"p"},"contract<unit>"),".")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_contract_opt : 'param.address -> 'param contract option"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let get_contract_opt: <param>(_: address) => option<contract<param>>"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"get_contract_opt addr")," casts the address ",(0,i.kt)("inlineCode",{parentName:"p"},"addr")," into\nthat of a contract address, if such contract exists. The value of\nthe call is ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," if no such contract exists, otherwise ",(0,i.kt)("inlineCode",{parentName:"p"},"Some\n      contract"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"contract")," is the contract's address. Note: The\naddress of an implicit account has type ",(0,i.kt)("inlineCode",{parentName:"p"},"unit contract"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"get_contract_opt(addr)")," casts the address ",(0,i.kt)("inlineCode",{parentName:"p"},"addr")," into\nthat of a contract address, if such contract exists. The value of\nthe call is ",(0,i.kt)("inlineCode",{parentName:"p"},"None()")," if no such contract exists, otherwise ",(0,i.kt)("inlineCode",{parentName:"p"},"Some\n      contract"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"contract")," is the contract's address. Note: The\naddress of an implicit account has type ",(0,i.kt)("inlineCode",{parentName:"p"},"unit contract"),".")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_contract_with_error : 'param.address -> string -> 'param contract"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let get_contract_with_error: <param>(_: address) => (_: string) => contract<param>"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"get_contract_with_error addr error")," casts the address\n",(0,i.kt)("inlineCode",{parentName:"p"},"addr")," into that of a contract address, if such contract\nexists. If not, the execution fails with the error message\n",(0,i.kt)("inlineCode",{parentName:"p"},"error"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"get_contract_with_error(addr, error)")," casts the address\n",(0,i.kt)("inlineCode",{parentName:"p"},"addr")," into that of a contract address, if such contract\nexists. If not, the execution fails with the error message\n",(0,i.kt)("inlineCode",{parentName:"p"},"error"),".")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_contract : 'param.address -> 'param contract"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let get_contract: <param>(_: address) => contract<param>"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"get_contract addr")," casts the address ",(0,i.kt)("inlineCode",{parentName:"p"},"addr")," into that\nof a smart contract address, if such contract exists. The call\nfails with the message ",(0,i.kt)("inlineCode",{parentName:"p"},'"bad address for get_contract"')," if no\nsuch smart contract exists. Note: The address of an implicit\naccount has type ",(0,i.kt)("inlineCode",{parentName:"p"},"unit contract"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"get_contract(addr)")," casts the address ",(0,i.kt)("inlineCode",{parentName:"p"},"addr")," into that\nof a smart contract address, if such contract exists. The call\nfails with the message ",(0,i.kt)("inlineCode",{parentName:"p"},'"bad address for get_contract"')," if no\nsuch smart contract exists. Note: The address of an implicit\naccount has type ",(0,i.kt)("inlineCode",{parentName:"p"},"contract<unit>"),".")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_entrypoint_opt : 'param.string -> address -> 'param contract option"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let get_entrypoint_opt: <param>(_: string) => (_: address) => option<contract<param>>"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"get_entrypoint_opt entrypoint addr")," has the same\nbehaviour as ",(0,i.kt)("inlineCode",{parentName:"p"},"get_contract_opt addr"),", with the additional\nconstraint that the contract must have an entrypoint named\n",(0,i.kt)("inlineCode",{parentName:"p"},"entrypoint"),". In other words, ",(0,i.kt)("inlineCode",{parentName:"p"},"get_entrypoint_opt entrypoint addr"),"\ncasts the address ",(0,i.kt)("inlineCode",{parentName:"p"},"addr")," into that of a smart contract\naddress, if such contract exists and has an entrypoint named\n",(0,i.kt)("inlineCode",{parentName:"p"},"entrypoint"),". The value of the call is ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," if no such smart\ncontract exists, otherwise ",(0,i.kt)("inlineCode",{parentName:"p"},"Some contract"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"contract")," is\nthe smart contract's address. Note: The address of an implicit\naccount has type ",(0,i.kt)("inlineCode",{parentName:"p"},"unit contract"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"get_entrypoint_opt(entrypoint, addr)")," has the same\nbehaviour as ",(0,i.kt)("inlineCode",{parentName:"p"},"get_contract_opt(addr)"),", with the additional\nconstraint that the contract must have an entrypoint named\n",(0,i.kt)("inlineCode",{parentName:"p"},"entrypoint"),". In other words, ",(0,i.kt)("inlineCode",{parentName:"p"},"get_entrypoint_opt(entrypoint, addr)"),"\ncasts the address ",(0,i.kt)("inlineCode",{parentName:"p"},"addr")," into that of a smart contract\naddress, if such contract exists and has an entrypoint named\n",(0,i.kt)("inlineCode",{parentName:"p"},"entrypoint"),". The value of the call is ",(0,i.kt)("inlineCode",{parentName:"p"},"None()")," if no such smart\ncontract exists, otherwise ",(0,i.kt)("inlineCode",{parentName:"p"},"Some(contract)"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"contract")," is\nthe smart contract's address. Note: The address of an implicit\naccount has type ",(0,i.kt)("inlineCode",{parentName:"p"},"contract<unit>"),".")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_entrypoint : 'param.string -> address -> 'param contract"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let get_entrypoint: <param>(_: string) => (_: address) => contract<param>"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"get_entrypoint entrypoint addr")," casts the address\n",(0,i.kt)("inlineCode",{parentName:"p"},"addr")," into that of a smart contract address, if such contract\nexists and has an entrypoint named ",(0,i.kt)("inlineCode",{parentName:"p"},"entrypoint"),". If no such smart\ncontract exists, the execution fails with the error message\n",(0,i.kt)("inlineCode",{parentName:"p"},'"bad address for get_entrypoint"'),". Note: The address of an implicit\naccount has type ",(0,i.kt)("inlineCode",{parentName:"p"},"unit contract"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"get_entrypoint(entrypoint, addr)")," casts the address\n",(0,i.kt)("inlineCode",{parentName:"p"},"addr")," into that of a smart contract address, if such contract\nexists and has an entrypoint named ",(0,i.kt)("inlineCode",{parentName:"p"},"entrypoint"),". If no such smart\ncontract exists, the execution fails with the error message\n",(0,i.kt)("inlineCode",{parentName:"p"},'"bad address for get_entrypoint"'),". Note: The address of an implicit\naccount has type ",(0,i.kt)("inlineCode",{parentName:"p"},"contract<unit>"),".")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val open_chest : chest_key -> chest -> nat -> bytes option"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let open_chest: (_: chest_key) => (_: chest) => (_: nat) => option<bytes>"),"The function [open_chest] opens a timelocked chest given its key and the time. The result is a byte option depending if the opening is correct or not.",(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_balance : unit -> tez"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let get_balance: (_: unit) => tez"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"get_balance ()")," returns the balance in mutez of the\naccount associated to the currently executed smart contract,\nincluding any mutez added by the calling transaction.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"get_balance()")," returns the balance in mutez of the\naccount associated to the currently executed smart contract,\nincluding any mutez added by the calling transaction.")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_amount : unit -> tez"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let get_amount: (_: unit) => tez"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"get_amount ()")," returns the amount in mutez of the\ncurrent transaction.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"get_amount()")," returns the amount in mutez of the\ncurrent transaction.")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_now : unit -> timestamp"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let get_now: (_: unit) => timestamp"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"get_now ()"),' returns the minimal injection time for the\ncurrent block, namely the block whose application triggered this\nexecution. The minimal injection time constitutes an estimate of\nthe moment when the current block is injected, hence the name\n"now".')),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"get_now()"),' returns the minimal injection time for the\ncurrent block, namely the block whose application triggered this\nexecution. The minimal injection time constitutes an estimate of\nthe moment when the current block is injected, hence the name\n"now".')),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_min_block_time : unit -> nat"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let get_min_block_time: (_: unit) => nat"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"get_min_block_time ()")," returns the minimal delay\nbetween two consecutive blocks in the chain.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"get_min_block_time()")," returns the minimal delay\nbetween two consecutive blocks in the chain.")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_level : unit -> nat"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let get_level: (_: unit) => nat"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"get_level ()")," returns the current block level.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"get_level()")," returns the current block level.")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_chain_id : unit -> chain_id"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let get_chain_id: (_: unit) => chain_id"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"get_chain_id ()")," returns the identifier of the chain\non which the smart contract is executed.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"get_chain_id ()")," returns the identifier of the chain\non which the smart contract is executed.")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_total_voting_power : unit -> nat"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let get_total_voting_power: (_: unit) => nat"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"get_total_voting_power ()")," returns the total voting\npower of all contracts. The total voting power coincides with the\nsum of the stake of every contract in the voting listings. The\nvoting listings is calculated at the beginning of every voting\nperiod.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"get_total_voting_power()")," returns the total voting\npower of all contracts. The total voting power coincides with the\nsum of the stake of every contract in the voting listings. The\nvoting listings is calculated at the beginning of every voting\nperiod.")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val voting_power : key_hash -> nat"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let voting_power: (_: key_hash) => nat"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"voting_power contract_kh")," returns the voting power of\na given contract specified by the key hash ",(0,i.kt)("inlineCode",{parentName:"p"},"contract_kh"),". This\nvoting power coincides with the weight of the contract in the\nvoting listings (that is, the stake) which is calculated at the\nbeginning of every voting period.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"voting_power(contract_kh)")," returns the voting power of\na given contract specified by the key hash ",(0,i.kt)("inlineCode",{parentName:"p"},"contract_kh"),". This\nvoting power coincides with the weight of the contract in the\nvoting listings (that is, the stake) which is calculated at the\nbeginning of every voting period.")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val never : 'a.never -> 'a"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let never: <a>(_: never) => a"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"never n")," is never meant to be executed, as the type\n",(0,i.kt)("inlineCode",{parentName:"p"},"never")," is inhabited, but to instruct the typechecker that a\nbranch in the control flow, for example, in a pattern matching, is\ndead.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"never(n)")," is never meant to be executed, as the type\n",(0,i.kt)("inlineCode",{parentName:"p"},"never")," is inhabited, but to instruct the typechecker that a\nbranch in the control flow, for example, in a pattern matching, is\ndead.")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val pairing_check : (bls12_381_g1 * bls12_381_g2) list -> bool"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let pairing_check: (_: list<[bls12_381_g1, bls12_381_g2]>) => bool"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"pairing_check pairings")," verifies that the product of\npairings of the given list of points ",(0,i.kt)("inlineCode",{parentName:"p"},"pairings")," is equal to 1 in\nthe field Fq12. It evaluates in ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," if the list is empty. This\nfunction can be used to verify if two pairings P1 and P2 are equal\nby verifying P1 * P2^(-1) = 1.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"pairing_check(pairings)")," verifies that the product of\npairings of the given list of points ",(0,i.kt)("inlineCode",{parentName:"p"},"pairings")," is equal to 1 in\nthe field Fq12. It evaluates in ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," if the list is empty. This\nfunction can be used to verify if two pairings P1 and P2 are equal\nby verifying P1 * P2^(-1) = 1.")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val constant : 'a.string -> 'a"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let constant: <a>(_: string) => a"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call to ",(0,i.kt)("inlineCode",{parentName:"p"},"constant hash")," returns the value stored on-chain\nwhose hash value is ",(0,i.kt)("inlineCode",{parentName:"p"},"hash")," (global constants). This call can fail\nwhen the contract is originated if the hash is invalid or the\nexpansion of the global constant is ill-typed, or too large (gas\nconsumption).")),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call to ",(0,i.kt)("inlineCode",{parentName:"p"},"constant(hash)")," returns the value stored on-chain\nwhose hash value is ",(0,i.kt)("inlineCode",{parentName:"p"},"hash")," (global constants). This call can fail\nwhen the contract is originated if the hash is invalid or the\nexpansion of the global constant is ill-typed, or too large (gas\nconsumption).")))}h.isMDXComponent=!0}}]);