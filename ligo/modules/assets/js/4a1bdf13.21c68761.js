"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[89546],{48720:(e,t,n)=>{n.d(t,{D:()=>i.Z,Z:()=>l});var a=n(67294),i=n(75402);const l=function(e){return a.createElement(i.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},99191:(e,t,n)=>{n.d(t,{Z:()=>y});var a=n(43164),i=n(67294),l=n(52263),s=n(48720),o=n(11506);function r(){return r=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},r.apply(this,arguments)}const{Prism:p}=n(43164);p.languages={...p.languages,cameligo:{...p.languages.ocaml,comment:[/(^|[^\\])\/\*[\s\S]*?\*\//,/\(\*[\s\S]*?\*\)/,/\/\/.*/]},jsligo:p.languages.typescript};const y=function(e){const{siteConfig:{themeConfig:{prism:t={}}}}=(0,l.Z)(),n=t.singleTheme||o.Z,[p,y]=(0,i.useState)(!1);return(0,i.useEffect)((()=>{y(!0)}),[]),i.createElement(s.D.Consumer,null,(t=>{let{syntax:l}=t;return l===e.syntax?i.createElement(a.default,r({},a.defaultProps,{key:p,language:e.syntax,code:e.children,theme:n}),(e=>{let{className:t,tokens:n,getLineProps:a,getTokenProps:l}=e;return i.createElement("h4",{className:t,style:{backgroundColor:"var(--ifm-background-color)",fontFamily:"var(--ifm-font-family-monospace)",lineHeight:"var(--ifm-pre-line-height)",fontSize:"1.1rem",fontWeight:"bold",padding:0,whiteSpace:"break-spaces",marginTop:"3rem"}},n.map(((e,t)=>i.createElement("div",a({line:e,key:t}),e.map(((e,t)=>i.createElement("span",l({token:e,key:t}))))))))})):i.createElement("div",null)}))}},59718:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>y,contentTitle:()=>r,default:()=>m,frontMatter:()=>o,metadata:()=>p,toc:()=>c});var a=n(87462),i=(n(67294),n(3905)),l=n(48720),s=n(99191);const o={id:"bytes-reference",title:"bytes",hide_table_of_contents:!0},r=void 0,p={unversionedId:"reference/bytes-reference",id:"version-1.6.0/reference/bytes-reference",title:"bytes",description:"Sequences of bytes",source:"@site/versioned_docs/version-1.6.0/reference/bytes.md",sourceDirName:"reference",slug:"/reference/bytes-reference",permalink:"/previews/ligo/modules/docs/1.6.0/reference/bytes-reference",draft:!1,tags:[],version:"1.6.0",frontMatter:{id:"bytes-reference",title:"bytes",hide_table_of_contents:!0},sidebar:"API",next:{title:"toplevel",permalink:"/previews/ligo/modules/docs/1.6.0/reference/toplevel-reference"}},y={},c=[],d={toc:c};function m(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Sequences of bytes"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Bytes are used for serializing data, in order to check signatures\nand compute hashes on them. They can also be used to read untyped\ndata from outside of the contract.\n")),(0,i.kt)(s.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val length : bytes -> nat"),(0,i.kt)(s.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let length: (_: bytes) => nat"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"length b")," is the number of bytes in the sequence of\nbytes ",(0,i.kt)("inlineCode",{parentName:"p"},"b"),". Note: ",(0,i.kt)("inlineCode",{parentName:"p"},"Bytes.length")," is another name for\n",(0,i.kt)("inlineCode",{parentName:"p"},"Bytes.size"),".")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"length(b)")," is the number of bytes in the sequence of\nbytes ",(0,i.kt)("inlineCode",{parentName:"p"},"b"),". Note: ",(0,i.kt)("inlineCode",{parentName:"p"},"Bytes.length")," is another name for\n",(0,i.kt)("inlineCode",{parentName:"p"},"Bytes.size"),".")),(0,i.kt)(s.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val size : bytes -> nat"),(0,i.kt)(s.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let size: (_: bytes) => nat"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"size b")," is the number of bytes in the sequence of\nbytes ",(0,i.kt)("inlineCode",{parentName:"p"},"b"),".")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"size(b)")," is the number of bytes in the sequence of\nbytes ",(0,i.kt)("inlineCode",{parentName:"p"},"b"),".")),(0,i.kt)(s.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val concat : bytes -> bytes -> bytes"),(0,i.kt)(s.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let concat: (_: bytes) => (_: bytes) => bytes"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"concat left right")," is the sequence of bytes obtained\nby concatenating the sequence ",(0,i.kt)("inlineCode",{parentName:"p"},"left")," before the sequence\n",(0,i.kt)("inlineCode",{parentName:"p"},"right"),".")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"concat(left, right)")," is the sequence of bytes obtained\nby concatenating the sequence ",(0,i.kt)("inlineCode",{parentName:"p"},"left")," before the sequence\n",(0,i.kt)("inlineCode",{parentName:"p"},"right"),".")),(0,i.kt)(s.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val concats : bytes list -> bytes"),(0,i.kt)(s.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let concats: (_: list<bytes>) => bytes"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"concats list")," is the concatenation of the byte\nsequences in the list ",(0,i.kt)("inlineCode",{parentName:"p"},"list"),", from left to right.")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"concats(list)")," is the concatenation of the byte\nsequences in the list ",(0,i.kt)("inlineCode",{parentName:"p"},"list"),", from left to right.")),(0,i.kt)(s.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val sub : nat -> nat -> bytes -> bytes"),(0,i.kt)(s.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let sub: (_: nat) => (_: nat) => (_: bytes) => bytes"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"sub index len bytes")," is the subsequence of bytes\n",(0,i.kt)("inlineCode",{parentName:"p"},"bytes")," starting at index ",(0,i.kt)("inlineCode",{parentName:"p"},"index")," (0 denoting the first byte) and\nof length ",(0,i.kt)("inlineCode",{parentName:"p"},"len"),". If the index or length are invalid, an exception\ninterrupts the execution.")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"sub(index, len, bytes)")," is the subsequence of bytes\n",(0,i.kt)("inlineCode",{parentName:"p"},"bytes")," starting at index ",(0,i.kt)("inlineCode",{parentName:"p"},"index")," (0 denoting the first byte) and\nof length ",(0,i.kt)("inlineCode",{parentName:"p"},"len"),". If the index or length are invalid, an exception\ninterrupts the execution.")),(0,i.kt)(s.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val slice : nat -> nat -> bytes -> bytes"),(0,i.kt)(s.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let slice: (_: nat) => (_: nat) => (_: bytes) => bytes"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"slice index len bytes")," is the subsequence of bytes\n",(0,i.kt)("inlineCode",{parentName:"p"},"bytes")," starting at index ",(0,i.kt)("inlineCode",{parentName:"p"},"index")," (0 denoting the first byte) and\nof length ",(0,i.kt)("inlineCode",{parentName:"p"},"len"),". If the index or length are invalid, an exception\ninterrupts the execution.")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"slice(index, len, bytes)")," is the subsequence of bytes\n",(0,i.kt)("inlineCode",{parentName:"p"},"bytes")," starting at index ",(0,i.kt)("inlineCode",{parentName:"p"},"index")," (0 denoting the first byte) and\nof length ",(0,i.kt)("inlineCode",{parentName:"p"},"len"),". If the index or length are invalid, an exception\ninterrupts the execution.")),(0,i.kt)(s.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val pack : 'a.'a -> bytes"),(0,i.kt)(s.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let pack: <a>(_: a) => bytes"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"pack v")," transforms the value ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," into a sequence of\nbytes.")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"pack(v)")," transforms the value ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," into a sequence of\nbytes.")),(0,i.kt)(s.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val unpack : 'a.bytes -> 'a option"),(0,i.kt)(s.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let unpack: <a>(_: bytes) => option<a>"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"unpack bytes")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"Some v")," if the sequence of bytes\n",(0,i.kt)("inlineCode",{parentName:"p"},"bytes")," decodes into a valid LIGO value ",(0,i.kt)("inlineCode",{parentName:"p"},"v"),"; otherwise ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),".")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"unpack(bytes)")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"Some(v)")," if the sequence of bytes\n",(0,i.kt)("inlineCode",{parentName:"p"},"bytes")," decodes into a valid LIGO value ",(0,i.kt)("inlineCode",{parentName:"p"},"v"),"; otherwise\n",(0,i.kt)("inlineCode",{parentName:"p"},"None()"),".")))}m.isMDXComponent=!0}}]);