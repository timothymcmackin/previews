"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[87353],{48720:(e,t,a)=>{a.d(t,{D:()=>i.Z,Z:()=>l});var n=a(67294),i=a(75402);const l=function(e){return n.createElement(i.Z.Consumer,null,(t=>{let{syntax:a}=t;return a===e.syntax?e.children:n.createElement(n.Fragment,null)}))}},99191:(e,t,a)=>{a.d(t,{Z:()=>k});var n=a(43164),i=a(67294),l=a(52263),p=a(48720),o=a(11506);function m(){return m=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var n in a)Object.prototype.hasOwnProperty.call(a,n)&&(e[n]=a[n])}return e},m.apply(this,arguments)}const{Prism:r}=a(43164);r.languages={...r.languages,cameligo:{...r.languages.ocaml,comment:[/(^|[^\\])\/\*[\s\S]*?\*\//,/\(\*[\s\S]*?\*\)/,/\/\/.*/]},jsligo:r.languages.typescript};const k=function(e){const{siteConfig:{themeConfig:{prism:t={}}}}=(0,l.Z)(),a=t.singleTheme||o.Z,[r,k]=(0,i.useState)(!1);return(0,i.useEffect)((()=>{k(!0)}),[]),i.createElement(p.D.Consumer,null,(t=>{let{syntax:l}=t;return l===e.syntax?i.createElement(n.default,m({},n.defaultProps,{key:r,language:e.syntax,code:e.children,theme:a}),(e=>{let{className:t,tokens:a,getLineProps:n,getTokenProps:l}=e;return i.createElement("h4",{className:t,style:{backgroundColor:"var(--ifm-background-color)",fontFamily:"var(--ifm-font-family-monospace)",lineHeight:"var(--ifm-pre-line-height)",fontSize:"1.1rem",fontWeight:"bold",padding:0,whiteSpace:"break-spaces",marginTop:"3rem"}},a.map(((e,t)=>i.createElement("div",n({line:e,key:t}),e.map(((e,t)=>i.createElement("span",l({token:e,key:t}))))))))})):i.createElement("div",null)}))}},97689:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>k,contentTitle:()=>m,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>y});var n=a(87462),i=(a(67294),a(3905)),l=a(48720),p=a(99191);const o={id:"big-map-reference",title:"big_map",hide_table_of_contents:!0},m=void 0,r={unversionedId:"reference/big-map-reference",id:"reference/big-map-reference",title:"big_map",description:"Maps from keys to values, lazily accessed and where the bindings",source:"@site/../docs/reference/big_map.md",sourceDirName:"reference",slug:"/reference/big-map-reference",permalink:"/previews/ligo/modules/docs/next/reference/big-map-reference",draft:!1,tags:[],version:"current",frontMatter:{id:"big-map-reference",title:"big_map",hide_table_of_contents:!0},sidebar:"API",previous:{title:"option",permalink:"/previews/ligo/modules/docs/next/reference/option-reference"},next:{title:"list",permalink:"/previews/ligo/modules/docs/next/reference/list-reference"}},k={},y=[],s={toc:y};function d(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},s,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Maps from keys to values, lazily accessed and where the bindings\nkey/value are ordered by increasing keys."),(0,i.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type ('key, 'value) t = ('key, 'value) big_map"),(0,i.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type t<key, value> = big_map<key, value>"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The type ",(0,i.kt)("inlineCode",{parentName:"p"},"('key,'value) Big_map.t")," is an alias for\n",(0,i.kt)("inlineCode",{parentName:"p"},"('key,'value) big_map"),".")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The type ",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.t<key, value>")," is an alias for ",(0,i.kt)("inlineCode",{parentName:"p"},"big_map<key,\n      value>"),".")),(0,i.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val empty : 'key 'value.('key, 'value) t"),(0,i.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let empty: <key, value>t<key, value>"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The value ",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.empty")," is the empty big map. In some\ncontexts, it is useful to annotate it with its type, for example:\n",(0,i.kt)("inlineCode",{parentName:"p"},"(Big_map.empty : (int, string) big_map)"),".")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The value ",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.empty")," is the empty big map. In some\ncontexts, it is useful to annotate it with its type, for example:\n",(0,i.kt)("inlineCode",{parentName:"p"},"(Big_map.empty as big_map<int, string>"),".")),(0,i.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_and_update : 'key 'value.'key -> 'value option -> ('key, 'value) t -> ('value option * ('key, 'value) t)"),(0,i.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let get_and_update: <key, value>(_: key) => (_: option<value>) => (_: t<key, value>) => [option<value>, t<key, value>]"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.get_and_update key None map")," returns a copy of\nthe big map ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," without the entry for the key ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),"\n(no change if the key is absent). The call\n",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.get_and_update key (Some value) map")," returns a copy of\nthe big map ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," where there is an entry for the key ",(0,i.kt)("inlineCode",{parentName:"p"},"key"),"\nassociated with the value ",(0,i.kt)("inlineCode",{parentName:"p"},"value"),". In both cases, if there was\nalready a value ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," bound to ",(0,i.kt)("inlineCode",{parentName:"p"},"key"),", it is returned as ",(0,i.kt)("inlineCode",{parentName:"p"},"Some v"),",\notherwise ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),".")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.get_and_update(key, None(), map)")," returns a\ncopy of the big map ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," without the entry for the key ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," in\n",(0,i.kt)("inlineCode",{parentName:"p"},"map")," (no change if the key is absent). The call\n",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.get_and_update(key, Some(value), map)")," returns a copy\nof the big map ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," where there is an entry for the key ",(0,i.kt)("inlineCode",{parentName:"p"},"key"),"\nassociated with the value ",(0,i.kt)("inlineCode",{parentName:"p"},"value"),". In both cases, if there was\nalready a value ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," bound to ",(0,i.kt)("inlineCode",{parentName:"p"},"key"),", it is returned as ",(0,i.kt)("inlineCode",{parentName:"p"},"Some(v)"),",\notherwise ",(0,i.kt)("inlineCode",{parentName:"p"},"None()"),".")),(0,i.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val update : 'key 'value.'key -> 'value option -> ('key, 'value) t -> ('key, 'value) t"),(0,i.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let update: <key, value>(_: key) => (_: option<value>) => (_: t<key, value>) => t<key, value>"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.update key None map")," returns a copy of the big\nmap ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," without the entry for the key ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," (no\nchange if the key is absent). The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.update key (Some\n      value) map")," returns the big map ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," where there is an entry\nfor the key ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," associated with the value ",(0,i.kt)("inlineCode",{parentName:"p"},"value"),". In both\ncases, the value originally bound to ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," is lost. See\n",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.get_and_update"),".")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.update(key, None(), map)")," returns a copy of\nthe big map ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," without the entry for the key ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),"\n(no change if the key is absent). The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.update(key,\n      Some(value), map)")," returns the big map ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," where there is an\nentry for the key ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," associated with the value ",(0,i.kt)("inlineCode",{parentName:"p"},"value"),". In\nboth cases, the value originally bound to ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," is lost. See\n",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.get_and_update"),".")),(0,i.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val add : 'key 'value.'key -> 'value -> ('key, 'value) t -> ('key, 'value) t"),(0,i.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let add: <key, value>(_: key) => (_: value) => (_: t<key, value>) => t<key, value>"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.add key value map")," returns a copy of the big\nmap ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," where there is a binding of key ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," to value\n",(0,i.kt)("inlineCode",{parentName:"p"},"value"),". If there is a binding for ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),", then it is\nlost.")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.add(key, value, map)")," returns a copy of the\nbig map ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," where there is a binding of key ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," to value\n",(0,i.kt)("inlineCode",{parentName:"p"},"value"),". If there is a binding for ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),", then it is\nlost.")),(0,i.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val remove : 'key 'value.'key -> ('key, 'value) t -> ('key, 'value) t"),(0,i.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let remove: <key, value>(_: key) => (_: t<key, value>) => t<key, value>"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.remove key map")," returns a copy of the big map\n",(0,i.kt)("inlineCode",{parentName:"p"},"map")," where the binding for key ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," is absent.")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.remove(key, map)")," returns a copy of the big\nmap ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," where the binding for key ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," is absent.")),(0,i.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val literal : 'key 'value.('key * 'value) list -> ('key, 'value) t"),(0,i.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let literal: <key, value>(_: list<[key, value]>) => t<key, value>"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.literal [(k1,v1); ...; (kn,vn)]")," returns a big\nmap from the pairs of key/value in the list. Note: The list must\nbe a literal, not an expression (compile-time list of values).")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.literal(list([[k1,v1], ..., [kn,vn]]))")," returns\na big map from the pairs of key/value in the list. Note: The list\nmust be a literal, not an expression (compile-time list of\nvalues).")),(0,i.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val of_list : 'key 'value.('key * 'value) list -> ('key, 'value) t"),(0,i.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let of_list: <key, value>(_: list<[key, value]>) => t<key, value>"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.of_list bindings")," returns a big map from the\npairs of key/value in the list ",(0,i.kt)("inlineCode",{parentName:"p"},"bindings"),". Note: Use\n",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.literal")," instead if using a literal list.")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.of_list(bindings)")," returns a big map from the\npairs of key/value in the list ",(0,i.kt)("inlineCode",{parentName:"p"},"bindings"),". Note: Use\n",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.literal")," instead if using a literal list.")),(0,i.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val mem : 'key 'value.'key -> ('key, 'value) t -> bool"),(0,i.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let mem: <key, value>(_: key) => (_: t<key, value>) => bool"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.mem key map")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," if, and only if, the\nkey ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," is in the big map ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),".")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.mem(key, map)")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," if, and only if, the\nkey ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," is in the big map ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),".")),(0,i.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val find_opt : 'key 'value.'key -> ('key, 'value) t -> 'value option"),(0,i.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let find_opt: <key, value>(_: key) => (_: t<key, value>) => option<value>"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.find_opt key map")," returns ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," if the key\n",(0,i.kt)("inlineCode",{parentName:"p"},"key")," is present in the big map ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),"; otherwise, it is ",(0,i.kt)("inlineCode",{parentName:"p"},"Some v"),",\nwhere ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," is the value associated to ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),".")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.find_opt(key, map)")," returns ",(0,i.kt)("inlineCode",{parentName:"p"},"None()")," if the\nkey ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," is present in the big map ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),"; otherwise, it is\n",(0,i.kt)("inlineCode",{parentName:"p"},"Some(v)"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," is the value associated to ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),".")),(0,i.kt)(p.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val find : 'key 'value.'key -> ('key, 'value) t -> 'value"),(0,i.kt)(p.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let find: <key, value>(_: key) => (_: t<key, value>) => value"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.find key map")," returns the value associated to\n",(0,i.kt)("inlineCode",{parentName:"p"},"key")," in the big map ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),". If the key is absent, the execution\nfails with the string ",(0,i.kt)("inlineCode",{parentName:"p"},'"MAP FIND"'),".")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.find(key, map)")," returns the value associated\nto ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," in the big map ",(0,i.kt)("inlineCode",{parentName:"p"},"map"),". If the key is absent, the\nexecution fails with the string ",(0,i.kt)("inlineCode",{parentName:"p"},'"MAP FIND"'),".")))}d.isMDXComponent=!0}}]);