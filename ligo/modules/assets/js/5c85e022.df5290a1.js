"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[24452],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>u});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var d=a.createContext({}),l=function(e){var t=a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=l(e.components);return a.createElement(d.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,d=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),m=l(n),u=r,h=m["".concat(d,".").concat(u)]||m[u]||p[u]||s;return n?a.createElement(h,o(o({ref:t},c),{},{components:n})):a.createElement(h,o({ref:t},c))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,o=new Array(s);o[0]=m;var i={};for(var d in t)hasOwnProperty.call(t,d)&&(i[d]=t[d]);i.originalType=e,i.mdxType="string"==typeof e?e:r,o[1]=i;for(var l=2;l<s;l++)o[l]=n[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},48720:(e,t,n)=>{n.d(t,{D:()=>r.Z,Z:()=>s});var a=n(67294),r=n(75402);const s=function(e){return a.createElement(r.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},79814:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>d,toc:()=>c});var a=n(87462),r=(n(67294),n(3905)),s=n(48720);const o={id:"address",title:"Addresses"},i=void 0,d={unversionedId:"tezos/contracts/address",id:"version-1.5.0/tezos/contracts/address",title:"Addresses",description:"An address on the Tezos blockchain is a string whose suffix is the",source:"@site/versioned_docs/version-1.5.0/tezos/contracts/address.md",sourceDirName:"tezos/contracts",slug:"/tezos/contracts/address",permalink:"/previews/ligo/modules/docs/1.5.0/tezos/contracts/address",draft:!1,tags:[],version:"1.5.0",frontMatter:{id:"address",title:"Addresses"},sidebar:"docs",previous:{title:"view",permalink:"/previews/ligo/modules/docs/1.5.0/tezos/decorators/view"},next:{title:"Contracts",permalink:"/previews/ligo/modules/docs/1.5.0/tezos/contracts/"}},l={},c=[{value:"The <code>address</code> type",id:"the-address-type",level:3},{value:"Self",id:"self",level:3},{value:"Self-Address",id:"self-address",level:3},{value:"Sender",id:"sender",level:3},{value:"Source",id:"source",level:3},{value:"The <code>contract</code> type",id:"the-contract-type",level:3}],p={toc:c};function m(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"An address on the Tezos blockchain is a string whose suffix is the\nhash of the public key of a peer. If that peer is a smart contract,\nthe address is prefixed by the string ",(0,r.kt)("inlineCode",{parentName:"p"},'"KT1"'),"; otherwise, it is\nassociated to an ",(0,r.kt)("em",{parentName:"p"},"implicit account"),", prefixed by ",(0,r.kt)("inlineCode",{parentName:"p"},'"kt1"'),", ",(0,r.kt)("inlineCode",{parentName:"p"},'"kt2"')," or\n",(0,r.kt)("inlineCode",{parentName:"p"},'"kt3"'),",\n",(0,r.kt)("a",{parentName:"p",href:"https://tezos.gitlab.io/michelson-reference/#type-address"},"depending on the hashing function"),"."),(0,r.kt)("p",null,"There are two ways to define and handle adresses."),(0,r.kt)("h3",{id:"the-address-type"},"The ",(0,r.kt)("inlineCode",{parentName:"h3"},"address")," type"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"address")," type in LIGO denotes ",(0,r.kt)("em",{parentName:"p"},"a well-formed")," Tezos address of\nany kind (",(0,r.kt)("inlineCode",{parentName:"p"},"tz1"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"tz2"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"tz3"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"tz4"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"KT1")," etc.). Currently, such\naddresses are created by casting a string to the ",(0,r.kt)("inlineCode",{parentName:"p"},"address"),"\ntype. Beware of failures if the address is invalid. Consider the\nfollowing examples."),(0,r.kt)(s.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=address",group:"address"},'let my_account : address =\n  ("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx" : address)\n'))),(0,r.kt)(s.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=address",group:"address"},'const my_account: address =\n  "tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx" as address;\n'))),(0,r.kt)("p",null,"Note that a literal value of type ",(0,r.kt)("inlineCode",{parentName:"p"},"address")," does not entail that it is\nthe valid address on the chain, only that it is well-formed."),(0,r.kt)("h3",{id:"self"},"Self"),(0,r.kt)(s.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("p",null,"The call ",(0,r.kt)("inlineCode",{parentName:"p"},"Tezos.self entrypoint")," is the address of the current smart\ncontract, that is, the smart contract containing the call. For the\naddress of the smart contract actually ",(0,r.kt)("em",{parentName:"p"},"executing")," the call, because\nit is embedded in a lambda sent to another smart contract, use\n",(0,r.kt)("inlineCode",{parentName:"p"},"Tezos.get_self_address")," instead. The string ",(0,r.kt)("inlineCode",{parentName:"p"},"entrypoint")," is the name\nof a valid entrypoint such that ",(0,r.kt)("inlineCode",{parentName:"p"},"entrypoint")," is not ",(0,r.kt)("inlineCode",{parentName:"p"},'"%default"'),", or\nthe empty string denoting the ",(0,r.kt)("inlineCode",{parentName:"p"},'"%default"')," entrypoint (which is the\nroot of the smart contract parameter if no ",(0,r.kt)("inlineCode",{parentName:"p"},'"%default"')," entrypoint is\nexplicitly defined). If the contract does not have the specified\nentrypoint, the call results in an type checking error.")),(0,r.kt)(s.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("p",null,"The call ",(0,r.kt)("inlineCode",{parentName:"p"},"Tezos.self(entrypoint)")," is the address of the current smart\ncontract, that is, the smart contract containing the call. For the\naddress of the smart contract actually ",(0,r.kt)("em",{parentName:"p"},"executing")," the call, because\nit is embedded in a lambda sent to another smart contract, use\n",(0,r.kt)("inlineCode",{parentName:"p"},"Tezos.get_self_address")," instead. The string ",(0,r.kt)("inlineCode",{parentName:"p"},"entrypoint")," is the name\nof a valid entrypoint such that ",(0,r.kt)("inlineCode",{parentName:"p"},"entrypoint")," is not ",(0,r.kt)("inlineCode",{parentName:"p"},'"%default"'),", or\nthe empty string denoting the ",(0,r.kt)("inlineCode",{parentName:"p"},'"%default"')," entrypoint (which is the\nroot of the smart contract parameter if no ",(0,r.kt)("inlineCode",{parentName:"p"},'"%default"')," entrypoint is\nexplicitly defined). If the contract does not have the specified\nentrypoint, the call results in an type checking error.")),(0,r.kt)("p",null,"Naming convention: if you are using entrypoints, use ",(0,r.kt)("inlineCode",{parentName:"p"},'"%bar"')," to\ndenote the constructor ",(0,r.kt)("inlineCode",{parentName:"p"},'"Bar"')," of the parameter, in turn corresponding\nto the entrypoint function ",(0,r.kt)("inlineCode",{parentName:"p"},"bar"),". If you are not using entrypoints:\nuse ",(0,r.kt)("inlineCode",{parentName:"p"},'"%default"'),"."),(0,r.kt)(s.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=self",group:"self"},'let check () = Tezos.self("%default")\n'))),(0,r.kt)(s.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=self",group:"self"},'let check = () => Tezos.self("%default");\n'))),(0,r.kt)("h3",{id:"self-address"},"Self-Address"),(0,r.kt)("p",null,"Often you want to get the address of the contract being executed. You\ncan do it with ",(0,r.kt)("inlineCode",{parentName:"p"},"Tezos.get_self_address"),". When used inside a lambda,\nthat function returns the address of the contract ",(0,r.kt)("em",{parentName:"p"},"executing the\nlambda"),", which can be different from the address of the contract in\nwhich the call is written."),(0,r.kt)(s.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=address",group:"address"},"let current_addr : address = Tezos.get_self_address ()\n"))),(0,r.kt)(s.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=address",group:"address"},"const current_addr : address = Tezos.get_self_address();\n"))),(0,r.kt)("h3",{id:"sender"},"Sender"),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"sender")," is the address of the contract (that is, a smart contract\nor an implicit account) that initiated the current internal\ntransaction. Note that, if transactions have been chained, that\naddress could be different from the ",(0,r.kt)("em",{parentName:"p"},"source"),"."),(0,r.kt)(s.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=sender",group:"sender"},"let sender : address = Tezos.get_sender ()\n"))),(0,r.kt)(s.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=sender",group:"sender"},"const sender: address = Tezos.get_sender();\n"))),(0,r.kt)("h3",{id:"source"},"Source"),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"source")," is the address of the implicit account that initiated the\ncurrent transaction. If transactions have been chained, that address\nis different from the ",(0,r.kt)("em",{parentName:"p"},"sender"),"."),(0,r.kt)(s.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=source",group:"source"},"let source : address = Tezos.get_source ()\n"))),(0,r.kt)(s.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=source",group:"source"},"const source: address = Tezos.get_source();\n"))),(0,r.kt)("h3",{id:"the-contract-type"},"The ",(0,r.kt)("inlineCode",{parentName:"h3"},"contract")," type"),(0,r.kt)("p",null,"In order to handle addresses that denote an originated account on the\nchain, we need a value of type ",(0,r.kt)("inlineCode",{parentName:"p"},"contract"),". In fact, it is a type\nparameterised by the type of the contract's parameter. Contrary to the\ntype ",(0,r.kt)("inlineCode",{parentName:"p"},"address"),", there are no literal values of the type ",(0,r.kt)("inlineCode",{parentName:"p"},"contract"),", so\nvalues have to be created by means of predefined functions."),(0,r.kt)(s.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("p",null,"The call ",(0,r.kt)("inlineCode",{parentName:"p"},"Tezos.implicit_account kh")," casts the public key hash ",(0,r.kt)("inlineCode",{parentName:"p"},"kh"),"\ninto the address of its ",(0,r.kt)("em",{parentName:"p"},"implicit account"),". Note that addresses of\nimplicit accounts always have the type ",(0,r.kt)("inlineCode",{parentName:"p"},"unit contract"),".")),(0,r.kt)(s.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("p",null,"The call ",(0,r.kt)("inlineCode",{parentName:"p"},"Tezos.implicit_account(kh)")," casts the public key hash ",(0,r.kt)("inlineCode",{parentName:"p"},"kh"),"\ninto the address of its ",(0,r.kt)("em",{parentName:"p"},"implicit account"),". Note that addresses of\nimplicit accounts always have the type ",(0,r.kt)("inlineCode",{parentName:"p"},"contract<unit>"),".")))}m.isMDXComponent=!0}}]);