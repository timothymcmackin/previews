"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2372],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>g});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=l(n),g=o,u=m["".concat(c,".").concat(g)]||m[g]||d[g]||r;return n?a.createElement(u,i(i({ref:t},p),{},{components:n})):a.createElement(u,i({ref:t},p))}));function g(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=m;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var l=2;l<r;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},48720:(e,t,n)=>{n.d(t,{D:()=>o.Z,Z:()=>r});var a=n(67294),o=n(75402);const r=function(e){return a.createElement(o.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},16638:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>i,metadata:()=>c,toc:()=>p});var a=n(87462),o=(n(67294),n(3905)),r=n(48720);const i={id:"entrypoints-contracts",title:"Main functions and Entrypoints"},s=void 0,c={unversionedId:"advanced/entrypoints-contracts",id:"version-1.5.0/advanced/entrypoints-contracts",title:"Main functions and Entrypoints",description:"Entry points",source:"@site/versioned_docs/version-1.5.0/advanced/entrypoints-contracts.md",sourceDirName:"advanced",slug:"/advanced/entrypoints-contracts",permalink:"/previews/ligo/modules/docs/1.5.0/advanced/entrypoints-contracts",draft:!1,tags:[],version:"1.5.0",frontMatter:{id:"entrypoints-contracts",title:"Main functions and Entrypoints"}},l={},p=[{value:"Entry points",id:"entry-points",level:2},{value:"Calling a contract",id:"calling-a-contract",level:2},{value:"Using the dry-run command",id:"using-the-dry-run-command",level:3},{value:"Calling an on-chain contract",id:"calling-an-on-chain-contract",level:3},{value:"Using the WebIDE",id:"using-the-webide",level:3},{value:"Using the <code>ligo run test</code> command",id:"using-the-ligo-run-test-command",level:3},{value:"Main function",id:"main-function",level:2},{value:"Workaround for the deprecation of the <code>main</code> function",id:"workaround-for-the-deprecation-of-the-main-function",level:3},{value:"Tezos-specific Built-ins",id:"tezos-specific-built-ins",level:2},{value:"Accepting or Declining Tokens in a Smart Contract",id:"accepting-or-declining-tokens-in-a-smart-contract",level:3},{value:"Access Control",id:"access-control",level:3},{value:"Inter-Contract Invocations",id:"inter-contract-invocations",level:3}],d={toc:p};function m(e){let{components:t,...i}=e;return(0,o.kt)("wrapper",(0,a.Z)({},d,i,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"entry-points"},"Entry points"),(0,o.kt)("p",null,"A LIGO smart contract is made of a series of constant and function\ndeclarations. Only functions having a special type can be called when\nthe contract is activated: we call them ",(0,o.kt)("em",{parentName:"p"},"entry points"),". An entry point\nfunction takes two parameters, the ",(0,o.kt)("em",{parentName:"p"},"contract parameter")," and the\n",(0,o.kt)("em",{parentName:"p"},"on-chain storage"),", and returns a pair made of a ",(0,o.kt)("em",{parentName:"p"},"list of operations"),"\nand a (new) storage value."),(0,o.kt)("p",null,"A smart contract can export more than one entry point function.\nAn entry point can be selected by specifying its name when calling the contract.\nFor example, the following contract exports two functions, named ",(0,o.kt)("inlineCode",{parentName:"p"},"increment")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"decrement"),".\nThe ",(0,o.kt)("inlineCode",{parentName:"p"},"increment")," function can be called by passing ",(0,o.kt)("inlineCode",{parentName:"p"},"Increment (10)")," to the contract (notice the capitalization of ",(0,o.kt)("inlineCode",{parentName:"p"},"Increment"),").\nMore examples on how to perform this call are given below."),(0,o.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=incdec",group:"incdec"},"export namespace IncDec {\n  type storage = int;\n  type result = [list<operation>, storage];\n\n  // Four entrypoints\n\n  @entry\n  const increment = (delta : int, store : storage) : result =>\n    [list([]), store + delta];\n\n  @entry\n  const @default = (_u : unit, store : storage) : result =>\n    increment(1, store)\n\n  @entry\n  const decrement = (delta : int, store : storage) : result =>\n    [list([]), store - delta];\n\n  @entry\n  const reset = (_p : unit, _s : storage) : result =>\n    [list([]), 0];\n};\n"))),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=incdec",group:"incdec"},"module IncDec = struct\n  type storage = int\n  type result = operation list * storage\n\n  (* Four entrypoints *)\n  [@entry] let increment (delta : int) (store : storage) : result =\n    [], store + delta\n  [@entry] let default (() : unit) (store : storage) : result =\n    increment 1 store\n  [@entry] let decrement (delta : int) (store : storage) : result =\n    [], store - delta\n  [@entry] let reset (() : unit) (_ : storage) : result =\n    [], 0\nend\n"))),(0,o.kt)("p",null,"When the contract is originated, the initial value of the storage is\nprovided. When an entry point is later called, only the parameter is\nprovided by the user, and the blockchain (or testing framework)\nsupplies the current storage value as a second argument."),(0,o.kt)("p",null,"The type of the contract parameter and the storage are up to the\ncontract designer, but the type for the list of operations is not.\nThe return type of an entry point is as follows, assuming that the type\n",(0,o.kt)("inlineCode",{parentName:"p"},"storage")," has been defined elsewhere. (Note that you can use any type\nwith any name for the storage.)"),(0,o.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("p",null,"Note that the name ",(0,o.kt)("inlineCode",{parentName:"p"},"default")," has a special meaning for a Tezos entry point,\nand denotes the default entry point to be called unless another one is\nspecified. Due to the fact that ",(0,o.kt)("inlineCode",{parentName:"p"},"default")," is a reserved keyword in JsLIGO,\nwe use the escape notation ",(0,o.kt)("inlineCode",{parentName:"p"},"@default")," to write the function name, without\nit being misinterpreted as a keyword.")),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},"type storage = ...  // Any name, any type\ntype result = operation list * storage\n"))),(0,o.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},"type storage = ...;  // Any name, any type\ntype result = [list<operation>, storage];\n"))),(0,o.kt)("p",null,"The contract storage can only be modified by activating an entry point:\ngiven the state of the storage ",(0,o.kt)("em",{parentName:"p"},"on-chain"),", an entry point function\nspecifies how to create another state for it, depending on the\ncontract's parameter."),(0,o.kt)("h2",{id:"calling-a-contract"},"Calling a contract"),(0,o.kt)("h3",{id:"using-the-dry-run-command"},"Using the dry-run command"),(0,o.kt)("p",null,"In order to call the ",(0,o.kt)("inlineCode",{parentName:"p"},"increment")," entry point of the smart contract, we can pass the ",(0,o.kt)("inlineCode",{parentName:"p"},"-m IncDec")," option to specify the module and the ",(0,o.kt)("inlineCode",{parentName:"p"},"Increment(...)")," constructor to specify the entry point (note the capitalization of ",(0,o.kt)("inlineCode",{parentName:"p"},"Increment"),")."),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"ligo run dry-run -m IncDec gitlab-pages/docs/advanced/src/entrypoints-contracts/incdec.mligo 'Increment(5)' '0'\n"))),(0,o.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"ligo run dry-run -m IncDec gitlab-pages/docs/advanced/src/entrypoints-contracts/incdec.jsligo 'Increment(5)' '0'\n"))),(0,o.kt)("p",null,"In the command above, ",(0,o.kt)("inlineCode",{parentName:"p"},"0")," is the initial ",(0,o.kt)("inlineCode",{parentName:"p"},"storage"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"5")," is the ",(0,o.kt)("inlineCode",{parentName:"p"},"delta")," argument."),(0,o.kt)("h3",{id:"calling-an-on-chain-contract"},"Calling an on-chain contract"),(0,o.kt)("p",null,"When a contract is deployed on-chain, the Michelson value for the parameter can be obtained with:"),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"ligo compile parameter -m IncDec gitlab-pages/docs/advanced/src/entrypoints-contracts/incdec.mligo 'Increment(5)'\n"))),(0,o.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"ligo compile parameter -m IncDec gitlab-pages/docs/advanced/src/entrypoints-contracts/incdec.jsligo 'Increment(5)'\n"))),(0,o.kt)("p",null,"In the command above, ",(0,o.kt)("inlineCode",{parentName:"p"},"Increment")," is the (capitalized) name of the entry point to call, and ",(0,o.kt)("inlineCode",{parentName:"p"},"5")," is the ",(0,o.kt)("inlineCode",{parentName:"p"},"delta")," argument."),(0,o.kt)("h3",{id:"using-the-webide"},"Using the WebIDE"),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Clicking on Dry Run in the WebIDE",src:n(72109).Z,width:"1912",height:"932"}))),(0,o.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Clicking on Dry Run in the WebIDE",src:n(98481).Z,width:"1912",height:"932"}))),(0,o.kt)("h3",{id:"using-the-ligo-run-test-command"},"Using the ",(0,o.kt)("inlineCode",{parentName:"h3"},"ligo run test")," command"),(0,o.kt)("p",null,"A LIGO program can instantiate a new contract (or obtain an existing contract from its address),\nand call one of its entry points by passing e.g. the parameter ",(0,o.kt)("inlineCode",{parentName:"p"},"Increment(5)"),"."),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=test",group:"test"},'#import "gitlab-pages/docs/advanced/src/entrypoints-contracts/incdec.mligo" "C"\n\nlet test =\n  let {addr ; code = _ ; size = _} = Test.originate (contract_of C.IncDec) 0 (0tez) in\n  let _ = Test.transfer_exn addr (Increment 42) (0tez) in\n  assert (42 = Test.get_storage(addr))\n'))),(0,o.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=test",group:"test"},'#import "gitlab-pages/docs/advanced/src/entrypoints-contracts/incdec.jsligo" "C"\n\nconst test = do {\n  let {addr , code , size} = Test.originate(contract_of(C.IncDec), 0, 0tez);\n  Test.transfer_exn(addr, Increment(42), 0tez);\n  assert(42 == Test.get_storage(addr));\n};\n'))),(0,o.kt)("p",null,"The file above can be run with e.g. the ",(0,o.kt)("inlineCode",{parentName:"p"},"ligo run test")," sub-command."),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"ligo run test --library . gitlab-pages/docs/advanced/src/entrypoints-contracts/test.mligo\n"))),(0,o.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"ligo run test --library . gitlab-pages/docs/advanced/src/entrypoints-contracts/test.jsligo\n"))),(0,o.kt)("h2",{id:"main-function"},"Main function"),(0,o.kt)("p",null,"For more control over the contract's API, it used to be possible to declare\n",(0,o.kt)("em",{parentName:"p"},"one")," main function called ",(0,o.kt)("inlineCode",{parentName:"p"},"main"),", that dispatches the control flow\naccording to its parameter. When declaring ",(0,o.kt)("em",{parentName:"p"},"entrypoints")," using the\n",(0,o.kt)("inlineCode",{parentName:"p"},"@entry")," annotation, LIGO automatically generates a ",(0,o.kt)("inlineCode",{parentName:"p"},"main")," function,\nbut it used to be possible to write such a function by hand instead of using\nthe ",(0,o.kt)("inlineCode",{parentName:"p"},"@entry")," facility."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"This feature is now deprecated, future versions of LIGO will not allow the declaration of a single ",(0,o.kt)("inlineCode",{parentName:"strong"},"main")," function. A workaround is given at the end of this section.")),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"While it is still possible to define a single function called ",(0,o.kt)("inlineCode",{parentName:"em"},"main")," and mark it as the sole entry point using ",(0,o.kt)("inlineCode",{parentName:"em"},"@entry"),", this is not what most programs should do. The following paragraphs are intended for programs which need more fine control over the behaviour of the entire program than what is possible using the automatic ",(0,o.kt)("inlineCode",{parentName:"em"},"@entry")," mechanism.")),(0,o.kt)("p",null,"As an analogy, in the C programming language, the ",(0,o.kt)("inlineCode",{parentName:"p"},"main")," function is\nthe unique main function and any function called from it would be an\nentrypoint."),(0,o.kt)("p",null,"Usually, the parameter of the contract is then a variant type, and, depending\non the constructors of that type, different functions in the contract\nare called. In other terms, the unique main function dispatches the\ncontrol flow depending on a ",(0,o.kt)("em",{parentName:"p"},"pattern matching")," on the contract\nparameter."),(0,o.kt)("p",null,"In the following example, the storage contains a counter of type ",(0,o.kt)("inlineCode",{parentName:"p"},"nat"),"\nand a name of type ",(0,o.kt)("inlineCode",{parentName:"p"},"string"),". Depending on the parameter of the\ncontract, either the counter or the name is updated."),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=contract_main",group:"contract_main"},"type parameter =\n  Action_A of nat\n| Action_B of string\n\ntype storage = {\n  counter : nat;\n  name    : string\n}\n\ntype result = operation list * storage\n\nlet entry_A (n : nat) (store : storage) : result =\n  [], {store with counter = n}\n\nlet entry_B (s : string) (store : storage) : result =\n  [], {store with name = s}\n\n[@entry]\nlet main (action : parameter) (store: storage) : result =\n  match action with\n    Action_A n -> entry_A n store\n  | Action_B s -> entry_B s store\n"))),(0,o.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=contract_main",group:"contract_main"},'export type parameter =\n| ["Action_A", nat]\n| ["Action_B", string];\n\nexport type storage = {\n  counter : nat,\n  name    : string\n};\n\ntype result = [list<operation>, storage];\n\nconst entry_A = (n: nat, store: storage): result =>\n  [list([]), {...store, counter: n}];\n\nconst entry_B = (s: string, store: storage): result =>\n  [list([]), {...store, name: s}];\n\n@entry\nconst main = (action: parameter, store: storage): result =>\n  match(action) {\n    when(Action_A(n)): entry_A(n, store);\n    when(Action_B(s)): entry_B(s, store)\n  };\n'))),(0,o.kt)("h3",{id:"workaround-for-the-deprecation-of-the-main-function"},"Workaround for the deprecation of the ",(0,o.kt)("inlineCode",{parentName:"h3"},"main")," function"),(0,o.kt)("p",null,"In most cases, adding ",(0,o.kt)("inlineCode",{parentName:"p"},"[@entry]")," for CameLIGO or ",(0,o.kt)("inlineCode",{parentName:"p"},"@entry")," for JsLIGO\nbefore the existing ",(0,o.kt)("inlineCode",{parentName:"p"},"main")," function should suffice. However in cases\nwhere it is not possible or desirable to convert an existing\n",(0,o.kt)("inlineCode",{parentName:"p"},"contract_main")," contract to the new ",(0,o.kt)("inlineCode",{parentName:"p"},"@entry")," format (e.g. generated\ncode or a code review process that forbids making changes to an\nalready-audited file), the deprecation can be circumvented by adding a\nproxy file which declares a single entry point and calls the existing\n",(0,o.kt)("inlineCode",{parentName:"p"},"main")," function, as follows:"),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=contract_main_proxy",group:"contract_main_proxy"},'#import "gitlab-pages/docs/advanced/src/entrypoints-contracts/contract_main.mligo" "C"\n\nmodule Proxy = struct\n\n  [@entry]\n  let proxy (p : C.parameter) (s : C.storage) : operation list * C.storage =\n    C.main p s\n\nend\n')),(0,o.kt)("p",null,"The contract can then be compiled using the following command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"ligo compile contract --library . -m Proxy gitlab-pages/docs/advanced/src/entrypoints-contracts/contract_main_proxy.mligo\n"))),(0,o.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=contract_main_proxy",group:"contract_main_proxy"},'#import "gitlab-pages/docs/advanced/src/entrypoints-contracts/contract_main.jsligo" "C"\n\nnamespace Proxy {\n  @entry\n  const proxy =\n    (p: C.parameter, s: C.storage): [list<operation>, C.storage] =>\n    C.main(p, s)\n}\n')),(0,o.kt)("p",null,"The contract can then be compiled using the following command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"ligo compile contract --library . \\\n  -m Proxy \\\n  gitlab-pages/docs/advanced/src/entrypoints-contracts/contract_main_proxy.jsligo\n"))),(0,o.kt)("p",null,"Notice that to compile a parameter for this contract, now we need to\npass the either ",(0,o.kt)("inlineCode",{parentName:"p"},"-e proxy")," or construct a value using the ",(0,o.kt)("inlineCode",{parentName:"p"},"Proxy"),"\nconstructor:"),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},'ligo compile parameter --library . \\\n  -m Proxy -e proxy \\\n  gitlab-pages/docs/advanced/src/entrypoints-contracts/contract_main_proxy.mligo \\\n  "Action_A(42n)"\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},'ligo compile parameter --library . \\\n  -m Proxy \\\n  gitlab-pages/docs/advanced/src/entrypoints-contracts/contract_main_proxy.mligo \\\n  "Proxy(Action_A(42n))"\n'))),(0,o.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},'ligo compile parameter --library . \\\n  -m Proxy -e proxy \\\n  gitlab-pages/docs/advanced/src/entrypoints-contracts/contract_main_proxy.jsligo \\\n  "Action_A(42n)"\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},'ligo compile parameter --library . \\\n  -m Proxy \\\n  gitlab-pages/docs/advanced/src/entrypoints-contracts/contract_main_proxy.jsligo \\\n  "Proxy(Action_A(42n))"\n'))),(0,o.kt)("h2",{id:"tezos-specific-built-ins"},"Tezos-specific Built-ins"),(0,o.kt)("p",null,"A LIGO smart contract can query part of the state of the Tezos\nblockchain by means of built-in values. In this section you will find\nhow those built-ins can be utilised."),(0,o.kt)("h3",{id:"accepting-or-declining-tokens-in-a-smart-contract"},"Accepting or Declining Tokens in a Smart Contract"),(0,o.kt)("p",null,"This example shows how ",(0,o.kt)("inlineCode",{parentName:"p"},"Tezos.get_amount")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"failwith")," can be used to\ndecline any transaction that sends more tez than ",(0,o.kt)("inlineCode",{parentName:"p"},"0tez"),", that is, no\nincoming tokens are accepted."),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=c",group:"c"},'type parameter = unit\ntype storage = unit\ntype result = operation list * storage\n\n[@entry]\nlet no_tokens (action : parameter) (store : storage) : result =\n  if Tezos.get_amount () > 0tez then\n    failwith "This contract does not accept tokens."\n  else ([], store)\n'))),(0,o.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=c",group:"c"},'type parameter = unit;\ntype storage = unit;\ntype result = [list<operation>, storage];\n\n@entry\nconst no_tokens = (action: parameter, store: storage): result => {\n  if (Tezos.get_amount() > 0tez) {\n    return failwith("This contract does not accept tokens.");\n  } else {\n    return [list([]), store];\n  };\n};\n'))),(0,o.kt)("h3",{id:"access-control"},"Access Control"),(0,o.kt)("p",null,"This example shows how ",(0,o.kt)("inlineCode",{parentName:"p"},"Tezos.get_sender")," can be used to deny access to an\nentrypoint."),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=c",group:"c"},'let owner = ("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx": address)\n\n[@entry]\nlet owner_only (action : parameter) (store: storage) : result =\n  if Tezos.get_sender () <> owner then failwith "Access denied."\n  else ([], store)\n'))),(0,o.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=c",group:"c"},'const owner = "tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx" as address;\n\nconst owner_only = (action: parameter, store: storage): result => {\n  if (Tezos.get_sender() != owner) { return failwith("Access denied."); }\n  else { return [list([]), store]; };\n};\n'))),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Note that we do not use ",(0,o.kt)("inlineCode",{parentName:"p"},"Tezos.get_source"),", but instead\n",(0,o.kt)("inlineCode",{parentName:"p"},"Tezos.get_sender"),". In our ",(0,o.kt)("a",{parentName:"p",href:"/previews/ligo/modules/docs/1.5.0/tutorials/security/#incorrect-authorisation-checks"},"tutorial about\nsecurity"),"\nyou can read more about it.")),(0,o.kt)("h3",{id:"inter-contract-invocations"},"Inter-Contract Invocations"),(0,o.kt)("p",null,'It would be somewhat misleading to speak of "contract calls", as this\nwording may wrongly suggest an analogy between contract "calls" and\nfunction "calls". Indeed, the control flow returns to the site of a\nfunction call, and composed function calls therefore are ',(0,o.kt)("em",{parentName:"p"},"stacked"),",\nthat is, they follow a last in, first out ordering. This is not what\nhappens when a contract invokes another: the invocation is ",(0,o.kt)("em",{parentName:"p"},"queued"),',\nthat is, follows a first in, first out ordering, and the dequeuing\nonly starts at the normal end of a contract (no failure). That is why\nwe speak of "contract invocations" instead of "calls".'),(0,o.kt)("p",null,'It is possible to obtain the behaviour of normal function "calls" using\n',(0,o.kt)("em",{parentName:"p"},"views"),", which are pure functions that do not modify the callee's on-chain\nstate. However, this section describes inter-contract invocations which\nare queued, and may modify the callee's state."),(0,o.kt)("p",null,"The following example shows how a contract can invoke another by\nemitting a transaction operation at the end of an entrypoint."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"The same technique can be used to transfer tokens to an implicit\naccount (tz1, ...): all you have to do is use a unit value as the\nparameter of the smart contract.")),(0,o.kt)("p",null,"In our case, we have a ",(0,o.kt)("inlineCode",{parentName:"p"},"counter")," contract that accepts an action of\ntype ",(0,o.kt)("inlineCode",{parentName:"p"},"parameter"),", and we have a ",(0,o.kt)("inlineCode",{parentName:"p"},"proxy")," contract that accepts the same\nparameter type, and forwards the call to the deployed counter\ncontract."),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},"(* gitlab-pages/docs/advanced/src/entrypoints-contracts/incdec.mligo *)\n\nmodule IncDec = struct\n  type storage = int\n  type return = operation list * storage\n\n  [@entry] let increment (delta : int) (store : storage) : return =\n    [], store + delta\n\n  (* And so on, as above *)\nend\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=d",group:"d"},'(* proxy.mligo *)\n\ntype parameter =\n  Increment of int\n| Decrement of int\n| Reset\n\ntype storage = unit\n\ntype result = operation list * storage\n\nlet dest = ("KT19wgxcuXG9VH4Af5Tpm1vqEKdaMFpznXT3" : address)\n\n[@entry]\nlet proxy (action : parameter) (store : storage) : result =\n  let counter : parameter contract = Tezos.get_contract_with_error dest "not found" in\n  let op = Tezos.transaction (Increment 5) 0tez counter\n  in [op], store\n'))),(0,o.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},"// gitlab-pages/docs/advanced/src/entrypoints-contracts/incdec.jsligo\n\nexport namespace IncDec {\n  type storage = int;\n  type ret = [list<operation>, storage];\n\n  @entry\n  const increment = (delta : int, store : storage) : ret =>\n    [list([]), store + delta];\n\n  // And so on, as above\n};\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=d",group:"d"},'// proxy.jsligo\n\ntype parameter =\n| ["Increment", int]\n| ["Decrement", int]\n| ["Reset"];\n\ntype storage = unit;\n\ntype result = [list<operation>, storage];\n\nconst dest = "KT19wgxcuXG9VH4Af5Tpm1vqEKdaMFpznXT3" as address;\n\nconst proxy = (action: parameter, store: storage): result => {\n  let counter : contract<parameter> = Tezos.get_contract_with_error(dest, "not found");\n  let op = Tezos.transaction(Increment(5), 0tez, counter);\n  return [list([op]), store];\n};\n'))))}m.isMDXComponent=!0},98481:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/webide-jsligo-ea549cbfcabd48d063600db6146ca159.png"},72109:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/webide-mligo-4b2d80b2a51ee82601d0452c332a7047.png"}}]);