"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9883],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>d});var r=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var p=r.createContext({}),s=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},m=function(e){var t=s(e.components);return r.createElement(p.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,p=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),u=s(n),d=o,g=u["".concat(p,".").concat(d)]||u[d]||c[d]||a;return n?r.createElement(g,i(i({ref:t},m),{},{components:n})):r.createElement(g,i({ref:t},m))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=u;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var s=2;s<a;s++)i[s]=n[s];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},48720:(e,t,n)=>{n.d(t,{D:()=>o.Z,Z:()=>a});var r=n(67294),o=n(75402);const a=function(e){return r.createElement(o.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:r.createElement(r.Fragment,null)}))}},76164:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>p,toc:()=>m});var r=n(87462),o=(n(67294),n(3905)),a=n(48720);const i={id:"import",title:"#import"},l=void 0,p={unversionedId:"preprocessor/import",id:"version-1.6.0/preprocessor/import",title:"#import",description:"The #import directive is specific to the LIGO compiler. It provides",source:"@site/versioned_docs/version-1.6.0/preprocessor/import.md",sourceDirName:"preprocessor",slug:"/preprocessor/import",permalink:"/previews/ligo/modules/docs/1.6.0/preprocessor/import",draft:!1,tags:[],version:"1.6.0",frontMatter:{id:"import",title:"#import"},sidebar:"docs",previous:{title:"#include",permalink:"/previews/ligo/modules/docs/1.6.0/preprocessor/include"},next:{title:"#error",permalink:"/previews/ligo/modules/docs/1.6.0/preprocessor/error"}},s={},m=[],c={toc:m};function u(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"#import")," directive is specific to the LIGO compiler. It provides\nthe support for a minimal module system."),(0,o.kt)(a.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("p",null,"Modules get more handy when they can be made from a file, separate\nfrom our own program, like a library: when we ",(0,o.kt)("em",{parentName:"p"},"import")," a module from\nsuch a file, we automatically obtain a module encapsulating all the\ndefinitions in it. This will become very handy for organising large\ncontracts, as we can divide it into different files, and the module\nsystem keeps the naming space clean (no need for name mangling)."),(0,o.kt)("p",null,"Generally, we will take a set of definitions that can be naturally\ngrouped by functionality, and put them together in a separate\nfile. For example, we can create a file ",(0,o.kt)("inlineCode",{parentName:"p"},"euro.mligo"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=module_imports",group:"module_imports"},"type t = nat\n\nlet add (a, b : t * t) : t = a + b\n\nlet one : t = 1n\nlet two : t = 2n\n")),(0,o.kt)("p",null,"In another file, we can import ",(0,o.kt)("inlineCode",{parentName:"p"},"euro.mligo")," as a module, and use its\ndefinitions. For example, we can create a ",(0,o.kt)("inlineCode",{parentName:"p"},"main.mligo")," that imports\nall definitions from ",(0,o.kt)("inlineCode",{parentName:"p"},"euro.mligo")," as the module ",(0,o.kt)("inlineCode",{parentName:"p"},"Euro"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=main_importer",group:"main_importer"},'#import "gitlab-pages/docs/modules/src/euro.mligo" "Euro"\n\ntype storage = Euro.t\n\nlet tip (s : storage) : storage = Euro.add (s, Euro.one)\n'))),(0,o.kt)(a.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("p",null,"Namespaces get more handy when they can be made from a file, separate\nfrom our own program, like a library: when we ",(0,o.kt)("em",{parentName:"p"},"import")," a namespace\nfrom such a file, we automatically obtain a namespace encapsulating\nall the definitions in it. This will become very handy for organising\nlarge contracts, as we can divide it into different files, and the\nnamespace system keeps the naming space clean (no need for name\nmangling)."),(0,o.kt)("p",null,"Generally, we will take a set of definitions that can be naturally\ngrouped by functionality, and put them together in a separate\nfile. For example, we can create a file ",(0,o.kt)("inlineCode",{parentName:"p"},"euro.jsligo"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=namespace_imports",group:"namespace_imports"},"export type t = nat;\n\nexport const add = (a: t, b: t): t => a + b;\n\nexport const one: t = 1n;\nexport const two: t = 2n;\n")),(0,o.kt)("p",null,"In another file, we can import ",(0,o.kt)("inlineCode",{parentName:"p"},"euro.jsligo")," as a namespace, and use\nits definitions. For example, we can create a ",(0,o.kt)("inlineCode",{parentName:"p"},"main.jsligo")," that\nimports all definitions from ",(0,o.kt)("inlineCode",{parentName:"p"},"euro.jsligo")," as the namespace ",(0,o.kt)("inlineCode",{parentName:"p"},"Euro"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=main_importer",group:"main_importer"},'#import "gitlab-pages/docs/modules/src/euro.jsligo" "Euro"\n\ntype storage = Euro.t;\n\nconst tip = (s : storage) : storage =>\n  Euro.add (s, Euro.one);\n'))))}u.isMDXComponent=!0}}]);