"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[33028],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>d});var i=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function r(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=i.createContext({}),c=function(e){var n=i.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},p=function(e){var n=c(e.components);return i.createElement(s.Provider,{value:n},e.children)},h={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},m=i.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),m=c(t),d=a,u=m["".concat(s,".").concat(d)]||m[d]||h[d]||o;return t?i.createElement(u,l(l({ref:n},p),{},{components:t})):i.createElement(u,l({ref:n},p))}));function d(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,l=new Array(o);l[0]=m;var r={};for(var s in n)hasOwnProperty.call(n,s)&&(r[s]=n[s]);r.originalType=e,r.mdxType="string"==typeof e?e:a,l[1]=r;for(var c=2;c<o;c++)l[c]=t[c];return i.createElement.apply(null,l)}return i.createElement.apply(null,t)}m.displayName="MDXCreateElement"},48720:(e,n,t)=>{t.d(n,{D:()=>a.Z,Z:()=>o});var i=t(67294),a=t(75402);const o=function(e){return i.createElement(a.Z.Consumer,null,(n=>{let{syntax:t}=n;return t===e.syntax?e.children:i.createElement(i.Fragment,null)}))}},55839:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>m,frontMatter:()=>l,metadata:()=>s,toc:()=>p});var i=t(87462),a=(t(67294),t(3905)),o=t(48720);const l={id:"michelson-injection",title:"Michelson injection"},r=void 0,s={unversionedId:"syntax/contracts/michelson-injection",id:"syntax/contracts/michelson-injection",title:"Michelson injection",description:"If you have an existing piece of Michelson code that you want to use",source:"@site/../docs/syntax/contracts/michelson_inj.md",sourceDirName:"syntax/contracts",slug:"/syntax/contracts/michelson-injection",permalink:"/previews/ligo/external-link-icon/docs/next/syntax/contracts/michelson-injection",draft:!1,tags:[],version:"current",frontMatter:{id:"michelson-injection",title:"Michelson injection"},sidebar:"docs",previous:{title:"Interoperability",permalink:"/previews/ligo/external-link-icon/docs/next/syntax/contracts/interop"},next:{title:"Attributes",permalink:"/previews/ligo/external-link-icon/docs/next/syntax/decorators"}},c={},p=[{value:"Internal injection",id:"internal-injection",level:3},{value:"External injection",id:"external-injection",level:3},{value:"Injection of Michelson contracts",id:"injection-of-michelson-contracts",level:3}],h={toc:p};function m(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,i.Z)({},h,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"If you have an existing piece of Michelson code that you want to use\nas-is, LIGO provides the ability to embed (inject) Michelson\ncode. This feature can be useful when you need to have a deep level of\ncontrol over the generated code, for example for optimisation, or if\nyou need to use a feature from Michelson that is not yet supported by\nhigh-level constructions in LIGO."),(0,a.kt)("h3",{id:"internal-injection"},"Internal injection"),(0,a.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,a.kt)("p",null,"The syntax for embedding Michelson is by means of the\n",(0,a.kt)("inlineCode",{parentName:"p"},"[%Michelson ...]")," special hook. The ellipsis is meant to denote a\nverbatim string annotated with a type, which contains the Michelson\ncode to be injected in the generated Michelson and the type (that of a\nfunction) of the Michelson code."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=michelson_inj",group:"michelson_inj"},"let michelson_add n =\n  [%Michelson ({| { UNPAIR ; ADD } |} : nat * nat -> nat)] n\n"))),(0,a.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,a.kt)("p",null,"The syntax for embedding Michelson is by means of the ",(0,a.kt)("inlineCode",{parentName:"p"},"(Michelson\n...)")," hook. The ellipsis is meant to denote a verbatim string\nannotated with a type, which contains the Michelson code to be\ninjected in the generated Michelson and the type (that of a function)\nof the Michelson code."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=michelson_inj",group:"michelson_inj"},"const michelson_add = n =>\n  (Michelson`{ UNPAIR ; ADD }` as ((n: [nat, nat]) => nat))(n);\n"))),(0,a.kt)("p",null,"Note that the type annotation is required, because the embedded\nMichelson code is not type-checked by the LIGO compiler, which\ntherefore assumes that the given type is correct."),(0,a.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,a.kt)("p",null,"In the example above, the notation ",(0,a.kt)("inlineCode",{parentName:"p"},"{| ... |}")," is used to\nrepresent a verbatim string literal, that is, an uninterpreted string,\nwhich here contains a piece of Michelson code. The type annotation\ndescribes the behaviour of the Michelson code:")),(0,a.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,a.kt)("p",null,"In the example above, the notation ",(0,a.kt)("inlineCode",{parentName:"p"},"` ... `")," is used to represent a\nverbatim string literal, that is, an uninterpreted string, which here\ncontains a piece of Michelson code. The type annotation describes the\nbehaviour of the Michelson code:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"It starts working on a stack consisting of a tuple of ",(0,a.kt)("inlineCode",{parentName:"p"},"nat"),"s: ",(0,a.kt)("inlineCode",{parentName:"p"},"[ nat * nat ]"),".")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"The tuple is destructured using ",(0,a.kt)("inlineCode",{parentName:"p"},"UNPAIR"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"[ nat ] [ nat ]"),".")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"The two top values of the stack are added using ",(0,a.kt)("inlineCode",{parentName:"p"},"ADD"),",\nand stops working on a stack consisting of a single ",(0,a.kt)("inlineCode",{parentName:"p"},"nat"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"[ nat ]"),"."))),(0,a.kt)("p",null,"The compiler will prevent changes to the embedded Michelson code if\nthe function resulting from the embedded code is not applied. For\nexample, let us see what happens when we compile an embedded Michelson\nexpression that pushes some value on the stack, then drops it\nimmediately, and then continues as a regular increment function."),(0,a.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,a.kt)("p",null,"The following command-line:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},'ligo compile expression cameligo "[%Michelson ({| { PUSH nat 42; DROP; PUSH nat 1; ADD } |} : nat -> nat)]"\n')),(0,a.kt)("p",null,"outputs:"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"{ PUSH nat 42 ; DROP ; PUSH nat 1 ; ADD }"))),(0,a.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,a.kt)("p",null,"The following command-line:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},'ligo compile expression jsligo "(Michelson`{ PUSH nat 42; DROP; PUSH nat 1; ADD }` : nat -> nat)"\n')),(0,a.kt)("p",null,"outputs:"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"{ PUSH nat 42 ; DROP ; PUSH nat 1 ; ADD }"))),(0,a.kt)("p",null,"As we can see, the embedded Michelson code was not modified. However,\nif the resulting function is applied, then the embedded Michelson code\ncould be modified/optimised by the compiler. To demonstrate this\nbehaviour, a function call can be introduced in the example above by\ncreating a lambda around the Michelson code. In this case, the first\ntwo instructions will be removed by the LIGO compiler because they\nhave no effect on the final result."),(0,a.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,a.kt)("p",null,"The following command-line:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},'ligo compile expression cameligo "fun n -> [%Michelson ({| { PUSH nat 42; DROP ; PUSH nat 1; ADD } |} : nat -> nat)] n"\n')),(0,a.kt)("p",null,"outputs:"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"{ PUSH nat 1 ; ADD }"))),(0,a.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,a.kt)("p",null,"The following command-line:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},'ligo compile expression jsligo "fun n -> (Michelson`{ PUSH nat 42; DROP ; PUSH nat 1; ADD }` : nat -> nat) n"\n')),(0,a.kt)("p",null,"outputs:"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"{ PUSH nat 1 ; ADD }"))),(0,a.kt)("h3",{id:"external-injection"},"External injection"),(0,a.kt)("p",null,"Sometimes the Michelson code we wish to inject is better maintained\nexternally, perhaps by a third-party, in which case we need to load\nthe Michelson code in order to inject it."),(0,a.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,a.kt)("p",null,"This is achieved by the special hook ",(0,a.kt)("inlineCode",{parentName:"p"},"[%of_file ...]"),", where the\nellipsis is a string containing a file path to a Michelson file with\nextension ",(0,a.kt)("inlineCode",{parentName:"p"},".tz"),". It has to be wrapped in a ",(0,a.kt)("inlineCode",{parentName:"p"},"[%Michelson ...]")," hook,\nlike so:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},'let michelson_add (v1 : int) (v2 : int) : int =\n  [%Michelson ([%of_file "my_michelson.tz"] : int * int -> int)] (v1, v2)\n'))),(0,a.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,a.kt)("p",null,"This is achieved by the special hook ",(0,a.kt)("inlineCode",{parentName:"p"},"(michelson_of_file ...)"),", where the\nellipsis is a ",(0,a.kt)("em",{parentName:"p"},"verbatim")," string containing a file path to a Michelson\nfile with extension ",(0,a.kt)("inlineCode",{parentName:"p"},".tz"),", like so:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},"const michelson_add = (n : [int, int]) : int =>\n  (Michelson_of_file`my_michelson.tz` as ((n: [int, int]) => int))(n)\n"))),(0,a.kt)("p",null,"where ",(0,a.kt)("inlineCode",{parentName:"p"},"my_michelson.tz")," contains"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-michelson"},"{ parameter nat ;\n  storage nat ;\n  code { UNPAIR; ADD } }\n")),(0,a.kt)("h3",{id:"injection-of-michelson-contracts"},"Injection of Michelson contracts"),(0,a.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,a.kt)("p",null,"This is achieved by the special hook ",(0,a.kt)("inlineCode",{parentName:"p"},"[%create_contract_of_file ...]"),",\nwhere the ellipsis is a string containg the file path to a Michelson\nfile with extension ",(0,a.kt)("inlineCode",{parentName:"p"},".tz"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=michelson_inj",group:"michelson_inj"},'[@entry]\nlet main (param : unit) () : operation list * unit =\n  let op, _addr =\n    [%create_contract_of_file "gitlab-pages/docs/syntax/contracts/src/compiled.tz"]\n    None 1tez param\n  in [op], ()\n'))),(0,a.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,a.kt)("p",null,"This is achieved by the special hook ",(0,a.kt)("inlineCode",{parentName:"p"},"(create_contract_of_file ...)"),",\nwhere the ellipsis is a ",(0,a.kt)("em",{parentName:"p"},"verbatim")," string containg the file path to a\nMichelson file with extension ",(0,a.kt)("inlineCode",{parentName:"p"},".tz"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=michelson_inj",group:"michelson_inj"},'// @entry\nconst main = (param: unit, _storage: unit) : [list<operation>, unit] => {\n  const [op, _addr] =\n    (create_contract_of_file `gitlab-pages/docs/syntax/contracts/src/compiled.tz`)\n    (["None" as "None"], 1 as tez, param)\n  return [[op], []];\n}\n'))),(0,a.kt)("p",null,"where ",(0,a.kt)("inlineCode",{parentName:"p"},"compiled.tz")," contains"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-michelson"},"{ parameter unit ;\n  storage unit ;\n  code { DROP ; UNIT ; NIL operation ; PAIR } }\n")))}m.isMDXComponent=!0}}]);