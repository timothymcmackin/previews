"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[35514],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var a=n(67294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},y=a.forwardRef((function(e,t){var n=e.components,s=e.mdxType,r=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),y=p(n),d=s,m=y["".concat(l,".").concat(d)]||y[d]||u[d]||r;return n?a.createElement(m,o(o({ref:t},c),{},{components:n})):a.createElement(m,o({ref:t},c))}));function d(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var r=n.length,o=new Array(r);o[0]=y;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:s,o[1]=i;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}y.displayName="MDXCreateElement"},48720:(e,t,n)=>{n.d(t,{D:()=>s.Z,Z:()=>r});var a=n(67294),s=n(75402);const r=function(e){return a.createElement(s.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},84524:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>y,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var a=n(87462),s=(n(67294),n(3905)),r=n(48720);const o={title:"Classes"},i=void 0,l={unversionedId:"syntax/classes",id:"syntax/classes",title:"Classes",description:"Classes are not supported in CameLIGO.",source:"@site/../docs/syntax/classes.md",sourceDirName:"syntax",slug:"/syntax/classes",permalink:"/previews/ligo/external-link-icon/docs/next/syntax/classes",draft:!1,tags:[],version:"current",frontMatter:{title:"Classes"},sidebar:"docs",previous:{title:"Modules",permalink:"/previews/ligo/external-link-icon/docs/next/syntax/modules"},next:{title:"Contracts",permalink:"/previews/ligo/external-link-icon/docs/next/syntax/contracts/"}},p={},c=[{value:"Creating classes",id:"creating-classes",level:2},{value:"Importing and using classes",id:"importing-and-using-classes",level:2}],u={toc:c};function y(e){let{components:t,...n}=e;return(0,s.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("p",null,"Classes are not supported in CameLIGO.")),(0,s.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("p",null,"Classes (introduced in JsLIGO 2.0) are similar to classes in JavaScript/Typescript.\nYou can use them to define a smart contract or group related definitions."),(0,s.kt)("p",null,"JsLIGO classes do not have all of the same features as JavaScript/TypeScript classes.\nFor example, JsLIGO classes cannot inherit from other classes as they can in JavaScript/TypeScript.\nHowever, classes can implement ",(0,s.kt)("a",{parentName:"p",href:"./signatures"},"interfaces"),"."),(0,s.kt)("h2",{id:"creating-classes"},"Creating classes"),(0,s.kt)("p",null,"JsLIGO classes can contain only function definitions and value definitions, which are referred to as ",(0,s.kt)("em",{parentName:"p"},"properties")," when they are in a class.\nBecause each property is assumed to be constant, you do not prefix definitions with the ",(0,s.kt)("inlineCode",{parentName:"p"},"function"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"const"),", or ",(0,s.kt)("inlineCode",{parentName:"p"},"let")," keywords.\nWithin a class, you can also apply decorators such as ",(0,s.kt)("inlineCode",{parentName:"p"},"@entry")," to functions without putting them in comments."),(0,s.kt)("p",null,"Classes are one way to define contracts, as in this example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=classes",group:"classes"},"type storage_type = int;\ntype return_type = [list<operation>, storage_type];\n\nclass Counter {\n  @entry\n  add = (value: int, storage: storage_type): return_type =>\n    [[], storage + value];\n\n  @entry\n  sub = (value: int, storage: storage_type): return_type =>\n    [[], storage - value];\n}\n")),(0,s.kt)("admonition",{type:"tip"},(0,s.kt)("p",{parentName:"admonition"},"Classes cannot contain type definitions.\nTo encapsulate classes with types, such as if you want to define a type that represents the contract storage or types that represent complex parameter types, you can group the contract class and the related types in a namespace.")),(0,s.kt)("h2",{id:"importing-and-using-classes"},"Importing and using classes"),(0,s.kt)("p",null,"You can import and use definitions from classes in the same file or in different files.\nFor example, this version of the previous example uses functions that are in another class and types that are in another namespace:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=import_classes_local",group:"import_classes_local"},"namespace MyTypes {\n  export type storage_type = int;\n  export type return_type = [list<operation>, storage_type];\n}\n\nclass MyFunctions {\n  static add = (a: int, b: int): int => a + b;\n  static sub = (a: int, b: int): int => a - b;\n}\n\nclass Counter {\n  @entry\n  add = (value: int, storage: MyTypes.storage_type): MyTypes.return_type =>\n    [[], MyFunctions.add(storage, value)];\n\n  @entry\n  sub = (value: int, storage: MyTypes.storage_type): MyTypes.return_type =>\n    [[], MyFunctions.add(storage, value)];\n}\n")),(0,s.kt)("p",null,"To make properties accessible outside of a class, you must mark them with the ",(0,s.kt)("inlineCode",{parentName:"p"},"static")," keyword or the ",(0,s.kt)("inlineCode",{parentName:"p"},"@public")," decorator.\nThe ",(0,s.kt)("inlineCode",{parentName:"p"},"static")," keyword is more appropriate because external code accesses the definitions of the class in a static manner, without creating an instance of the class."),(0,s.kt)("p",null,"For example, this file exports a class with static properties:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=exported_class",group:"exported_class"},"export class MyFunctions {\n  static add = (a: int, b: int): int => a + b;\n  static sub = (a: int, b: int): int => a - b;\n}\n")),(0,s.kt)("p",null,"This file imports and uses the class:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=imports_classes",group:"imports_classes"},'type storage_type = int;\ntype return_type = [list<operation>, storage_type];\n\nimport * as MyImportedFunctions from "gitlab-pages/docs/syntax/src/classes/exported_class.jsligo";\n\nclass Calculator {\n  @entry\n  add = (value: int, storage: storage_type): return_type =>\n    [[], MyImportedFunctions.MyFunctions.add(storage, value)];\n\n  @entry\n  sub = (value: int, storage: storage_type): return_type =>\n    [[], MyImportedFunctions.MyFunctions.sub(storage, value)];\n}\n'))))}y.isMDXComponent=!0}}]);