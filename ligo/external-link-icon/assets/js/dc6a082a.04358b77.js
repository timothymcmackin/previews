"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5140],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},y=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),y=p(n),m=r,g=y["".concat(l,".").concat(m)]||y[m]||c[m]||o;return n?a.createElement(g,s(s({ref:t},u),{},{components:n})):a.createElement(g,s({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=y;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var p=2;p<o;p++)s[p]=n[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}y.displayName="MDXCreateElement"},48720:(e,t,n)=>{n.d(t,{D:()=>r.Z,Z:()=>o});var a=n(67294),r=n(75402);const o=function(e){return a.createElement(r.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},81451:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>y,frontMatter:()=>s,metadata:()=>l,toc:()=>u});var a=n(87462),r=(n(67294),n(3905)),o=n(48720);const s={id:"type-annotations",title:"Type annotations"},i=void 0,l={unversionedId:"data-types/type-annotations",id:"data-types/type-annotations",title:"Type annotations",description:"As described in Types, the LIGO compiler must know the type of each variable to be able to compile to Michelson, which is strongly and statically typed.",source:"@site/../docs/data-types/type-annotations.md",sourceDirName:"data-types",slug:"/data-types/type-annotations",permalink:"/previews/ligo/external-link-icon/docs/next/data-types/type-annotations",draft:!1,tags:[],version:"current",frontMatter:{id:"type-annotations",title:"Type annotations"},sidebar:"docs",previous:{title:"Data types",permalink:"/previews/ligo/external-link-icon/docs/next/data-types/types"},next:{title:"Numbers",permalink:"/previews/ligo/external-link-icon/docs/next/data-types/numbers"}},p={},u=[{value:"Annotating types",id:"annotating-types",level:2},{value:"Inferring types",id:"inferring-types",level:2},{value:"Type assumptions",id:"type-assumptions",level:2}],c={toc:u};function y(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"As described in ",(0,r.kt)("a",{parentName:"p",href:"./types"},"Types"),", the LIGO compiler must know the type of each variable to be able to compile to Michelson, which is strongly and statically typed.\nLIGO can infer or assume the types of variables in many cases, but in cases where it can't, you can manually annotate the types of variables, as in TypeScript and Ocaml.\nAnnotating types can also improve code readability."),(0,r.kt)("h2",{id:"annotating-types"},"Annotating types"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("p",null,"As in Ocaml, you can annotate a variable with its type by adding a colon and the type or type alias:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=annotate",group:"annotate"},'let myInteger : int = 5\nlet myString : string = "Hello"\n')),(0,r.kt)("p",null,"More complex types such as lists and maps take sub-types, as in these examples:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=annotate",group:"annotate"},'let myList : int list = [1; 2; 3]\nlet myMap : (string, int) map =\n  Map.literal [\n    ("one", 1);\n    ("two", 2);\n  ]\n')),(0,r.kt)("p",null,"For readability, contracts often annotate function and entrypoint parameters and return types, as in this example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=annotate",group:"annotate"},"module Counter = struct\n  type storage_type = int\n  type return_type = operation list * storage_type\n\n  [@entry]\n  let add (value : int) (storage: storage_type) : return_type =\n    [], storage + value\n\n  [@entry]\n  let sub (value : int) (storage: storage_type) : return_type =\n    [], storage - value\n\nend\n"))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("p",null,"As in TypeScript, you can annotate a variable with its type by adding a colon and the type or type alias:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=annotate",group:"annotate"},'const myInteger: int = 5;\nconst myString: string = "Hello";\n')),(0,r.kt)("p",null,"Similarly, you can annotate the value that you assign to a variable:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=annotate",group:"annotate"},'const myOtherInteger = 5 as int;\nconst myOtherString = "Hello" as string;\n')),(0,r.kt)("p",null,"More complex types such as lists and maps take sub-types in angle brackets, as in these examples:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=annotate",group:"annotate"},'const myList: list<int> = [1, 2, 3];\nconst myMap: map<string, int> =\n  Map.literal([\n    ["one", 1],\n    ["two", 2],\n  ]);\n')),(0,r.kt)("p",null,"For readability, contracts often annotate function and entrypoint parameters and return types, as in this example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=annotate",group:"annotate"},"namespace Counter {\n  type storage_type = int;\n  type return_type = [list<operation>, storage_type];\n\n  // @entry\n  const add = (value: int, storage: storage_type): return_type =>\n    [[], storage + value];\n\n  // @entry\n  const sub = (value: int, storage: storage_type): return_type =>\n    [[], storage - value];\n\n}\n"))),(0,r.kt)("h2",{id:"inferring-types"},"Inferring types"),(0,r.kt)("p",null,"Sometimes, the LIGO compiler can infer a variable's type from the context."),(0,r.kt)("p",null,"The following example subtracts two nats and puts the result in a variable.\nThis variable does not have an explicit type declaration, but the compiler infers that it is a number and that it is an int because the value could be negative, even though in this case it is positive:"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=inferring",group:"inferring"},"let a : nat = 7\nlet b : nat = 5\nlet c = a - b (* Inferred to be an int *)\n"))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=inferring",group:"inferring"},"const a: nat = 7;\nconst b: nat = 5;\nconst c = a - b; // Inferred to be an int\n"))),(0,r.kt)("h2",{id:"type-assumptions"},"Type assumptions"),(0,r.kt)("p",null,"In some cases, the LIGO compiler assumes a variable's type when it does not have complete information."),(0,r.kt)("p",null,"For example, when LIGO knows that a variable is a number but not whether that number is an integer or a nat, it assumes that it is an integer.\nSimilarly, LIGO assumes that a list of literal values in brackets is a tuple, not a list, unless you cast that list with the ",(0,r.kt)("inlineCode",{parentName:"p"},"list")," function."),(0,r.kt)("p",null,"The following contract has two entrypoints that each accept one parameter.\nThe types of the parameters are not specified, but the compiler can infer that they are numbers by how they are used.\nFrom there, it assumes that they are integers and therefore types them as integers in the compiled contract."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=assumptions",group:"assumptions"},"module Counter = struct\n  type storage_type = int\n  type return_type = operation list * storage_type\n\n  [@entry]\n  (* The type of the value parameter is assumed to be an int *)\n  let add (value) (storage: storage_type) : return_type =\n    [], storage + value\n\n  [@entry]\n  (* The type of the value parameter is assumed to be an int *)\n  let sub (value) (storage: storage_type) : return_type =\n    [], storage - value\n\nend\n"))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=assumptions",group:"assumptions"},"namespace Counter {\n  type storage_type = int;\n  type return_type = [list<operation>, storage_type];\n\n  // @entry\n  // The type of the value parameter is assumed to be an int\n  const add = (value, storage: storage_type): return_type =>\n    [[], storage + value];\n\n  // @entry\n  // The type of the value parameter is assumed to be an int\n  const sub = (value, storage: storage_type): return_type =>\n    [[], storage - value];\n\n}\n"))))}y.isMDXComponent=!0}}]);