"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[13581],{3905:(t,e,n)=>{n.d(e,{Zo:()=>d,kt:()=>c});var a=n(67294);function r(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function i(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function l(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?i(Object(n),!0).forEach((function(e){r(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function o(t,e){if(null==t)return{};var n,a,r=function(t,e){if(null==t)return{};var n,a,r={},i=Object.keys(t);for(a=0;a<i.length;a++)n=i[a],e.indexOf(n)>=0||(r[n]=t[n]);return r}(t,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);for(a=0;a<i.length;a++)n=i[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(r[n]=t[n])}return r}var s=a.createContext({}),p=function(t){var e=a.useContext(s),n=e;return t&&(n="function"==typeof t?t(e):l(l({},e),t)),n},d=function(t){var e=p(t.components);return a.createElement(s.Provider,{value:e},t.children)},m={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},u=a.forwardRef((function(t,e){var n=t.components,r=t.mdxType,i=t.originalType,s=t.parentName,d=o(t,["components","mdxType","originalType","parentName"]),u=p(n),c=r,k=u["".concat(s,".").concat(c)]||u[c]||m[c]||i;return n?a.createElement(k,l(l({ref:e},d),{},{components:n})):a.createElement(k,l({ref:e},d))}));function c(t,e){var n=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var i=n.length,l=new Array(i);l[0]=u;var o={};for(var s in e)hasOwnProperty.call(e,s)&&(o[s]=e[s]);o.originalType=t,o.mdxType="string"==typeof t?t:r,l[1]=o;for(var p=2;p<i;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},48720:(t,e,n)=>{n.d(e,{D:()=>r.Z,Z:()=>i});var a=n(67294),r=n(75402);const i=function(t){return a.createElement(r.Z.Consumer,null,(e=>{let{syntax:n}=e;return n===t.syntax?t.children:a.createElement(a.Fragment,null)}))}},38538:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>p,contentTitle:()=>o,default:()=>u,frontMatter:()=>l,metadata:()=>s,toc:()=>d});var a=n(87462),r=(n(67294),n(3905)),i=n(48720);const l={title:"Migrating to LIGO v2.0"},o=void 0,s={unversionedId:"intro/upgrade-v2",id:"intro/upgrade-v2",title:"Migrating to LIGO v2.0",description:"Version 2.0 of LIGO includes breaking changes, so you must update your code when you upgrade your installation of LIGO as described in Installation.",source:"@site/../docs/intro/upgrade-v2.md",sourceDirName:"intro",slug:"/intro/upgrade-v2",permalink:"/previews/ligo/external-link-icon/docs/next/intro/upgrade-v2",draft:!1,tags:[],version:"current",frontMatter:{title:"Migrating to LIGO v2.0"},sidebar:"docs",previous:{title:"Migrating to LIGO v1.0",permalink:"/previews/ligo/external-link-icon/docs/next/intro/upgrade-v1"},next:{title:"Part 1: Creating a contract",permalink:"/previews/ligo/external-link-icon/docs/next/tutorials/taco-shop/selling-tacos"}},p={},d=[{value:"Promotion of <code>Test.Next</code>",id:"promotion-of-testnext",level:2},{value:"Contract syntax",id:"contract-syntax",level:2},{value:"Namespaces",id:"namespaces",level:2},{value:"Classes",id:"classes",level:2},{value:"Interfaces",id:"interfaces",level:2},{value:"Types",id:"types",level:2},{value:"Specifying the types of literals",id:"specifying-the-types-of-literals",level:3},{value:"Records (now called objects)",id:"records-now-called-objects",level:3},{value:"Variants and options",id:"variants-and-options",level:3},{value:"Pattern matching",id:"pattern-matching",level:2},{value:"Imports",id:"imports",level:2},{value:"Preprocessor directives",id:"preprocessor-directives",level:2},{value:"The <code>switch</code> statement",id:"the-switch-statement",level:2},{value:"<code>do</code> expressions",id:"do-expressions",level:2},{value:"Escaping keywords",id:"escaping-keywords",level:2},{value:"Decorators",id:"decorators",level:2},{value:"Commands",id:"commands",level:2}],m={toc:d};function u(t){let{components:e,...n}=t;return(0,r.kt)("wrapper",(0,a.Z)({},m,n,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Version 2.0 of LIGO includes breaking changes, so you must update your code when you upgrade your installation of LIGO as described in ",(0,r.kt)("a",{parentName:"p",href:"./installation"},"Installation"),"."),(0,r.kt)("h2",{id:"promotion-of-testnext"},"Promotion of ",(0,r.kt)("inlineCode",{parentName:"h2"},"Test.Next")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Test.Next")," library is now the ",(0,r.kt)("inlineCode",{parentName:"p"},"Test")," library, replacing the old ",(0,r.kt)("inlineCode",{parentName:"p"},"Test")," library.\nThis table shows the old functions and their new equivalents:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Function in LIGO v1.9.2"),(0,r.kt)("th",{parentName:"tr",align:null},"Function in LIGO v2"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.run")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Michelson.run"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.eval")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Michelson.eval"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.decompile")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Michelson.decompile"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.compile_value")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Michelson.eval"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.get_total_voting_power")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.State.get_total_voting_power"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.failwith")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Assert.failwith"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.to_contract")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Typed_address.to_contract"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.set_source")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.State.set_source"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.cast_address")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Address.to_typed_address"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.to_address")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Typed_address.to_address"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.get_storage")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Typed_address.get_storage"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.get_storage_of_address")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Address.get_storage"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.get_balance_of_address")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Address.get_balance"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.get_balance")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Typed_address.get_balance"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.print")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.IO.print"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.eprint")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.IO.eprint"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.get_voting_power")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.State.get_voting_power"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.nth_bootstrap_contract")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Account.Contract.bootstrap"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.nth_bootstrap_account")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Account.address"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.get_bootstrap_account")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Account.info"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.nth_bootstrap_typed_address")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Account.Contract.bootstrap_typed_address"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.last_originations")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.State.last_originations"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.random")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.random")," (unchanged)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.new_account")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Account.new"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.bake_until_n_cycle_end")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.State.bake_until"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.get_time")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Tezos.get_now"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.register_delegate")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.State.register_delegate"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.stake")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.State.stake"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.register_constant")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.State.register_constant"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.to_typed_address")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Contract.to_typed_address"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.constant_to_michelson_program")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Michelson.parse"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.parse_michelson")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Michelson.parse"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.restore_context")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.State.restore"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.save_context")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.State.save"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.drop_context")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.State.drop"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.to_string")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.String.show"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.to_json")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.String.json"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.to_debugger_json")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.String.debugger_json"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.set_baker_policy")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.State.set_baker_policy"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.set_baker")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.State.set_baker"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.size")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Michelson.Contract.size"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.compile_contract")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Michelson.Contract.compile"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.read_contract_from_file")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Michelson.Contract.from_file"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.chr")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.String.chr"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.nl")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.String.nl"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.println")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.IO.println"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.set_print_values")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.IO.set_test_print"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.unset_print_values")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.IO.unset_test_print"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.get_last_events_from")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.State.last_events"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.transfer")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Typed_address.transfer"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.transfer_exn")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Typed_address.transfer_exn"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.log")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.IO.log"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.reset_state")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.State.reset"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.reset_state_at")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.State.reset_at"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.bootstrap_contract")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.State.Reset.add_func_contract"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.mutate_value")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Mutation.value"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.save_mutation")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Mutation.save"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.sign")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Crypto.sign"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.add_account")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Account.add"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.baker_account")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.State.Reset.add_baker"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.set_big_map")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.State.set_big_map"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.transfer_to_contract")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Contract.transfer"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.transfer_to_contract_exn")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Contract.transfer_exn"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.michelson_equal")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Compare.eq"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.to_entrypoint")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Typed_address.get_entrypoint"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.storage_with_dynamic_entrypoints")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Dynamic_entrypoints.storage"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.originate_contract")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Originate.michelson"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.compile_contract_with_views")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Michelson.Contract.compile_with_views"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.originate")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Originate.contract"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.compile_contract_from_file")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Michelson.Contract.from_file"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.originate_from_file")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Originate.from_file"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.mutation_test")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Mutation.func"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.mutation_test_all")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Mutation.All.func"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.originate_from_file_and_mutate")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Mutation.from_file"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.originate_from_file_and_mutate_all")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Mutation.All.from_file"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.originate_module_and_mutate")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Mutation.contract"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.originate_and_mutate_all")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Mutation.All.contract"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.assert")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Assert.assert"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.assert_some")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Assert.some"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.assert_none")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Assert.none"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.assert_with_error")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Assert.Error.assert"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.assert_some_with_error")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Assert.Error.some"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.assert_none_with_error")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Assert.Error.none"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.equal")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Compare.eq"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.not_equal")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Compare.neq"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.greater")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Compare.gt"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.less")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Compare.lt"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.greater_or_equal")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Compare.ge"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.less_or_equal")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Compare.le"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.create_chest")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Timelock.create"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.create_chest_key")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Test.Timelock.create_key"))))),(0,r.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"}),(0,r.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("h2",{id:"contract-syntax"},"Contract syntax"),(0,r.kt)("p",null,"In previous versions of JsLIGO, contracts could be defined in namespaces or at the top level of a file.\nVersion 2.0 adds the option to define contracts in classes.\nWhether you define contracts in namespaces, classes, or in the top level of a file depends on the features that you need and the syntax that you prefer.\nFor example, if you want a contract to implement an interface, you must put the contract in a class."),(0,r.kt)("p",null,"The syntax for contracts in namespaces and in the top levels of files has changed in some ways:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"As before, they can include type definitions"),(0,r.kt)("li",{parentName:"ul"},"As before, they must define entrypoints as functions with the ",(0,r.kt)("inlineCode",{parentName:"li"},"function"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"const"),", or ",(0,r.kt)("inlineCode",{parentName:"li"},"let")," properties"),(0,r.kt)("li",{parentName:"ul"},"They must put decorators such as ",(0,r.kt)("inlineCode",{parentName:"li"},"@entry")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"@view")," in a comment immediately before the definition that they modify"),(0,r.kt)("li",{parentName:"ul"},"They cannot implement interfaces")),(0,r.kt)("p",null,"Here is an example of a JsLIGO 2.0 contract in a namespace.\nThe only change for JsLIGO 2.0 is that the decorators are now in comments:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=namespace",group:"namespace"},"namespace Counter {\n  type storage_type = int;\n  type return_type = [list<operation>, storage_type];\n\n  // @entry\n  const add = (value: int, storage: storage_type): return_type =>\n    [[], storage + value];\n\n  // @entry\n  const sub = (value: int, storage: storage_type): return_type =>\n    [[], storage - value];\n}\n")),(0,r.kt)("p",null,"The syntax for a JsLIGO 2.0 contract at the top level of a file is similar.\nThe only change for JsLIGO 2.0 is that the decorators are now in comments:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=toplevel",group:"toplevel"},"type storage_type = int;\ntype return_type = [list<operation>, storage_type];\n\n// @entry\nconst add = (value: int, store: storage_type): return_type =>\n  [[], store + value];\n\n// @entry\nconst sub = (value: int, store: storage_type): return_type =>\n  [[], store - value];\n")),(0,r.kt)("p",null,"However, the syntax for a JsLIGO 2.0 contract in a class is different, as described in ",(0,r.kt)("a",{parentName:"p",href:"#classes"},"Classes"),"."),(0,r.kt)("h2",{id:"namespaces"},"Namespaces"),(0,r.kt)("p",null,"As described in ",(0,r.kt)("a",{parentName:"p",href:"#contract-syntax"},"Contract syntax"),", the syntax for namespaces (whether they define a contract or merely a group of other related definitions) has changed in some ways:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"As before, they can include type definitions"),(0,r.kt)("li",{parentName:"ul"},"As before, they must define entrypoints as functions with the ",(0,r.kt)("inlineCode",{parentName:"li"},"function"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"const"),", or ",(0,r.kt)("inlineCode",{parentName:"li"},"let")," properties"),(0,r.kt)("li",{parentName:"ul"},"They must put decorators such as ",(0,r.kt)("inlineCode",{parentName:"li"},"@entry")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"@view")," in a comment immediately before the definition that they modify"),(0,r.kt)("li",{parentName:"ul"},"They cannot implement interfaces")),(0,r.kt)("h2",{id:"classes"},"Classes"),(0,r.kt)("p",null,"JsLIGO 2.0 introduces classes, which are similar to classes in JavaScript/Typescript.\nYou can use JsLIGO classes to define a smart contract or group related functions, which are referred to as properties when they are in a class.\nHowever, JsLIGO classes do not have all of the same features as JavaScript/TypeScript classes.\nFor example, JsLIGO classes cannot inherit from other classes as they can in JavaScript/TypeScript."),(0,r.kt)("p",null,"JsLIGO classes have these characteristics:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"They cannot include type definitions"),(0,r.kt)("li",{parentName:"ul"},"They define functions (including entrypoints) without the ",(0,r.kt)("inlineCode",{parentName:"li"},"function"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"const"),", or ",(0,r.kt)("inlineCode",{parentName:"li"},"let")," keywords"),(0,r.kt)("li",{parentName:"ul"},"They do not need to put decorators such as ",(0,r.kt)("inlineCode",{parentName:"li"},"@entry")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"@view")," in comments"),(0,r.kt)("li",{parentName:"ul"},"They can implement interfaces")),(0,r.kt)("p",null,"Here is an example contract that is defined in a class:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=classes",group:"classes"},"type storage_type = int;\ntype return_type = [list<operation>, storage_type];\n\nclass Counter {\n  @entry\n  add = (value: int, storage: storage_type): return_type =>\n    [[], storage + value];\n\n  @entry\n  sub = (value: int, storage: storage_type): return_type =>\n    [[], storage - value];\n}\n")),(0,r.kt)("p",null,"To encapsulate classes with types, such as if you want to define a type that represents the contract storage or complex parameter types, you can group the contract class and the related types in a namespace."),(0,r.kt)("h2",{id:"interfaces"},"Interfaces"),(0,r.kt)("p",null,"The syntax for interfaces has changed; they now have a syntax that is similar to classes:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Like classes, they cannot contain type definitions."),(0,r.kt)("li",{parentName:"ul"},"They contain function signatures that are not defined with the ",(0,r.kt)("inlineCode",{parentName:"li"},"function"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"const"),", or ",(0,r.kt)("inlineCode",{parentName:"li"},"let")," properties."),(0,r.kt)("li",{parentName:"ul"},"Unlike classes, they must put decorators such as ",(0,r.kt)("inlineCode",{parentName:"li"},"@entry")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"@view")," in a comment immediately before the definition that they modify.")),(0,r.kt)("p",null,"For example, this is an interface in JsLIGO 1.9.2:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},"// Not valid in JsLIGO 2.0\ninterface MyInterface {\n  type storage = int;\n  @entry\n  const add: (s: int, k: storage) => [list<operation>, storage];\n}\n")),(0,r.kt)("p",null,"This is the equivalent interface in JsLIGO 2.0:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=interfaces",group:"interfaces"},"type storage = int;\ninterface MyInterface {\n  // @entry\n  add: (s: int, k: storage) => [list<operation>, storage];\n}\n")),(0,r.kt)("p",null,"As a result of these changes, abstract types (type names that are required by an interface without specifying the actual type) are no longer permitted in JsLIGO."),(0,r.kt)("h2",{id:"types"},"Types"),(0,r.kt)("p",null,"JsLIGO 2.0 includes changes to make its type system more similar to TypeScript."),(0,r.kt)("h3",{id:"specifying-the-types-of-literals"},"Specifying the types of literals"),(0,r.kt)("p",null,"Instead of using postfixes to denote certain types, LIGO 2.0 uses the ",(0,r.kt)("inlineCode",{parentName:"p"},"as")," keyword to denote the type of a literal, as in these examples:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Data type"),(0,r.kt)("th",{parentName:"tr",align:null},"LIGO 1.0"),(0,r.kt)("th",{parentName:"tr",align:null},"LIGO 2.0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Bytes"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"const zero = 0x")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'const zero = "" as bytes'))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Natural numbers"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"const one = 1n")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"const one = 1 as nat"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"tez"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"const one_tez = 1tez")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"const one_tez = 1 as tez"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"mutez"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"const one_mutez = 1mutez")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"const one_mutez = 1 as mutez"))))),(0,r.kt)("p",null,"Similarly, the ",(0,r.kt)("inlineCode",{parentName:"p"},"parameter_of")," keyword now takes its type in a way more similar to TypeScript:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"LIGO 1.0"),(0,r.kt)("th",{parentName:"tr",align:null},"LIGO 2.0"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"const parameter = MyEntrypoint(value) as parameter_of MyContract;")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"const parameter = MyEntrypoint(value) as parameter_of<MyContract>;"))))),(0,r.kt)("h3",{id:"records-now-called-objects"},"Records (now called objects)"),(0,r.kt)("p",null,"To be closer to JavaScript, JslIGO now refers to the record data type as an object.\nJsLIGO objects are similar to JavaScript objects, but they have some limitations that JavaScript objects don't have."),(0,r.kt)("p",null,"To specify the type of an object, use commas to separate the fields, not semicolons as in the previous version of JsLIGO.\nContinue to use commas to separate the values in an object, as in the previous version of JsLIGO and as in JavaScript.\nFor example, this contract uses an object type in JsLIGO 2.0:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=objects",group:"objects"},"type object_type = {x: int, y: int, z: int};\ntype storage_type = object_type;\ntype return_type = [list<operation>, storage_type];\n\nclass Counter {\n  @entry\n  reset = (_: unit, _s: storage_type): return_type => {\n    const newObject: object_type = {\n      x: 0,\n      y: 0,\n      z: 0,\n    };\n    return [[], newObject];\n  }\n\n  @entry\n  increment = (_: unit, storage: storage_type): return_type => {\n    const { x, y, z } = storage;\n    const newObject: object_type = {\n      x: x + 1,\n      y: y + 1,\n      z: z + 1,\n    };\n    return [[], newObject];\n  }\n}\n")),(0,r.kt)("p",null,"Field name punning (a shorthand way of setting the value of a field to a variable of the same name) is no longer permitted in object type definitions.\nThis example shows how to avoid punning by specifying the type of each field explicitly:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=type_punning",group:"type_punning"},"type x = int;\ntype y = int;\ntype z = int;\n// type object_type = { x, y, z }; // not permitted\ntype object_type = {x: x, y: y, z: z}; // correct\n")),(0,r.kt)("p",null,"Punning is still permitted in variable definitions, as in this example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=value_punning",group:"value_punning"},"type object_type = { x: int, y: int, z: int };\nconst x = 5;\nconst y = 6;\nconst z = 7;\nconst newObject: object_type = { x, y, z };\n")),(0,r.kt)("p",null,"JsLIGO objects have these limitations that JavaScript objects don't have:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"You cannot change the fields of a JsLIGO object that is declared as a constant.\nHowever, you can change the fields of a JsLIGO object that is declared as a variable."),(0,r.kt)("li",{parentName:"ul"},"You cannot add fields to an object after you create it, regardless of whether it is declared as a constant or a variable."),(0,r.kt)("li",{parentName:"ul"},"You cannot access fields in an object by putting a variable name in brackets; you must access the fields by specifying the field names as literals in brackets or with the selection operator (",(0,r.kt)("inlineCode",{parentName:"li"},"."),").")),(0,r.kt)("p",null,"For more information about objects, see ",(0,r.kt)("a",{parentName:"p",href:"../data-types/records"},"Objects"),"."),(0,r.kt)("h3",{id:"variants-and-options"},"Variants and options"),(0,r.kt)("p",null,"The syntax for variant and option types has changed.\nIf the variant type has only one variant, it must start with a vertical bar, as in this example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=union",group:"union"},'type singleton = | ["Single"];\n')),(0,r.kt)("p",null,"To define the values of a variant type, use the usual tuple syntax, with the type as the first tuple value and the value of the variant as the second tuple value.\nTo prevent the compiler from seeing the first value as a string, you must set its type as one of the constructors from the variant type, as in this example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=union",group:"union"},'type user =\n  ["Admin", nat]\n| ["Manager", int]\n| ["Guest"];\n\nconst admin1: user = ["Admin" as "Admin", 1 as nat];\nconst manager2: user = ["Manager" as "Manager", 2 as int];\nconst guest3: user = ["Guest" as "Guest"];\n')),(0,r.kt)("h2",{id:"pattern-matching"},"Pattern matching"),(0,r.kt)("p",null,"The syntax for pattern matching has changed to use the ",(0,r.kt)("inlineCode",{parentName:"p"},"$match")," predefined function instead of the ",(0,r.kt)("inlineCode",{parentName:"p"},"match")," keyword.\nAs its parameters, the ",(0,r.kt)("inlineCode",{parentName:"p"},"$match")," function receives the variant value to match on and an object.\nThe property names of the object are the constructors of the corresponding variant type.\nThe property values are either a single expression or functions that receive the value of the variant as a parameter.\nHere is an example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=matching",group:"matching"},'type user =\n  ["Admin", nat]\n| ["Manager", nat]\n| ["Guest"];\n\nconst greetUser = (user: user): string => {\n  $match (user, {\n    "Admin": _id => "Hello, administrator",\n    "Manager": _id => "Welcome, manager",\n    "Guest": () => "Hello, guest",\n  });\n}\n')),(0,r.kt)("p",null,"To define the thunk, use an immediately invoked function expression (IIFE) as the result of a match, as in the following example.\nJsLIGO 2.0 uses this syntax in place of ",(0,r.kt)("inlineCode",{parentName:"p"},"do")," expressions in the previous version."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=matching",group:"matching"},'const getSquareOfUserId = (user: user): nat => {\n  $match (user, {\n    "Admin": id => (() => {\n      const squareOfId = id * id;\n      return squareOfId;\n    })(),\n    "Manager": id => (() => {\n      const squareOfId = id * id;\n      return squareOfId;\n    })(),\n    "Guest": () => 0,\n  });\n}\n')),(0,r.kt)("p",null,"Matching works only on values of variant types.\nIf you want to use the ",(0,r.kt)("inlineCode",{parentName:"p"},"$match")," statement on other types or on more than one variable at a time, you can wrap them in a variant or option.\nThis example wraps two types in a variant so the ",(0,r.kt)("inlineCode",{parentName:"p"},"$match")," statement can use them both:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=matching",group:"matching"},'type wrapper = | ["Wrap", [int, int]];\nconst wrapped: wrapper = ["Wrap" as "Wrap", [5, 5]];\n\nconst compareResult: string = $match(wrapped, {\n  "Wrap": ([_a, _b]) => (() => {\n    if (_a == _b) return "Equal";\n    if (_a > _b) return "Greater";\n    if (_a < _b) return "Less";\n    return "Default";\n  })(),\n});\n')),(0,r.kt)("p",null,"Also, match cases can accept only one parameter.\nIn LIGO v1, the following match statement was allowed; note that the match expression for the ",(0,r.kt)("inlineCode",{parentName:"p"},"RGB")," case accepts three parameters, one for each of the values in the variant:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},'type colour =\n| ["RGB", [int, int, int]]\n| ["Gray", int]\n| ["Default"];\n\nlet colourInt: colour = RGB(1, 2, 3);\nlet result = match(colourInt) {\n  when(Gray(val)): do {\n    const a = 5n;\n    const b = 6n;\n    return a + b + abs(val);\n  };\n  when(RGB(a, b, c)): do {\n    return abs(a + b + c);\n  }\n  when(Default): do {\n    return 5n;\n  };\n}\n')),(0,r.kt)("p",null,"The equivalent match expression in LIGO v2 accepts only one parameter, a tuple that contains the values from the variant case:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=match_case_tuple",group:"match_case_tuple"},'type colour =\n  ["RGB", [int, int, int]] | ["Gray", int] | ["Default"];\n\nlet colourInt: colour = ["RGB" as "RGB", 1, 2, 3];\nlet result =\n  $match(colourInt, {\n    "Gray": (val) =>\n      (() =>\n      {\n        const a = (5 as nat);\n        const b = (6 as nat);\n        return a + b + abs(val);\n      })(),\n    "RGB": ([a, b, c]) =>\n      (() =>\n      { return abs(a + b + c); })(),\n    "Default": () =>\n      (() =>\n      { return (5 as nat); })(),\n  })\n')),(0,r.kt)("h2",{id:"imports"},"Imports"),(0,r.kt)("p",null,"JsLIGO now uses a syntax closer to JavaScript/TypeScript to import definitions.\nIt supports three syntaxes for importing definitions from other files and namespaces:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"import M = M.O")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},'import * as M from "./targetFile.jsligo"')),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},'import {x, y} from "./targetFile.jsligo"'))),(0,r.kt)("p",null,"In most cases, to import definitions from other files, use the syntax ",(0,r.kt)("inlineCode",{parentName:"p"},'import * as M from "./targetFile.jsligo"')," to import everything in a file and then create local definitions from that imported file."),(0,r.kt)("p",null,"For example, assume that this file is ",(0,r.kt)("inlineCode",{parentName:"p"},"myFunctions.jsligo"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=myFunctions",group:"myFunctions"},"export namespace MyFunctions {\n  export const addToImport = (a: int, b: int): int => a + b;\n  export const subToImport = (a: int, b: int): int => a - b;\n}\n")),(0,r.kt)("p",null,"You can import the file and access the namespace like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=useMyFunctions",group:"useMyFunctions"},"import * as MyFileWithFunctions from './gitlab-pages/docs/intro/src/upgrade-v2/myFunctions.jsligo';\nconst addToImport = MyFileWithFunctions.MyFunctions.addToImport;\nconst subToImport = MyFileWithFunctions.MyFunctions.subToImport;\n\nnamespace Counter {\n  type storage_type = int;\n  type return_type = [list<operation>, storage_type];\n\n  // @entry\n  const add = (value: int, storage: storage_type): return_type =>\n    [[], addToImport(storage, value)];\n\n  // @entry\n  const sub = (value: int, storage: storage_type): return_type =>\n    [[], subToImport(storage, value)];\n\n}\n")),(0,r.kt)("p",null,"If variables or functions are defined at the top level of the file, you can import them directly with the syntax ",(0,r.kt)("inlineCode",{parentName:"p"},'import {x, y} from "./targetFile.jsligo"'),".\nYou cannot import types, classes, or namespaces with this syntax."),(0,r.kt)("p",null,"For example, assume that this file is ",(0,r.kt)("inlineCode",{parentName:"p"},"topLevelDefinitions.jsligo"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=topLevelDefinitions",group:"topLevelDefinitions"},"export const addToImport = (a: int, b: int): int => a + b;\nexport const subToImport = (a: int, b: int): int => a - b;\nexport const myConstant = 5 as int;\n")),(0,r.kt)("p",null,"You can import and use those definitions as in this example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=useTopLevelDefinitions",group:"useTopLevelDefinitions"},'import { addToImport, subToImport, myConstant } from "./gitlab-pages/docs/intro/src/upgrade-v2/topLevelDefinitions.jsligo";\n\ntype storage_type = int;\ntype return_type = [list<operation>, storage_type];\n\nclass Calculator {\n\n  @entry\n  add = (value: int, storage: storage_type): return_type =>\n    [[], addToImport(storage, value)];\n\n  @entry\n  sub = (value: int, storage: storage_type): return_type =>\n    [[], subToImport(storage, value)];\n\n  @entry\n  increment = (_: unit, storage: storage_type): return_type =>\n    [[], addToImport(storage, myConstant)];\n\n}\n')),(0,r.kt)("p",null,"You cannot import types as in this TypeScript syntax:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},'// Not allowed\nimport { type x } from "./myTypes.jsligo";\n')),(0,r.kt)("p",null,"Instead, import the file and bind a type locally.\nFor example, assume that this file is ",(0,r.kt)("inlineCode",{parentName:"p"},"myTypes.jsligo"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=myTypes",group:"myTypes"},"export type storage_type = int;\nexport type return_type = [list<operation>, storage_type];\n")),(0,r.kt)("p",null,"This file imports those types and uses them:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=use_myTypes",group:"use_myTypes"},'import * as myTypes from "./gitlab-pages/docs/intro/src/upgrade-v2/myTypes.jsligo";\ntype storage_type = myTypes.storage_type;\ntype return_type = myTypes.return_type;\n\nclass Counter {\n  @entry\n  add = (value: int, storage: storage_type): return_type =>\n    [[], storage + value];\n\n  @entry\n  sub = (value: int, storage: storage_type): return_type =>\n    [[], storage - value];\n}\n')),(0,r.kt)("h2",{id:"preprocessor-directives"},"Preprocessor directives"),(0,r.kt)("p",null,"Preprocessor directives are no longer used in JsLIGO version 2.0.\nHere are some ways to update code that uses preprocessor directives:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Instead of using the ",(0,r.kt)("inlineCode",{parentName:"p"},"#include")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"#import")," directives, import namespaces in other files directly with the ",(0,r.kt)("inlineCode",{parentName:"p"},"import")," keyword as described previously.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"#if"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"#else"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"#elif"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"#endif"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"#define"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"#undef"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"#error")," directives are no longer supported.\nIf you need to continue using them, you can run your JsLIGO code through a C++ preprocessor, which uses the same syntax.\nJsLIGO code with these directives does not compile."))),(0,r.kt)("h2",{id:"the-switch-statement"},"The ",(0,r.kt)("inlineCode",{parentName:"h2"},"switch")," statement"),(0,r.kt)("p",null,"Blocks that use the ",(0,r.kt)("inlineCode",{parentName:"p"},"switch")," statement must have at least one case.\nAlso, ",(0,r.kt)("inlineCode",{parentName:"p"},"switch")," blocks can have only one default case."),(0,r.kt)("h2",{id:"do-expressions"},(0,r.kt)("inlineCode",{parentName:"h2"},"do")," expressions"),(0,r.kt)("p",null,"Instead of the expression ",(0,r.kt)("inlineCode",{parentName:"p"},"do { ... }"),", use an IIFE in the format ",(0,r.kt)("inlineCode",{parentName:"p"},"(() => {})()"),".\nIIFEs are often used to run tests, as in this example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},'const test = (() => {\n\n  const contract = Test.Originate.contract(contract_of(Counter), 0, 0 as tez);\n  Test.Contract.transfer_exn(Test.Typed_address.get_entrypoint("add", contract.taddr), 5, 0 as tez);\n  Test.Contract.transfer_exn(Test.Typed_address.get_entrypoint("sub", contract.taddr), 2, 0 as tez);\n  Assert.assert(Test.Typed_address.get_storage(contract.taddr) == 3);\n\n})();\n')),(0,r.kt)("h2",{id:"escaping-keywords"},"Escaping keywords"),(0,r.kt)("p",null,"Escaping keywords is no longer supported; keywords cannot be used as variable names or object fields, even if you prefix the names with the ",(0,r.kt)("inlineCode",{parentName:"p"},"@")," symbol.\nFor example, you can add an underscore as a suffix, creating variables with names such as ",(0,r.kt)("inlineCode",{parentName:"p"},"return_")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"entry_"),"."),(0,r.kt)("h2",{id:"decorators"},"Decorators"),(0,r.kt)("p",null,"Decorators such as ",(0,r.kt)("inlineCode",{parentName:"p"},"@entry")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"@view")," must now be in a comment immediately before the definition that they modify except when they are in classes, as described above."),(0,r.kt)("h2",{id:"commands"},"Commands"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"ligo run dry-run")," command accepts a different format for entrypoints and parameters.\nInstead of accepting the name of the entrypoint, it accepts the entrypoint and parameter as a value of a variant type with the name of the entrypoint.\nThe name of the entrypoint is always capitalized.\nFor example, this command calls an entrypoint named ",(0,r.kt)("inlineCode",{parentName:"p"},"add")," that accepts an integer as a parameter:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'ligo run dry-run counter.jsligo -m "Counter" \'["Add" as "Add", 1]\' 5\n'))))}u.isMDXComponent=!0}}]);