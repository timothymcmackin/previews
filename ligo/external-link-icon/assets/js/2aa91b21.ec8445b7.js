"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[31199],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>u});var a=t(67294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var s=a.createContext({}),c=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},d=function(e){var n=c(e.components);return a.createElement(s.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),m=c(t),u=o,h=m["".concat(s,".").concat(u)]||m[u]||p[u]||i;return t?a.createElement(h,r(r({ref:n},d),{},{components:t})):a.createElement(h,r({ref:n},d))}));function u(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var i=t.length,r=new Array(i);r[0]=m;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,r[1]=l;for(var c=2;c<i;c++)r[c]=t[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},48720:(e,n,t)=>{t.d(n,{D:()=>o.Z,Z:()=>i});var a=t(67294),o=t(75402);const i=function(e){return a.createElement(o.Z.Consumer,null,(n=>{let{syntax:t}=n;return t===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},48175:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>d});var a=t(87462),o=(t(67294),t(3905)),i=t(48720);const r={id:"embedded-michelson",title:"Embedded Michelson"},l=void 0,s={unversionedId:"advanced/embedded-michelson",id:"version-1.6.0/advanced/embedded-michelson",title:"Embedded Michelson",description:"If you have an existing piece of Michelson code that you want to use",source:"@site/versioned_docs/version-1.6.0/advanced/code-injection.md",sourceDirName:"advanced",slug:"/advanced/embedded-michelson",permalink:"/previews/ligo/external-link-icon/docs/1.6.0/advanced/embedded-michelson",draft:!1,tags:[],version:"1.6.0",frontMatter:{id:"embedded-michelson",title:"Embedded Michelson"}},c={},d=[{value:"Embedding Code",id:"embedding-code",level:2},{value:"Compiling Embedded Code",id:"compiling-embedded-code",level:2}],p={toc:d};function m(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"If you have an existing piece of Michelson code that you want to use\nas-is, LIGO provides the ability to embed Michelson code. This feature\ncan be useful when you need to have a deep level of control over the\ngenerated code, for example for optimisation, or if you need to use a\nfeature from Michelson that is not yet supported by high-level\nconstructions in LIGO."),(0,o.kt)("h2",{id:"embedding-code"},"Embedding Code"),(0,o.kt)("p",null,"The syntax for embedding Michelson is by means of the ",(0,o.kt)("inlineCode",{parentName:"p"},"[%Michelson\n...]")," construction. The ellipsis is meant to denote an annotated\nstring literal containing the Michelson code to be injected in the\ngenerated Michelson and the type (as a function) of the Michelson\ncode."),(0,o.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo"},"let michelson_add n =\n  [%Michelson ({| { UNPAIR ; ADD } |} : nat * nat -> nat)] n\n"))),(0,o.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo"},"const michelson_add = n =>\n  (Michelson `{ UNPAIR ; ADD }` as ((n: [nat, nat]) => nat))(n);\n"))),(0,o.kt)("p",null,"Note that the type annotation is required, because the embedded Michelson code\nis not type checked by LIGO. This assumes that the given type is correct."),(0,o.kt)("p",null,"In the example above, the notation ",(0,o.kt)("inlineCode",{parentName:"p"},"{| ... |}")," is used to\nrepresent a verbatim string literal, that is, an uninterpreted string,\nwhich here contains a piece of Michelson code. The type annotation\ndescribes the behaviour of the Michelson code:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"It starts working on a stack consisting of a tuple of ",(0,o.kt)("inlineCode",{parentName:"p"},"nat"),"s: ",(0,o.kt)("inlineCode",{parentName:"p"},"[ nat * nat ]"),".")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The tuple is destructured using ",(0,o.kt)("inlineCode",{parentName:"p"},"UNPAIR"),": ",(0,o.kt)("inlineCode",{parentName:"p"},"[ nat ] [ nat ]"),".")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The two top values of the stack are added using ",(0,o.kt)("inlineCode",{parentName:"p"},"ADD"),",\nand stops working on a stack consisting of a single ",(0,o.kt)("inlineCode",{parentName:"p"},"nat"),": ",(0,o.kt)("inlineCode",{parentName:"p"},"[ nat ]"),"."))),(0,o.kt)("p",null,"The compiler will prevent changes to the embedded Michelson code if\nthe function resulting from the embedded code is not applied. For\nexample, let's see what happens when we compile an embedded Michelson\nexpression that pushes some value on the stack, then drops it\nimmediately, and then continues as a regular increment function."),(0,o.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},'ligo compile expression cameligo "[%Michelson ({| { PUSH nat 42; DROP ; PUSH nat 1; ADD } |} : nat -> nat)]"\n# Outputs:\n# { PUSH nat 42 ; DROP ; PUSH nat 1 ; ADD }\n'))),(0,o.kt)("p",null,"As we can see, the embedded Michelson code was not modified. However,\nif the resulting function is applied, then the embedded Michelson code\ncould be modified/optimised by the compiler. To exemplify this\nbehaviour, an application can be introduced in the example above by\neta-expanding. In this case, the first two instructions will be\nremoved by LIGO because they have no effect on the final result."),(0,o.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},'ligo compile expression cameligo "fun n -> [%Michelson ({| { PUSH nat 42; DROP ; PUSH nat 1; ADD } |} : nat -> nat)] n"\n# Outputs:\n# { PUSH nat 1 ; ADD }\n'))),(0,o.kt)("h2",{id:"compiling-embedded-code"},"Compiling Embedded Code"),(0,o.kt)("p",null,"Contracts with embedded Michelson code are compiled normally like any\nother contract. We give an example of a contract that uses the type\n",(0,o.kt)("inlineCode",{parentName:"p"},"never"),", a new Michelson type that represents the empty type. You can\nread more about it\n",(0,o.kt)("a",{parentName:"p",href:"https://tezos.gitlab.io/michelson-reference/#type-never"},"here"),"."),(0,o.kt)("p",null,"We will use the Michelson instruction ",(0,o.kt)("inlineCode",{parentName:"p"},"NEVER")," to resolve a forbidden\nbranch when matching on the parameter of our contract:"),(0,o.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=never",group:"never"},"type parameter =\n  Increment of int\n| Extend of never\n\ntype storage = int\n\n[@entry]\nlet main (action : parameter) (store : storage) : operation list * storage =\n  [],\n  (match action with\n     Increment n -> store + n\n   | Extend k    -> [%Michelson ({| { NEVER } |} : never -> int)] k)\n"))),(0,o.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},'type parameter =\n  ["Increment", int]\n| ["Extend", never];\n\ntype storage = int;\n\n@entry\nfunction main (action: parameter, store: storage) : [list<operation>, storage] {\n  let storage =\n    match(action, {\n      Increment: n => store + n,\n      Extend: k => (Michelson`{ NEVER }` as ((n: never) => int))(k)\n    });\n  return [[], storage];\n};\n'))),(0,o.kt)("p",null,"Assuming we have saved those contents in a file with name ",(0,o.kt)("inlineCode",{parentName:"p"},"never"),", we\ncan compile it using the following command:"),(0,o.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"ligo compile contract --protocol nairobi --disable-michelson-typechecking gitlab-pages/docs/advanced/src/code-injection/never.mligo\n"))),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"\u26a0\ufe0f Just for reference, there is support now for generating the\ninstruction ",(0,o.kt)("inlineCode",{parentName:"p"},"NEVER")," directly from LIGO, using ",(0,o.kt)("inlineCode",{parentName:"p"},"Tezos.never"),".")))}m.isMDXComponent=!0}}]);