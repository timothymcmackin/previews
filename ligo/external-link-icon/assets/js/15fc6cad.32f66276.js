"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1783],{3905:(t,n,e)=>{e.d(n,{Zo:()=>p,kt:()=>m});var a=e(67294);function r(t,n,e){return n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}function i(t,n){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(t,n).enumerable}))),e.push.apply(e,a)}return e}function o(t){for(var n=1;n<arguments.length;n++){var e=null!=arguments[n]?arguments[n]:{};n%2?i(Object(e),!0).forEach((function(n){r(t,n,e[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):i(Object(e)).forEach((function(n){Object.defineProperty(t,n,Object.getOwnPropertyDescriptor(e,n))}))}return t}function s(t,n){if(null==t)return{};var e,a,r=function(t,n){if(null==t)return{};var e,a,r={},i=Object.keys(t);for(a=0;a<i.length;a++)e=i[a],n.indexOf(e)>=0||(r[e]=t[e]);return r}(t,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);for(a=0;a<i.length;a++)e=i[a],n.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(t,e)&&(r[e]=t[e])}return r}var c=a.createContext({}),y=function(t){var n=a.useContext(c),e=n;return t&&(e="function"==typeof t?t(n):o(o({},n),t)),e},p=function(t){var n=y(t.components);return a.createElement(c.Provider,{value:n},t.children)},l={inlineCode:"code",wrapper:function(t){var n=t.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(t,n){var e=t.components,r=t.mdxType,i=t.originalType,c=t.parentName,p=s(t,["components","mdxType","originalType","parentName"]),d=y(e),m=r,u=d["".concat(c,".").concat(m)]||d[m]||l[m]||i;return e?a.createElement(u,o(o({ref:n},p),{},{components:e})):a.createElement(u,o({ref:n},p))}));function m(t,n){var e=arguments,r=n&&n.mdxType;if("string"==typeof t||r){var i=e.length,o=new Array(i);o[0]=d;var s={};for(var c in n)hasOwnProperty.call(n,c)&&(s[c]=n[c]);s.originalType=t,s.mdxType="string"==typeof t?t:r,o[1]=s;for(var y=2;y<i;y++)o[y]=e[y];return a.createElement.apply(null,o)}return a.createElement.apply(null,e)}d.displayName="MDXCreateElement"},48720:(t,n,e)=>{e.d(n,{D:()=>r.Z,Z:()=>i});var a=e(67294),r=e(75402);const i=function(t){return a.createElement(r.Z.Consumer,null,(n=>{let{syntax:e}=n;return e===t.syntax?t.children:a.createElement(a.Fragment,null)}))}},98208:(t,n,e)=>{e.r(n),e.d(n,{assets:()=>y,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>c,toc:()=>p});var a=e(87462),r=(e(67294),e(3905)),i=e(48720);const o={id:"dynamic-entrypoints",title:"Dynamic entrypoints"},s=void 0,c={unversionedId:"syntax/contracts/dynamic-entrypoints",id:"syntax/contracts/dynamic-entrypoints",title:"Dynamic entrypoints",description:"Dynamic entrypoints are lambda functions stored in a contract within a big_map.",source:"@site/../docs/syntax/contracts/dynamic-entrypoints.md",sourceDirName:"syntax/contracts",slug:"/syntax/contracts/dynamic-entrypoints",permalink:"/previews/ligo/external-link-icon/docs/next/syntax/contracts/dynamic-entrypoints",draft:!1,tags:[],version:"current",frontMatter:{id:"dynamic-entrypoints",title:"Dynamic entrypoints"},sidebar:"docs",previous:{title:"Views",permalink:"/previews/ligo/external-link-icon/docs/next/syntax/contracts/views"},next:{title:"Interoperability",permalink:"/previews/ligo/external-link-icon/docs/next/syntax/contracts/interop"}},y={},p=[{value:"Storage",id:"storage",level:2},{value:"Defining dynamic entrypoints",id:"defining-dynamic-entrypoints",level:2},{value:"Calling dynamic entrypoints",id:"calling-dynamic-entrypoints",level:2},{value:"Updating dynamic entrypoints",id:"updating-dynamic-entrypoints",level:2},{value:"Opted out dynamic entrypoints",id:"opted-out-dynamic-entrypoints",level:2},{value:"Compiling dynamic entrypoints",id:"compiling-dynamic-entrypoints",level:2},{value:"Testing dynamic entrypoints",id:"testing-dynamic-entrypoints",level:2}],l={toc:p};function d(t){let{components:n,...e}=t;return(0,r.kt)("wrapper",(0,a.Z)({},l,e,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Dynamic entrypoints are lambda functions stored in a contract within a big_map.\nA contract can update its dynamic entrypoints without deploying a new contract.\nIn this way, contracts can use dynamic entrypoints to change their internal logic."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Only the contract itself can call its dynamic entrypoints, not clients or other contracts.\nIf you want a client or other contract to be able to call a dynamic entrypoint, you can create an ordinary non-dynamic entrypoint as a wrapper for the dynamic entrypoint.")),(0,r.kt)("p",null,"A contract with dynamic entrypoints must have at least one non-dynamic entrypoint with the ",(0,r.kt)("inlineCode",{parentName:"p"},"@entry")," declaration, like any other contract.\nThey must also obey the following convention on storage type definition and have at least one function with the ",(0,r.kt)("inlineCode",{parentName:"p"},"@dyn_entry")," declaration."),(0,r.kt)("h2",{id:"storage"},"Storage"),(0,r.kt)("p",null,"To contain dynamic entrypoints, the contract storage must be a record with two fields:"),(0,r.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"storage"),": The contract's storage, just like in an ordinary contract"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"dynamic_entrypoints"),": The code of the dynamic entrypoints, which must be of the type ",(0,r.kt)("inlineCode",{parentName:"li"},"(nat,bytes) big_map")))),(0,r.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"storage"),": The contract's storage, just like in an ordinary contract"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"dynamic_entrypoints"),": The code of the dynamic entrypoints, which must be of the type ",(0,r.kt)("inlineCode",{parentName:"li"},"big_map<nat, bytes>")))),(0,r.kt)("p",null,"For convenience, the type of the ",(0,r.kt)("inlineCode",{parentName:"p"},"dynamic_entrypoints")," storage field is defined as ",(0,r.kt)("inlineCode",{parentName:"p"},"Dynamic_entrypoints.t")," in the standard library."),(0,r.kt)("p",null,"The LIGO compiler can generate the initial value of the storage for you; see ",(0,r.kt)("a",{parentName:"p",href:"#compiling-dynamic-entrypoints"},"Compiling dynamic entrypoints"),"."),(0,r.kt)("h2",{id:"defining-dynamic-entrypoints"},"Defining dynamic entrypoints"),(0,r.kt)("p",null,"To set the dynamic entrypoints that the contract has at origination time, define functions at the top level of the contract just like ordinary entrypoints but with these differences:"),(0,r.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"They have the ",(0,r.kt)("inlineCode",{parentName:"li"},"@dyn_entry")," attribute instead of the ",(0,r.kt)("inlineCode",{parentName:"li"},"@entry")," attribute"),(0,r.kt)("li",{parentName:"ul"},"Their storage and return types are different, as explained next"))),(0,r.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"They have the ",(0,r.kt)("inlineCode",{parentName:"li"},"@dyn_entry")," decorator instead of the ",(0,r.kt)("inlineCode",{parentName:"li"},"@entry")," decorator"),(0,r.kt)("li",{parentName:"ul"},"They must be exported with the ",(0,r.kt)("inlineCode",{parentName:"li"},"export")," keyword"),(0,r.kt)("li",{parentName:"ul"},"Their storage and return types are different, as explained next"))),(0,r.kt)("p",null,"Ordinary entrypoints in the contract receive a parameter and the value of the contract storage as usual, which, as described in ",(0,r.kt)("a",{parentName:"p",href:"#storage"},"Storage"),", is always a record with a ",(0,r.kt)("inlineCode",{parentName:"p"},"storage")," field and a ",(0,r.kt)("inlineCode",{parentName:"p"},"dynamic_entrypoints")," field.\nAlso as usual, the ordinary entrypoints return a tuple with a list of operations and the new value of the storage, including both of these fields."),(0,r.kt)("p",null,"By contrast, dynamic entrypoints receive a parameter and the ",(0,r.kt)("inlineCode",{parentName:"p"},"storage")," field of the contract storage, not the ",(0,r.kt)("inlineCode",{parentName:"p"},"dynamic_entrypoints")," field.\nSimilarly, they return a tuple with a list of operations and the new value of that ",(0,r.kt)("inlineCode",{parentName:"p"},"storage")," field."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Smart contracts cannot add dynamic entrypoints after the contract is originated.\nTherefore, you must define all dynamic entrypoints in the contract source code.")),(0,r.kt)("p",null,"For example, this contract stores an integer but none of its ordinary entrypoints change it directly.\nInstead, it contains dynamic entrypoints that manipulate it:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"double")," dynamic entrypoint doubles the value in storage"),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"square")," dynamic entrypoint squares the value in storage"),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"currentAction")," dynamic entrypoint initially does nothing")),(0,r.kt)("p",null,"The contract has two ordinary entrypoints that manipulate the dynamic entrypoints:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"runAction")," entrypoint runs the ",(0,r.kt)("inlineCode",{parentName:"li"},"currentAction")," dynamic entrypoint and updates the contract storage based on its result"),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"changeAction")," entrypoint changes the ",(0,r.kt)("inlineCode",{parentName:"li"},"currentAction")," dynamic entrypoint to be a copy of either the ",(0,r.kt)("inlineCode",{parentName:"li"},"double")," or the ",(0,r.kt)("inlineCode",{parentName:"li"},"square")," entrypoint")),(0,r.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=simple_dynamic",group:"simple_dynamic"},'module DynamicContract = struct\n  type internal_storage = int\n  type storage_type = {\n    storage : internal_storage;\n    dynamic_entrypoints : Dynamic_entrypoints.t; // big_map<nat, bytes>\n  }\n  type return_type = operation list * storage_type\n  type dyn_return_type = operation list * internal_storage\n\n  // Dynamic entrypoint: double the integer in storage\n  [@dyn_entry]\n  let double (() : unit) (s : internal_storage) : dyn_return_type = [], s + s\n\n  // Dynamic entrypoint: square the integer in storage\n  [@dyn_entry]\n  let square (() : unit) (s : internal_storage) : dyn_return_type = [], s * s\n\n  // Initially, this dynamic entrypoint does nothing\n  // But the changeAction entrypoint sets it to a different dynamic entrypoint\n  [@dyn_entry]\n  let currentAction (() : unit) (s : internal_storage) : dyn_return_type = [], s\n\n  // Run the currentAction entrypoint\n  [@entry]\n  let runAction (() : unit) (full_storage : storage_type) : return_type =\n    let {storage; dynamic_entrypoints} = full_storage in\n\n    match (Dynamic_entrypoints.get currentAction dynamic_entrypoints) with\n      Some f ->\n        let (operations, newStorage) = f unit storage in\n        operations, {\n          storage = newStorage;\n          dynamic_entrypoints = dynamic_entrypoints\n        }\n      | None -> failwith "Error"\n\n  // Change the currentAction entrypoint to double or square\n  [@entry]\n  let changeAction (new_action_str : string) (full_storage : storage_type) : return_type =\n    let {storage; dynamic_entrypoints} = full_storage in\n\n    let new_dynamic_entrypoints : Dynamic_entrypoints.t =\n      if (new_action_str = "double")\n      then let new_action = match (Dynamic_entrypoints.get double dynamic_entrypoints) with\n        | Some f -> f\n        | None -> failwith "Error" in\n        Dynamic_entrypoints.set currentAction (Some new_action) dynamic_entrypoints\n      else let new_action = match (Dynamic_entrypoints.get square dynamic_entrypoints) with\n        | Some f -> f\n        | None -> failwith "Error" in\n        Dynamic_entrypoints.set currentAction (Some new_action) dynamic_entrypoints in\n\n    [], {\n      storage = storage;\n      dynamic_entrypoints = new_dynamic_entrypoints\n    }\n\nend\n'))),(0,r.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=simple_dynamic",group:"simple_dynamic"},'namespace DynamicContract {\n  type internal_storage = int;\n  type storage_type = {\n    storage: internal_storage;\n    dynamic_entrypoints: Dynamic_entrypoints.t; // map<nat, bytes>;\n  };\n  type return_type = [list<operation>, storage_type];\n  type dyn_return_type = [list<operation>, internal_storage];\n\n  // Dynamic entrypoint: double the integer in storage\n  @dyn_entry\n  export const double = (_u: unit, s: internal_storage): dyn_return_type => [[], s + s];\n\n  // Dynamic entrypoint: square the integer in storage\n  @dyn_entry\n  export const square = (_u: unit, s: internal_storage): dyn_return_type => [[], s * s];\n\n  // Initially, this dynamic entrypoint does nothing\n  // But the changeAction entrypoint sets it to a different dynamic entrypoint\n  @dyn_entry\n  export const currentAction = (_u: unit, s: internal_storage): dyn_return_type => [[], s];\n\n  // Run the currentAction entrypoint\n  // @entry\n  const runAction = (_u: unit, full_storage: storage_type): return_type => {\n    const {storage, dynamic_entrypoints} = full_storage;\n\n    return $match (Dynamic_entrypoints.get(currentAction, dynamic_entrypoints), {\n      "Some": f => (() => {\n        const [operations, newStorage] = f(unit, storage);\n        return [operations, ({\n          storage: newStorage,\n          dynamic_entrypoints: dynamic_entrypoints\n        })];\n      })(),\n      "None": () => failwith(-1)\n    })\n  }\n\n  // Change the currentAction entrypoint to double or square\n  // @entry\n  const changeAction = (new_action_str: string, full_storage: storage_type): return_type => {\n    const {storage, dynamic_entrypoints} = full_storage;\n\n    let new_dynamic_entrypoints = dynamic_entrypoints;\n\n    if (new_action_str == "double") {\n      const new_action =\n        $match(Dynamic_entrypoints.get(double, dynamic_entrypoints), {\n          "Some": f => f,\n          "None": () => failwith(-1)\n        });\n      new_dynamic_entrypoints =\n        Dynamic_entrypoints.set(currentAction,\n                                ["Some" as "Some", new_action],\n                                dynamic_entrypoints);\n    }\n\n    if (new_action_str == "square") {\n      const new_action =\n        $match(Dynamic_entrypoints.get(square, dynamic_entrypoints), {\n          "Some": f => f,\n          "None": () => failwith(-1)\n      });\n      new_dynamic_entrypoints =\n        Dynamic_entrypoints.set(currentAction,\n                                ["Some" as "Some", new_action],\n                                dynamic_entrypoints);\n    }\n\n    return [[], {\n      storage: storage,\n      dynamic_entrypoints: new_dynamic_entrypoints,\n    }];\n  }\n}\n'))),(0,r.kt)("h2",{id:"calling-dynamic-entrypoints"},"Calling dynamic entrypoints"),(0,r.kt)("p",null,"To call a dynamic entrypoint, use the function ",(0,r.kt)("inlineCode",{parentName:"p"},"Dynamic_entrypoints.get")," to retrieve a dynamic entrypoint by name.\nThe function returns an option that contains a function that you can call like any other function."),(0,r.kt)("p",null,"This section from an earlier example attempts to retrieve the dynamic entrypoint named ",(0,r.kt)("inlineCode",{parentName:"p"},"currentAction")," and runs it if it is found:"),(0,r.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},'match (Dynamic_entrypoints.get currentAction dynamic_entrypoints) with\n  Some f ->\n    let (operations, newStorage) = f unit storage in\n    operations, {\n      storage = newStorage;\n      dynamic_entrypoints = dynamic_entrypoints\n    }\n  | None -> failwith "Error"\n'))),(0,r.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},'return $match (Dynamic_entrypoints.get(currentAction, dynamic_entrypoints), {\n  "Some": f => (() => {\n    const [operations, newStorage] = f(unit, storage);\n    return [operations, ({\n      storage: newStorage,\n      dynamic_entrypoints: dynamic_entrypoints\n    })];\n  })(),\n  "None": () => failwith("Error")\n})\n'))),(0,r.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("p",null,"Contracts cannot call dynamic entrypoints directly because they are stored as typed keys in the ",(0,r.kt)("inlineCode",{parentName:"p"},"dynamic_entrypoints")," big map, not as functions.\nLIGO uses an abstract type ",(0,r.kt)("inlineCode",{parentName:"p"},"('a,'b) dynamic_entrypoint")," to denote such keys.")),(0,r.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("p",null,"Contracts cannot call dynamic entrypoints directly because they are stored as typed keys in the ",(0,r.kt)("inlineCode",{parentName:"p"},"dynamic_entrypoints")," big map, not as functions.\nLIGO uses an abstract type ",(0,r.kt)("inlineCode",{parentName:"p"},"dynamic_entrypoint<a, b>")," to denote such keys.")),(0,r.kt)("h2",{id:"updating-dynamic-entrypoints"},"Updating dynamic entrypoints"),(0,r.kt)("p",null,"After the contract is deployed, it can update its dynamic entrypoints by rewriting the ",(0,r.kt)("inlineCode",{parentName:"p"},"dynamic_entrypoints")," field in its storage."),(0,r.kt)("p",null,"You can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"Dynamic_entrypoints.set")," function to get the updated value of this field by passing the current value, the name of a dynamic entrypoint to update, and the code of that dynamic entrypoint.\nThis function does not directly update the contract storage; you must use its return value as the new value of the ",(0,r.kt)("inlineCode",{parentName:"p"},"dynamic_entrypoints")," field in the entrypoint return value."),(0,r.kt)("p",null,"This section from an earlier example changes the entrypoint named ",(0,r.kt)("inlineCode",{parentName:"p"},"currentAction")," to the code of the entrypoint named ",(0,r.kt)("inlineCode",{parentName:"p"},"square"),":"),(0,r.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},'if (new_action_str = "square")\nthen let new_action = match (Dynamic_entrypoints.get square dynamic_entrypoints) with\n  | Some f -> f\n  | None -> failwith "Error" in\n  Dynamic_entrypoints.set currentAction (Some new_action) dynamic_entrypoints in\n\n[], {\n  storage = storage;\n  dynamic_entrypoints = new_dynamic_entrypoints\n}\n'))),(0,r.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},'if (new_action_str == "square") {\n  const new_action =\n    $match (Dynamic_entrypoints.get(square, dynamic_entrypoints), {\n      "Some": f => f,\n      "None": () => failwith("Error")\n    });\n  new_dynamic_entrypoints =\n    Dynamic_entrypoints.set(currentAction,\n                            ["Some" as "Some", new_action],\n                            dynamic_entrypoints);\n}\n\nreturn [[], {\n  storage: storage,\n  dynamic_entrypoints: new_dynamic_entrypoints,\n}];\n'))),(0,r.kt)("p",null,"You can also set a dynamic entrypoint to new code by passing bytecode to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Dynamic_entrypoints.set_bytes")," function.\nThis function does not verify that the bytecode is valid, only that it is a valid LIGO bytes data type.\nIf the encoding is wrong, any call to ",(0,r.kt)("inlineCode",{parentName:"p"},"Dynamic_entrypoints.get")," for the dynamic entrypoint fails."),(0,r.kt)("p",null,"For example, the dynamic entrypoint ",(0,r.kt)("inlineCode",{parentName:"p"},"double")," from an earlier example compiles to the bytecode ",(0,r.kt)("inlineCode",{parentName:"p"},"0x0502000000250320093100000019035b0765055f036d035b020000000a03210312053d036d034200000000"),".\nTo set a dynamic entrypoint to this bytecode, pass the name of the entrypoint and the bytecode to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Dynamic_entrypoints.set_bytes")," function, as in this example:"),(0,r.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},"[@entry]\nlet set_double_bytes (() : unit) (full_storage : storage_type) : return_type =\n  let {storage; dynamic_entrypoints} = full_storage in\n  let double_bytes : bytes = 0x0502000000250320093100000019035b0765055f036d035b020000000a03210312053d036d034200000000 in\n  let new_dynamic_entrypoints = Dynamic_entrypoints.set_bytes currentAction (Some double_bytes) dynamic_entrypoints in\n  [], {\n    storage = storage;\n    dynamic_entrypoints = new_dynamic_entrypoints\n  }\n"))),(0,r.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},'// @entry\nconst set_double_bytes = (_: unit, full_storage: storage_type): return_type => {\n  const {storage, dynamic_entrypoints} = full_storage;\n  const double_bytes = 0x0502000000250320093100000019035b0765055f036d035b020000000a03210312053d036d034200000000 as bytes;\n  const new_dynamic_entrypoints =\n    Dynamic_entrypoints.set_bytes(currentAction,\n                                  ["Some" as "Some", double_bytes],\n                                  dynamic_entrypoints);\n\n  return [[], {\n    storage: storage,\n    dynamic_entrypoints: new_dynamic_entrypoints,\n  }];\n}\n'))),(0,r.kt)("h2",{id:"opted-out-dynamic-entrypoints"},"Opted out dynamic entrypoints"),(0,r.kt)("p",null,"Because a contract cannot add dynamic entrypoints, you must define all dynamic entrypoints in the contract source code.\nIf you want to include a dynamic entrypoint in the contract but provide the code for it later, you can make the function a no-op (a function that does nothing) and change it later or you can use the special expression ",(0,r.kt)("inlineCode",{parentName:"p"},"OPT_OUT_ENTRY"),".\nThis expression makes the LIGO compiler include the entrypoint without any initial code.\nIf you call the entrypoint in a test before setting code for it, it behaves as a no-op.\nIf you call the entrypoint in a deployed contract before setting code for it, the operation fails."),(0,r.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},'[@dyn_entry]\nlet opt_out (_i : int) (_s : internal_storage) : dyn_return_type =\n  let _ = 1 in [%external ("OPT_OUT_ENTRY")]\n'))),(0,r.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},"// @dyn_entry\nconst opt_out = (_i: int, _s : internal_storage) : dyn_return_type =>\n  (External `OPT_OUT_ENTRY`)\n"))),(0,r.kt)("p",null,"When you run a test with an opted out dynamic entrypoint like this, the compiler prints the message ",(0,r.kt)("inlineCode",{parentName:"p"},"unsupported primitive OPT_OUT_ENTRY"),".\nYou can safely ignore this message."),(0,r.kt)("h2",{id:"compiling-dynamic-entrypoints"},"Compiling dynamic entrypoints"),(0,r.kt)("p",null,"When you compile the storage for a contract with dynamic entrypoints, you provide only the value of the ",(0,r.kt)("inlineCode",{parentName:"p"},"storage")," field, not the full value of the storage.\nThe compiler automatically compiles the dynamic entrypoints and provides the full value of the storage including the ",(0,r.kt)("inlineCode",{parentName:"p"},"dynamic_entrypoints")," field."),(0,r.kt)("p",null,"For example, to compile the example contract in ",(0,r.kt)("a",{parentName:"p",href:"#defining-dynamic-entrypoints"},"Defining dynamic entrypoints"),", pass only the value of the integer in storage, as in this example:"),(0,r.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"ligo compile storage -m DynamicContract gitlab-pages/docs/syntax/contracts/src/dynamic-entrypoints/simple_dynamic.mligo 42\n"))),(0,r.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"ligo compile storage -m DynamicContract gitlab-pages/docs/syntax/contracts/src/dynamic-entrypoints/simple_dynamic.jsligo 42\n"))),(0,r.kt)("p",null,"The response is the full value of the contract storage.\nYou can use this value as the initial storage when you originate the contract."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-michelson"},"(Pair 42\n      { Elt 0\n            0x0502000000250320093100000019035b0765055f036d035b020000000a03210312053d036d034200000000 ;\n        Elt 1\n            0x0502000000250320093100000019035b0765055f036d035b020000000a0321033a053d036d034200000000 })\n")),(0,r.kt)("h2",{id:"testing-dynamic-entrypoints"},"Testing dynamic entrypoints"),(0,r.kt)("p",null,"To simplify testing contracts with dynamic entrypoints, you can use\nthe function ",(0,r.kt)("inlineCode",{parentName:"p"},"Test.Dynamic_entrypoints.storage")," to generate the\ninitial storage.  Like the ",(0,r.kt)("inlineCode",{parentName:"p"},"ligo compile storage")," command, this\nfunction takes only the value of the ",(0,r.kt)("inlineCode",{parentName:"p"},"storage")," field in the contract\nstorage, not the full storage value."),(0,r.kt)("p",null,"It returns the full storage value with both the ",(0,r.kt)("inlineCode",{parentName:"p"},"storage")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"dynamic_entrypoints")," field.\nThen you can use this return value to originate the contract in the test."),(0,r.kt)("p",null,"After origination, testing a contract with dynamic entrypoints is the same as testing any other contract.\nYou cannot call the dynamic entrypoints directly in a test because this is the same behavior that the originated contract has."),(0,r.kt)("p",null,"For example, this is a test for the contract in ",(0,r.kt)("a",{parentName:"p",href:"#defining-dynamic-entrypoints"},"Defining dynamic entrypoints"),":"),(0,r.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=simple_dynamic",group:"simple_dynamic"},'let test_dyn =\n  // Generate storage with dynamic entrypoints\n  let initial_storage = Test.Dynamic_entrypoints.storage (contract_of DynamicContract) 3 in\n  let contract = Test.Originate.contract (contract_of DynamicContract) initial_storage 0mutez in\n  let storage_before = Test.Typed_address.get_storage contract.taddr in\n  let () = Assert.assert (Test.Compare.eq storage_before.storage 3) in\n\n  // At the start, the runAction dynamic entrypoint does nothing\n  let _ : nat = Test.Contract.transfer_exn (Test.Typed_address.get_entrypoint "runAction" contract.taddr) unit 0tez in\n  let storage = Test.Typed_address.get_storage contract.taddr in\n  // Verify that storage did not change\n  let () = Assert.assert (Test.Compare.eq storage storage_before) in\n\n  // Set current action to double\n  let _ : nat = Test.Contract.transfer_exn (Test.Typed_address.get_entrypoint "changeAction" contract.taddr) "double" 0tez in\n\n  // Double storage to 6\n  let _ : nat = Test.Contract.transfer_exn (Test.Typed_address.get_entrypoint "runAction" contract.taddr) unit 0tez in\n  let storage = Test.Typed_address.get_storage contract.taddr in\n  let () = Assert.assert (Test.Compare.eq storage.storage 6) in\n\n  // Double storage to 12\n  let _ : nat = Test.Contract.transfer_exn (Test.Typed_address.get_entrypoint "runAction" contract.taddr) unit 0tez in\n  let storage = Test.Typed_address.get_storage contract.taddr in\n  let () = Assert.assert (Test.Compare.eq storage.storage 12) in\n\n  // Switch to square\n  let _ : nat = Test.Contract.transfer_exn (Test.Typed_address.get_entrypoint "changeAction" contract.taddr) "square" 0tez in\n  let storage = Test.Typed_address.get_storage contract.taddr in\n  let () = Assert.assert (Test.Compare.eq storage.storage 12) in\n\n  // Square storage to 144\n  let _ : nat = Test.Contract.transfer_exn (Test.Typed_address.get_entrypoint "runAction" contract.taddr) unit 0tez in\n  let storage = Test.Typed_address.get_storage contract.taddr in\n  Assert.assert(Test.Compare.eq storage.storage 144)\n'))),(0,r.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=simple_dynamic",group:"simple_dynamic"},'const test_dyn = (() => {\n  // Generate storage with dynamic entrypoints\n  const initial_storage =\n    Test.Dynamic_entrypoints.storage(contract_of(DynamicContract), 3);\n  const contract =\n  Test.Originate.contract(contract_of(DynamicContract),\n                          initial_storage,\n                          0 as mutez);\n  const storage_before = Test.Typed_address.get_storage(contract.taddr);\n  Assert.assert(Test.Compare.eq(storage_before.storage, 3));\n\n  // At the start, the runAction dynamic entrypoint does nothing\n  Test.Contract.transfer_exn(Test.Typed_address.get_entrypoint("runAction",\n  contract.taddr), unit, 0 as tez);\n  let storage = Test.Typed_address.get_storage(contract.taddr);\n  // Verify that storage did not change\n  Assert.assert(Test.Compare.eq(storage, storage_before));\n\n  // Set current action to double\n  Test.Contract.transfer_exn(Test.Typed_address.get_entrypoint("changeAction",\n  contract.taddr), "double", 0 as tez);\n\n  // Double storage to 6\n  Test.Contract.transfer_exn(Test.Typed_address.get_entrypoint("runAction",\n  contract.taddr), unit, 0 as tez);\n  storage = Test.Typed_address.get_storage(contract.taddr);\n  Assert.assert(Test.Compare.eq(storage.storage, 6));\n\n  // Double storage to 12\n  Test.Contract.transfer_exn(Test.Typed_address.get_entrypoint("runAction",\n  contract.taddr), unit, 0 as tez);\n  storage = Test.Typed_address.get_storage(contract.taddr);\n  Assert.assert(Test.Compare.eq(storage.storage, 12));\n\n  // Switch to square\n  Test.Contract.transfer_exn(Test.Typed_address.get_entrypoint("changeAction",\n  contract.taddr), "square", 0 as tez);\n  storage = Test.Typed_address.get_storage(contract.taddr);\n  Assert.assert(Test.Compare.eq(storage.storage, 12));\n\n  // Square storage to 144\n  Test.Contract.transfer_exn(Test.Typed_address.get_entrypoint("runAction",\n  contract.taddr), unit, 0 as tez);\n  storage = Test.Typed_address.get_storage(contract.taddr);\n  Assert.assert(Test.Compare.eq(storage.storage, 144));\n})()\n'))))}d.isMDXComponent=!0}}]);