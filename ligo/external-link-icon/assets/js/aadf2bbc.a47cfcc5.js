"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[62129],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(n),m=r,g=u["".concat(l,".").concat(m)]||u[m]||d[m]||o;return n?a.createElement(g,i(i({ref:t},p),{},{components:n})):a.createElement(g,i({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},48720:(e,t,n)=>{n.d(t,{D:()=>r.Z,Z:()=>o});var a=n(67294),r=n(75402);const o=function(e){return a.createElement(r.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},25521:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var a=n(87462),r=(n(67294),n(3905)),o=n(48720);const i={title:"Records",jsligoTitle:"Objects"},s=void 0,l={unversionedId:"data-types/records",id:"data-types/records",title:"Records",description:"Records are a structured data type that can include one or more fields, each with a name and a type.",source:"@site/../docs/data-types/records.md",sourceDirName:"data-types",slug:"/data-types/records",permalink:"/previews/ligo/external-link-icon/docs/next/data-types/records",draft:!1,tags:[],version:"current",frontMatter:{title:"Records",jsligoTitle:"Objects"},sidebar:"docs",previous:{title:"Lists",permalink:"/previews/ligo/external-link-icon/docs/next/data-types/lists"},next:{title:"Sets",permalink:"/previews/ligo/external-link-icon/docs/next/data-types/sets"}},c={},p=[{value:"Accessing",id:"accessing",level:2},{value:"Assigning",id:"assigning",level:2},{value:"Nested updates",id:"nested-updates",level:3},{value:"Comparing",id:"comparing",level:2}],d={toc:p};function u(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("p",null,"Records are a structured data type that can include one or more fields, each with a name and a type.\nA record type can contain any number of different data types, as in this example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=records1",group:"records1"},"type user = {\n  id       : nat;\n  is_admin : bool;\n  name     : string\n}\n"))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("p",null,"As in JavaScript, objects (called ",(0,r.kt)("em",{parentName:"p"},"records")," in previous versions of JsLIGO), are a structured data type that can include one or more fields, each with a name and a type.\nA record type can contain any number of different data types, as in this example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=objects1",group:"objects1"},"type user = {\n  id       : nat,\n  is_admin : bool,\n  name     : string\n};\n"))),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("p",null,"To create a variable of a record type, specify the name and value of each field, as in this example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=records1",group:"records1"},'let alice : user = {\n  id       = 1n;\n  is_admin = true;\n  name     = "Alice"\n}\n'))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("p",null,"To create a variable of an object type, specify the name and value of each field, as in this example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=objects1",group:"objects1"},'const alice : user = {\n  id       : 1 as nat,\n  is_admin : true,\n  name     : "Alice"\n};\n')),(0,r.kt)("p",null,"You can also use a semicolon (",(0,r.kt)("inlineCode",{parentName:"p"},";"),") to separate the fields in a record instead of a comma.")),(0,r.kt)("h2",{id:"accessing"},"Accessing"),(0,r.kt)("p",null,"To get the value of a field, use a period (",(0,r.kt)("inlineCode",{parentName:"p"},"."),") as the selection operator, as in this example:"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=record_access",group:"record_access"},'type user = {\n  login : string;\n  name  : string\n}\n\ntype account = {\n  user     : user;\n  id       : int;\n  is_admin : bool\n}\n\nlet user : user = {login = "al"; name = "Alice"}\nlet alice : account = {user; id=5; is_admin = true}\nlet is_alice_admin : bool = alice.is_admin // = true\n'))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=object_access",group:"object_access"},'type user = {\n  login : string,\n  name  : string\n};\n\ntype account = {\n  user     : user,\n  id       : int,\n  is_admin : bool\n};\n\nconst user: user = {login: "al", name: "Alice"};\nconst alice: account = {user, id: 5, is_admin: true};\nconst is_alice_admin = alice.is_admin; // == true\nconst alice_name = alice.user.name; // == "Alice"\n')),(0,r.kt)("p",null,"Instead of using the field name and the selection operator, you can put the name of the field in square brackets, as in this example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=object_access",group:"object_access"},'const alice_id = alice["id"]; // 5\n')),(0,r.kt)("p",null,"Unlike in JavaScript, you cannot use the name of a variable in square brackets to specify which field to retrieve.")),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("p",null,"You can also access fields of a record using a destructuring syntax,\nknown as ",(0,r.kt)("em",{parentName:"p"},"pattern matching"),", which enables accessing multiple fields of\na record in parallel, like so:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=record_access",group:"record_access"},"let user_to_triple (a : account) =\n  let {user; id; is_admin} = a\n  in user, id, is_admin\n"))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("p",null,"You can also access fields of a record using the destructuring\nsyntax, known as ",(0,r.kt)("em",{parentName:"p"},"pattern matching"),", which allows accessing multiple\nfields of a record in parallel, like so:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=object_access",group:"object_access"},"function userToTuple (a: account) {\n  const {user, id, is_admin} = a;\n  return [user, id, is_admin];\n}\n"))),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("p",null,"If you do not use one or more of the fields in the record, assign them the special variable name ",(0,r.kt)("inlineCode",{parentName:"p"},"_")," to avoid triggering a warning about an unused variable, like so:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=record_access",group:"record_access"},"let get_id (a : account) =\n  let {user=_; id; is_admin=_} = a // To avoid a warning\n  in id\n"))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("p",null,"If you do not use one or more of the fields in the object, use the predefined function ",(0,r.kt)("inlineCode",{parentName:"p"},"ignore")," on them to avoid triggering a warning about an unused variable, like so:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=object_access",group:"object_access"},"function getId (a: account) {\n  let {user, id, is_admin} = a;\n  ignore([user, is_admin]); // To avoid a warning\n  return id;\n}\n"))),(0,r.kt)("h2",{id:"assigning"},"Assigning"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("p",null,"Given a record, it is a common design pattern to update only a small\nnumber of its fields. Instead of forcing the programmer to copy the\nremaining, unchanged fields, CameLIGO offers a way to update only the\nfields that are modified."),(0,r.kt)("p",null,"One way to understand the update of records is the ",(0,r.kt)("em",{parentName:"p"},"functional\nupdate"),". The idea is to have an ",(0,r.kt)("em",{parentName:"p"},"expression")," whose value is the\nupdated record."),(0,r.kt)("p",null,"Let us consider defining a function that translates three-dimensional\npoints on a plane."),(0,r.kt)("p",null,"The syntax for the functional updates of record in CameLIGO follows\nthat of OCaml:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=record_update",group:"record_update"},"type point = {x : int; y : int; z : int}\ntype vector = {dx : int; dy : int}\n\nlet origin : point = {x = 0; y = 0; z = 0}\n\nlet xy_translate (p, vec : point * vector) : point =\n  {p with x = p.x + vec.dx; y = p.y + vec.dy}\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"It is important to understand that ",(0,r.kt)("inlineCode",{parentName:"p"},"p")," has not been changed by the\nfunctional update: a nameless new version of it has been created and\nreturned."))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("p",null,"You can change the fields of an object that is declared as a variable, as in this example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=object_update",group:"object_update"},'function my_function () {\n  let my_object = {a: 1, b: 2};\n  my_object.a = 5;\n  my_object["b"] = 3;\n}\n')),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Unlike in JavaScript, you cannot change the fields of an object that is declared as a constant.")),(0,r.kt)("p",null,"Similarly, you cannot add fields to an object after you create it, regardless of whether it is declared as a constant or a variable.\nTo add fields, you can use a ",(0,r.kt)("em",{parentName:"p"},"functional update")," to create a new object that has all of the fields of one or more other objects with the updates that you want.\nAs in JavaScript, this type of update uses the ",(0,r.kt)("inlineCode",{parentName:"p"},"...")," operator, as in this example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=object_update",group:"object_update"},"type point = {x: int, y: int, z: int}\ntype vector = {dx: int, dy: int}\n\nconst origin: point = {x: 0, y: 0, z: 0};\n\nconst xy_translate = (p: point, vec: vector) =>\n  ({...p, x: p.x + vec.dx, y: p.y + vec.dy});\n")),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"In the previous example, the constant ",(0,r.kt)("inlineCode",{parentName:"p"},"p")," has not been changed by the functional update; a nameless new version of it has been created and returned."))),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("h3",{id:"nested-updates"},"Nested updates"),(0,r.kt)("p",null,"A unique feature of CameLIGO is the ability to perform nested updates\non records. For example, given the following record declarations:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=record_nested_update",group:"record_nested_update"},"type user = {\n  login : string;\n  name  : string\n}\n\ntype account = {\n  user     : user;\n  id       : int;\n  is_admin : bool\n}\n")),(0,r.kt)("p",null,"You can update the record ",(0,r.kt)("inlineCode",{parentName:"p"},"user")," nested inside ",(0,r.kt)("inlineCode",{parentName:"p"},"account")," with the\nfollowing code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=record_nested_update",group:"record_nested_update"},"let change_login (login : string) (account : account) : account =\n  {account with user.login = login}\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note: This is not possible in OCaml."))),(0,r.kt)("h2",{id:"comparing"},"Comparing"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("p",null,"Record types are comparable types, which means that their values can\nbe implicitly compared for equality. As a result, records can be used\nas keys in ",(0,r.kt)("a",{parentName:"p",href:"/previews/ligo/external-link-icon/docs/next/data-types/sets"},"sets")," and ",(0,r.kt)("a",{parentName:"p",href:"/previews/ligo/external-link-icon/docs/next/data-types/maps"},"maps"),". By default, the\nimplicit, total order over records is ",(0,r.kt)("strong",{parentName:"p"},"undefined and\nimplementation-dependent")," \u2014 ultimately, the order is determined by\nthe translated Michelson type."),(0,r.kt)("p",null,"When using the ",(0,r.kt)("inlineCode",{parentName:"p"},'[@layout "comb"]')," (or ",(0,r.kt)("inlineCode",{parentName:"p"},"[@layout:comb]"),") attribute,\nfields are translated in Michelson with their order as written in the\nsource code, and records are then ordered lexicographically (that is,\nwhen two fields of the same name have the same values, another field\nis compared, like ordering two English words according to the alphabet).")),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("p",null,"Object types are comparable types, which means that their values can\nbe implicitly compared for equality. As a result, objects can be used\nas keys in ",(0,r.kt)("a",{parentName:"p",href:"/previews/ligo/external-link-icon/docs/next/data-types/sets"},"sets")," and ",(0,r.kt)("a",{parentName:"p",href:"/previews/ligo/external-link-icon/docs/next/data-types/maps"},"maps"),". By default, the\nimplicit, total order over objects is ",(0,r.kt)("strong",{parentName:"p"},"undefined and\nimplementation-dependent")," \u2014 ultimately, the order is determined by\nthe translated Michelson type."),(0,r.kt)("p",null,"When using the ",(0,r.kt)("inlineCode",{parentName:"p"},'@layout("comb")')," decorator, fields are translated in\nMichelson with their order as written in the source code, and objects\nare then ordered lexicographically (that is, when two fields of the\nsame name have the same values, another field is compared,\nlike ordering two English words according to the alphabet).")))}u.isMDXComponent=!0}}]);