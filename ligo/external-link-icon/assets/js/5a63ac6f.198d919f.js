"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[82934],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=c(n),h=i,y=m["".concat(l,".").concat(h)]||m[h]||d[h]||o;return n?a.createElement(y,r(r({ref:t},p),{},{components:n})):a.createElement(y,r({ref:t},p))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var c=2;c<o;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},48720:(e,t,n)=>{n.d(t,{D:()=>i.Z,Z:()=>o});var a=n(67294),i=n(75402);const o=function(e){return a.createElement(i.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},99191:(e,t,n)=>{n.d(t,{Z:()=>p});var a=n(23746),i=n(67294),o=n(52263),r=n(48720),s=n(87552);function l(){return l=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},l.apply(this,arguments)}const{Prism:c}=n(23746);c.languages={...c.languages,cameligo:{...c.languages.ocaml,comment:[/(^|[^\\])\/\*[\s\S]*?\*\//,/\(\*[\s\S]*?\*\)/,/\/\/.*/]},jsligo:c.languages.typescript};const p=function(e){const{siteConfig:{themeConfig:{prism:t={}}}}=(0,o.Z)(),n=t.singleTheme||s.Z,[c,p]=(0,i.useState)(!1);return(0,i.useEffect)((()=>{p(!0)}),[]),i.createElement(r.D.Consumer,null,(t=>{let{syntax:o}=t;return o===e.syntax?i.createElement(a.default,l({},a.defaultProps,{key:c,language:e.syntax,code:e.children,theme:n}),(e=>{let{className:t,tokens:n,getLineProps:a,getTokenProps:o}=e;return i.createElement("h4",{className:t,style:{backgroundColor:"var(--ifm-background-color)",fontFamily:"var(--ifm-font-family-monospace)",lineHeight:"var(--ifm-pre-line-height)",fontSize:"1.1rem",fontWeight:"bold",padding:0,whiteSpace:"break-spaces",marginTop:"3rem"}},n.map(((e,t)=>i.createElement("div",a({line:e,key:t}),e.map(((e,t)=>i.createElement("span",o({token:e,key:t}))))))))})):i.createElement("div",null)}))}},51942:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>c,toc:()=>d});var a=n(87462),i=(n(67294),n(3905)),o=n(48720),r=n(99191);const s={id:"tezos-reference",title:"tezos",hide_table_of_contents:!0},l=void 0,c={unversionedId:"reference/tezos-reference",id:"reference/tezos-reference",title:"tezos",description:"Tezos-specific functions",source:"@site/../docs/reference/tezos.md",sourceDirName:"reference",slug:"/reference/tezos-reference",permalink:"/previews/ligo/external-link-icon/docs/next/reference/tezos-reference",draft:!1,tags:[],version:"current",frontMatter:{id:"tezos-reference",title:"tezos",hide_table_of_contents:!0},sidebar:"API",previous:{title:"pair",permalink:"/previews/ligo/external-link-icon/docs/next/reference/pair-reference"},next:{title:"operation",permalink:"/previews/ligo/external-link-icon/docs/next/reference/tezos.operation-reference"}},p={},d=[],m={toc:d};function h(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Tezos-specific functions"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/previews/ligo/external-link-icon/docs/next/reference/tezos.operation-reference"},"module Operation")),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/previews/ligo/external-link-icon/docs/next/reference/tezos.view-reference"},"module View")),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/previews/ligo/external-link-icon/docs/next/reference/tezos.ticket-reference"},"module Ticket")),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/previews/ligo/external-link-icon/docs/next/reference/tezos.sapling-reference"},"module Sapling")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_sender : unit -> address"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"get_sender: (_: unit) => address"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_sender ()")," is the address of the contract (that\nis, a smart contract or an implicit account) that initiated the\ncurrent internal transaction. Note that, if transactions have been\nchained, that address could be different from ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_source ()"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_sender()")," is the address of the contract (that is,\na smart contract or an implicit account) that initiated the current\ninternal transaction. Note that, if transactions have been chained,\nthat address could be different from ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_source()"),".")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_source : unit -> address"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"get_source: (_: unit) => address"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_source ()")," is the address of the implicit account\nthat initiated the current transaction. If transactions have been\nchained, that address is different from ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_sender ()"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_source()")," is the address of the implicit account\nthat initiated the current transaction. If transactions have been\nchained, that address is different from ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_sender()"),".")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val self : 'a.string -> 'a contract"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"self: <a>(entrypoint: string) => contract<a>"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.self entrypoint")," is the address of the current smart\ncontract, that is, the smart contract containing the call. For the\naddress of the smart contract actually ",(0,i.kt)("em",{parentName:"p"},"executing")," the call, because\nit is embedded in a lambda sent to another smart contract, use\n",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_self_address")," instead. The string ",(0,i.kt)("inlineCode",{parentName:"p"},"entrypoint")," is the name\nof a valid entrypoint such that ",(0,i.kt)("inlineCode",{parentName:"p"},"entrypoint")," is not ",(0,i.kt)("inlineCode",{parentName:"p"},'"%default"'),", or\nthe empty string denoting the ",(0,i.kt)("inlineCode",{parentName:"p"},'"%default"')," entrypoint (which is the\nroot of the smart contract parameter if no ",(0,i.kt)("inlineCode",{parentName:"p"},'"%default"')," entrypoint is\nexplicitly defined). If the contract does not have the specified\nentrypoint, the call results in an type checking error.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.self(entrypoint)")," is the address of the current smart\ncontract, that is, the smart contract containing the call. For the\naddress of the smart contract actually ",(0,i.kt)("em",{parentName:"p"},"executing")," the call, because\nit is embedded in a lambda sent to another smart contract, use\n",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_self_address")," instead. The string ",(0,i.kt)("inlineCode",{parentName:"p"},"entrypoint")," is the name\nof a valid entrypoint such that ",(0,i.kt)("inlineCode",{parentName:"p"},"entrypoint")," is not ",(0,i.kt)("inlineCode",{parentName:"p"},'"%default"'),", or\nthe empty string denoting the ",(0,i.kt)("inlineCode",{parentName:"p"},'"%default"')," entrypoint (which is the\nroot of the smart contract parameter if no ",(0,i.kt)("inlineCode",{parentName:"p"},'"%default"')," entrypoint is\nexplicitly defined). If the contract does not have the specified\nentrypoint, the call results in an type checking error.")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_self_address : unit -> address"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"get_self_address: (_: unit) => address"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_self_address ()")," is the address of the smart\ncontract actually executing the call, as a value of type\n",(0,i.kt)("inlineCode",{parentName:"p"},"address"),". That contract can be different from the one containing the\ncall if the call is in a lambda transmitted to another smart\ncontract. Therefore, it is assumed that, in general, the type of the\nexecuting contract is statically unknown, so the return type of\n",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_self_address")," is not ",(0,i.kt)("inlineCode",{parentName:"p"},"'a contract"),", but ",(0,i.kt)("inlineCode",{parentName:"p"},"address"),". (See\n",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.self"),".)")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_self_address()")," is the address of the smart\ncontract actually executing the call, as a value of type\n",(0,i.kt)("inlineCode",{parentName:"p"},"address"),". That contract can be different from the one containing the\ncall if the call is in a lambda transmitted to another smart\ncontract. Therefore, it is assumed that, in general, the type of the\nexecuting contract is statically unknown, so the return type of\n",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_self_address")," is not ",(0,i.kt)("inlineCode",{parentName:"p"},"'a contract"),", but ",(0,i.kt)("inlineCode",{parentName:"p"},"address"),". (See\n",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.self"),".)")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val address : 'a.'a contract -> address"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"address: <a>(contract_addr: contract<a>) => address"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.address contract")," casts the address of the smart\ncontract ",(0,i.kt)("inlineCode",{parentName:"p"},"contract")," into the more general value of type ",(0,i.kt)("inlineCode",{parentName:"p"},"address"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.address(contract)")," casts the address of the smart\ncontract ",(0,i.kt)("inlineCode",{parentName:"p"},"contract")," into the more general value of type ",(0,i.kt)("inlineCode",{parentName:"p"},"address"),".")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val implicit_account : key_hash -> unit contract"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"implicit_account: (_: key_hash) => contract<unit>"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.implicit_account kh")," casts the public key hash ",(0,i.kt)("inlineCode",{parentName:"p"},"kh"),"\ninto the address of its implicit account. Note that addresses of\nimplicit accounts always have the type ",(0,i.kt)("inlineCode",{parentName:"p"},"unit contract"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.implicit_account(kh)")," casts the public key hash ",(0,i.kt)("inlineCode",{parentName:"p"},"kh"),"\ninto the address of its implicit account. Note that addresses of\nimplicit accounts always have the type ",(0,i.kt)("inlineCode",{parentName:"p"},"contract<unit>"),".")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_contract_opt : 'param.address -> 'param contract option"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"get_contract_opt: <param>(_: address) => option<contract<param>>"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_contract_opt addr")," casts the address ",(0,i.kt)("inlineCode",{parentName:"p"},"addr")," into\nthat of a contract address, if such contract exists. The value of the\ncall is ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," if no such contract exists, otherwise ",(0,i.kt)("inlineCode",{parentName:"p"},"Some contract"),",\nwhere ",(0,i.kt)("inlineCode",{parentName:"p"},"contract")," is the contract's address. Note: The address of an\nimplicit account has type ",(0,i.kt)("inlineCode",{parentName:"p"},"unit contract"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"get_contract_opt(addr)")," casts the address ",(0,i.kt)("inlineCode",{parentName:"p"},"addr")," into\nthat of a contract address, if such contract exists. The value\nof the call is ",(0,i.kt)("inlineCode",{parentName:"p"},'["None" as "None"]')," if no such contract exists,\notherwise ",(0,i.kt)("inlineCode",{parentName:"p"},'["Some" as "Some", contract]'),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"contract")," is\nthe contract's address. Note: The address of an implicit account\nhas type ",(0,i.kt)("inlineCode",{parentName:"p"},"contract<unit>"),".")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_contract_with_error : 'param.address -> string -> 'param contract"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"get_contract_with_error: <param>(_: address) => (_: string) => contract<param>"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_contract_with_error addr error")," casts the address\n",(0,i.kt)("inlineCode",{parentName:"p"},"addr")," into that of a contract address, if such contract exists. If\nnot, the execution fails with the error message ",(0,i.kt)("inlineCode",{parentName:"p"},"error"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_contract_with_error(addr, error)")," casts the\naddress ",(0,i.kt)("inlineCode",{parentName:"p"},"addr")," into that of a contract address, if such contract\nexists. If not, the execution fails with the error message ",(0,i.kt)("inlineCode",{parentName:"p"},"error"),".")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_contract : 'param.address -> 'param contract"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"get_contract: <param>(_: address) => contract<param>"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_contract addr")," casts the address ",(0,i.kt)("inlineCode",{parentName:"p"},"addr")," into that\nof a smart contract address, if such contract exists. The call fails\nwith the message ",(0,i.kt)("inlineCode",{parentName:"p"},'"bad address for get_contract"')," if no such smart\ncontract exists. Note: The address of an implicit account has type\n",(0,i.kt)("inlineCode",{parentName:"p"},"unit contract"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_contract(addr)")," casts the address ",(0,i.kt)("inlineCode",{parentName:"p"},"addr")," into that\nof a smart contract address, if such contract exists. The call fails\nwith the message ",(0,i.kt)("inlineCode",{parentName:"p"},'"bad address for get_contract"')," if no such smart\ncontract exists. Note: The address of an implicit account has type\n",(0,i.kt)("inlineCode",{parentName:"p"},"contract<unit>"),".")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_entrypoint_opt : 'param.string -> address -> 'param contract option"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"get_entrypoint_opt: <param>(entrypoint: string, addr: address) => option<contract<param>>"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_entrypoint_opt entrypoint addr")," has the same\nbehaviour as ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_contract_opt addr"),", with the additional\nconstraint that the contract must have an entrypoint named\n",(0,i.kt)("inlineCode",{parentName:"p"},"entrypoint"),". In other words, ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_entrypoint_opt entrypoint\naddr")," casts the address ",(0,i.kt)("inlineCode",{parentName:"p"},"addr")," into that of a smart contract address,\nif such contract exists and has an entrypoint named ",(0,i.kt)("inlineCode",{parentName:"p"},"entrypoint"),". The\nvalue of the call is ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," if no such smart contract exists,\notherwise ",(0,i.kt)("inlineCode",{parentName:"p"},"Some contract"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"contract")," is the smart contract's\naddress. Note: The address of an implicit account has type ",(0,i.kt)("inlineCode",{parentName:"p"},"unit\ncontract"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"get_entrypoint_opt(entrypoint, addr)")," has the same\nbehaviour as ",(0,i.kt)("inlineCode",{parentName:"p"},"get_contract_opt(addr)"),", with the additional\nconstraint that the contract must have an entrypoint named\n",(0,i.kt)("inlineCode",{parentName:"p"},"entrypoint"),". In other words, ",(0,i.kt)("inlineCode",{parentName:"p"},"get_entrypoint_opt(entrypoint,\naddr)")," casts the address ",(0,i.kt)("inlineCode",{parentName:"p"},"addr")," into that of a smart contract\naddress, if such contract exists and has an entrypoint named\n",(0,i.kt)("inlineCode",{parentName:"p"},"entrypoint"),". The value of the call is ",(0,i.kt)("inlineCode",{parentName:"p"},'["None" as "None"]')," if\nno such smart contract exists, otherwise ",(0,i.kt)("inlineCode",{parentName:"p"},'["Some" as "Some",\ncontract]'),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"contract")," is the smart contract's\naddress. Note: The address of an implicit account has type\n",(0,i.kt)("inlineCode",{parentName:"p"},"contract<unit>"),".")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_entrypoint : 'param.string -> address -> 'param contract"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"get_entrypoint: <param>(entrypoint: string, addr: address) => contract<param>"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"get_entrypoint entrypoint addr")," casts the address ",(0,i.kt)("inlineCode",{parentName:"p"},"addr"),"\ninto that of a smart contract address, if such contract exists and has\nan entrypoint named ",(0,i.kt)("inlineCode",{parentName:"p"},"entrypoint"),". If no such smart contract exists,\nthe execution fails with the error message ",(0,i.kt)("inlineCode",{parentName:"p"},'"bad address for\nget_entrypoint"'),". Note: The address of an implicit account has type\n",(0,i.kt)("inlineCode",{parentName:"p"},"unit contract"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"get_entrypoint(entrypoint, addr)")," casts the address ",(0,i.kt)("inlineCode",{parentName:"p"},"addr"),"\ninto that of a smart contract address, if such contract exists and has\nan entrypoint named ",(0,i.kt)("inlineCode",{parentName:"p"},"entrypoint"),". If no such smart contract exists,\nthe execution fails with the error message ",(0,i.kt)("inlineCode",{parentName:"p"},'"bad address for\nget_entrypoint"'),". Note: The address of an implicit account has type\n",(0,i.kt)("inlineCode",{parentName:"p"},"contract<unit>"),".")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val open_chest : chest_key -> chest -> nat -> bytes option"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"open_chest: (key: chest_key, _: chest, time: nat) => option<bytes>"),(0,i.kt)("p",null,"The function ",(0,i.kt)("inlineCode",{parentName:"p"},"open_chest")," opens a timelocked chest given its key and\nthe time. The result is a byte option depending if the opening is\ncorrect or not."),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_balance : unit -> tez"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"get_balance: (_: unit) => tez"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_balance ()")," returns the balance in mutez of the\naccount associated to the currently executed smart contract, including\nany mutez added by the calling transaction.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_balance()")," returns the balance in mutez of the\naccount associated to the currently executed smart contract, including\nany mutez added by the calling transaction.")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_amount : unit -> tez"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"get_amount: (_: unit) => tez"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_amount ()")," returns the amount in mutez of the\ncurrent transaction.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_amount()")," returns the amount in mutez of the\ncurrent transaction.")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_now : unit -> timestamp"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"get_now: (_: unit) => timestamp"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_now ()"),' returns the minimal injection time for the\ncurrent block, namely the block whose application triggered this\nexecution. The minimal injection time constitutes an estimate of the\nmoment when the current block is injected, hence the name "now".')),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_now()"),' returns the minimal injection time for the\ncurrent block, namely the block whose application triggered this\nexecution. The minimal injection time constitutes an estimate of the\nmoment when the current block is injected, hence the name "now".')),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_min_block_time : unit -> nat"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"get_min_block_time: (_: unit) => nat"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_min_block_time ()")," returns the minimal delay\nbetween two consecutive blocks in the chain.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_min_block_time()")," returns the minimal delay\nbetween two consecutive blocks in the chain.")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_level : unit -> nat"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"get_level: (_: unit) => nat"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_level ()")," returns the current block level.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_level()")," returns the current block level.")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_chain_id : unit -> chain_id"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"get_chain_id: (_: unit) => chain_id"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_chain_id ()")," returns the identifier of the chain\non which the smart contract is executed.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_chain_id ()")," returns the identifier of the chain\non which the smart contract is executed.")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_total_voting_power : unit -> nat"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"get_total_voting_power: (_: unit) => nat"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_total_voting_power ()")," returns the total voting\npower of all contracts. The total voting power coincides with the sum\nof the stake of every contract in the voting listings. The voting\nlistings is calculated at the beginning of every voting period.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.get_total_voting_power()")," returns the total voting\npower of all contracts. The total voting power coincides with the sum\nof the stake of every contract in the voting listings. The voting\nlistings is calculated at the beginning of every voting period.")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val voting_power : key_hash -> nat"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"voting_power: (_: key_hash) => nat"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.voting_power contract_kh")," returns the voting power of\na given contract specified by the key hash ",(0,i.kt)("inlineCode",{parentName:"p"},"contract_kh"),". This voting\npower coincides with the weight of the contract in the voting listings\n(that is, the stake) which is calculated at the beginning of every\nvoting period.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.voting_power(contract_kh)")," returns the voting power of\na given contract specified by the key hash ",(0,i.kt)("inlineCode",{parentName:"p"},"contract_kh"),". This voting\npower coincides with the weight of the contract in the voting listings\n(that is, the stake) which is calculated at the beginning of every\nvoting period.")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val never : 'a.never -> 'a"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"never: <a>(_: never) => a"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.never n")," is never meant to be executed, as the type\n",(0,i.kt)("inlineCode",{parentName:"p"},"never")," is inhabited, but to instruct the typechecker that a branch in\nthe control flow, for example, in a pattern matching, is dead.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.never(n)")," is never meant to be executed, as the type\n",(0,i.kt)("inlineCode",{parentName:"p"},"never")," is inhabited, but to instruct the typechecker that a branch in\nthe control flow, for example, in a pattern matching, is dead.")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val pairing_check : (bls12_381_g1 * bls12_381_g2) list -> bool"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"pairing_check: (_: list<[bls12_381_g1, bls12_381_g2]>) => bool"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.pairing_check pairings")," verifies that the product of\npairings of the given list of points ",(0,i.kt)("inlineCode",{parentName:"p"},"pairings")," is equal to 1 in the\nfield Fq12. It evaluates in ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," if the list is empty. This function\ncan be used to verify if two pairings P1 and P2 are equal by verifying\nP1 * P2^(-1) = 1.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.pairing_check(pairings)")," verifies that the product of\npairings of the given list of points ",(0,i.kt)("inlineCode",{parentName:"p"},"pairings")," is equal to 1 in the\nfield Fq12. It evaluates in ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," if the list is empty. This function\ncan be used to verify if two pairings P1 and P2 are equal by verifying\nP1 * P2^(-1) = 1.")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val constant : 'a.string -> 'a"),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"constant: <a>(hash: string) => a"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call to ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.constant hash")," returns the value stored on-chain\nwhose hash value is ",(0,i.kt)("inlineCode",{parentName:"p"},"hash")," (global constants). This call can fail when\nthe contract is originated if the hash is invalid or the expansion of\nthe global constant is ill-typed, or too large (gas consumption).")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call to ",(0,i.kt)("inlineCode",{parentName:"p"},"Tezos.constant(hash)")," returns the value stored on-chain\nwhose hash value is ",(0,i.kt)("inlineCode",{parentName:"p"},"hash")," (global constants). This call can fail when\nthe contract is originated if the hash is invalid or the expansion of\nthe global constant is ill-typed, or too large (gas consumption).")))}h.isMDXComponent=!0},23746:(e,t,n)=>{n.r(t),n.d(t,{Prism:()=>a.Z,default:()=>y,defaultProps:()=>r});var a=n(87410);const i={plain:{backgroundColor:"#2a2734",color:"#9a86fd"},styles:[{types:["comment","prolog","doctype","cdata","punctuation"],style:{color:"#6c6783"}},{types:["namespace"],style:{opacity:.7}},{types:["tag","operator","number"],style:{color:"#e09142"}},{types:["property","function"],style:{color:"#9a86fd"}},{types:["tag-id","selector","atrule-id"],style:{color:"#eeebff"}},{types:["attr-name"],style:{color:"#c4b9fe"}},{types:["boolean","string","entity","url","attr-value","keyword","control","directive","unit","statement","regex","atrule","placeholder","variable"],style:{color:"#ffcc99"}},{types:["deleted"],style:{textDecorationLine:"line-through"}},{types:["inserted"],style:{textDecorationLine:"underline"}},{types:["italic"],style:{fontStyle:"italic"}},{types:["important","bold"],style:{fontWeight:"bold"}},{types:["important"],style:{color:"#c4b9fe"}}]};var o=n(67294),r={Prism:a.Z,theme:i};function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(){return l=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},l.apply(this,arguments)}var c=/\r\n|\r|\n/,p=function(e){0===e.length?e.push({types:["plain"],content:"\n",empty:!0}):1===e.length&&""===e[0].content&&(e[0].content="\n",e[0].empty=!0)},d=function(e,t){var n=e.length;return n>0&&e[n-1]===t?e:e.concat(t)},m=function(e,t){var n=e.plain,a=Object.create(null),i=e.styles.reduce((function(e,n){var a=n.languages,i=n.style;return a&&!a.includes(t)||n.types.forEach((function(t){var n=l({},e[t],i);e[t]=n})),e}),a);return i.root=n,i.plain=l({},n,{backgroundColor:null}),i};function h(e,t){var n={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&-1===t.indexOf(a)&&(n[a]=e[a]);return n}const y=function(e){function t(){for(var t=this,n=[],a=arguments.length;a--;)n[a]=arguments[a];e.apply(this,n),s(this,"getThemeDict",(function(e){if(void 0!==t.themeDict&&e.theme===t.prevTheme&&e.language===t.prevLanguage)return t.themeDict;t.prevTheme=e.theme,t.prevLanguage=e.language;var n=e.theme?m(e.theme,e.language):void 0;return t.themeDict=n})),s(this,"getLineProps",(function(e){var n=e.key,a=e.className,i=e.style,o=l({},h(e,["key","className","style","line"]),{className:"token-line",style:void 0,key:void 0}),r=t.getThemeDict(t.props);return void 0!==r&&(o.style=r.plain),void 0!==i&&(o.style=void 0!==o.style?l({},o.style,i):i),void 0!==n&&(o.key=n),a&&(o.className+=" "+a),o})),s(this,"getStyleForToken",(function(e){var n=e.types,a=e.empty,i=n.length,o=t.getThemeDict(t.props);if(void 0!==o){if(1===i&&"plain"===n[0])return a?{display:"inline-block"}:void 0;if(1===i&&!a)return o[n[0]];var r=a?{display:"inline-block"}:{},s=n.map((function(e){return o[e]}));return Object.assign.apply(Object,[r].concat(s))}})),s(this,"getTokenProps",(function(e){var n=e.key,a=e.className,i=e.style,o=e.token,r=l({},h(e,["key","className","style","token"]),{className:"token "+o.types.join(" "),children:o.content,style:t.getStyleForToken(o),key:void 0});return void 0!==i&&(r.style=void 0!==r.style?l({},r.style,i):i),void 0!==n&&(r.key=n),a&&(r.className+=" "+a),r})),s(this,"tokenize",(function(e,t,n,a){var i={code:t,grammar:n,language:a,tokens:[]};e.hooks.run("before-tokenize",i);var o=i.tokens=e.tokenize(i.code,i.grammar,i.language);return e.hooks.run("after-tokenize",i),o}))}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.render=function(){var e=this.props,t=e.Prism,n=e.language,a=e.code,i=e.children,o=this.getThemeDict(this.props),r=t.languages[n];return i({tokens:function(e){for(var t=[[]],n=[e],a=[0],i=[e.length],o=0,r=0,s=[],l=[s];r>-1;){for(;(o=a[r]++)<i[r];){var m=void 0,h=t[r],y=n[r][o];if("string"==typeof y?(h=r>0?h:["plain"],m=y):(h=d(h,y.type),y.alias&&(h=d(h,y.alias)),m=y.content),"string"==typeof m){var u=m.split(c),g=u.length;s.push({types:h,content:u[0]});for(var k=1;k<g;k++)p(s),l.push(s=[]),s.push({types:h,content:u[k]})}else r++,t.push(h),n.push(m),a.push(0),i.push(m.length)}r--,t.pop(),n.pop(),a.pop(),i.pop()}return p(s),l}(void 0!==r?this.tokenize(t,a,r,n):[a]),className:"prism-code language-"+n,style:void 0!==o?o.root:{},getLineProps:this.getLineProps,getTokenProps:this.getTokenProps})},t}(o.Component)},87552:(e,t,n)=>{n.d(t,{Z:()=>a});const a={plain:{color:"#bfc7d5",backgroundColor:"#292d3e"},styles:[{types:["comment"],style:{color:"rgb(105, 112, 152)",fontStyle:"italic"}},{types:["string","inserted"],style:{color:"rgb(195, 232, 141)"}},{types:["number"],style:{color:"rgb(247, 140, 108)"}},{types:["builtin","char","constant","function"],style:{color:"rgb(130, 170, 255)"}},{types:["punctuation","selector"],style:{color:"rgb(199, 146, 234)"}},{types:["variable"],style:{color:"rgb(191, 199, 213)"}},{types:["class-name","attr-name"],style:{color:"rgb(255, 203, 107)"}},{types:["tag","deleted"],style:{color:"rgb(255, 85, 114)"}},{types:["operator"],style:{color:"rgb(137, 221, 255)"}},{types:["boolean"],style:{color:"rgb(255, 88, 116)"}},{types:["keyword"],style:{fontStyle:"italic"}},{types:["doctype"],style:{color:"rgb(199, 146, 234)",fontStyle:"italic"}},{types:["namespace"],style:{color:"rgb(178, 204, 214)"}},{types:["url"],style:{color:"rgb(221, 221, 221)"}}]}}}]);