"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[40059],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>m});var o=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},l=Object.keys(e);for(o=0;o<l.length;o++)t=l[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(o=0;o<l.length;o++)t=l[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=o.createContext({}),u=function(e){var n=o.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},c=function(e){var n=u(e.components);return o.createElement(s.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},g=o.forwardRef((function(e,n){var t=e.components,a=e.mdxType,l=e.originalType,s=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),g=u(t),m=a,d=g["".concat(s,".").concat(m)]||g[m]||p[m]||l;return t?o.createElement(d,r(r({ref:n},c),{},{components:t})):o.createElement(d,r({ref:n},c))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var l=t.length,r=new Array(l);r[0]=g;var i={};for(var s in n)hasOwnProperty.call(n,s)&&(i[s]=n[s]);i.originalType=e,i.mdxType="string"==typeof e?e:a,r[1]=i;for(var u=2;u<l;u++)r[u]=t[u];return o.createElement.apply(null,r)}return o.createElement.apply(null,t)}g.displayName="MDXCreateElement"},48720:(e,n,t)=>{t.d(n,{D:()=>a.Z,Z:()=>l});var o=t(67294),a=t(75402);const l=function(e){return o.createElement(a.Z.Consumer,null,(n=>{let{syntax:t}=n;return t===e.syntax?e.children:o.createElement(o.Fragment,null)}))}},99895:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>i,default:()=>g,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var o=t(87462),a=(t(67294),t(3905)),l=t(48720);const r={id:"loops",title:"Iteration"},i=void 0,s={unversionedId:"language-basics/loops",id:"version-1.5.0/language-basics/loops",title:"Iteration",description:"General Iteration",source:"@site/versioned_docs/version-1.5.0/language-basics/loops.md",sourceDirName:"language-basics",slug:"/language-basics/loops",permalink:"/previews/ligo/external-link-icon/docs/1.5.0/language-basics/loops",draft:!1,tags:[],version:"1.5.0",frontMatter:{id:"loops",title:"Iteration"}},u={},c=[{value:"General Iteration",id:"general-iteration",level:2},{value:"for-of Loops",id:"for-of-loops",level:2}],p={toc:c};function g(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,o.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"general-iteration"},"General Iteration"),(0,a.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,a.kt)("p",null,"CameLIGO is a functional language where user-defined values are\nconstant, therefore the preferred way to write iterations is by means\nof recursive functions. Here is how to compute the greatest common\ndivisors of two natural numbers by means of Euclid's algorithm:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=gcd",group:"gcd"},"let rec iter (x, y : nat * nat) : nat =\n  if y = 0n then x else iter (y, x mod y)\n\nlet gcd (x, y : nat * nat) : nat =\n  let x, y = if x < y then y,x else x,y\n  in iter (x, y)\n")),(0,a.kt)("p",null,"You can call the function ",(0,a.kt)("inlineCode",{parentName:"p"},"gcd")," defined above using the LIGO compiler\nlike so:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"ligo run evaluate-call \\\n  gitlab-pages/docs/language-basics/src/loops/gcd.mligo \\\n  gcd '(2n*2n*3n*11n, 2n*2n*2n*3n*3n*5n*7n)'\n# Outputs: +12\n")),(0,a.kt)("p",null,"CameLIGO also features loops, which we understand as syntactic\nconstructs where the state of a stopping condition is mutated. There\nare two kinds of loops: for-loops and while-loops. Here is again\nEuclid's algorithm, but using mutation and a while-loop:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=gcd-loop",group:"gcd-loop"},"let gcd (a, b : nat * nat) =\n  let mut x, y = a, b in // we will modify x and y\n  let () =\n    if x < y then\n      let z = x in\n      begin\n        x := y; y := z\n      end in\n  let mut r : nat = 0n in\n  let () =\n    while y <> 0n do\n      r := x mod y;\n      x := y;\n      y := r\n    done\n  in x\n")),(0,a.kt)("p",null,"Here is how to check if a string is a palindrome or not using a ",(0,a.kt)("inlineCode",{parentName:"p"},"for")," loop:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=a",group:"a"},'let get_char s idx = String.sub idx 1n s\n\nlet is_palindrome s =\n  let mut p = "" in\n  let length = String.length s in\n  let () =\n    for i = length - 1 downto 0 do\n      p := p ^ get_char s (abs i)\n    done\n  in p = s\n'))),(0,a.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,a.kt)("p",null,"JsLIGO currently supports iteration through while-loops, for-loops,\nand through the use of tail recursive functions."),(0,a.kt)("p",null,"Here is how to check if a string is a palindrome or not using a ",(0,a.kt)("inlineCode",{parentName:"p"},"for")," loop:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=a",group:"a"},'const getChar = (s: string, idx: nat): string => String.sub(idx, 1n, s);\n\nfunction isPalindrome (s: string): bool {\n  let p = "";\n  let length = String.length(s);\n  for (let i = length - 1 ; i >= 0 ; i--)\n    p += getChar(s, abs(i));\n  return p == s;\n};\n')),(0,a.kt)("p",null,"Here is how to compute the greatest common divisors of two natural\nnumbers by means of Euclid's algorithm with using a while loop:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=gcd",group:"gcd"},"function gcd (a: nat, b: nat) {\n  let [x,y] = [a,b]; // we will modify x and y\n  if (x < y) {\n    const z = x;\n    x = y; y = z;\n  }\n  let r: nat = 0n\n  while (y != 0n) {\n    r = x % y;\n    x = y;\n    y = r;\n  }\n  return x;\n};\n")),(0,a.kt)("p",null,"And here is how to compute the greatest common divisors of two natural\nnumbers by means of Euclid's algorithm using tail recursion:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=gcd",group:"gcd"},"function iter (x: nat,y: nat): nat {\n  if (y == 0n) return x else return iter (y, x % y)\n};\n\nfunction gcd2 (x: nat,y: nat) : nat {\n  if (x < y) return iter (y, x) else return iter (x, y)\n};\n")),(0,a.kt)("p",null,"You can call the function ",(0,a.kt)("inlineCode",{parentName:"p"},"gcd")," defined above using the LIGO compiler\nlike so:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"ligo run evaluate-expr \\\n  gitlab-pages/docs/language-basics/src/loops/gcd.jsligo \\\n  'gcd(2n*2n*3n*11n, 2n*2n*2n*3n*3n*5n*7n)'\n# Outputs: +12\n")),(0,a.kt)("p",null,"and can call the function ",(0,a.kt)("inlineCode",{parentName:"p"},"gcd2")," defined above using the LIGO compiler\nlike so:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"ligo run evaluate-expr \\\n  gitlab-pages/docs/language-basics/src/loops/gcd.jsligo \\\n  'gcd2(2n*2n*3n*11n, 2n*2n*2n*3n*3n*5n*7n)'\n# Outputs: +12\n")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Note: Currently JsLIGO does not support the key words ",(0,a.kt)("inlineCode",{parentName:"p"},"break")," & ",(0,a.kt)("inlineCode",{parentName:"p"},"continue")," in the context\nof loops."))),(0,a.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,a.kt)("h2",{id:"for-of-loops"},"for-of Loops"),(0,a.kt)("p",null,'JsLIGO "for-of" loops can iterate through the contents of a\ncollection, that is, a list, a set or a map. This is done with a loop\nof the form ',(0,a.kt)("inlineCode",{parentName:"p"},"for (const <element var> of <collection var>) <block>"),"."),(0,a.kt)("p",null,"Here is an example where the integers in a list are summed up."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=collection",group:"collection"},"function sum_list (l : list<int>) {\n  let total = 0;\n  for (const i of l) total = total + i;\n  return total;\n};\n")),(0,a.kt)("p",null,"You can call the function ",(0,a.kt)("inlineCode",{parentName:"p"},"sum_list")," defined above using the LIGO compiler\nlike so:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"ligo run evaluate-expr \\\n  gitlab-pages/docs/language-basics/src/loops/collection.jsligo \\\n  'sum_list(list([1,2,3]))'\n# Outputs: 6\n")),(0,a.kt)("p",null,"Here is an example where the integers in a set are summed up."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=collection",group:"collection"},"function sum_set (s : set<int>) {\n  let total : int = 0;\n  for (const i of s) total = total + i;\n  return total;\n};\n")),(0,a.kt)("p",null,"You can call the function ",(0,a.kt)("inlineCode",{parentName:"p"},"sum_set")," defined above using the LIGO compiler\nlike so:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"ligo run evaluate-expr \\\n  gitlab-pages/docs/language-basics/src/loops/collection.jsligo \\\n  'sum_set(Set.literal(list([1,2,2,3])))'\n# Outputs: 6\n")),(0,a.kt)("p",null,"Loops over maps are actually loops over the bindings of the map.\nGiven a map from strings to integers, here is how to sum\nall the integers and concatenate all the strings."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=collection",group:"collection"},'function sum_map (m: map<string, int>) {\n  let string_total = ""\n  let int_total = 0\n  for (const item of m) {\n    let [key, value] = item;\n    string_total = string_total + key;\n    int_total = int_total + value\n  }\n  return [string_total, int_total]\n}\n')),(0,a.kt)("p",null,"You can call the function ",(0,a.kt)("inlineCode",{parentName:"p"},"sum_map")," defined above using the LIGO compiler\nlike so:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},'ligo run evaluate-expr \\\n  gitlab-pages/docs/language-basics/src/loops/collection.jsligo \\\n \'sum_map(Map.literal(list([ ["1", 1], ["2", 2], ["3", 3] ])))\'\n# Outputs: ( "123", 6 )\n'))))}g.isMDXComponent=!0}}]);