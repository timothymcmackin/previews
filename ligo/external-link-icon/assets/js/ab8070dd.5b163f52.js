"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[32200],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>m});var a=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=a.createContext({}),u=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},c=function(e){var n=u(e.components);return a.createElement(s.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=u(t),m=i,g=d["".concat(s,".").concat(m)]||d[m]||p[m]||r;return t?a.createElement(g,o(o({ref:n},c),{},{components:t})):a.createElement(g,o({ref:n},c))}));function m(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,o=new Array(r);o[0]=d;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var u=2;u<r;u++)o[u]=t[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},48720:(e,n,t)=>{t.d(n,{D:()=>i.Z,Z:()=>r});var a=t(67294),i=t(75402);const r=function(e){return a.createElement(i.Z.Consumer,null,(n=>{let{syntax:t}=n;return t===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},15640:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>l,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var a=t(87462),i=(t(67294),t(3905)),r=t(48720);const o={id:"declaring",title:"Declaring"},l=void 0,s={unversionedId:"functions/declaring",id:"version-1.5.0/functions/declaring",title:"Declaring",description:"LIGO functions are the basic building block of contracts.",source:"@site/versioned_docs/version-1.5.0/functions/declaring.md",sourceDirName:"functions",slug:"/functions/declaring",permalink:"/previews/ligo/external-link-icon/docs/1.5.0/functions/declaring",draft:!1,tags:[],version:"1.5.0",frontMatter:{id:"declaring",title:"Declaring"},sidebar:"docs",previous:{title:"Accessing",permalink:"/previews/ligo/external-link-icon/docs/1.5.0/tuples/accessing"},next:{title:"Lambdas",permalink:"/previews/ligo/external-link-icon/docs/1.5.0/functions/lambdas"}},u={},c=[],p={toc:c};function d(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"LIGO functions are the basic building block of contracts."),(0,i.kt)("p",null,"The semantics of function calls in LIGO is that of a ",(0,i.kt)("em",{parentName:"p"},"copy of the\narguments but also of the environment"),". This means that any mutation\n(assignment) on variables outside the scope of the function will be\nlost when the function returns, just as the mutations inside the\nfunctions will be."),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"Function declarations are introduced by the ",(0,i.kt)("inlineCode",{parentName:"p"},"let")," keyword, like other\nvalues. A difference with non-functional values is the succession of\nparameters provided after the value name. This follows OCaml\nsyntax. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=fun_decl",group:"fun_decl"},"let add x y = x + y\nlet int_add (x: int) (y: int) : int = x + y\n")),(0,i.kt)("p",null,"This means that ",(0,i.kt)("inlineCode",{parentName:"p"},"sum")," is a function that takes an argument (value)\nbound to parameter ",(0,i.kt)("inlineCode",{parentName:"p"},"x"),", and returns a function that takes an argument\nbound to parameter ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),", then returns ",(0,i.kt)("inlineCode",{parentName:"p"},"x+y"),". This is called\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Currying"},"currying"),". This default\nsemantics enables\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Partial_application"},"partial application"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=curry",group:"curry"},"let add (x,y) = x + y         // Uncurried\nlet add_curry x y = add (x,y) // Curried\nlet increment = add_curry 1   // Partial application\nlet one = increment 0\n")),(0,i.kt)("p",null,"The type of ",(0,i.kt)("inlineCode",{parentName:"p"},"increment")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"int -> int"),", meaning that it is a function\ntaking an argument of type ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," and returning a value of type\n",(0,i.kt)("inlineCode",{parentName:"p"},"int"),". Similarly, the type of ",(0,i.kt)("inlineCode",{parentName:"p"},"add_curry")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"int -> int -> int"),",\nwhich means ",(0,i.kt)("inlineCode",{parentName:"p"},"int -> (int -> int)")," and explains how we can partially\napply it (only on its first argument) with the declaration of\n",(0,i.kt)("inlineCode",{parentName:"p"},"increment"),"."),(0,i.kt)("p",null,"By default, LIGO will warn about unused arguments inside\nfunctions. In case we do not use an argument, we can use the wildcard\n",(0,i.kt)("inlineCode",{parentName:"p"},"_")," to prevent warnings. Either use ",(0,i.kt)("inlineCode",{parentName:"p"},"_")," instead of the argument\nidentifier:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo"},"let drop x _ = x\n")),(0,i.kt)("p",null,"or use an identifier starting with wildcard:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo"},"let drop x _y = x  // _y silently ignored\n")),(0,i.kt)("p",null,"Functions can capture variables in their bodies that are defined\noutside, as shown above with the function ",(0,i.kt)("inlineCode",{parentName:"p"},"add_curry"),". We could have\nthe same phenomenon with nested functions instead of two functions at\nthe same scope level:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo"},"let convoluted_doubling x =\n  let add_x y = x + y  // x is bound by convoluted_doubling\n  in add_x x\n"))),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"Function declarations can be introduced in two main ways: either by\nthe keyword ",(0,i.kt)("inlineCode",{parentName:"p"},"function")," or the keyword ",(0,i.kt)("inlineCode",{parentName:"p"},"const")," (the keyword ",(0,i.kt)("inlineCode",{parentName:"p"},"let")," is\npossible too, but defaulted to ",(0,i.kt)("inlineCode",{parentName:"p"},"const")," in this instance). The latter\nmanner is preferred when the function body is an expression. For\nexample, here is how you define a basic function that sums two\nintegers:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=sum",group:"sum"},"const add = (x,y) => x + y;  // Single-expression body\nconst int_add = (x: int, y: int) : int => x + y\n")),(0,i.kt)("p",null,"This means that ",(0,i.kt)("inlineCode",{parentName:"p"},"add")," is a function that takes a pair of integers and\nreturns their sum."),(0,i.kt)("p",null,"If the body contains ",(0,i.kt)("em",{parentName:"p"},"statements")," instead of a single expression, you\nwould use a block and a ",(0,i.kt)("inlineCode",{parentName:"p"},"return")," statement:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=sum",group:"sum"},"const double_sum = (x: int, y: int) : int => {\n  const doubleX = 2*x;\n  const doubleY = 2*y;\n  return doubleX + doubleY;\n};\n")),(0,i.kt)("p",null,"although it is arguably more readable to use ",(0,i.kt)("inlineCode",{parentName:"p"},"function"),", like so:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=sum",group:"sum"},"function double_sum_bis (x: int, y: int) {\n  const doubleX = 2*x;\n  const doubleY = 2*y;\n  return doubleX + doubleY;\n};\n")),(0,i.kt)("p",null,"Note that JsLIGO, like JavaScript, requires the ",(0,i.kt)("inlineCode",{parentName:"p"},"return")," keyword to\nindicate what is being returned. If ",(0,i.kt)("inlineCode",{parentName:"p"},"return")," is not used, it will be\nthe same as ",(0,i.kt)("inlineCode",{parentName:"p"},"return []")," (unit)."),(0,i.kt)("p",null,"By default, LIGO will warn about unused arguments inside functions. In\ncase we do not use an argument, its name should start with ",(0,i.kt)("inlineCode",{parentName:"p"},"_")," to\nprevent warnings."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo"},"const drop = (x, _y) => x; // _y silently ignored\n")),(0,i.kt)("p",null,"Functions can capture variables in their bodies that are defined\noutside:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=sum",group:"sum"},"const double_incr = x => add (x,x) + 1; // add is captured from outside\n")),(0,i.kt)("p",null,"We could have the same phenomenon with nested functions instead of two\nfunctions at the same scope level:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo"},"function convoluted_doubling (x) {\n  const addX = y => x + y;  // x is bound by convoluted_doubling\n  return addX(x);\n}\n"))))}d.isMDXComponent=!0}}]);