"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[73718],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>u});var a=n(67294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},y={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},g=a.forwardRef((function(e,t){var n=e.components,s=e.mdxType,i=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),g=p(n),u=s,m=g["".concat(l,".").concat(u)]||g[u]||y[u]||i;return n?a.createElement(m,r(r({ref:t},c),{},{components:n})):a.createElement(m,r({ref:t},c))}));function u(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var i=n.length,r=new Array(i);r[0]=g;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:s,r[1]=o;for(var p=2;p<i;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}g.displayName="MDXCreateElement"},48720:(e,t,n)=>{n.d(t,{D:()=>s.Z,Z:()=>i});var a=n(67294),s=n(75402);const i=function(e){return a.createElement(s.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},53676:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>g,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var a=n(87462),s=(n(67294),n(3905)),i=n(48720);const r={id:"bytes",title:"Bytes"},o=void 0,l={unversionedId:"data-types/bytes",id:"data-types/bytes",title:"Bytes",description:"Bytes are used for serializing data, for example to compute signature",source:"@site/../docs/data-types/bytes.md",sourceDirName:"data-types",slug:"/data-types/bytes",permalink:"/previews/ligo/external-link-icon/docs/next/data-types/bytes",draft:!1,tags:[],version:"current",frontMatter:{id:"bytes",title:"Bytes"},sidebar:"docs",previous:{title:"Timestamps",permalink:"/previews/ligo/external-link-icon/docs/next/data-types/timestamp"},next:{title:"Tuples",permalink:"/previews/ligo/external-link-icon/docs/next/data-types/tuples"}},p={},c=[{value:"Literals",id:"literals",level:2},{value:"From numbers to bytes and back",id:"from-numbers-to-bytes-and-back",level:2},{value:"From strings",id:"from-strings",level:2},{value:"Concatenating",id:"concatenating",level:2},{value:"Sizing",id:"sizing",level:2},{value:"Slicing",id:"slicing",level:2},{value:"Bitwise operations",id:"bitwise-operations",level:2},{value:"Packing and unpacking",id:"packing-and-unpacking",level:2},{value:"Cryptography",id:"cryptography",level:2}],y={toc:c};function g(e){let{components:t,...n}=e;return(0,s.kt)("wrapper",(0,a.Z)({},y,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Bytes are used for serializing data, for example to compute signature\nhashes. Conversely, they can be used to deserialise external data, in\nwhich case the expected LIGO type needs to be specified."),(0,s.kt)("h2",{id:"literals"},"Literals"),(0,s.kt)("p",null,"Byte literals are sequences of bytes (eight-bit values, also known as\n",(0,s.kt)("em",{parentName:"p"},"octets"),"), defined using the prefix ",(0,s.kt)("inlineCode",{parentName:"p"},"0x")," followed by hexadecimal\ndigits, or none if the denoted literal is zero:"),(0,s.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=bytes",group:"bytes"},"let a : bytes = 0x70FF\nlet zero : bytes = 0x\nlet zero_too = 0x00\n"))),(0,s.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=bytes",group:"bytes"},'const a : bytes = 0x70FF;\nconst zero = "" as bytes;\nconst zero_too = 0x00;\n'))),(0,s.kt)("p",null,"This means that literal bytes are always comprised of an even number of hexadecimal digits, because one hexadecimal digit requires up to four bits in binary, and eight are needed to make up a byte."),(0,s.kt)("h2",{id:"from-numbers-to-bytes-and-back"},"From numbers to bytes and back"),(0,s.kt)("p",null,"You can convert some other numerals to bytes by calling the predefined function ",(0,s.kt)("inlineCode",{parentName:"p"},"bytes"),".\nTo convert ints or nats to bytes, use the predefined functions ",(0,s.kt)("inlineCode",{parentName:"p"},"int")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"nat"),".\nFor example, here is how to create bytes from natural numbers and integers:"),(0,s.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=bytes",group:"bytes"},"let b : bytes = bytes 123n   // 7B in hexadecimal\nlet c : bytes = bytes 123\nlet d : bytes = bytes (-123) // Two's complement\n\nlet n : nat = nat 0x7B // n = 123n\nlet i : int = int 0x7B // i = 123\n"))),(0,s.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=bytes",group:"bytes"},"const b: bytes = bytes(123 as nat); // 7B in hexadecimal\nconst c: bytes = bytes(123);\nconst d: bytes = bytes(-123); // Two's complement\n\nconst n: nat = nat(0x7B); // n == 123n\nconst i: int = int(0x7B); // i == 123\n"))),(0,s.kt)("p",null,"Note: See ",(0,s.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Two's_complement"},"Two's complement"),"."),(0,s.kt)("h2",{id:"from-strings"},"From strings"),(0,s.kt)("p",null,"You can convert a string literal to bytes in two ways:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"By interpreting the ",(0,s.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/ASCII"},"ASCII")," code of each character (which spans over two hexadecimal digits) as one byte"),(0,s.kt)("li",{parentName:"ul"},"By interpreting directly each character as one hexadecimal digit")),(0,s.kt)("p",null,"To interpret the ASCII code, use this syntax:"),(0,s.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=bytes",group:"bytes"},'let from_ascii : bytes = [%bytes "foo"]\n'))),(0,s.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=bytes",group:"bytes"},"const from_ascii: bytes = bytes`foo`; // Not a function call\n"))),(0,s.kt)("p",null,"To interpret each character directly, use a type cast:"),(0,s.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=bytes",group:"bytes"},'// raw = from_ascii\nlet raw : bytes = ("666f6f" : bytes)\n')),(0,s.kt)("admonition",{type:"note"},(0,s.kt)("p",{parentName:"admonition"},"Both cases apply only to string literals, not variables or other expressions of type ",(0,s.kt)("inlineCode",{parentName:"p"},"string"),".\nIn other words, the contents of the strings must be available in-place at compile time.\n(This reveals that ",(0,s.kt)("inlineCode",{parentName:"p"},'("666f6f" : bytes)')," is not really a cast, because casts are non-operations.)"))),(0,s.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=bytes",group:"bytes"},'// raw == from_ascii\nconst raw: bytes = ("666f6f" as bytes);\n')),(0,s.kt)("admonition",{type:"note"},(0,s.kt)("p",{parentName:"admonition"},"Both cases apply only to string literals, not variables or other expressions of type ",(0,s.kt)("inlineCode",{parentName:"p"},"string"),".\nIn other words, the contents of the strings must be available in-place at compile time.\n(This reveals that ",(0,s.kt)("inlineCode",{parentName:"p"},'("666f6f" as bytes)')," is not really a cast, because casts are non-operations.)"))),(0,s.kt)("h2",{id:"concatenating"},"Concatenating"),(0,s.kt)("p",null,"Two or more bytes can be concatenated."),(0,s.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=concatenating",group:"concatenating"},"let two : bytes = Bytes.concat 0x70 0xAA\nlet three : bytes = Bytes.concats [0x70; 0xAA; 0xFF]\n"))),(0,s.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=concatenating",group:"concatenating"},"const two: bytes = Bytes.concat(0x70, 0xAA);\nconst three: bytes = Bytes.concats([0x70, 0xAA, 0xFF]);\n"))),(0,s.kt)("h2",{id:"sizing"},"Sizing"),(0,s.kt)("p",null,"In order to obtain the length of a sequence of bytes, use the\npredefined function ",(0,s.kt)("inlineCode",{parentName:"p"},"Bytes.length")," like so:"),(0,s.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=sizing",group:"sizing"},"let len : nat = Bytes.length 0x0AFF // len = 2n\n"))),(0,s.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=sizing",group:"sizing"},"const len: nat = Bytes.length(0x0AFF); // len == (2 as nat)\n"))),(0,s.kt)("h2",{id:"slicing"},"Slicing"),(0,s.kt)("p",null,"You can extract a subset from bytes with the ",(0,s.kt)("inlineCode",{parentName:"p"},"Bytes.sub")," function.\nIt accepts a nat for the index of the start of the subset and a nat for the number of bytes in the subset.\nBoth numbers are inclusive.\nThe first byte has the index 0."),(0,s.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=slicing",group:"slicing"},"let large = 0x12345678\nlet slice = Bytes.sub 1n 2n large // sub = 0x3456\n"))),(0,s.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=slicing",group:"slicing"},"const large = 0x12345678;\nconst slice = Bytes.sub(1 as nat, 2 as nat, large); // sub == 0x3456\n"))),(0,s.kt)("h2",{id:"bitwise-operations"},"Bitwise operations"),(0,s.kt)("p",null,"The bitwise operations on sequences of bytes are as follows:"),(0,s.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=bitwise",group:"bitwise"},'// Bitwise "and"\nlet and : bytes = 0x0005 land 0x0106 // 0x0004\n\n// Bitwise "or"\nlet @or : bytes = 0x0005 lor 0x0106 // 0x0107\n\n// Bitwise "xor"\nlet xor : bytes = 0x0005 lxor 0x0106 // 0x0103\n\n// Bitwise "shift left"\nlet shift_left : bytes = 0x06 lsl 8n // 0x0600\n\n// Bitwise "shift right"\nlet shift_right : bytes = 0x0006 lsr 1n // 0x0003\n'))),(0,s.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=bitwise",group:"bitwise"},'// Bitwise "and"\nconst and: bytes = 0x0005 & 0x0106; // 0x0004\n\n// Bitwise "or"\nconst or: bytes = 0x0005 | 0x0106; // 0x0107\n\n// Bitwise "xor"\nconst xor: bytes = 0x0005 ^ 0x0106; // 0x0103\n\n// Bitwise "shift left"\nconst shift_left: bytes = 0x06 << (8 as nat); // 0x0600\n\n// Bitwise "shift right"\nconst shift_right: bytes = 0x0006 >> (1 as nat); // 0x0003\n'))),(0,s.kt)("h2",{id:"packing-and-unpacking"},"Packing and unpacking"),(0,s.kt)("p",null,"LIGO provides the functions ",(0,s.kt)("inlineCode",{parentName:"p"},"Bytes.pack")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"Bytes.unpack")," to serialize and deserialize data into a binary format.\nThese functions correspond to the Michelson instructions ",(0,s.kt)("inlineCode",{parentName:"p"},"PACK")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"UNPACK"),".\nUnpacking may fail, so the return type of ",(0,s.kt)("inlineCode",{parentName:"p"},"Byte.unpack")," is an option that needs a type annotation."),(0,s.kt)("admonition",{type:"note"},(0,s.kt)("p",{parentName:"admonition"},"These functions are intended for use by developers who are familiar with data serialization.\nThere are several risks and failure cases, such as unpacking a lambda from an untrusted source or casting the result to the wrong type.")),(0,s.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=packing",group:"packing"},"let id_string (p : string) : string option =\n  let packed: bytes = Bytes.pack p\n  in Bytes.unpack packed\n"))),(0,s.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=packing",group:"packing"},"function id_string (p: string) : option<string> {\n  let packed = Bytes.pack(p);\n  return Bytes.unpack(packed);\n};\n"))),(0,s.kt)("h2",{id:"cryptography"},"Cryptography"),(0,s.kt)("p",null,"One common use of bytes, beyond packing and unpacking, is\ncryptography. The predefined module ",(0,s.kt)("inlineCode",{parentName:"p"},"Crypto")," provides the following\nhashing functions, which are efficient because they are natively\nsupported by the Michelson virtual machine:"),(0,s.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},"val blake2b : bytes -> bytes\nval sha256 : bytes -> bytes\nval sha512 : bytes -> bytes\nval sha3 : bytes -> bytes\nval keccak : bytes -> bytes\n"))),(0,s.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},"const blake2b: bytes => bytes;\nconst sha256: bytes => bytes;\nconst sha512: bytes => bytes;\nconst sha3: bytes => bytes;\nconst keccak: bytes => bytes;\n"))))}g.isMDXComponent=!0}}]);