"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[84777],{3905:(t,e,n)=>{n.d(e,{Zo:()=>d,kt:()=>h});var a=n(67294);function o(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function r(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function s(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?r(Object(n),!0).forEach((function(e){o(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function c(t,e){if(null==t)return{};var n,a,o=function(t,e){if(null==t)return{};var n,a,o={},r=Object.keys(t);for(a=0;a<r.length;a++)n=r[a],e.indexOf(n)>=0||(o[n]=t[n]);return o}(t,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(a=0;a<r.length;a++)n=r[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(o[n]=t[n])}return o}var i=a.createContext({}),p=function(t){var e=a.useContext(i),n=e;return t&&(n="function"==typeof t?t(e):s(s({},e),t)),n},d=function(t){var e=p(t.components);return a.createElement(i.Provider,{value:e},t.children)},l={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},u=a.forwardRef((function(t,e){var n=t.components,o=t.mdxType,r=t.originalType,i=t.parentName,d=c(t,["components","mdxType","originalType","parentName"]),u=p(n),h=o,_=u["".concat(i,".").concat(h)]||u[h]||l[h]||r;return n?a.createElement(_,s(s({ref:e},d),{},{components:n})):a.createElement(_,s({ref:e},d))}));function h(t,e){var n=arguments,o=e&&e.mdxType;if("string"==typeof t||o){var r=n.length,s=new Array(r);s[0]=u;var c={};for(var i in e)hasOwnProperty.call(e,i)&&(c[i]=e[i]);c.originalType=t,c.mdxType="string"==typeof t?t:o,s[1]=c;for(var p=2;p<r;p++)s[p]=n[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},97105:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>i,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>c,toc:()=>p});var a=n(87462),o=(n(67294),n(3905));const r={title:"Part 2: Testing the contract"},s=void 0,c={unversionedId:"tutorials/taco-shop/testing-contract",id:"tutorials/taco-shop/testing-contract",title:"Part 2: Testing the contract",description:"It's critical to test contracts before you deploy them because they cannot be changed after you deploy them.",source:"@site/../docs/tutorials/taco-shop/testing-contract.md",sourceDirName:"tutorials/taco-shop",slug:"/tutorials/taco-shop/testing-contract",permalink:"/previews/ligo/external-link-icon/docs/next/tutorials/taco-shop/testing-contract",draft:!1,tags:[],version:"current",frontMatter:{title:"Part 2: Testing the contract"},sidebar:"docs",previous:{title:"Part 1: Creating a contract",permalink:"/previews/ligo/external-link-icon/docs/next/tutorials/taco-shop/selling-tacos"},next:{title:"Part 3: Getting the payouts",permalink:"/previews/ligo/external-link-icon/docs/next/tutorials/taco-shop/getting-payouts"}},i={},p=[{value:"Creating tests",id:"creating-tests",level:2},{value:"Running tests",id:"running-tests",level:2},{value:"Testing with dry-run",id:"testing-with-dry-run",level:2}],d=(l="Syntax",function(t){return console.warn("Component "+l+" was not imported, exported, or provided by MDXProvider as global scope"),(0,o.kt)("div",t)});var l;const u={toc:p};function h(t){let{components:e,...n}=t;return(0,o.kt)("wrapper",(0,a.Z)({},u,n,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"It's critical to test contracts before you deploy them because they cannot be changed after you deploy them.\nLIGO includes automated testing tools that let you test contracts and verify that they work the way you intend before you deploy them.\nIn this section, you add tests for the ",(0,o.kt)("inlineCode",{parentName:"p"},"buy_taco")," entrypoint."),(0,o.kt)("h2",{id:"creating-tests"},"Creating tests"),(0,o.kt)("p",null,"You can put tests in the same file as the contract or in a different file.\nFor convenience, in this tutorial, you put the tests in the same file."),(0,o.kt)(d,{syntax:"jsligo",mdxType:"Syntax"},"1. At the end of the contract file, outside of the namespace, add this convenience function to call the view and get the current price of a taco:",(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},'// Convenience function to get current taco price\nconst get_taco_price = (untyped_address: address, taco_kind_index: nat): tez => {\n  const view_result_option: option<tez> = Tezos.View.call("get_taco_price", taco_kind_index, untyped_address);\n  return $match(view_result_option, {\n    "Some": (cost_mutez) => cost_mutez,\n    "None": () => Test.Assert.failwith("Couldn\'t get the price of the taco."),\n  });\n}\n')),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Add this convenience function to verify the current stock and maximum price of a taco:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},'// Convenience function for testing equality in maps\nconst eq_in_map = (r: TacoShop.taco_supply, m: TacoShop.taco_data, k: nat) =>\n  $match(Map.find_opt(k, m), {\n    "None": () => false,\n    "Some": (v) => v.current_stock == r.current_stock && v.max_price == r.max_price\n  });\n')),(0,o.kt)("p",{parentName:"li"},"This function accepts information about a taco type and verifies that the values in the stored map match.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"At the end of the contract file, outside of the namespace, add this stub of a function to hold the test logic:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},"const test = (() => {\n\n  // Test logic goes here\n\n}) ();\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Inside the test function, add code to deploy the contract in the test scenario:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},"// Set the initial storage and deploy the contract\nconst admin_address: address = Test.Account.address(0 as nat);\nconst initial_storage: TacoShop.storage = {\n  admin_address: admin_address,\n  taco_data: TacoShop.default_taco_data,\n}\nconst contract = Test.Originate.contract(contract_of(TacoShop), initial_storage, 0 as tez);\n")),(0,o.kt)("p",{parentName:"li"},"This code creates the ",(0,o.kt)("inlineCode",{parentName:"p"},"contract")," object to represent the deployed (originated) contract.\nThis object has a few fields, but the main one the test uses is the ",(0,o.kt)("inlineCode",{parentName:"p"},"taddr")," field, which is the address of the deployed contract.\nNow you can call the deployed contract in the test scenario.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Get the current price of one kind of taco by calling the ",(0,o.kt)("inlineCode",{parentName:"p"},"get_taco_price")," function:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},"// Get the current price of a taco\nconst untyped_address = Test.Typed_address.to_address(contract.taddr);\nconst current_price = get_taco_price(untyped_address, 1 as nat);\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Call the ",(0,o.kt)("inlineCode",{parentName:"p"},"buy_taco")," entrypoint with this code:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},'// Purchase a taco\nconst success_result =\n  Test.Contract.transfer(\n    Test.Typed_address.get_entrypoint("buy_taco", contract.taddr),\n    1 as nat,\n    current_price\n  );\n')),(0,o.kt)("p",{parentName:"li"},"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Test.Contract.transfer")," function calls an entrypoint in a test scenario.\nIt takes these parameters:"),(0,o.kt)("ol",{parentName:"li"},(0,o.kt)("li",{parentName:"ol"},"The contract to call, here represented by the ",(0,o.kt)("inlineCode",{parentName:"li"},"buy_taco")," entrypoint of the contract."),(0,o.kt)("li",{parentName:"ol"},"The parameter to pass to the entrypoint, in this case ",(0,o.kt)("inlineCode",{parentName:"li"},"1 as nat")," to represent the first type of taco."),(0,o.kt)("li",{parentName:"ol"},"The amount of tez to send with the transaction, in this case the current price of that type of taco from the previous lines of code."))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Verify that the transaction completed successfully and that the number of tacos of that type decreased by 1:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},'// Verify that the stock was updated\n$match(success_result, {\n  "Success": (_s) => (() => {\n    const storage = Test.Typed_address.get_storage(contract.taddr);\n    // Check that the stock has been updated correctly\n    Assert.assert(\n      eq_in_map(\n        { current_stock: 49 as nat, max_price: 50000000 as mutez },\n        storage.taco_data,\n        1 as nat\n      ));\n    // Check that the amount of the other taco type has not changed\n    Assert.assert(eq_in_map(\n        { current_stock: 20 as nat, max_price: 75000000 as mutez },\n        storage.taco_data,\n        2 as nat\n      )\n    );\n    Test.IO.log("Successfully bought a taco");\n})(),\n  "Fail": err => failwith(err),\n});\n'))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Verify that the entrypoint fails when a client passes the wrong price:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},'// Fail to purchase a taco without sending enough tez\nconst fail_result =\n  Test.Contract.transfer(\n    Test.Typed_address.get_entrypoint("buy_taco", contract.taddr),\n    1 as nat,\n    1 as mutez\n  );\n$match(fail_result, {\n  "Success": _s => failwith("Test was able to buy a taco for the wrong price"),\n  "Fail": _err => Test.IO.log("Contract successfully blocked purchase with incorrect price"),\n});\n')),(0,o.kt)("p",{parentName:"li"},"It's important to test failure cases as well as success cases to make sure the contract works properly in all cases."))),(0,o.kt)("p",null,"The completed contract file with convenience functions and test functions looks like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=testing_contract",group:"testing_contract"},'namespace TacoShop {\n  export type taco_supply = { current_stock: nat, max_price: tez };\n  export type taco_data = map<nat, taco_supply>;\n  export type admin_address = address;\n  export type storage = {\n    admin_address: admin_address,\n    taco_data: taco_data,\n  };\n\n  export const default_taco_data: taco_data = Map.literal([\n    [1 as nat, { current_stock: 50 as nat, max_price: 50 as tez }],\n    [2 as nat, { current_stock: 20 as nat, max_price: 75 as tez }]\n  ]);\n\n  // Internal function to get the price of a taco\n  const get_taco_price_internal = (taco_kind_index: nat, taco_data: taco_data): tez => {\n    const taco_kind: taco_supply =\n      $match (Map.find_opt(taco_kind_index, taco_data), {\n        "Some": (kind) => kind,\n        "None": () => failwith("Unknown kind of taco"),\n      });\n    return taco_kind.max_price / taco_kind.current_stock;\n  }\n\n  // @view\n  const get_taco_price = (taco_kind_index: nat, storage: storage): tez =>\n    get_taco_price_internal(taco_kind_index, storage.taco_data);\n\n  // Buy a taco\n  // @entry\n  const buy_taco = (taco_kind_index: nat, storage: storage): [\n      list<operation>,\n      storage\n    ] => {\n\n    const { admin_address, taco_data } = storage;\n\n    // Retrieve the kind of taco from the contracts storage or fail\n    const taco_kind: taco_supply =\n      $match (Map.find_opt(taco_kind_index, taco_data), {\n        "Some": (kind) => kind,\n        "None": () => failwith("Unknown kind of taco"),\n      });\n\n    // Get the current price of this type of taco\n    const current_purchase_price = get_taco_price_internal(taco_kind_index, taco_data);\n\n    // Verify that the caller sent the correct amount of tez\n    if ((Tezos.get_amount()) != current_purchase_price) {\n      return failwith("Sorry, the taco you are trying to purchase has a different price");\n    }\n\n    // Verify that there is at least one of this type of taco\n    if (taco_kind.current_stock == (0 as nat)) {\n      return failwith("Sorry, we are out of this type of taco");\n    }\n\n    // Update the storage with the new quantity of tacos\n    const updated_taco_data: taco_data = Map.update(\n      taco_kind_index,\n      ["Some" as "Some", {...taco_kind, current_stock: abs(taco_kind.current_stock - 1) }],\n      taco_data);\n\n    const updated_storage: storage = {\n      admin_address: admin_address,\n      taco_data: updated_taco_data,\n    };\n\n    return [[], updated_storage];\n  }\n\n  // @entry\n  const payout = (_u: unit, storage: storage): [\n      list<operation>,\n      storage\n    ] => {\n\n    // Entrypoint logic goes here\n\n    return [[], storage];\n  }\n\n};\n\n// Convenience function to get current taco price\nconst get_taco_price = (untyped_address: address, taco_kind_index: nat): tez => {\n  const view_result_option: option<tez> = Tezos.View.call("get_taco_price", taco_kind_index, untyped_address);\n  return $match(view_result_option, {\n    "Some": cost_mutez => cost_mutez,\n    "None": () => Test.Assert.failwith("Couldn\'t get the price of the taco."),\n  });\n}\n\n// Convenience function for testing equality in maps\nconst eq_in_map = (r: TacoShop.taco_supply, m: TacoShop.taco_data, k: nat) =>\n  $match(Map.find_opt(k, m), {\n    "None": () => false,\n    "Some": (v) => v.current_stock == r.current_stock && v.max_price == r.max_price\n  });\n\nconst test = (() => {\n\n  // Set the initial storage and deploy the contract\n  const admin_address: address = Test.Account.address(0 as nat);\n  const initial_storage: TacoShop.storage = {\n    admin_address: admin_address,\n    taco_data: TacoShop.default_taco_data,\n  }\n  const contract = Test.Originate.contract(contract_of(TacoShop), initial_storage, 0 as tez);\n\n  // Get the current price of a taco\n  const untyped_address = Test.Typed_address.to_address(contract.taddr);\n  const current_price = get_taco_price(untyped_address, 1 as nat);\n\n  // Purchase a taco\n  const success_result =\n    Test.Contract.transfer(\n      Test.Typed_address.get_entrypoint("buy_taco", contract.taddr),\n      1 as nat,\n      current_price\n    );\n\n  // Verify that the stock was updated\n  $match(success_result, {\n    "Success": (_s) => (() => {\n      const storage = Test.Typed_address.get_storage(contract.taddr);\n      // Check that the stock has been updated correctly\n      Assert.assert(\n        eq_in_map(\n          { current_stock: 49 as nat, max_price: 50000000 as mutez },\n          storage.taco_data,\n          1 as nat\n        ));\n      // Check that the amount of the other taco type has not changed\n      Assert.assert(eq_in_map(\n          { current_stock: 20 as nat, max_price: 75000000 as mutez },\n          storage.taco_data,\n          2 as nat\n        )\n      );\n      Test.IO.log("Successfully bought a taco");\n  })(),\n    "Fail": err => failwith(err),\n  });\n\n  // Fail to purchase a taco without sending enough tez\n  const fail_result =\n    Test.Contract.transfer(\n      Test.Typed_address.get_entrypoint("buy_taco", contract.taddr),\n      1 as nat,\n      1 as mutez\n    );\n  $match(fail_result, {\n    "Success": _s => failwith("Test was able to buy a taco for the wrong price"),\n    "Fail": _err => Test.IO.log("Contract successfully blocked purchase with incorrect price"),\n  });\n}) ();\n'))),(0,o.kt)(d,{syntax:"cameligo",mdxType:"Syntax"},"1. At the end of the contract file, outside of the module, add this convenience function to call the view and get the current price of a taco:",(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},'(* Convenience function to get current taco price *)\nlet get_taco_price (untyped_address : address) (taco_kind_index : nat) : tez =\n  let view_result_option : tez option = Tezos.View.call\n    "get_taco_price"\n    taco_kind_index\n    untyped_address in\n  match view_result_option with\n  | Some cost_mutez -> cost_mutez\n  | None -> Test.Assert.failwith "Couldn\'t get the price of a taco"\n')),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Add this convenience function to verify the current stock and maximum price of a taco:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},"(* Convenience function for testing equality in maps *)\nlet eq_in_map (r : TacoShop.taco_supply) (m : TacoShop.taco_data) (k : nat) =\n  match Map.find_opt k m with\n  | None -> false\n  | Some v -> v.current_stock = r.current_stock && v.max_price = r.max_price\n")),(0,o.kt)("p",{parentName:"li"},"This function accepts information about a taco type and verifies that the values in the stored map match.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"At the end of the contract file, outside of the namespace, create a function to hold the test logic:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},"let test =\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Inside the test function, add code to deploy the contract in the test scenario:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},"(* Set the initial storage and deploy the contract *)\nlet admin_address : address = Test.Account.address 0n in\nlet initial_storage : TacoShop.storage = {\n  admin_address = admin_address;\n  taco_data = TacoShop.default_taco_data\n} in\nlet contract = Test.Originate.contract (contract_of TacoShop) initial_storage 0tez in\n")),(0,o.kt)("p",{parentName:"li"},"This code creates the ",(0,o.kt)("inlineCode",{parentName:"p"},"contract")," object to represent the deployed (originated) contract.\nThis object has a few fields, but the main one the test uses is the ",(0,o.kt)("inlineCode",{parentName:"p"},"taddr")," field, which is the address of the deployed contract.\nNow you can call the deployed contract in the test scenario.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Get the current price of one kind of taco by calling the ",(0,o.kt)("inlineCode",{parentName:"p"},"get_taco_price")," function:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},"(* Get the current price of a taco *)\nlet untyped_address = Test.Typed_address.to_address contract.taddr in\nlet current_price = get_taco_price untyped_address 1n in\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Call the ",(0,o.kt)("inlineCode",{parentName:"p"},"buy_taco")," entrypoint with this code:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},'(* Purchase a taco *)\nlet success_result =\n  Test.Contract.transfer\n    (Test.Typed_address.get_entrypoint "buy_taco" contract.taddr)\n    1n\n    current_price\n  in\n')),(0,o.kt)("p",{parentName:"li"},"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Test.Contract.transfer")," function calls an entrypoint in a test scenario.\nIt takes these parameters:"),(0,o.kt)("ol",{parentName:"li"},(0,o.kt)("li",{parentName:"ol"},"The contract to call, here represented by the ",(0,o.kt)("inlineCode",{parentName:"li"},"buy_taco")," entrypoint of the contract."),(0,o.kt)("li",{parentName:"ol"},"The parameter to pass to the entrypoint, in this case ",(0,o.kt)("inlineCode",{parentName:"li"},"1n")," to represent the first type of taco."),(0,o.kt)("li",{parentName:"ol"},"The amount of tez to send with the transaction, in this case the current price of that type of taco from the previous lines of code."))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Verify that the transaction completed successfully and that the number of tacos of that type decreased by 1:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},'(* Verify that the stock was updated *)\nlet () = match success_result with\n  | Success _s ->\n    let storage = Test.Typed_address.get_storage contract.taddr in\n    let () = Assert.assert (eq_in_map\n      { current_stock = 49n; max_price = 50000000mutez }\n      storage.taco_data\n      1n\n    ) in\n    let () = Assert.assert (eq_in_map\n      { current_stock = 20n; max_price = 75000000mutez }\n      storage.taco_data\n      2n\n    ) in\n    Test.IO.log "Successfully bought a taco"\n  | Fail err -> failwith err\n  in\n'))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Verify that the entrypoint fails when a client passes the wrong price:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},'(* Fail to purchase a taco without sending enough tez *)\nlet fail_result = Test.Contract.transfer\n  (Test.Typed_address.get_entrypoint "buy_taco" contract.taddr)\n  1n\n  1mutez in\nmatch fail_result with\n| Success _s -> failwith "Test was able to buy a taco for the wrong price"\n| Fail _err -> Test.IO.log "Contract successfully blocked purchase with incorrect price"\n')),(0,o.kt)("p",{parentName:"li"},"It's important to test failure cases as well as success cases to make sure the contract works properly in all cases."))),(0,o.kt)("p",null,"The completed contract file with the convenience functions and test functions looks like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=testing_contract",group:"testing_contract"},'module TacoShop = struct\n  type taco_supply = { current_stock: nat; max_price: tez }\n  type taco_data = (nat, taco_supply) map\n  type admin_address = address\n  type storage = {\n    admin_address: admin_address;\n    taco_data: taco_data;\n  }\n\n  let default_taco_data: taco_data = Map.literal [\n    (1n, { current_stock = 50n; max_price = 50tez });\n    (2n, { current_stock = 20n; max_price = 75tez });\n  ]\n\n  (* Internal function to get the price of a taco *)\n  let get_taco_price_internal (taco_kind_index : nat) (taco_data : taco_data) : tez =\n    let taco_kind : taco_supply =\n      match Map.find_opt taco_kind_index taco_data with\n      | Some kind -> kind\n      | None -> failwith "Unknown kind of taco"\n      in\n      taco_kind.max_price / taco_kind.current_stock\n\n  [@view]\n  let get_taco_price (taco_kind_index : nat) (storage : storage) : tez =\n    get_taco_price_internal taco_kind_index storage.taco_data\n\n  (* Buy a taco *)\n  [@entry]\n  let buy_taco (taco_kind_index : nat) (storage : storage) : operation list * storage =\n\n    let { admin_address; taco_data } = storage in\n\n    (* Retrieve the kind of taco from the contracts storage or fail *)\n    let taco_kind : taco_supply =\n      match Map.find_opt taco_kind_index taco_data with\n      | Some kind -> kind\n      | None -> failwith "Unknown kind of taco" in\n\n    (* Get the current price of this type of taco *)\n    let current_purchase_price = get_taco_price_internal taco_kind_index taco_data in\n\n    (* Verify that the caller sent the correct amount of tez *)\n    let _ = if (Tezos.get_amount () <> current_purchase_price) then\n      failwith "Sorry, the taco you are trying to purchase has a different price" in\n\n    (* Verify that there is at least one of this type of taco *)\n    let _ = if (taco_kind.current_stock = 0n) then\n      failwith "Sorry, we are out of this type of taco" in\n\n\n    (* Update the storage with the new quantity of tacos *)\n    let updated_taco_data : taco_data = Map.update\n      taco_kind_index\n      (Some { taco_kind with current_stock = abs (taco_kind.current_stock - 1n) })\n      taco_data in\n\n\n    let updated_storage : storage = {\n      admin_address = admin_address;\n      taco_data = updated_taco_data;\n    } in\n\n    [], updated_storage\n\n    [@entry]\n    let payout (_u : unit) (storage : storage) : operation list * storage =\n\n      (* Entrypoint logic goes here *)\n\n      [], storage\n\n  end\n\n(* Convenience function to get current taco price *)\nlet get_taco_price (untyped_address : address) (taco_kind_index : nat) : tez =\n  let view_result_option : tez option = Tezos.View.call\n    "get_taco_price"\n    taco_kind_index\n    untyped_address in\n  match view_result_option with\n  | Some cost_mutez -> cost_mutez\n  | None -> Test.Assert.failwith "Couldn\'t get the price of a taco"\n\n(* Convenience function for testing equality in maps *)\nlet eq_in_map (r : TacoShop.taco_supply) (m : TacoShop.taco_data) (k : nat) =\n  match Map.find_opt k m with\n  | None -> false\n  | Some v -> v.current_stock = r.current_stock && v.max_price = r.max_price\n\nlet test =\n\n  (* Set the initial storage and deploy the contract *)\n  let admin_address : address = Test.Account.address 0n in\n  let initial_storage : TacoShop.storage = {\n    admin_address = admin_address;\n    taco_data = TacoShop.default_taco_data\n  } in\n  let contract = Test.Originate.contract (contract_of TacoShop) initial_storage 0tez in\n\n  (* Get the current price of a taco *)\n  let untyped_address = Test.Typed_address.to_address contract.taddr in\n  let current_price = get_taco_price untyped_address 1n in\n\n  (* Purchase a taco *)\n  let success_result =\n    Test.Contract.transfer\n      (Test.Typed_address.get_entrypoint "buy_taco" contract.taddr)\n      1n\n      current_price\n    in\n\n  (* Verify that the stock was updated *)\n  let () = match success_result with\n    | Success _s ->\n      let storage = Test.Typed_address.get_storage contract.taddr in\n      let () = Assert.assert (eq_in_map\n        { current_stock = 49n; max_price = 50000000mutez }\n        storage.taco_data\n        1n\n      ) in\n      let () = Assert.assert (eq_in_map\n        { current_stock = 20n; max_price = 75000000mutez }\n        storage.taco_data\n        2n\n      ) in\n      Test.IO.log "Successfully bought a taco"\n    | Fail err -> failwith err\n    in\n\n    (* Fail to purchase a taco without sending enough tez *)\n    let fail_result = Test.Contract.transfer\n      (Test.Typed_address.get_entrypoint "buy_taco" contract.taddr)\n      1n\n      1mutez in\n    match fail_result with\n    | Success _s -> failwith "Test was able to buy a taco for the wrong price"\n    | Fail _err -> Test.IO.log "Contract successfully blocked purchase with incorrect price"\n'))),(0,o.kt)("h2",{id:"running-tests"},"Running tests"),(0,o.kt)("p",null,"LIGO tests do not run automatically when you run the ",(0,o.kt)("inlineCode",{parentName:"p"},"ligo compile contract")," command; you must run them with the ",(0,o.kt)("inlineCode",{parentName:"p"},"ligo run test")," command."),(0,o.kt)("p",null,"Run the tests in the contract file by running this command:"),(0,o.kt)(d,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"ligo run test taco_shop.jsligo\n"))),(0,o.kt)(d,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"ligo run test taco_shop.mligo\n"))),(0,o.kt)("p",null,"The console response prints the messages from the calls to ",(0,o.kt)("inlineCode",{parentName:"p"},"Test.IO.log")," and a message that the test function completed:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'"Successfully bought a taco"\n"Contract successfully blocked purchase with incorrect price"\nEverything at the top-level was executed.\n- test exited with value ().\n')),(0,o.kt)("p",null,"If you want to expand the tests for your contract, you can add more test functions or more test code to the existing function.\nFor example, you can try buying the other kind of taco or buying more of the first kind of taco and verifying that the stock and price changes as expected."),(0,o.kt)("h2",{id:"testing-with-dry-run"},"Testing with dry-run"),(0,o.kt)("p",null,"Another way to test contracts is with the ",(0,o.kt)("inlineCode",{parentName:"p"},"ligo run dry-run")," command.\nThis command runs the contract in a simulated environment with parameters that you provide on the command line.\nYou pass these arguments to the command:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The contract file to run"),(0,o.kt)("li",{parentName:"ul"},"The amount of tez to pass with the transaction"),(0,o.kt)("li",{parentName:"ul"},"The parameter to pass to the contract, as a LIGO expression"),(0,o.kt)("li",{parentName:"ul"},"The value of the contract storage, as a LIGO expression")),(0,o.kt)("p",null,"For example, you can test the ",(0,o.kt)("inlineCode",{parentName:"p"},"buy_taco")," entrypoint with this command:"),(0,o.kt)(d,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'ligo run dry-run taco_shop.jsligo -m TacoShop --amount 1 \'["Buy_taco" as "Buy_taco", 1 as nat]\' \\\n  \'{admin_address: "tz1QCVQinE8iVj1H2fckqx6oiM85CNJSK9Sx" as address, taco_data: TacoShop.default_taco_data}\'\n')),(0,o.kt)("p",null,"The entrypoint and parameter in this command are formatted as a variant type.\nWhen the contract is compiled to Michelson, its parameter is a variant that has cases for each entrypoint, so you must pass the variant that corresponds to the entrypoint.\nFor the purposes of the ",(0,o.kt)("inlineCode",{parentName:"p"},"ligo run dry-run")," command, the variant type is the name of the entrypoint with the first letter in upper case.\nNote also that you can use variables from the contract (as in ",(0,o.kt)("inlineCode",{parentName:"p"},"TacoShop.default_taco_data"),") in the command because the contract parameter and storage value are LIGO expressions.")),(0,o.kt)(d,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'ligo run dry-run taco_shop.mligo -m TacoShop --amount 1 "Buy_taco 1n" \\\n  \'{admin_address = "tz1QCVQinE8iVj1H2fckqx6oiM85CNJSK9Sx" ; taco_data = TacoShop.default_taco_data}\'\n')),(0,o.kt)("p",null,"Note that the entrypoint name starts with a capital letter when you use it in a dry run.\nNote also that you can use variables from the contract (as in ",(0,o.kt)("inlineCode",{parentName:"p"},"TacoShop.default_taco_data"),") in the command because the contract parameter and storage value are LIGO expressions.")),(0,o.kt)("p",null,"The address in the dry run command isn't stored beyond this run of the command; you just need to provide any address for the amin address in storage.\nHowever, you must use the ",(0,o.kt)("inlineCode",{parentName:"p"},"as address")," declaration to specify that the string is a LIGO ",(0,o.kt)("inlineCode",{parentName:"p"},"address")," type; without the type declaration, LIGO would assume that it was a string."),(0,o.kt)("p",null,"The output of the command is the return value of the entrypoint that you called.\nIn this case, it is an empty list of operations (",(0,o.kt)("inlineCode",{parentName:"p"},"LIST_EMPTY()"),") and the code for the new state of the storage."),(0,o.kt)("p",null,"In this way, you can test different storage states and entrypoints from the command line.\nSometimes testing with a dry run can be more convenient than writing tests; it's up to you how to test the contract."),(0,o.kt)("p",null,"Now you know that the customer interface of the contract works.\nIn the next section, you implement the ",(0,o.kt)("inlineCode",{parentName:"p"},"payout")," entrypoint to retrieve the profits.\nContinue to ",(0,o.kt)("a",{parentName:"p",href:"./getting-payouts"},"Part 3: Getting the payouts"),"."))}h.isMDXComponent=!0}}]);