"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[90464],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>d});var a=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var p=a.createContext({}),s=function(e){var n=a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},u=function(e){var n=s(e.components);return a.createElement(p.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,p=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),c=s(t),d=i,g=c["".concat(p,".").concat(d)]||c[d]||m[d]||o;return t?a.createElement(g,r(r({ref:n},u),{},{components:t})):a.createElement(g,r({ref:n},u))}));function d(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,r=new Array(o);r[0]=c;var l={};for(var p in n)hasOwnProperty.call(n,p)&&(l[p]=n[p]);l.originalType=e,l.mdxType="string"==typeof e?e:i,r[1]=l;for(var s=2;s<o;s++)r[s]=t[s];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},48720:(e,n,t)=>{t.d(n,{D:()=>i.Z,Z:()=>o});var a=t(67294),i=t(75402);const o=function(e){return a.createElement(i.Z.Consumer,null,(n=>{let{syntax:t}=n;return t===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},90306:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>c,frontMatter:()=>r,metadata:()=>p,toc:()=>u});var a=t(87462),i=(t(67294),t(3905)),o=t(48720);const r={id:"unit-option-pattern-matching",title:"Unit, Option, Pattern matching"},l=void 0,p={unversionedId:"language-basics/unit-option-pattern-matching",id:"version-1.6.0/language-basics/unit-option-pattern-matching",title:"Unit, Option, Pattern matching",description:"Optional values are a pervasive programming pattern in OCaml. Since",source:"@site/versioned_docs/version-1.6.0/language-basics/unit-option-pattern-matching.md",sourceDirName:"language-basics",slug:"/language-basics/unit-option-pattern-matching",permalink:"/previews/ligo/external-link-icon/docs/1.6.0/language-basics/unit-option-pattern-matching",draft:!1,tags:[],version:"1.6.0",frontMatter:{id:"unit-option-pattern-matching",title:"Unit, Option, Pattern matching"}},s={},u=[{value:"The unit Type",id:"the-unit-type",level:2},{value:"Discriminated union type",id:"discriminated-union-type",level:2},{value:"Variant types",id:"variant-types",level:2},{value:"Optional values",id:"optional-values",level:2},{value:"Pattern matching",id:"pattern-matching",level:2},{value:"Match on variants",id:"match-on-variants",level:3},{value:"Matching records or tuples",id:"matching-records-or-tuples",level:3},{value:"Matching lists",id:"matching-lists",level:3},{value:"Deep patterns",id:"deep-patterns",level:3}],m={toc:u};function c(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Optional values are a pervasive programming pattern in OCaml. Since\nMichelson and LIGO are both inspired by OCaml, ",(0,i.kt)("em",{parentName:"p"},"optional types")," are\navailable in LIGO as well. Similarly, OCaml features a ",(0,i.kt)("em",{parentName:"p"},"unit")," type,\nand LIGO features it as well. Both the option type and the unit type\nare instances of a more general kind of types: ",(0,i.kt)("em",{parentName:"p"},"variant types"),"."),(0,i.kt)("h2",{id:"the-unit-type"},"The unit Type"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"unit")," type in Michelson or LIGO is a predefined type that\ncontains only one value that carries no information. It is used when\nno relevant information is required or produced. Here is how it used."),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"In CameLIGO, the unique value of the ",(0,i.kt)("inlineCode",{parentName:"p"},"unit")," type is ",(0,i.kt)("inlineCode",{parentName:"p"},"()"),", following\nthe OCaml convention."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=a",group:"a"},"let n : unit = ()\n")),(0,i.kt)("p",null,"Sequences of expressions that return the ",(0,i.kt)("inlineCode",{parentName:"p"},"unit")," type can be written\nusing ",(0,i.kt)("inlineCode",{parentName:"p"},"begin")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"end"),", separating expressions using semi-colons. The\nlast expression, which represents the value returned, can have a\ndifferent type to ",(0,i.kt)("inlineCode",{parentName:"p"},"unit"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=a",group:"a"},"let m (x : int) =\n  begin\n    assert (x > 0);\n    assert (x < 10);\n    x\n  end\n"))),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"In JsLIGO, the unique value of the ",(0,i.kt)("inlineCode",{parentName:"p"},"unit")," type is ",(0,i.kt)("inlineCode",{parentName:"p"},"[]"),". The global variable ",(0,i.kt)("inlineCode",{parentName:"p"},"unit")," contains ",(0,i.kt)("inlineCode",{parentName:"p"},"[]")," so that name can be used for clarity, but the value is the same."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=a",group:"a"},"let u1 : unit = [];\nlet u2 : unit = unit;\nlet eq = (u1 == u2); // true\n"))),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("h2",{id:"discriminated-union-type"},"Discriminated union type"),(0,i.kt)("p",null,"The simplest form of pattern matching in JsLIGO is with the help of a discriminated\nunion type, which should be familiar for developers coming from TypeScript."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo"},'type foo =\n  { kind: "increment", amount: int}\n| { kind: "decrement", amount: int}\n| { kind: "reset"};\n')),(0,i.kt)("p",null,"Here, the ",(0,i.kt)("inlineCode",{parentName:"p"},"kind")," field is unique among the objects. If not, an error will be\ngenerated. Also, if multiple fields are present which can be used as unique\nfield, only the first unique field will be used."),(0,i.kt)("p",null,"Creating an object from a discriminated union type requires all the fields\nto be fully written. So for increment that would be:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo"},'let obj = { kind: "increment", amount: 3};\n')),(0,i.kt)("p",null,"or"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo"},'let obj2 = { kind: "reset" };\n')),(0,i.kt)("p",null,"Pattern matching over a discriminated union type works like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo"},'function foo (item: foo) {\n  let state = 0;\n  switch(item.kind) {\n    case "increment":\n      state += item.amount;\n      break\n    case "decrement":\n      state -= item.amount;\n      break\n    case "reset":\n      state = 0;\n      break\n  }\n}\n')),(0,i.kt)("p",null,"Note that all cases of the discriminated union must be handled, if not an error\nwill be generated."),(0,i.kt)("p",null,'These "strict" rules on discriminated union types help prevent bugs where cases are not handled correctly.')),(0,i.kt)("h2",{id:"variant-types"},"Variant types"),(0,i.kt)("p",null,"A variant type is a user-defined or a built-in type (in case of\noptions) that defines a type by cases, so a value of a variant type is\neither this, or that or... The simplest variant type is equivalent to\nthe enumerated types found in Java, C++, JavaScript etc."),(0,i.kt)("p",null,"Here is how we define a coin as being either head or tail (and nothing\nelse):"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=b",group:"b"},"type coin = Head | Tail\nlet head : coin = Head\nlet tail : coin = Tail\n"))),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=b",group:"b"},'type coin = ["Head"] | ["Tail"];\nlet head: coin = Head();\nlet tail: coin = Tail();\n'))),(0,i.kt)("p",null,"The names ",(0,i.kt)("inlineCode",{parentName:"p"},"Head")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Tail")," in the definition of the type ",(0,i.kt)("inlineCode",{parentName:"p"},"coin")," are\ncalled ",(0,i.kt)("em",{parentName:"p"},"data constructors"),", or ",(0,i.kt)("em",{parentName:"p"},"variants"),". In this particular, they\ncarry no information beyond their names, so they are called ",(0,i.kt)("em",{parentName:"p"},"constant\nconstructors"),"."),(0,i.kt)("p",null,"In general, it is interesting for variants to carry some information,\nand thus go beyond enumerated types. In the following, we show how to\ndefine different kinds of users of a system."),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=c",group:"c"},"type id = nat\n\ntype user =\n  Admin   of id\n| Manager of id\n| Guest\n\nlet u : user = Admin 1000n\nlet g : user = Guest\n")),(0,i.kt)("p",null,"In CameLIGO, a constant constructor is equivalent to the same constructor\ntaking an argument of type ",(0,i.kt)("inlineCode",{parentName:"p"},"unit"),", so, for example, ",(0,i.kt)("inlineCode",{parentName:"p"},"Guest")," is the\nsame value as ",(0,i.kt)("inlineCode",{parentName:"p"},"Guest ()"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=c",group:"c"},'type id = nat;\n\ntype user =\n  ["Admin", id]\n| ["Manager", id]\n| ["Guest"];\n\nconst u : user = Admin(1000n);\nconst g : user = Guest();\n')),(0,i.kt)("p",null,"In JsLIGO, a constant constructor is equivalent to the same constructor\ntaking an argument of type ",(0,i.kt)("inlineCode",{parentName:"p"},"unit"),", so, for example, ",(0,i.kt)("inlineCode",{parentName:"p"},"Guest ()")," is the\nsame value as ",(0,i.kt)("inlineCode",{parentName:"p"},"Guest (unit)"),".")),(0,i.kt)("p",null,"There are cases where several sum types match a given constructor."),(0,i.kt)("p",null,"In the example below, types ",(0,i.kt)("inlineCode",{parentName:"p"},"t1")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"t6")," are all possible types for ",(0,i.kt)("inlineCode",{parentName:"p"},"x"),"."),(0,i.kt)("p",null,"In this case, the compiler will choose one of these types as the type\nof the expression, and throw a warning stating that other types are\npossible."),(0,i.kt)("p",null,"You can add a type annotation to remove this ambiguity."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"NOTE")," : The compiler will choose in priority the latest matching\nsum type in the current scope, if no type is defined in this scope, it\nwill look in the latest module, if not in the second latest etc.\nBelow, it will choose ",(0,i.kt)("inlineCode",{parentName:"p"},"t1"),", and if ",(0,i.kt)("inlineCode",{parentName:"p"},"t1")," didn't match it would have\nchosen ",(0,i.kt)("inlineCode",{parentName:"p"},"t2"),", otherwise ",(0,i.kt)("inlineCode",{parentName:"p"},"t3"),", etc."),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=multi_sum",group:"multi_sum"},"type t2 = A of int | B of int\n\nmodule MyModule = struct\n  type t5 = A of int | C of bool\n  type t4 = A of int | D of int\n\n  module MySubModule = struct\n    type t6 = A of int | E of tez\n  end\nend\n\nmodule MySecondModule = struct\n  type t3 = A of int | F of int\nend\n\ntype t1 = A of int | G of tez\n\n// The compiler will search above for sum types with an 'A' constructor\nlet x = A 42\n"))),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=multi_sum",group:"multi_sum"},'type t2 = ["A", int] | ["B", int];\n\nnamespace MyModule {\n  type t5 = ["A", int] | ["C", bool];\n  type t4 = ["A", int] | ["D", int];\n\n  namespace MySubModule {\n    type t6 = ["A", int] | ["E", tez];\n  }\n}\n\nnamespace MySecondModule {\n  type t3 = ["A", int] | ["F", int];\n}\n\ntype t1 = ["A", int] | ["G", tez];\n\n// The compiler will search above for sum types with an \'A\' constructor\nconst x = A(42);\n'))),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"In CameLigo when looking for a matching sum type, the compiler will\nnot look in shadowed modules.  The below code will throw an error\nbecause type ",(0,i.kt)("inlineCode",{parentName:"p"},"t1")," is in a shadowed module and thus not accessible."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=sum_shadow",group:"sum_shadow"},"module M = struct\n  type t1 = A of int | B of int\nend\nmodule M = struct\n  let y = 10\nend\n\n(* This will fail because A will not be found *)\n(* let x = A 42 *)\n"))),(0,i.kt)("h2",{id:"optional-values"},"Optional values"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"option")," type is a predefined variant type that is used to express\nwhether there is a value of some type or none. This is especially\nuseful when calling a ",(0,i.kt)("em",{parentName:"p"},"partial function"),", that is, a function that is\nnot defined for some inputs. In that case, the value of the ",(0,i.kt)("inlineCode",{parentName:"p"},"option"),"\ntype would be ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),", otherwise ",(0,i.kt)("inlineCode",{parentName:"p"},"Some (v)"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," is some\nmeaningful value ",(0,i.kt)("em",{parentName:"p"},"of any type"),". An example in arithmetic is the\ndivision operation:"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=d",group:"d"},"let div (a, b : nat * nat) : nat option =\n  if b = 0n then None else Some (a/b)\n"))),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=d",group:"d"},"function div (a: nat, b: nat): option<nat> {\n  if (b == 0n) return None() else return Some(a/b)\n};\n"))),(0,i.kt)("p",null,"You can extract the value of a ",(0,i.kt)("inlineCode",{parentName:"p"},"Some (v)")," with the function ",(0,i.kt)("inlineCode",{parentName:"p"},"Option.unopt (Some (v))"),". In case the value is ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),", this will fail with an error."),(0,i.kt)("p",null,"The proper way to deal with optional values is by means of pattern matching."),(0,i.kt)("h2",{id:"pattern-matching"},"Pattern matching"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Pattern matching")," is similar to the ",(0,i.kt)("inlineCode",{parentName:"p"},"switch")," construct in\nJavaScript, and can be used to route the program's control flow based\non the value of a variant, record, tuple, or list."),(0,i.kt)("p",null,"A component of a pattern can be discarded by using a wildcard ",(0,i.kt)("inlineCode",{parentName:"p"},"_"),"\ninstead of a variable name."),(0,i.kt)("p",null,"LIGO will warn about unused variables bound in patterns in the same\nway that function arguments are warned about. Variable names beginning\nwith ",(0,i.kt)("inlineCode",{parentName:"p"},"_")," can be used as a binder to prevent warnings."),(0,i.kt)("h3",{id:"match-on-variants"},"Match on variants"),(0,i.kt)("p",null,"Here is a function that transforms a colour variant type to an int."),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=pm_variant",group:"pm_variant"},"type color =\n  | RGB   of int * int * int\n  | Gray  of int\n  | Default\n\nlet int_of_color (c : color) : int =\n  match c with\n  | RGB (r,g,b) -> 16 + b + g * 6 + r * 36\n  | Gray i -> 232 + i\n  | Default -> 0\n"))),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=pm_variant",group:"pm_variant"},'type color =\n| ["RGB", [int, int, int]]\n| ["Gray", int]\n| ["Default"];\n\nconst int_of_color = (c : color) : int =>\n  match(c) {\n    when(RGB(rgb)): 16 + rgb[2] + rgb[1] * 6 + rgb[0] * 36;\n    when(Gray(i)): 232 + i;\n    when(Default()): 0 };\n')),(0,i.kt)("p",null,"The right-hand sides of each ",(0,i.kt)("inlineCode",{parentName:"p"},"when"),"-clause is an expression. Sometimes\nwe might need statements to be processed before a value is given to\nthe clause. In that case, the ",(0,i.kt)("inlineCode",{parentName:"p"},"do")," expression comes handy. It enables\nthe opening of a block of statements like a function body, that is, a\nblock ended with a ",(0,i.kt)("inlineCode",{parentName:"p"},"return")," statement whose argument has the value of\nthe block, like so:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=pm_variant",group:"pm_variant"},"function match_with_block () {\n  let x = 1;\n  return\n    match(Some(1)) {\n      when(None()): failwith(1);\n      when(Some(org)): do {\n        let y = x + 1;\n        return y\n      }\n    };\n};\n"))),(0,i.kt)("h3",{id:"matching-records-or-tuples"},"Matching records or tuples"),(0,i.kt)("p",null,"Fields of records and components of tuples can be destructured. Record\npattern variables can be renamed."),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=pm_rec_tuple",group:"pm_rec_tuple"},"type my_record = {a : int; b : nat; c : string}\ntype my_tuple = int * nat * string\n\nlet on_record (v : my_record) : int =\n  match v with\n    { a ; b = b_renamed ; c = _ } -> a + int b_renamed\n\nlet on_tuple (v : my_tuple) : int =\n  match v with (x , y, _) -> x + int y\n"))),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=pm_rec_tuple",group:"pm_rec_tuple"},"type my_record = { a : int ; b : nat ; c : string }\ntype my_tuple = [int, nat, string]\n\nlet on_record = (v : my_record) : int =>\n  match (v) {\n    when ({ a ; b : b_renamed ; c : _c }): a + int(b_renamed)\n  }\n\nlet on_tuple = (v : my_tuple) : int =>\n  match (v) {\n    when ([x, y, _s]): x + int(y)\n  }\n"))),(0,i.kt)("h3",{id:"matching-lists"},"Matching lists"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=pm_lists",group:"pm_lists"},"let weird_length (v : int list) : int =\n  match v with\n  | [] -> -1\n  | [ a; b ; c] -> -2\n  | x -> int (List.length x)\n"))),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=pm_lists",group:"pm_lists"},"let weird_length = (v : list<int>) : int =>\n  match(v) {\n    when([]): -1;\n    when([hd, ...tl]): 1 + int(List.length(tl))\n  };\n"))),(0,i.kt)("h3",{id:"deep-patterns"},"Deep patterns"),(0,i.kt)("p",null,"Pattern matching can also be used for nested patterns."),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=pm_complex",group:"pm_complex"},"type complex_t = { a : int list option ; b : int list }\n\nlet complex = fun (x:complex_t) (y:complex_t) ->\n  match (x,y) with\n  | {a=None; b=_}, {a = _; b = _} -> -1\n  | {a=_; b=_}, {a = Some ([]); b = (hd::tl)} -> hd\n  | {a=_; b=_}, {a = Some (hd::tl); b = []} -> hd\n  | {a=Some a; b=_}, _ -> int (List.length a)\n"))),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=pm_complex",group:"pm_complex"},"type complex_t = { a : option<list<int>> ; b : list<int> }\n\nconst complex = (x: complex_t, y: complex_t) =>\n  match ([x,y]) {\n    when ([{a:None; b:_bl}, {a:_ar; b:_br}]): -1\n    when ([{a:_a; b:_b}, {a: Some ([]); b: [hd,...tl]}]): hd\n    when ([{a:_a; b:_b}, {a: Some ([hd,...tl]); b:[]}]): hd\n    when ([{a: Some (a); b:_b}, _l]) : int (List.length (a))\n  }\n"))))}c.isMDXComponent=!0}}]);