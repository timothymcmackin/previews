"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[82417],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>d});var a=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=a.createContext({}),p=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},u=function(e){var n=p(e.components);return a.createElement(l.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),m=p(t),d=i,g=m["".concat(l,".").concat(d)]||m[d]||c[d]||o;return t?a.createElement(g,r(r({ref:n},u),{},{components:t})):a.createElement(g,r({ref:n},u))}));function d(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,r=new Array(o);r[0]=m;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var p=2;p<o;p++)r[p]=t[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},48720:(e,n,t)=>{t.d(n,{D:()=>i.Z,Z:()=>o});var a=t(67294),i=t(75402);const o=function(e){return a.createElement(i.Z.Consumer,null,(n=>{let{syntax:t}=n;return t===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},16260:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>s,default:()=>m,frontMatter:()=>r,metadata:()=>l,toc:()=>u});var a=t(87462),i=(t(67294),t(3905)),o=t(48720);const r={id:"functions",title:"Functions"},s=void 0,l={unversionedId:"syntax/functions",id:"syntax/functions",title:"Functions",description:"LIGO functions are the basic building blocks of contracts.",source:"@site/../docs/syntax/functions.md",sourceDirName:"syntax",slug:"/syntax/functions",permalink:"/previews/ligo/external-link-icon/docs/next/syntax/functions",draft:!1,tags:[],version:"current",frontMatter:{id:"functions",title:"Functions"},sidebar:"docs",previous:{title:"Variables and constants",permalink:"/previews/ligo/external-link-icon/docs/next/syntax/variables"},next:{title:"Looping",permalink:"/previews/ligo/external-link-icon/docs/next/imperative/looping"}},p={},u=[{value:"Chaining functions",id:"chaining-functions",level:2},{value:"Polymorphic functions",id:"polymorphic-functions",level:2},{value:"Scope and side effects",id:"scope-and-side-effects",level:2},{value:"Currying functions",id:"currying-functions",level:2},{value:"Function expressions",id:"function-expressions",level:2},{value:"Recursion",id:"recursion",level:2},{value:"Higher-order functions",id:"higher-order-functions",level:2},{value:"Inlining",id:"inlining",level:2}],c={toc:u};function m(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"LIGO functions are the basic building blocks of contracts.\nContracts can have any number of functions."),(0,i.kt)("p",null,"Entrypoints are a special case of functions.\nOutside consumers can call only the functions that are designated as entrypoints.\nEntrypoints must also follow certain rules that do not apply to functions in general.\nSee ",(0,i.kt)("a",{parentName:"p",href:"./contracts/entrypoints"},"Entrypoints"),"."),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"To declare a function, use the ",(0,i.kt)("inlineCode",{parentName:"p"},"let")," keyword, just like declaring variables.\nUnlike OCaml, cameLIGO functions can accept multiple parameters.\nThe function declaration includes its parameters, after the function name, following OCaml syntax, as in this example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=fun_decl",group:"fun_decl"},"let add x y = x + y\nlet int_add (x : int) (y : int) : int = x + y\n")),(0,i.kt)("p",null,"To call a function, use its name and pass the correct number and type of parameters, as in this example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=fun_decl",group:"fun_decl"},"let five_plus_three = int_add 5 3\n")),(0,i.kt)("p",null,"By default, LIGO warns about unused parameters inside functions.\nIf the function does not use one of its parameters, you can prefix its name with an underscore to hide the warning, as in this example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=unused",group:"unused"},"let drop (x : int) (_y : int) : int = x // _y silently ignored\n"))),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"As in JavaScript, you can declare functions with the ",(0,i.kt)("inlineCode",{parentName:"p"},"function")," keyword or the ",(0,i.kt)("inlineCode",{parentName:"p"},"const")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"let")," keywords."),(0,i.kt)("p",null,"Here are some examples:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=sum",group:"sum"},"function add_function (x: int, y: int): int {\n  const z = x + y;\n  return z;\n}\n\nconst add_function_const = (x: int, y: int): int  => {\n  const z = x + y;\n  return z;\n}\n")),(0,i.kt)("p",null,"This type of function must use the ",(0,i.kt)("inlineCode",{parentName:"p"},"return")," keyword to set the return value.\nIf it does not use ",(0,i.kt)("inlineCode",{parentName:"p"},"return"),", the function returns unit by default."),(0,i.kt)("p",null,"Also as in JavaScript, when you declare functions with the ",(0,i.kt)("inlineCode",{parentName:"p"},"const")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"let")," keywords, you can replace the body of the function with a single expression and omit the ",(0,i.kt)("inlineCode",{parentName:"p"},"return")," keyword.\nThe ",(0,i.kt)("inlineCode",{parentName:"p"},"add_expression")," function in the following example is equivalent to the ",(0,i.kt)("inlineCode",{parentName:"p"},"add_function")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"add_function_const")," functions in the previous example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=sum",group:"sum"},"const add_expression = (x, y) => x + y;  // Single-expression body\n")),(0,i.kt)("p",null,"To call a function, use its name and pass the correct number and type of parameters, as in this example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=sum",group:"sum"},"const five_plus_three = add_expression(5, 3);\n")),(0,i.kt)("p",null,"By default, LIGO warns about unused parameters inside functions.\nIf the function does not use one of its parameters, you can prefix its name with an underscore to hide the warning, as in this example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=unused",group:"unused"},"const drop = (x, _y) => x; // _y silently ignored\n"))),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("h2",{id:"chaining-functions"},"Chaining functions"),(0,i.kt)("p",null,"To chain functions, use parentheses to group each function name with its parameters.\nFor example, assume that you have defined these three functions:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=paren_grouping",group:"paren_grouping"},"let f (x : int) = x + 1\nlet g (x : int) = x - 2\nlet h (x : int) = x + x - 3\n")),(0,i.kt)("p",null,"To chain calls to these three functions, you must group them properly with parentheses.\nFor example, this code passes 42 to function ",(0,i.kt)("inlineCode",{parentName:"p"},"f"),", passes the result to function ",(0,i.kt)("inlineCode",{parentName:"p"},"g"),", and passes that result to function ",(0,i.kt)("inlineCode",{parentName:"p"},"h"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=paren_grouping",group:"paren_grouping"},"let result = h (g (f 42))\n")),(0,i.kt)("p",null,"The parentheses are required in this case.\nIf you omit the parentheses, CameLIGO runs the functions in order from left to right, as in this example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},"(* Previous example without parentheses *)\nlet result_2 = h g f 42\n(* The resulting value is equivalent to this code: *)\nlet result_2_equivalent = ((h g) f) 42\n(* These values cause errors because `g` is not a valid parameter of `h`)\n")),(0,i.kt)("p",null,"To reduce the amount of parentheses for readability, you can use the reverse-application operator (",(0,i.kt)("inlineCode",{parentName:"p"},"|>"),").\nFor example, the expression ",(0,i.kt)("inlineCode",{parentName:"p"},"f x")," can be written as ",(0,i.kt)("inlineCode",{parentName:"p"},"x |> f"),", and the expression ",(0,i.kt)("inlineCode",{parentName:"p"},"g (f x)")," can be written as ",(0,i.kt)("inlineCode",{parentName:"p"},"x |> f |> g"),'.\nYou can think of this expression as "I take ',(0,i.kt)("inlineCode",{parentName:"p"},"x"),", give it to function ",(0,i.kt)("inlineCode",{parentName:"p"},"f"),", and then give the result to function ",(0,i.kt)("inlineCode",{parentName:"p"},"g"),'."'),(0,i.kt)("p",null,"In this way, the expression ",(0,i.kt)("inlineCode",{parentName:"p"},"let result = h (g (f 42))")," can also be written like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=paren_grouping",group:"paren_grouping"},"let result = 42 |> f |> g |> h\n")),(0,i.kt)("p",null,"Function application has precedence over the reverse-application operator.\nFor this reason, ",(0,i.kt)("inlineCode",{parentName:"p"},"f 42 |> g")," is the same as ",(0,i.kt)("inlineCode",{parentName:"p"},"(f 42) |> g")," and not ",(0,i.kt)("inlineCode",{parentName:"p"},"f (42 |> g)"),".\nTherefore, this example shows another way to write the expression ",(0,i.kt)("inlineCode",{parentName:"p"},"let result = h (g (f 42))"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=paren_grouping",group:"paren_grouping"},"let result = f 42 |> g |> h\n")),(0,i.kt)("p",null,"The reverse-application operator can be useful when you have to deal with a long chain of function calls."),(0,i.kt)("p",null,"This operator comes from ",(0,i.kt)("a",{parentName:"p",href:"https://v2.ocaml.org/releases/4.02/htmlman/libref/Pervasives.html#6_Compositionoperators"},"OCaml's pervasives"),".")),(0,i.kt)("h2",{id:"polymorphic-functions"},"Polymorphic functions"),(0,i.kt)("p",null,"Polymorphic functions can take advantage of parametric types to accept a wide variety of inputs instead of only a single input type.\nFor more information, see ",(0,i.kt)("a",{parentName:"p",href:"../data-types/parametric_types#polymorphic-functions"},"Polymorphic functions"),"."),(0,i.kt)("h2",{id:"scope-and-side-effects"},"Scope and side effects"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"Functions can access, or ",(0,i.kt)("em",{parentName:"p"},"capture"),", immutable variables and functions that are outside their code as long as those variables and functions are in their scope.\nFor example, a function can capture another function in its scope so it can call it, as in this example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},"let double_incr (x : int) : int => add(x, x) + 1 // add is captured from outside\n")),(0,i.kt)("p",null,"Capturing also works with nested functions just like two functions at the same scope level:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},"let convoluted_doubling (x : int) : int =\n  let addX y = x + y in\n  addX(x)\n")),(0,i.kt)("p",null,"Functions cannot change values outside their scope, but they can define variables within their scope that have the same name.\nIn this example, a function appears to change the value of a parameter, but it is actually defining a new variable within the scope of the function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},"let addValue (value : int) : int =\n  let value = 12 in\n  value + 5\n"))),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"Functions can access, or ",(0,i.kt)("em",{parentName:"p"},"capture"),", immutable variables and functions that are outside their code as long as those variables and functions are in their scope.\nFor example, a function can capture another function in its scope so it can call it, as in this example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=sum",group:"sum"},"const double_incr = x => add_expression (x, x) + 1; // add_expression is captured from outside\n")),(0,i.kt)("p",null,"Capturing also works with nested functions just like two functions at the same scope level:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},"function convoluted_doubling (x) {\n  const addX = y => x + y;  // x is bound by convoluted_doubling\n  return addX(x);\n}\n")),(0,i.kt)("p",null,"Functions cannot change values outside their scope, including values passed as parameters.\nIn this example, a function tries to change a variable and a parameter but fails:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},'let myConstant = 5;\nconst addConstant = (x) => {\n  myConstant++; // Mutable variable "myConstant" not found.\n  x += myConstant; // Mutable variable "x" not found.\n  return x + myConstant;\n}\n'))),(0,i.kt)("h2",{id:"currying-functions"},"Currying functions"),(0,i.kt)("p",null,"To simplify a function for use in different contexts, you can create new functions that decompose the original function into simpler functions that take fewer parameters.\nCreating these simplified functions is called ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Currying"},"currying"),", and it enables ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Partial_application"},"partial application"),"."),(0,i.kt)("p",null,"For example, this code creates a function that accepts a single parameter, a tuple that contains two integers.\nThen it creates a curried function that accepts two separate integers as parameters and passes them to the first function as a tuple.\nThen it uses partial application to create a function that accepts one parameter and passes it to the curried function:"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=curry",group:"curry"},"let add (x, y) = x + y         // Uncurried\nlet add_curry x y = add (x, y) // Curried\nlet increment = add_curry 1    // Partial application\nlet one = increment 0\n")),(0,i.kt)("p",null,"In this example, type of ",(0,i.kt)("inlineCode",{parentName:"p"},"increment")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"int -> int"),", meaning that it is a function that takes an argument of the type ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," and returns a value of the type ",(0,i.kt)("inlineCode",{parentName:"p"},"int"),".\nSimilarly, the type of ",(0,i.kt)("inlineCode",{parentName:"p"},"add_curry")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"int -> int -> int"),",  which means ",(0,i.kt)("inlineCode",{parentName:"p"},"int -> (int -> int)")," and demonstrates how currying can partially apply it (only on its first argument) with the declaration of ",(0,i.kt)("inlineCode",{parentName:"p"},"increment"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=curry",group:"curry"},"const add = ([x, y]) => x + y;           // Uncurried\nconst add_curry = (x, y) => add([x, y]); // Curried\nconst increment = add_curry(1);          // Partial application\nconst one = increment(0);\n"))),(0,i.kt)("h2",{id:"function-expressions"},"Function expressions"),(0,i.kt)("p",null,"Sometimes you need to use a function only once, so it doesn't need a name.\nAlso, giving the function a name might incur a slight risk of cluttering the scope or being captured unintentionally.\nFunctions without names are called ",(0,i.kt)("em",{parentName:"p"},"anonymous functions"),", ",(0,i.kt)("em",{parentName:"p"},"function expressions"),", or ",(0,i.kt)("em",{parentName:"p"},"lambdas"),"."),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"Function expressions are introduced with the ",(0,i.kt)("inlineCode",{parentName:"p"},"fun")," keyword, followed by the parameters, then an arrow ",(0,i.kt)("inlineCode",{parentName:"p"},"->"),", followed by the function body (an expression):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=anonymous",group:"anonymous"},"let sum = fun x y -> x + y      // Uncurried function expression\nlet add = fun (x,y) -> x + y    // Curried function expression\nlet increment = fun x -> x + 1\n")),(0,i.kt)("p",null,"The anonymous functions ",(0,i.kt)("inlineCode",{parentName:"p"},"fun x y -> x + y")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"fun (x,y) -> x + y")," are expressions, and you can use them ",(0,i.kt)("em",{parentName:"p"},"without a name")," in contexts where functions of type ",(0,i.kt)("inlineCode",{parentName:"p"},"int -> int -> int"),", respectively ",(0,i.kt)("inlineCode",{parentName:"p"},"int * int -> int"),", are valid.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"Function expressions are called ",(0,i.kt)("em",{parentName:"p"},"arrow functions")," in JsLIGO:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=anonymous",group:"anonymous"},"const sum = (x,y) => x + y;\nconst increment = x => x + 1; // Or (x) => x + 1\n")),(0,i.kt)("p",null,"Note that when there is a single parameter that is not given a type, the parentheses are not necessary, but they are if the return type is given, as in this example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=anonymous",group:"anonymous"},"const decrement = (x) : int => x - 1;\n")),(0,i.kt)("p",null,"The anonymous function ",(0,i.kt)("inlineCode",{parentName:"p"},"(x,y) => x + y")," is an expression, and you can use it ",(0,i.kt)("em",{parentName:"p"},"without a name")," in contexts where functions of type ",(0,i.kt)("inlineCode",{parentName:"p"},"(x: int, y: int) => int")," are valid."),(0,i.kt)("p",null,"Note: When a function takes ",(0,i.kt)("strong",{parentName:"p"},"one")," argument that is a tuple, parentheses are mandatory, as in this example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=anonymous",group:"anonymous"},"const comp_sum = ([x,y]) => x + y;\n")),(0,i.kt)("p",null,"That function is different from the function ",(0,i.kt)("inlineCode",{parentName:"p"},"(x,y) => x + y"),", which takes ",(0,i.kt)("strong",{parentName:"p"},"two")," arguments.\nIn other words, ",(0,i.kt)("inlineCode",{parentName:"p"},"sum")," has type ",(0,i.kt)("inlineCode",{parentName:"p"},"(x: int, y: int) => int")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"comp_sum")," has type ",(0,i.kt)("inlineCode",{parentName:"p"},"([x,y] : [int,int]) => int"),".")),(0,i.kt)("h2",{id:"recursion"},"Recursion"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"As in OCaml, recursive functions are defined using the ",(0,i.kt)("inlineCode",{parentName:"p"},"let rec"),"\nkeywords:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=recursion",group:"recursion"},"let rec sum (n, acc : int * int) : int =\n  if n < 1 then acc else sum (n-1, acc + n)\n\nlet rec fibonacci (n, n_1, n_0 : int * int * int) : int =\n  if n < 2 then n_1 else fibonacci (n-1, n_1 + n_0, n_1)\n"))),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"Recursive functions are defined and called using the same syntax as non-recursive functions."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=recursion",group:"recursion"},"function sum (n: int, acc: int) : int {\n  if (n < 1) return acc; else return sum (n-1, acc + n);\n};\n\nfunction fibonacci (n: int, n_1: int, n_0: int): int {\n  if (n < 2) return n_1; else return fibonacci (n-1, n_1 + n_0, n_1);\n};\n")),(0,i.kt)("p",null,"This means that all values, including functions, declared in the same block or top-level scope, must have different names, because they can all potentially be mutually recursive.")),(0,i.kt)("h2",{id:"higher-order-functions"},"Higher-order functions"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"Functions that take a function as a parameter or return a function are known as ",(0,i.kt)("em",{parentName:"p"},"higher-order functions"),".\nThis example accepts two functions and composes them into one, as in mathematics:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=lambdas",group:"lambdas"},"let compose f g x = f (g x)\nlet double_incr = compose (fun x -> x + 1) (fun x -> 2*x)  // 2*x + 1\n")),(0,i.kt)("p",null,"You can also pass named functions as arguments:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=lambdas",group:"lambdas"},"let increment x = x + 1\nlet double x = 2*x\nlet double_incr2 = compose increment double\n"))),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"Functions that take a function as a parameter or return a function are known as ",(0,i.kt)("em",{parentName:"p"},"higher-order functions"),".\nThis example accepts two functions and composes them into one, as in mathematics:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=lambdas",group:"lambdas"},"const compose = f => g => x => f (g (x));\nconst double_incr = compose (x => x + 1) (x => 2*x)  // 2*x + 1\n")),(0,i.kt)("p",null,"You can also pass named functions as arguments:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=lambdas",group:"lambdas"},"const increment = x => x + 1;\nconst double = x => 2*x;\nconst double_incr2 = compose (increment) (double);\n"))),(0,i.kt)("h2",{id:"inlining"},"Inlining"),(0,i.kt)("p",null,"Inlining is the process of embedding the code of a function instead of storing the function as a separate block of code.\nTo save space, the LIGO compiler inlines function code rather than using a separate function when the function is used only once and is pure, which means it has no side effects.\nIn this context, side effects include creating operations or exceptions."),(0,i.kt)("p",null,"The compiler does not inline functions that are used more than once or are not pure because doing so often results in larger contracts.\nHowever, in some cases, you may want to force the compiler to inline function code.\nYou can force the compiler to inline functions that are used more than once, but you cannot force the compiler to inline functions that cause side effects."),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"To force inlining, use the ",(0,i.kt)("inlineCode",{parentName:"p"},"[@inline]")," attribute."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=inlining",group:"inlining"},"[@inline]\nlet fst (p : nat * nat) = p.0\n\n[@entry]\nlet main (p : nat * nat) (s : nat * nat) : operation list * (nat * nat) =\n  [], (fst (p.0, p.1), fst (s.1, s.0))\n")),(0,i.kt)("p",null,"You can measure the difference between inlining and not inlining with the ",(0,i.kt)("inlineCode",{parentName:"p"},"info measure-contract")," command.\nIn this case, inlining the function saves space because the function is so small.\nThis table shows the results of the command ",(0,i.kt)("inlineCode",{parentName:"p"},"ligo info measure-contract inline.mligo")," with and without the ",(0,i.kt)("inlineCode",{parentName:"p"},"[@inline]")," attribute:")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"To force inlining, use the ",(0,i.kt)("inlineCode",{parentName:"p"},"@inline")," decorator."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=inlining",group:"inlining"},"// @inline\nconst fst = (p: [nat, nat]) => p[0];\n\n// @entry\nconst main = (p: [nat, nat], s: [nat, nat]) : [list<operation>, [nat, nat]] =>\n  [[], [fst([p[0], p[1]]), fst([s[1], s[0]])]];\n")),(0,i.kt)("p",null,"You can measure the difference between inlining and not inlining with the ",(0,i.kt)("inlineCode",{parentName:"p"},"info measure-contract")," command.\nIn this case, inlining the function saves space because the function is so small.\nThis table shows the results of the command ",(0,i.kt)("inlineCode",{parentName:"p"},"ligo info measure-contract inline.jsligo")," with and without the ",(0,i.kt)("inlineCode",{parentName:"p"},"@inline")," decorator:")),(0,i.kt)("table",null,(0,i.kt)("tr",null,(0,i.kt)("td",null,"With inlining"),(0,i.kt)("td",null,"46 bytes")),(0,i.kt)("tr",null,(0,i.kt)("td",null,"Without inlining"),(0,i.kt)("td",null,"97 bytes"))),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Note that these results can change due to ongoing work to optimise output of\nthe LIGO compiler.")))}m.isMDXComponent=!0}}]);