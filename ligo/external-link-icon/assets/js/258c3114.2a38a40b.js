"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[55467],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>g});var o=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,o,i=function(e,t){if(null==e)return{};var n,o,i={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=o.createContext({}),u=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=u(e.components);return o.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),d=u(n),g=i,h=d["".concat(l,".").concat(g)]||d[g]||c[g]||a;return n?o.createElement(h,s(s({ref:t},p),{},{components:n})):o.createElement(h,s({ref:t},p))}));function g(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,s=new Array(a);s[0]=d;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:i,s[1]=r;for(var u=2;u<a;u++)s[u]=n[u];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},36524:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>a,metadata:()=>r,toc:()=>u});var o=n(87462),i=(n(67294),n(3905));const a={},s="Testing LIGO",r={unversionedId:"contributors/ligo_test_guide",id:"version-1.6.0/contributors/ligo_test_guide",title:"Testing LIGO",description:"Adding to the LIGO test suite is one of the most accessible ways to contribute. It exposes you to the compiler structure and primitives without demanding a deep understanding of OCaml or compiler development.",source:"@site/versioned_docs/version-1.6.0/contributors/ligo_test_guide.md",sourceDirName:"contributors",slug:"/contributors/ligo_test_guide",permalink:"/previews/ligo/external-link-icon/docs/1.6.0/contributors/ligo_test_guide",draft:!1,tags:[],version:"1.6.0",frontMatter:{}},l={},u=[{value:"How To Find Good Test Cases",id:"how-to-find-good-test-cases",level:2},{value:"Extending Existing Test Cases",id:"extending-existing-test-cases",level:3},{value:"Studying The Parsers For Gaps In Coverage",id:"studying-the-parsers-for-gaps-in-coverage",level:3},{value:"Two Useful Test Cases Using LIGO",id:"two-useful-test-cases-using-ligo",level:3},{value:"Coverage",id:"coverage",level:4},{value:"Depth",id:"depth",level:4},{value:"Fuzzing (Speculative)",id:"fuzzing-speculative",level:3},{value:"Structure of LIGO Tests",id:"structure-of-ligo-tests",level:2},{value:"Assignment Test",id:"assignment-test",level:3},{value:"assign.ligo",id:"assignligo",level:4},{value:"Annotation Test",id:"annotation-test",level:3},{value:"annotation.ligo",id:"annotationligo",level:4},{value:"How To Write A Test For LIGO",id:"how-to-write-a-test-for-ligo",level:2}],p={toc:u};function c(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,o.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"testing-ligo"},"Testing LIGO"),(0,i.kt)("p",null,"Adding to the LIGO test suite is one of the most accessible ways to contribute. It exposes you to the compiler structure and primitives without demanding a deep understanding of OCaml or compiler development."),(0,i.kt)("p",null,"Bonus: you will become more familiar with LIGO in the process!"),(0,i.kt)("p",null,"Tests are written in OCaml, as LIGO doesn't (yet) have a good way to do automated testing. Thankfully the test code is typically less demanding than the features being tested."),(0,i.kt)("p",null,"Tests are currently contained in\n",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.com/ligolang/ligo/tree/dev/src/test"},"src/test"),", but\nmost are integration tests which rely on test contracts kept in\n",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.com/ligolang/ligo/tree/dev/src/test/contracts"},"src/test/contracts"),". If\nyou are new to LIGO, reading these contracts can be a useful\nintroduction to a particular LIGO syntax."),(0,i.kt)("h2",{id:"how-to-find-good-test-cases"},"How To Find Good Test Cases"),(0,i.kt)("p",null,'Your first question is probably: "If I\'m not already experienced, how\ndo I know what to test?". There are a handful of things you can do to\nsystematically find good test cases. All of them will either get you\nmore familiar with the LIGO code base or LIGO itself.'),(0,i.kt)("h3",{id:"extending-existing-test-cases"},"Extending Existing Test Cases"),(0,i.kt)("p",null,"The fastest way to improve LIGO's test coverage is to extend existing\ntest cases. Consider the test cases that already exist, and think of\nthings they do not cover or situations they will fail in. A good deal\nof inference is required for this, but it requires minimal experience\nwith the existing code."),(0,i.kt)("h3",{id:"studying-the-parsers-for-gaps-in-coverage"},"Studying The Parsers For Gaps In Coverage"),(0,i.kt)("p",null,"LIGO is divided into two parts"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"the ",(0,i.kt)("strong",{parentName:"li"},"front end")," handles syntax"),(0,i.kt)("li",{parentName:"ul"},"the ",(0,i.kt)("strong",{parentName:"li"},"backend")," optimises and compiles a core language shared between syntaxes")),(0,i.kt)("p",null,"You can find basic test cases for a particular LIGO syntax by studying its parser. You will find the parser under ",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.com/ligolang/ligo/tree/dev/src/passes/01-parsing"},"src/passes/1-parser"),"."),(0,i.kt)("h3",{id:"two-useful-test-cases-using-ligo"},"Two Useful Test Cases Using LIGO"),(0,i.kt)("h4",{id:"coverage"},"Coverage"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"whether we have any testing at all for a particular aspect of a syntax")),(0,i.kt)("p",null,"You can find coverage tests by carefully going over the syntax tree for a syntax (probably best read by looking at its ",(0,i.kt)("inlineCode",{parentName:"p"},"Parser.mly"),") and comparing each branch to the test suite. (These tests are plentiful at the time of writing, but they will eventually be filled in reliably as part of writing a new syntax.)"),(0,i.kt)("h4",{id:"depth"},"Depth"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"features are put through a wide variety of complex scenarios to make sure they stand up to real world use")),(0,i.kt)("p",null,"One of the best ways to find these is to use LIGO for a real project. This will require some time and energy\u2014not just to learn LIGO but to write projects complex enough to stretch the limits of what the language can do. However, it will also get you used to engaging with LIGO from a developers perspective, asking how things could be better or what features are underdeveloped. If your project has practical use, you will also be contributing to the Tezos/LIGO ecosystem while you learn."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Note: because LIGO is open source, in order for us to add your work\nas a test case it needs to be licensed in a way that is compatible\nwith LIGO.")),(0,i.kt)("h3",{id:"fuzzing-speculative"},"Fuzzing (Speculative)"),(0,i.kt)("p",null,"In the future you will be able to\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Fuzzing"},"use fuzzing")," to generate test\ncases for LIGO. Fuzzing is often useful for finding 'weird' bugs on\ncode paths that humans normally would not stumble onto. This makes it\na useful supplement to human testing."),(0,i.kt)("h2",{id:"structure-of-ligo-tests"},"Structure of LIGO Tests"),(0,i.kt)("p",null,"LIGO's OCaml-based tests are written in\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/mirage/alcotest/"},"alcotest"),". However, the tests\nyou encounter in\n",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.com/ligolang/ligo/blob/dev/src/test/integration_tests.ml"},"src/test/integration_tests.ml"),"\nare built on top of some abstractions, currently defined in\n",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.com/ligolang/ligo/blob/dev/src/test/test_helpers.ml"},"src/test/test_helpers.ml"),". The\nuse of these can be inferred fairly well from looking at existing\ntests, but let us break a few of them down for analysis."),(0,i.kt)("h3",{id:"assignment-test"},"Assignment Test"),(0,i.kt)("p",null,"We will first analyse a short integration test for assignment."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'let assign () : unit result =\n  let%bind program = type_file "./contracts/assign.ligo" in\n  let make_expect = fun n -> n + 1 in\n  expect_eq_n_int program "main" make_expect\n')),(0,i.kt)("h4",{id:"assignligo"},"assign.ligo"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"function main (const i : int) : int is\n  begin\n    i := i + 1 ;\n  end with i\n")),(0,i.kt)("p",null,"What is going on here?"),(0,i.kt)("p",null,"We have a function which takes no arguments and returns a ",(0,i.kt)("inlineCode",{parentName:"p"},"unit result"),".\nWe then define two variables:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"a ",(0,i.kt)("inlineCode",{parentName:"li"},"program")," which is read from disk and fed to the LIGO compiler"),(0,i.kt)("li",{parentName:"ul"},"a comparison function ",(0,i.kt)("inlineCode",{parentName:"li"},"make_expect")," which takes an integer and adds one to it")),(0,i.kt)("p",null,"Using ",(0,i.kt)("inlineCode",{parentName:"p"},"expect_eq_n_int")," the ",(0,i.kt)("inlineCode",{parentName:"p"},"program"),"'s main function is run and compared to the result of the same input provided to ",(0,i.kt)("inlineCode",{parentName:"p"},"make_expect"),". Notice that the ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," argument given to ",(0,i.kt)("inlineCode",{parentName:"p"},"expect_eq_n_int")," corresponds to the name of the function in ",(0,i.kt)("inlineCode",{parentName:"p"},"assign.ligo"),"."),(0,i.kt)("p",null,"This gives us a taste of what to expect from these integration tests."),(0,i.kt)("h3",{id:"annotation-test"},"Annotation Test"),(0,i.kt)("p",null,"We can see in more complex tests that we are able to pull the values of arbitrary expressions or function calls from LIGO test contracts. Consider:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'let annotation () : unit result =\n  let%bind program = type_file "./contracts/annotation.ligo" in\n  let%bind () =\n    expect_eq_evaluate program "lst" (e_list [])\n  in\n  let%bind () =\n    expect_eq_evaluate program "address" (e_address "tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx")\n  in\n  let%bind () =\n    expect_eq_evaluate program "address_2" (e_address "tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx")\n  in\n  ok ()\n')),(0,i.kt)("h4",{id:"annotationligo"},"annotation.ligo"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'const lst : list(int) = list [] ;\n\nconst address : address = "tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx" ;\n\nconst address_2 : address = ("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx" : address) ;\n')),(0,i.kt)("p",null,"What is going on is similar to the last program: ",(0,i.kt)("inlineCode",{parentName:"p"},"expect_eq_evaluate"),"\nruns a program and then pulls a particular named value from the final\nprogram state."),(0,i.kt)("p",null,"For example, once the program stops running the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"address")," is\n",(0,i.kt)("inlineCode",{parentName:"p"},'"tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx"'),". The ",(0,i.kt)("em",{parentName:"p"},"comparison"),", however,\nis made to a constructed expression."),(0,i.kt)("p",null,"Remember that we are testing from OCaml, but the program is written\nand evaluated as LIGO. In order to provide a proper comparison, we\nconvert our expected test values into LIGO expressions and\ndata. Constructors such as ",(0,i.kt)("inlineCode",{parentName:"p"},"e_list")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"e_address")," provide a bridge\nbetween LIGO and OCaml. Their definitions can be found in files such\nas\n",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.com/ligolang/ligo/blob/dev/src/stages/ast_core/combinators.ml"},"src/stages/ast_core/combinators.ml"),",\nor using\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/ocaml/merlin/wiki"},"Merlin's definition point finder"),". These\nsame functions are used during the simplification stage of LIGO\ncompilation, so becoming familiar with them will help prepare you to\nwork on the ",(0,i.kt)("a",{parentName:"p",href:"/previews/ligo/external-link-icon/docs/1.6.0/contributors/big-picture/front-end"},"front end"),"."),(0,i.kt)("h2",{id:"how-to-write-a-test-for-ligo"},"How To Write A Test For LIGO"),(0,i.kt)("p",null,"What if we want to write a test of our own? If the test is in the\nintegration test vein (which it probably is if you are testing new\nsyntax or features), then the process looks something like:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Write a test contract which uses the new syntax or feature in ",(0,i.kt)("a",{parentName:"li",href:"https://gitlab.com/ligolang/ligo/tree/dev/src/test/contracts"},"src/test/contracts"),"."),(0,i.kt)("li",{parentName:"ol"},"Write an integration test in ",(0,i.kt)("a",{parentName:"li",href:"https://gitlab.com/ligolang/ligo/blob/dev/src/test/integration_tests.ml"},"src/test/integration_tests.ml")," in the vein of existing tests, make sure you add it to the test runner that is currently located at the bottom of the file."),(0,i.kt)("li",{parentName:"ol"},"Write the feature, assuming it does not already exist. Build the\nresulting version of LIGO without errors."),(0,i.kt)("li",{parentName:"ol"},"Run the test suite, see if your test(s) pass. If they do, you are\nprobably done. If not, it is time to go debugging.")))}c.isMDXComponent=!0}}]);