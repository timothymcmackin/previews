"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6626],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),m=p(n),d=i,h=m["".concat(l,".").concat(d)]||m[d]||c[d]||o;return n?a.createElement(h,r(r({ref:t},u),{},{components:n})):a.createElement(h,r({ref:t},u))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var p=2;p<o;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},48720:(e,t,n)=>{n.d(t,{D:()=>i.Z,Z:()=>o});var a=n(67294),i=n(75402);const o=function(e){return a.createElement(i.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},43792:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>s,default:()=>m,frontMatter:()=>r,metadata:()=>l,toc:()=>u});var a=n(87462),i=(n(67294),n(3905)),o=n(48720);const r={title:"Variants"},s=void 0,l={unversionedId:"data-types/variants",id:"data-types/variants",title:"Variants",description:"Variant types have one or more non-overlapping cases.",source:"@site/../docs/data-types/variants.md",sourceDirName:"data-types",slug:"/data-types/variants",permalink:"/previews/ligo/external-link-icon/docs/next/data-types/variants",draft:!1,tags:[],version:"current",frontMatter:{title:"Variants"},sidebar:"docs",previous:{title:"Tuples",permalink:"/previews/ligo/external-link-icon/docs/next/data-types/tuples"},next:{title:"Lists",permalink:"/previews/ligo/external-link-icon/docs/next/data-types/lists"}},p={},u=[{value:"Unit",id:"unit",level:2},{value:"Options",id:"options",level:2},{value:"Matching",id:"matching",level:2}],c={toc:u};function m(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Variant types have one or more non-overlapping cases.\nA value of a variant type can be one of these cases or another but never more than one case."),(0,i.kt)("p",null,"Simple variant types are similar to enumerated types found in many other languages.\nFor example, this type defines a coin as being either heads or tails (and nothing else):"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=variants",group:"variants"},"type coin = Head | Tail\nlet head : coin = Head\nlet tail : coin = Tail\n"))),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=variants",group:"variants"},'type coin = ["Head"] | ["Tail"];\nlet head: coin = ["Head" as "Head"];\nlet tail: coin = ["Tail" as "Tail"];\n'))),(0,i.kt)("p",null,"The names ",(0,i.kt)("inlineCode",{parentName:"p"},"Head")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Tail")," in the definition of the type ",(0,i.kt)("inlineCode",{parentName:"p"},"coin")," are called ",(0,i.kt)("em",{parentName:"p"},"data constructors"),".\nIn this particular case, they carry no information beyond their names, so they are called ",(0,i.kt)("em",{parentName:"p"},"constant constructors"),"."),(0,i.kt)("p",null,"Variants can carry more information than just their constructors.\nEach constructor in a variant can specify types that the constructor contains.\nFor example, this variant types defines different kinds of users of a system, with some having an ID number and others not:"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=variants",group:"variants"},"type id = nat\n\ntype user =\n  Admin   of id\n| Manager of id\n| Guest\n\nlet bob : user = Admin 1000n\nlet carl : user = Guest\n")),(0,i.kt)("p",null,"A constant constructor is equivalent to the same constructor taking an\nargument of type ",(0,i.kt)("inlineCode",{parentName:"p"},"unit"),", so, for example, ",(0,i.kt)("inlineCode",{parentName:"p"},"Guest")," is the same value as\n",(0,i.kt)("inlineCode",{parentName:"p"},"Guest ()"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=variants",group:"variants"},'type id = nat;\n\ntype user =\n  ["Admin", id]\n| ["Manager", id]\n| ["Guest"];\n\nconst bob : user = ["Admin" as "Admin", 1000 as nat];\nconst carl : user = ["Guest" as "Guest"];\n')),(0,i.kt)("p",null,"A constant constructor is equivalent to the same constructor taking a value of type ",(0,i.kt)("inlineCode",{parentName:"p"},"unit"),", so, for example, ",(0,i.kt)("inlineCode",{parentName:"p"},'["Guest" as "Guest"]')," is the same value as ",(0,i.kt)("inlineCode",{parentName:"p"},'["Guest" as "Guest", []]')," and ",(0,i.kt)("inlineCode",{parentName:"p"},'["Guest" as "Guest", unit]'),"."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"To create a variable of a variant type, you must specify its value as a tuple where the first value is the constructor and the second value is the value that the constructor takes.\nTo prevent the compiler from seeing the name of the constructor as a string, you must set its type as one of the constructors from the variant type with the ",(0,i.kt)("inlineCode",{parentName:"p"},"as")," syntax, as in the previous examples."))),(0,i.kt)("h2",{id:"unit"},"Unit"),(0,i.kt)("p",null,"The type ",(0,i.kt)("inlineCode",{parentName:"p"},"unit")," is a predefined type that contains only one value that\ncarries no information.\nIt is used when no relevant information is\nrequired or produced, as in constant constructors."),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The unique value of type ",(0,i.kt)("inlineCode",{parentName:"p"},"unit")," is written ",(0,i.kt)("inlineCode",{parentName:"p"},"()"),", like an empty tuple,\nfollowing the OCaml convention."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=unit",group:"unit"},"let x: unit = ()\n")),(0,i.kt)("p",null,"Imperative statements, like statements and loops, will have type\n",(0,i.kt)("inlineCode",{parentName:"p"},"unit"),", and that is why it is documented here.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The unique value of type ",(0,i.kt)("inlineCode",{parentName:"p"},"unit")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"[]"),", like an empty tuple."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=unit",group:"unit"},"const x : unit = [];\n"))),(0,i.kt)("h2",{id:"options"},"Options"),(0,i.kt)("p",null,"The option type is a predefined variant type that has two cases: ",(0,i.kt)("inlineCode",{parentName:"p"},"Some(v)"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," is some value of any type, and ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),"."),(0,i.kt)("p",null,"Some functions return options when they are not defined for certain inputs.\nFor example, you can get a value from a big map by passing the key to the ",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.find_opt")," function.\nThis function returns an option that is ",(0,i.kt)("inlineCode",{parentName:"p"},"Some")," with the value if the key is defined in the big map or ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," with unit if it is not."),(0,i.kt)("p",null,"Similarly, division by zero is not defined, so this function divides two numbers and returns ",(0,i.kt)("inlineCode",{parentName:"p"},"Some")," if the result is defined or ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," if it is not:"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=options",group:"options"},"let div (a, b : nat * nat) : nat option =\n  if b = 0n then None else Some (a/b)\n"))),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=options",group:"options"},'function div (a: nat, b: nat): option<nat> {\n  if (b == (0 as nat)) return ["None" as "None"];\n  return ["Some" as "Some", a/b]\n};\n'))),(0,i.kt)("p",null,"As a shortcut to dealing with options, you can use the function ",(0,i.kt)("inlineCode",{parentName:"p"},"Option.value_with_error")," to assume that an option is ",(0,i.kt)("inlineCode",{parentName:"p"},"Some")," and retrieve the value.\nIf the option is ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),", the function throws an error."),(0,i.kt)("p",null,"However, the best way to deal with option types is by pattern matching, as described in the next section, because it allows you to handle both cases explicitly."),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"For more functions that deal with option types, see the predefined ",(0,i.kt)("a",{parentName:"p",href:"../reference/option-reference/?lang=cameligo"},"module Option"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"For more functions that deal with option types, see the predefined ",(0,i.kt)("a",{parentName:"p",href:"../reference/option-reference/?lang=jsligo"},"namespace Option"),".")),(0,i.kt)("h2",{id:"matching"},"Matching"),(0,i.kt)("p",null,"To work with variants and options, you must handle each case of the type.\nLIGO handles different cases by ",(0,i.kt)("em",{parentName:"p"},"pattern matching"),", which uses the ",(0,i.kt)("inlineCode",{parentName:"p"},"$match")," predefined function to run different code for each case.\nThe ",(0,i.kt)("inlineCode",{parentName:"p"},"$match")," function must cover all of the cases of the type."),(0,i.kt)("p",null,"For example, the following code defines a colour variant type and a function that converts values of that type to a single integer by using pattern matching on each variant:"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=variant_matching",group:"variant_matching"},"type colour =\n  | RGB of int * int * int\n  | Gray of int\n  | Default\n\nlet int_of_colour (c : colour) : int =\n  match c with\n  | RGB (r,g,b) -> 16 + b + g * 6 + r * 36\n  | Gray i -> 232 + i\n  | Default -> 0\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Note: This is the same construct as in OCaml."))),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=variant_matching",group:"variant_matching"},'type colour =\n| ["RGB", [int, int, int]]\n| ["Gray", int]\n| ["Default"];\n\nconst int_of_colour = (c : colour) : int =>\n  $match(c, {\n    "RGB": ([r,g,b]) => 16 + b + g * 6 + r * 36,\n    "Gray": i => 232 + i,\n    "Default": () => 0\n  });\n')),(0,i.kt)("p",null,"As its parameters, the ",(0,i.kt)("inlineCode",{parentName:"p"},"$match")," function receives the variant value to match on and an object.\nThe property names of the object are the constructors of the corresponding variant type.\nThe property values are either a single expression or expressions that receive the value of the variant as a parameter.\nWhen the variant has no value, as in constant constructors or the ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," variant, the expression receives unit as a parameter."),(0,i.kt)("p",null,"For complex expressions, you can use an immediately invoked function expression (IIFE) as the result of a match.\nThis allows you to use a block of statements with a ",(0,i.kt)("inlineCode",{parentName:"p"},"return")," statement like a function body, as in this example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=match_with_block",group:"match_with_block"},'const match_with_block = (x : option<int>) : int =>\n  $match(x, {\n    "None": () => 0,\n    "Some": n => (() => {\n      const y = n + 1;\n      return y;\n    })(),\n  });\n'))),(0,i.kt)("p",null,"Another example is matching on whether an integer is a natural number\nor not:"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=nat_matching",group:"nat_matching"},"let is_it_a_nat (i : int) =\n  match is_nat i with\n    None   -> false\n  | Some _ -> true\n"))),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=nat_matching",group:"nat_matching"},'const is_it_a_nat = (i : int) =>\n  $match(is_nat(i), {\n    "None": () => false,\n    "Some": n => (() => { ignore(n); return true; })()\n  })\n'))))}m.isMDXComponent=!0}}]);