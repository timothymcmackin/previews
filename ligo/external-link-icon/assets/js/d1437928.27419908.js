"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[94018],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=p(n),m=i,g=c["".concat(s,".").concat(m)]||c[m]||u[m]||r;return n?a.createElement(g,o(o({ref:t},d),{},{components:n})):a.createElement(g,o({ref:t},d))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},48720:(e,t,n)=>{n.d(t,{D:()=>i.Z,Z:()=>r});var a=n(67294),i=n(75402);const r=function(e){return a.createElement(i.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},61430:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var a=n(87462),i=(n(67294),n(3905)),r=n(48720);const o={id:"signatures",title:"Signatures",jsligoTitle:"Interfaces"},l=void 0,s={unversionedId:"syntax/signatures",id:"syntax/signatures",title:"Signatures",description:"A signature is a list of types and values that you can apply to a module.",source:"@site/../docs/syntax/signatures.md",sourceDirName:"syntax",slug:"/syntax/signatures",permalink:"/previews/ligo/external-link-icon/docs/next/syntax/signatures",draft:!1,tags:[],version:"current",frontMatter:{id:"signatures",title:"Signatures",jsligoTitle:"Interfaces"},sidebar:"docs",previous:{title:"Attributes",permalink:"/previews/ligo/external-link-icon/docs/next/syntax/decorators"},next:{title:"Keywords",permalink:"/previews/ligo/external-link-icon/docs/next/syntax/keywords"}},p={},d=[{value:"Extending signatures",id:"extending-signatures",level:2},{value:"Extending interfaces",id:"extending-interfaces",level:2}],u={toc:d};function c(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"A signature is a list of types and values that you can apply to a module.\nWhen you apply a signature to a module, that module must have all of the types and values in the signature and no types or values that are not in the signature.\nThe LIGO compiler warns you of any mismatches between the signature and the module."),(0,i.kt)("p",null,"As in OCaml, to create a signature, use the keywords ",(0,i.kt)("inlineCode",{parentName:"p"},"module type")," and list the types and values between the keywords ",(0,i.kt)("inlineCode",{parentName:"p"},"sig")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"end"),".\nFor example, the following signature specifies that a module must have these contents:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A type named ",(0,i.kt)("inlineCode",{parentName:"li"},"t"),", although the data type of that type is not specified, which makes it an ",(0,i.kt)("em",{parentName:"li"},"abstract type")),(0,i.kt)("li",{parentName:"ul"},"A function named ",(0,i.kt)("inlineCode",{parentName:"li"},"add"),", which accepts two values of type ",(0,i.kt)("inlineCode",{parentName:"li"},"t")," and returns a value of type ",(0,i.kt)("inlineCode",{parentName:"li"},"t")),(0,i.kt)("li",{parentName:"ul"},"Values ",(0,i.kt)("inlineCode",{parentName:"li"},"one")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"two"),", which are of the type ",(0,i.kt)("inlineCode",{parentName:"li"},"t"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=sig_declaring",group:"sig_declaring"},"module type Euro_SIG =\n  sig\n    type t\n    val add : t * t -> t\n    val one : t\n    val two : t\n  end\n")),(0,i.kt)("p",null,"To apply a signature to a module, put the name of the signature after a colon and the module name, as in the following example.\nThis module defines the type ",(0,i.kt)("inlineCode",{parentName:"p"},"t")," as a nat and defines the ",(0,i.kt)("inlineCode",{parentName:"p"},"add")," function and the ",(0,i.kt)("inlineCode",{parentName:"p"},"one")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"two")," values:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=sig_declaring",group:"sig_declaring"},"module Euro : Euro_SIG =\n  struct\n    type t = nat\n    let add (a, b : t * t) = a + b\n    let one : t = 1n\n    let two : t = 2n\n  end\n")),(0,i.kt)("p",null,"The module must instantiate any abstract type in the signature, as this module defines the abstract type ",(0,i.kt)("inlineCode",{parentName:"p"},"t")," as a nat.")),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"An interface is a list properties that you can apply to a class.  When\nyou apply an interface to a class, that class must have all of the\nproperties declared in the interface.  The class can also have\nadditional definitions that are not in the interface.  The LIGO\ncompiler warns you of any mismatches between the interface and the\nclass."),(0,i.kt)("p",null,"For example, the following interface specifies that a class must have these contents:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A property named ",(0,i.kt)("inlineCode",{parentName:"li"},"add"),", which accepts two values of type ",(0,i.kt)("inlineCode",{parentName:"li"},"nat")," and returns a value of type ",(0,i.kt)("inlineCode",{parentName:"li"},"nat")),(0,i.kt)("li",{parentName:"ul"},"Values ",(0,i.kt)("inlineCode",{parentName:"li"},"one")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"two"),", which are of the type ",(0,i.kt)("inlineCode",{parentName:"li"},"nat"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=intf_declaring",group:"intf_declaring"},"interface Euro_INTF {\n  add: (a: nat, b: nat) => nat;\n  one: nat;\n  two: nat;\n};\n")),(0,i.kt)("p",null,"To apply an interface to a class, put the name of the interface after\nthe keyword ",(0,i.kt)("inlineCode",{parentName:"p"},"implements")," and the class name, as in the following\nexample.  We say that the class ",(0,i.kt)("em",{parentName:"p"},"implements")," the interface.  This\nclass defines the properties ",(0,i.kt)("inlineCode",{parentName:"p"},"add"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"one")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"two"),".  It also adds a\nproperty named ",(0,i.kt)("inlineCode",{parentName:"p"},"multiply")," that is not specified in the interface:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=intf_declaring",group:"intf_declaring"},"class Euro implements Euro_INTF {\n  static add = (a: nat, b: nat): nat => a + b;\n  static one = 1 as nat;\n  static two : nat = 2 as nat;\n  multiply = (a: nat, b: nat): nat => a * b;\n};\n")),(0,i.kt)("p",null,"Note how properties from the interface must be defined as ",(0,i.kt)("inlineCode",{parentName:"p"},"static")," in\nthe class.")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("h2",{id:"extending-signatures"},"Extending signatures"),(0,i.kt)("p",null,"Like modules, you can extend signatures by including other signatures in them, as in this example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=sig_including",group:"sig_including"},"module type Euro_SIG =\n  sig\n    type t\n    val add : t * t -> t\n    val one : t\n    val two : t\n  end\n\nmodule type NewEuro_SIG =\n  sig\n    include Euro_SIG\n    val ten : t\n  end\n")),(0,i.kt)("p",null,"Note that the type ",(0,i.kt)("inlineCode",{parentName:"p"},"t")," remains abstract in both signatures.\nModules that use either signature must instantiate the type.")),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("h2",{id:"extending-interfaces"},"Extending interfaces"),(0,i.kt)("p",null,"Interfaces can be extended by inheritance with the ",(0,i.kt)("inlineCode",{parentName:"p"},"extends")," keyword, as in this example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=intf_extending",group:"intf_extending"},"interface Euro_INTF {\n  add: (a: nat, b: nat) => nat;\n  one: nat;\n  two: nat;\n};\n\ninterface WithTenEuro_INTF extends Euro_INTF {\n  ten: nat;\n};\n\ninterface WithFiftyEuro_INTF extends Euro_INTF {\n  fifty: nat;\n};\n")),(0,i.kt)("p",null,"Interfaces can extend more than one interface, which can lead to an\ninterface that extends a base interface more than once, known as\n",(0,i.kt)("em",{parentName:"p"},"diamond inheritance"),".  For example, the following interface extends\ntwo interfaces from the previous example.  Because both of these\ninterfaces extend the same base interface, it is as if the interface\nextends the base interface twice.  Diamond inheritance doesn't cause\nany problems for the interface."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=intf_extending",group:"intf_extending"},"interface NewEuro_INTF\n  extends WithTenEuro_INTF, WithFiftyEuro_INTF {\n  hundred: nat;\n  five_hundred?: nat;\n};\n")),(0,i.kt)("p",null,"Interfaces can have optional types and values indicated with a\nquestion mark ",(0,i.kt)("inlineCode",{parentName:"p"},"?"),".  In the previous example, the interface\n",(0,i.kt)("inlineCode",{parentName:"p"},"NewEuro_INTF")," has an optional property ",(0,i.kt)("inlineCode",{parentName:"p"},"five_hundred"),".  This class\ndefines this optional value and adds a property named ",(0,i.kt)("inlineCode",{parentName:"p"},"twenty")," that is\nnot defined in the ",(0,i.kt)("inlineCode",{parentName:"p"},"NewEuro_INTF")," interface:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=intf_extending",group:"intf_extending"},"class NewEuro implements NewEuro_INTF {\n  static add = (a: nat, b: nat) => a + b;\n\n  static one: nat = 1;\n  static two: nat = 2;\n  static ten: nat = 10;\n  static fifty: nat = 50;\n  static hundred: nat = 100;\n  static five_hundred: nat = 500; // Could be omitted\n  static twenty: nat = 20; // Extra new constant\n}\n"))))}c.isMDXComponent=!0}}]);