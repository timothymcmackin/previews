"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[15968],{3905:(e,t,a)=>{a.d(t,{Zo:()=>l,kt:()=>c});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function p(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?p(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):p(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},p=Object.keys(e);for(n=0;n<p.length;n++)a=p[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var p=Object.getOwnPropertySymbols(e);for(n=0;n<p.length;n++)a=p[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var m=n.createContext({}),s=function(e){var t=n.useContext(m),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},l=function(e){var t=s(e.components);return n.createElement(m.Provider,{value:t},e.children)},g={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,p=e.originalType,m=e.parentName,l=o(e,["components","mdxType","originalType","parentName"]),u=s(a),c=i,d=u["".concat(m,".").concat(c)]||u[c]||g[c]||p;return a?n.createElement(d,r(r({ref:t},l),{},{components:a})):n.createElement(d,r({ref:t},l))}));function c(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var p=a.length,r=new Array(p);r[0]=u;var o={};for(var m in t)hasOwnProperty.call(t,m)&&(o[m]=t[m]);o.originalType=e,o.mdxType="string"==typeof e?e:i,r[1]=o;for(var s=2;s<p;s++)r[s]=a[s];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},48720:(e,t,a)=>{a.d(t,{D:()=>i.Z,Z:()=>p});var n=a(67294),i=a(75402);const p=function(e){return n.createElement(i.Z.Consumer,null,(t=>{let{syntax:a}=t;return a===e.syntax?e.children:n.createElement(n.Fragment,null)}))}},96625:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>m,toc:()=>l});var n=a(87462),i=(a(67294),a(3905)),p=a(48720);const r={title:"Big maps",id:"big_maps"},o=void 0,m={unversionedId:"data-types/big_maps",id:"data-types/big_maps",title:"Big maps",description:"Big-maps are data structures that are similar to Maps but are optimized in Michelson for large datasets.",source:"@site/../docs/data-types/big_maps.md",sourceDirName:"data-types",slug:"/data-types/big_maps",permalink:"/previews/ligo/external-link-icon/docs/next/data-types/big_maps",draft:!1,tags:[],version:"current",frontMatter:{title:"Big maps",id:"big_maps"},sidebar:"docs",previous:{title:"Big sets",permalink:"/previews/ligo/external-link-icon/docs/next/data-types/big_sets"},next:{title:"Tickets",permalink:"/previews/ligo/external-link-icon/docs/next/data-types/tickets"}},s={},l=[{value:"Creating big-maps",id:"creating-big-maps",level:2},{value:"Searching for elements",id:"searching-for-elements",level:2},{value:"Adding elements",id:"adding-elements",level:2},{value:"Removing elements",id:"removing-elements",level:2},{value:"Updating elements",id:"updating-elements",level:2}],g={toc:l};function u(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},g,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Big-maps are data structures that are similar to ",(0,i.kt)("a",{parentName:"p",href:"./maps"},"Maps")," but are optimized in Michelson for large datasets.\nLike maps, big-maps associate keys to values, where all keys are the same type and all values are the same type.\nLike maps, the keys must be comparable types, which includes most primitives and tuples consisting of otherwise comparable types."),(0,i.kt)("p",null,"As described in ",(0,i.kt)("a",{parentName:"p",href:"./maps"},"Maps"),", to read a single element from a map, the contract must load the entire map.\nBy contrast, elements in big-maps are lazily deserialised, which means that when a contract reads elements from a big-map, it loads only the elements that it needs to access, instead of the entire big-map.\nLoading only the necessary elements makes big-maps more cost-effective than maps when the dataset gets large because the contract manipulates less data.\nInternally, big-maps also store their keys as hashes instead of raw data, which can save space when the keys are large or complex."),(0,i.kt)("p",null,"Despite these internal differences, big-maps behave much like maps in contracts.\nHowever, the way big-maps are stored and deserialised causes these limitations that maps don't have:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"You can't get the number of elements in a big-map like you can with the ",(0,i.kt)("inlineCode",{parentName:"li"},"Map.size")," function."),(0,i.kt)("li",{parentName:"ul"},"There is no way to get a list of all of the keys in a big-map."),(0,i.kt)("li",{parentName:"ul"},"You can't iterate through the elements in a big-map or use functions that access all of the elements in a big-map like the ",(0,i.kt)("inlineCode",{parentName:"li"},"Map.fold")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"Map.map")," functions."),(0,i.kt)("li",{parentName:"ul"},"Big-maps are not packable.")),(0,i.kt)("h2",{id:"creating-big-maps"},"Creating big-maps"),(0,i.kt)("p",null,"To create a big-map, you can use the predefined value ",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.empty")," or create a non-empty map by passing a list of pairs of keys and values to the function ",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.literal"),".\nThis example creates a big-map type that uses a string for the key and a list of strings for the value:"),(0,i.kt)(p.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=big_maps",group:"big_maps"},'type word       = string\ntype definition = string list\ntype dictionary = (word, definition) big_map\n\nlet empty_dict : dictionary = Big_map.empty\n\nlet dictionary : dictionary =\n  Big_map.literal [\n    ("one", ["The number 1."; "A member of a group."]);\n    ("two", ["The number 2"])]\n')),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.literal")," predefined function builds a big-map from a list of key-value pairs, ",(0,i.kt)("inlineCode",{parentName:"p"},"(<key>, <value>)"),".\nNote that each binding in the list is separated with a semicolon (",(0,i.kt)("inlineCode",{parentName:"p"},";"),")."),(0,i.kt)("p",null,"For reference, see the predefined ",(0,i.kt)("a",{parentName:"p",href:"../reference/big-map-reference"},"module Big_map"),".")),(0,i.kt)(p.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=big_maps",group:"big_maps"},'type word       = string;\ntype definition = list<string>;\ntype dictionary = big_map<word, definition>;\n\nconst empty_dict: dictionary = Big_map.empty;\n\nconst dictionary: dictionary =\n  Big_map.literal([\n    ["one", (["The number 1.", "A member of a group."] as definition)],\n    ["two", (["The number 2."] as definition)]]);\n')),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.literal")," predefined function builds a big-map from a list of key-value pairs, ",(0,i.kt)("inlineCode",{parentName:"p"},"[<key>, <value>]"),".\nNote that each binding in the list is separated with a comma (",(0,i.kt)("inlineCode",{parentName:"p"},","),")."),(0,i.kt)("p",null,"For reference, see the predefined ",(0,i.kt)("a",{parentName:"p",href:"../reference/big-map-reference"},"namespace Big_map"),".")),(0,i.kt)("h2",{id:"searching-for-elements"},"Searching for elements"),(0,i.kt)("p",null,"The predefined function ",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.mem")," returns true if a value exists in the big-map for a given key."),(0,i.kt)(p.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=big_map_searching",group:"big_map_searching"},'let my_big_map : (int, string) big_map =\n  Big_map.literal [(1,"one"); (2,"two")]\nlet contains_2 : bool = Big_map.mem 2 my_big_map // = true\n'))),(0,i.kt)(p.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=big_map_searching",group:"big_map_searching"},'const my_big_map: big_map<int,string> =\n  Big_map.literal([[1, "one"], [2, "two"]]);\nconst contains_2: bool = Big_map.mem(2, my_big_map); // == true\n'))),(0,i.kt)("p",null,"To get the value for a key, use the ",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.find_opt")," function, which returns an ",(0,i.kt)("a",{parentName:"p",href:"./variants#options"},"option"),".\nIf the key exists in the big-map, the option is ",(0,i.kt)("inlineCode",{parentName:"p"},"Some()")," with the value.\nIf the key does not exist in the big-map, the option is ",(0,i.kt)("inlineCode",{parentName:"p"},"None()"),"."),(0,i.kt)("p",null,"Because the return value of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.find_opt")," function is an option, you must account for missing keys in the big-map by ",(0,i.kt)("a",{parentName:"p",href:"./variants#matching"},"matching")," the return value, as in this example:"),(0,i.kt)(p.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=big_map_searching",group:"big_map_searching"},'let value_option : string option = Big_map.find_opt 2 my_big_map\nlet value = match value_option with\n    Some value -> value\n  | None -> failwith "No value."\n'))),(0,i.kt)(p.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=big_map_searching",group:"big_map_searching"},'const value_option: option<string> = Big_map.find_opt(2, my_big_map);\nconst value = $match(value_option, {\n  "Some": value => value,\n  "None": () => failwith("No value."),\n});\n'))),(0,i.kt)("p",null,"As shorthand, you can use the function ",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.find"),".\nThis function behaves like the previous example: it returns the value for a key if it exists or fails with the message ",(0,i.kt)("inlineCode",{parentName:"p"},"MAP FIND")," if the value does not exist."),(0,i.kt)("h2",{id:"adding-elements"},"Adding elements"),(0,i.kt)("p",null,"To add an element to a big-map, pass the key and value to the ",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.add")," function.\nIf the key already exists, the corresponding value is updated."),(0,i.kt)(p.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=big_map_adding",group:"big_map_adding"},'let my_map : (int, string) big_map =\n  Big_map.literal [(1,"one"); (2,"two")]\nlet new_map = Big_map.add 3 "three" my_map\nlet contains_3 = Big_map.mem 3 new_map // = true\n'))),(0,i.kt)(p.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=big_map_adding",group:"big_map_adding"},'const my_map: big_map<int,string> =\n  Big_map.literal([[1,"one"],[2,"two"]]);\nconst new_map = Big_map.add(3, "three", my_map);\nconst contains_3 = Big_map.mem(3, new_map); // == true\n'))),(0,i.kt)("h2",{id:"removing-elements"},"Removing elements"),(0,i.kt)("p",null,"The function ",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.remove")," creates a big-map containing the elements of a given big-map, without the element with the given key.\nIf the element is not already present, the new big-map is the same as the old one."),(0,i.kt)(p.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=big_map_removing",group:"big_map_removing"},'let my_map : (int, string) big_map =\n  Big_map.literal [(1,"one"); (2,"two")]\nlet new_map = Big_map.remove 2 my_map\nlet contains_3 = Big_map.mem 2 new_map // = false\n'))),(0,i.kt)(p.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=big_map_removing",group:"big_map_removing"},'const my_map: big_map<int,string> =\n  Big_map.literal([[1,"one"],[2,"two"]]);\nconst new_map = Big_map.remove(2, my_map);\nconst contains_3 = Big_map.mem(2, new_map); // == false\n'))),(0,i.kt)("h2",{id:"updating-elements"},"Updating elements"),(0,i.kt)("p",null,"Previous sections show how to add and remove an element from a big-map.\nThe function ",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.update")," can do both depending whether some value is given for the new binding or not."),(0,i.kt)("p",null,"To update a big-map in this way, pass the key and an option with the value.\nIf the option is ",(0,i.kt)("inlineCode",{parentName:"p"},"Some(value)"),", the function adds the element, replacing any element with the given key.\nIf the option is ",(0,i.kt)("inlineCode",{parentName:"p"},"None()"),", the function removes the element with the given key if it exists.\nIn either case, the function returns a new big-map, as in these examples:"),(0,i.kt)(p.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=big_map_updating",group:"big_map_updating"},'let my_map : (int, string) big_map =\n  Big_map.literal [(1,"one"); (2,"two")]\nlet map_with_3 = Big_map.update 3 (Some "three") my_map\nlet contains_3 = Big_map.mem 3 map_with_3 // = true\nlet map_without_2 = Big_map.update 2 None my_map\nlet contains_2 = Big_map.mem 2 map_without_2 // = false\n'))),(0,i.kt)(p.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=big_map_updating",group:"big_map_updating"},'const my_map: big_map<int,string> =\n  Big_map.literal([[1,"one"],[2,"two"]]);\nconst map_with_3 = Big_map.update (3, ["Some" as "Some", "three"], my_map);\nconst contains_3 = Big_map.mem(3, map_with_3); // == true\nconst map_without_2 = Big_map.update(2, ["None" as "None"], my_map);\nconst contains_2 = Big_map.mem (2, map_without_2); // == false\n'))),(0,i.kt)("p",null,"To simultaneously update a map and obtain the value of the updated element, use the function ",(0,i.kt)("inlineCode",{parentName:"p"},"Big_map.get_and_update"),".\nThis function allows you to extract a value from a big-map for use, as in this example:"),(0,i.kt)(p.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=big_map_updating",group:"big_map_updating"},'// three = Some "three"\nlet three, map_without_3 = Big_map.get_and_update 3 None map_with_3\n'))),(0,i.kt)(p.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=big_map_updating",group:"big_map_updating"},'// three == ["Some" as "Some", "three"]\nconst [three, map_without_3] =\n  Big_map.get_and_update(3, ["None" as "None"], map_with_3);\n'))))}u.isMDXComponent=!0}}]);