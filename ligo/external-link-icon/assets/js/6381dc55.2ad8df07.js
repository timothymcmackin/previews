"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[65365],{3905:(t,n,e)=>{e.d(n,{Zo:()=>l,kt:()=>h});var o=e(67294);function a(t,n,e){return n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}function r(t,n){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(t,n).enumerable}))),e.push.apply(e,o)}return e}function c(t){for(var n=1;n<arguments.length;n++){var e=null!=arguments[n]?arguments[n]:{};n%2?r(Object(e),!0).forEach((function(n){a(t,n,e[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):r(Object(e)).forEach((function(n){Object.defineProperty(t,n,Object.getOwnPropertyDescriptor(e,n))}))}return t}function i(t,n){if(null==t)return{};var e,o,a=function(t,n){if(null==t)return{};var e,o,a={},r=Object.keys(t);for(o=0;o<r.length;o++)e=r[o],n.indexOf(e)>=0||(a[e]=t[e]);return a}(t,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(o=0;o<r.length;o++)e=r[o],n.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(t,e)&&(a[e]=t[e])}return a}var s=o.createContext({}),p=function(t){var n=o.useContext(s),e=n;return t&&(e="function"==typeof t?t(n):c(c({},n),t)),e},l=function(t){var n=p(t.components);return o.createElement(s.Provider,{value:n},t.children)},u={inlineCode:"code",wrapper:function(t){var n=t.children;return o.createElement(o.Fragment,{},n)}},d=o.forwardRef((function(t,n){var e=t.components,a=t.mdxType,r=t.originalType,s=t.parentName,l=i(t,["components","mdxType","originalType","parentName"]),d=p(e),h=a,m=d["".concat(s,".").concat(h)]||d[h]||u[h]||r;return e?o.createElement(m,c(c({ref:n},l),{},{components:e})):o.createElement(m,c({ref:n},l))}));function h(t,n){var e=arguments,a=n&&n.mdxType;if("string"==typeof t||a){var r=e.length,c=new Array(r);c[0]=d;var i={};for(var s in n)hasOwnProperty.call(n,s)&&(i[s]=n[s]);i.originalType=t,i.mdxType="string"==typeof t?t:a,c[1]=i;for(var p=2;p<r;p++)c[p]=e[p];return o.createElement.apply(null,c)}return o.createElement.apply(null,e)}d.displayName="MDXCreateElement"},48720:(t,n,e)=>{e.d(n,{D:()=>a.Z,Z:()=>r});var o=e(67294),a=e(75402);const r=function(t){return o.createElement(a.Z.Consumer,null,(n=>{let{syntax:e}=n;return e===t.syntax?t.children:o.createElement(o.Fragment,null)}))}},10962:(t,n,e)=>{e.r(n),e.d(n,{assets:()=>p,contentTitle:()=>i,default:()=>d,frontMatter:()=>c,metadata:()=>s,toc:()=>l});var o=e(87462),a=(e(67294),e(3905)),r=e(48720);const c={id:"tezos-taco-shop-payout",title:"Paying out profits from the Taco Shop"},i=void 0,s={unversionedId:"tutorials/taco-shop/tezos-taco-shop-payout",id:"version-1.5.0/tutorials/taco-shop/tezos-taco-shop-payout",title:"Paying out profits from the Taco Shop",description:"In the",source:"@site/versioned_docs/version-1.5.0/tutorials/taco-shop/tezos-taco-shop-payout.md",sourceDirName:"tutorials/taco-shop",slug:"/tutorials/taco-shop/tezos-taco-shop-payout",permalink:"/previews/ligo/external-link-icon/docs/1.5.0/tutorials/taco-shop/tezos-taco-shop-payout",draft:!1,tags:[],version:"1.5.0",frontMatter:{id:"tezos-taco-shop-payout",title:"Paying out profits from the Taco Shop"},sidebar:"docs",previous:{title:"The Taco Shop Smart Contract",permalink:"/previews/ligo/external-link-icon/docs/1.5.0/tutorials/taco-shop/tezos-taco-shop-smart-contract"},next:{title:"Start a project from a template",permalink:"/previews/ligo/external-link-icon/docs/1.5.0/tutorials/start-a-project-from-a-template"}},p={},l=[{value:"Analysing the Current Contract",id:"analysing-the-current-contract",level:2},{value:"<strong><code>taco-shop.mligo</code></strong>",id:"taco-shopmligo",level:3},{value:"<strong><code>taco-shop.jsligo</code></strong>",id:"taco-shopjsligo",level:3},{value:"Purchase Price Formula",id:"purchase-price-formula",level:3},{value:"Designing a Payout Scheme",id:"designing-a-payout-scheme",level:2},{value:"Forging a Payout Transaction",id:"forging-a-payout-transaction",level:2},{value:"Defining the Recipient",id:"defining-the-recipient",level:3},{value:"Adding the Transaction to the List of Output Operations",id:"adding-the-transaction-to-the-list-of-output-operations",level:3},{value:"Finalising the Contract",id:"finalising-the-contract",level:2},{value:"<strong><code>taco-shop.mligo</code></strong>",id:"taco-shopmligo-1",level:3},{value:"<strong><code>taco-shop.jsligo</code></strong>",id:"taco-shopjsligo-1",level:3},{value:"Dry-run the Contract",id:"dry-run-the-contract",level:3},{value:"\ud83d\udc7c Bonus: Donating Part of the Profits",id:"-bonus-donating-part-of-the-profits",level:2}],u={toc:l};function d(t){let{components:n,...e}=t;return(0,a.kt)("wrapper",(0,o.Z)({},u,e,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"In the\n",(0,a.kt)("a",{parentName:"p",href:"/previews/ligo/external-link-icon/docs/1.5.0/tutorials/taco-shop/tezos-taco-shop-smart-contract"},"previous tutorial"),"\nwe have learnt how to setup & interact with the LIGO CLI. Followed an\nimplementation of a simple Taco Shop smart contract for our\nentrepreneur Pedro."),(0,a.kt)("p",null,"In this tutorial we will make sure Pedro has access to tokens that\npeople have spent at his shop when buying tacos."),(0,a.kt)("br",null),(0,a.kt)("img",{src:"/img/tutorials/get-started/tezos-taco-shop-payout/get-money.svg",width:"50%"}),(0,a.kt)("div",{style:{opacity:.7,textAlign:"center",fontSize:"10px"}},(0,a.kt)("div",null,"Icons made by ",(0,a.kt)("a",{href:"https://www.flaticon.com/authors/smashicons",title:"Smashicons"},"Smashicons")," from ",(0,a.kt)("a",{href:"https://www.flaticon.com/",title:"Flaticon"},"www.flaticon.com")," is licensed by ",(0,a.kt)("a",{href:"http://creativecommons.org/licenses/by/3.0/",title:"Creative Commons BY 3.0",target:"_blank"},"CC 3.0 BY"))),(0,a.kt)("h2",{id:"analysing-the-current-contract"},"Analysing the Current Contract"),(0,a.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,a.kt)("h3",{id:"taco-shopmligo"},(0,a.kt)("strong",{parentName:"h3"},(0,a.kt)("inlineCode",{parentName:"strong"},"taco-shop.mligo"))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=a",group:"a"},'module TacoShop = struct\n  type taco_supply =\n    {\n     current_stock : nat;\n     max_price : tez\n    }\n\n  type taco_shop_storage = (nat, taco_supply) map\n\n  [@entry]\n  let buy_taco (taco_kind_index : nat) (taco_shop_storage : taco_shop_storage)\n  : operation list * taco_shop_storage =\n    (* Retrieve the taco_kind from the contract\'s storage or fail *)\n\n    let taco_kind =\n      match Map.find_opt (taco_kind_index) taco_shop_storage with\n        Some k -> k\n      | None -> failwith "Unknown kind of taco" in\n    let current_purchase_price : tez =\n      taco_kind.max_price / taco_kind.current_stock in\n    (* We won\'t sell tacos if the amount is not correct *)\n\n    let () =\n      if (Tezos.get_amount ()) <> current_purchase_price\n      then\n        failwith\n          "Sorry, the taco you are trying to purchase has a different price" in\n    (* Update the storage decreasing the stock by 1n *)\n\n    let taco_shop_storage =\n      Map.update\n        taco_kind_index\n        (Some\n           {taco_kind with current_stock = abs (taco_kind.current_stock - 1n)})\n        taco_shop_storage in\n    [], taco_shop_storage\n\nend\n\nlet default_storage : TacoShop.taco_shop_storage =\n  Map.literal\n    [\n      (1n,\n       {\n        current_stock = 50n;\n        max_price = 50000000mutez\n       });\n      (2n,\n       {\n        current_stock = 20n;\n        max_price = 75000000mutez\n       })\n    ]\n'))),(0,a.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,a.kt)("h3",{id:"taco-shopjsligo"},(0,a.kt)("strong",{parentName:"h3"},(0,a.kt)("inlineCode",{parentName:"strong"},"taco-shop.jsligo"))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=a",group:"a"},'namespace TacoShop {\n  export type taco_supply = { current_stock: nat, max_price: tez };\n  export type taco_shop_storage = map<nat, taco_supply>;\n\n  @entry\n  function buy_taco(taco_kind_index: nat, taco_shop_storage: taco_shop_storage): [\n    list<operation>,\n    taco_shop_storage\n  ]  {\n  /* Retrieve the taco_kind from the contracts storage or fail */\n  const taco_kind : taco_supply =\n    match (Map.find_opt (taco_kind_index, taco_shop_storage)) {\n      when(Some(kind)): kind;\n      when(None()): failwith ("Unknown kind of taco")\n    };\n  const current_purchase_price : tez = taco_kind.max_price / taco_kind.current_stock ;\n  /* We won\'t sell tacos if the amount is not correct */\n  if ((Tezos.get_amount ()) != current_purchase_price) {\n    return failwith ("Sorry, the taco you are trying to purchase has a different price")\n  } else {\n    /* Update the storage decreasing the stock by 1n */\n    const taco_shop_storage = Map.update (\n      taco_kind_index,\n      (Some ({...taco_kind, current_stock : abs (taco_kind.current_stock - 1n) })),\n      taco_shop_storage );\n    return [list([]), taco_shop_storage]\n  }\n  };\n};\n\nconst default_storage: TacoShop.taco_shop_storage =\n  Map.literal(\n    list(\n      [\n        [1n, { current_stock: 50n, max_price: 50000000mutez }],\n        [2n, { current_stock: 20n, max_price: 75000000mutez }]\n      ]\n    )\n  );\n\n'))),(0,a.kt)("h3",{id:"purchase-price-formula"},"Purchase Price Formula"),(0,a.kt)("p",null,"Pedro's Taco Shop contract currently enables customers to buy tacos,\nat a price based on a simple formula."),(0,a.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},"let current_purchase_price : tez =\n  taco_kind.max_price / taco_kind.current_stock\n"))),(0,a.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},"const current_purchase_price : tez =\n  taco_kind.max_price / taco_kind.current_stock\n"))),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"designing-a-payout-scheme"},"Designing a Payout Scheme"),(0,a.kt)("p",null,"Pedro is a standalone business owner, and in our case, he does not\nhave to split profits and earnings of the taco shop with anyone. So\nfor the sake of simplicity, we will payout all the earned XTZ directly\nto Pedro right after a successful purchase."),(0,a.kt)("p",null,"This means that after all the ",(0,a.kt)("em",{parentName:"p"},"purchase conditions")," of our contract\nare met, e.g., the correct amount is sent to the contract, we will not\nonly decrease the supply of the individual purchased ",(0,a.kt)("em",{parentName:"p"},"taco kind"),", but\nwe will also transfer this amount in a ",(0,a.kt)("em",{parentName:"p"},"subsequent transaction")," to\nPedro's personal address."),(0,a.kt)("h2",{id:"forging-a-payout-transaction"},"Forging a Payout Transaction"),(0,a.kt)("h3",{id:"defining-the-recipient"},"Defining the Recipient"),(0,a.kt)("p",null,"In order to send tokens, we will need a receiver address, which, in\nour case, will be Pedro's personal account. Additionally we will wrap\nthe given address as a ",(0,a.kt)("em",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"em"},"contract (unit)")),", which represents either a\ncontract with no parameters, or an implicit account."),(0,a.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=ex1",group:"ex1"},'let ownerAddress : address = ("tz1TGu6TN5GSez2ndXXeDX6LgUDvLzPLqgYV" : address)\nlet receiver : unit contract =\n  match (Tezos.get_contract_opt ownerAddress : unit contract option) with\n    Some (contract) -> contract\n  | None -> (failwith "Not a contract" : unit contract)\n'))),(0,a.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=ex1",group:"ex1"},'const ownerAddress = ("tz1TGu6TN5GSez2ndXXeDX6LgUDvLzPLqgYV" as address)\nconst receiver : contract<unit> =\n  match (Tezos.get_contract_opt(ownerAddress) as option<contract<unit>>) {\n    when(Some(contract)): contract;\n    when(None()): (failwith ("Not a contract") as contract<unit>)\n  }\n'))),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Would you like to learn more about addresses, contracts and\noperations in LIGO? Check out the\n",(0,a.kt)("a",{parentName:"p",href:"/previews/ligo/external-link-icon/docs/1.5.0/api/cheat-sheet"},"LIGO cheat sheet"))),(0,a.kt)("h3",{id:"adding-the-transaction-to-the-list-of-output-operations"},"Adding the Transaction to the List of Output Operations"),(0,a.kt)("p",null,"Now we can transfer the amount received by ",(0,a.kt)("inlineCode",{parentName:"p"},"buy_taco")," to Pedro's\n",(0,a.kt)("inlineCode",{parentName:"p"},"ownerAddress"),". We will do so by forging a ",(0,a.kt)("inlineCode",{parentName:"p"},"transaction (unit, amount,\nreceiver)")," within a list of operations returned at the end of our\ncontract."),(0,a.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=ex1",group:"ex1"},"let payoutOperation : operation = Tezos.transaction () (Tezos.get_amount ()) receiver\nlet operations : operation list = [payoutOperation]\n"))),(0,a.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=ex1",group:"ex1"},"const payoutOperation : operation = Tezos.transaction (unit, Tezos.get_amount (), receiver) ;\nconst operations : list <operation> = list([payoutOperation]);\n"))),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"finalising-the-contract"},"Finalising the Contract"),(0,a.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,a.kt)("h3",{id:"taco-shopmligo-1"},(0,a.kt)("strong",{parentName:"h3"},(0,a.kt)("inlineCode",{parentName:"strong"},"taco-shop.mligo"))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=b",group:"b"},'module TacoShop = struct\n  type taco_supply =\n    {\n     current_stock : nat;\n     max_price : tez\n    }\n\n  type taco_shop_storage = (nat, taco_supply) map\n\n  let ownerAddress : address = ("tz1TGu6TN5GSez2ndXXeDX6LgUDvLzPLqgYV" : address)\n\n  [@entry]\n  let buy_taco (taco_kind_index : nat) (taco_shop_storage : taco_shop_storage)\n  : operation list * taco_shop_storage =\n    (* Retrieve the taco_kind from the contract\'s storage or fail *)\n\n    let taco_kind =\n      match Map.find_opt (taco_kind_index) taco_shop_storage with\n        Some k -> k\n      | None -> failwith "Unknown kind of taco" in\n    let current_purchase_price : tez =\n      taco_kind.max_price / taco_kind.current_stock in\n    (* We won\'t sell tacos if the amount is not correct *)\n\n    let () =\n      if (Tezos.get_amount ()) <> current_purchase_price\n      then\n        failwith\n          "Sorry, the taco you are trying to purchase has a different price" in\n    (* Update the storage decreasing the stock by 1n *)\n\n    let taco_shop_storage =\n      Map.update\n        taco_kind_index\n        (Some\n           {taco_kind with current_stock = abs (taco_kind.current_stock - 1n)})\n        taco_shop_storage in\n\n    let receiver : unit contract =\n      match (Tezos.get_contract_opt ownerAddress : unit contract option) with\n        Some (contract) -> contract\n      | None -> (failwith "Not a contract" : unit contract) in \n\n    let payoutOperation : operation = Tezos.transaction () (Tezos.get_amount ()) receiver in\n    let operations : operation list = [payoutOperation] in\n\n    operations, taco_shop_storage\nend\n\nlet default_storage : TacoShop.taco_shop_storage =\n  Map.literal\n    [\n      (1n,\n       {\n        current_stock = 50n;\n        max_price = 50000000mutez\n       });\n      (2n,\n       {\n        current_stock = 20n;\n        max_price = 75000000mutez\n       })\n    ]\n'))),(0,a.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,a.kt)("h3",{id:"taco-shopjsligo-1"},(0,a.kt)("strong",{parentName:"h3"},(0,a.kt)("inlineCode",{parentName:"strong"},"taco-shop.jsligo"))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=b",group:"b"},'namespace TacoShop {\n  export type taco_supply = { current_stock: nat, max_price: tez };\n  export type taco_shop_storage = map<nat, taco_supply>;\n\n  const ownerAddress = ("tz1TGu6TN5GSez2ndXXeDX6LgUDvLzPLqgYV" as address);\n\n  const donationAddress = ("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx" as address);\n\n  @entry\n  function buy_taco(taco_kind_index: nat, taco_shop_storage: taco_shop_storage): [\n    list<operation>,\n    taco_shop_storage\n  ]  {\n    /* Retrieve the taco_kind from the contracts storage or fail */\n\n    const taco_kind: taco_supply =\n      match(Map.find_opt(taco_kind_index, taco_shop_storage)) {\n        when (Some(kind)):\n          kind\n        when (None):\n          failwith("Unknown kind of taco")\n      };\n    const current_purchase_price: tez =\n      taco_kind.max_price / taco_kind.current_stock;\n    /* We won\'t sell tacos if the amount is not correct */\n\n    if ((Tezos.get_amount()) != current_purchase_price) {\n      return failwith(\n        "Sorry, the taco you are trying to purchase has a different price"\n      )\n    } else {\n      /* Update the storage decreasing the stock by 1n */\n\n      const taco_shop_storage =\n        Map.update(\n          taco_kind_index,\n          (\n            Some({\n              ...taco_kind, current_stock: abs(taco_kind.current_stock - 1n)\n            })\n          ),\n          taco_shop_storage\n        );\n\n      const receiver : contract<unit> =\n      match ((Tezos.get_contract_opt (ownerAddress))) {\n        when(Some(contract)): contract;\n        when(None()): ((failwith ("Not a contract")))\n      };\n\n      const donationReceiver : contract<unit>  =\n        match ((Tezos.get_contract_opt (donationAddress))) {\n          when(Some(contract)): contract;\n          when(None()): ((failwith ("Not a contract")))\n        };\n\n      const donationAmount = ((Tezos.get_amount ()) / 10n) as tez;\n\n      // Pedro will get 90% of the amount\n      const op1 = match ((Tezos.get_amount ()) - donationAmount) {\n        when(Some(x)): Tezos.transaction (unit, x, receiver);\n        when(None()): failwith ("Insufficient balance")\n      };\n      const op2 = Tezos.transaction (unit, donationAmount, donationReceiver);\n      const operations : list<operation> = list([ op1 , op2 ]);\n\n      return [operations, taco_shop_storage]\n    }\n  };\n}\nconst default_storage: TacoShop.taco_shop_storage =\n  Map.literal(\n    list(\n      [\n        [1n, { current_stock: 50n, max_price: 50000000mutez }],\n        [2n, { current_stock: 20n, max_price: 75000000mutez }]\n      ]\n    )\n  );\n\n'))),(0,a.kt)("h3",{id:"dry-run-the-contract"},"Dry-run the Contract"),(0,a.kt)("p",null,"To confirm that our contract is valid, we can dry-run it. As a result,\nwe see a ",(0,a.kt)("em",{parentName:"p"},"new operation")," in the list of returned operations to be\nexecuted subsequently."),(0,a.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},'ligo run dry-run taco-shop.mligo --syntax cameligo --amount 1 --entry-point buy_taco 1n "Map.literal [\n    (1n, {  current_stock = 50n;  max_price = 50tez }) ;\n    (2n, {  current_stock = 20n;  max_price = 75tez }) ;\n]"\n'))),(0,a.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},"ligo run dry-run taco-shop.jsligo --syntax jsligo -m TacoShop --amount 1 --entry-point buy_taco '1n' \"default_storage\"\n"))),(0,a.kt)("img",{src:"/img/tutorials/get-started/tezos-taco-shop-payout/dry-run-1.png"}),(0,a.kt)("div",{style:{opacity:.7,textAlign:"center",fontSize:"12px",marginTop:"-24px"}},(0,a.kt)("b",null,"Operation(...bytes)")," included in the output"),(0,a.kt)("br",null),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Done! Our tokens are no longer locked in the contract, and instead\nthey are sent to Pedro's personal account/wallet.")),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"-bonus-donating-part-of-the-profits"},"\ud83d\udc7c Bonus: Donating Part of the Profits"),(0,a.kt)("p",null,"Because Pedro is a member of the Speciality Taco Association (STA), he\nhas decided to donate ",(0,a.kt)("strong",{parentName:"p"},"10%")," of the earnings to the STA. We will just\nadd a ",(0,a.kt)("inlineCode",{parentName:"p"},"donationAddress")," to the contract, and compute a 10% donation\nsum from each taco purchase."),(0,a.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=bonus",group:"bonus"},'let ownerAddress : address = ("tz1TGu6TN5GSez2ndXXeDX6LgUDvLzPLqgYV" : address)\nlet donationAddress : address = ("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx" : address)\n\nlet receiver : unit contract =\n  match ((Tezos.get_contract_opt ownerAddress) : unit contract option) with\n    Some contract -> contract\n  | None -> ((failwith "Not a contract") : unit contract)\n\nlet donationReceiver : unit contract  =\n  match ((Tezos.get_contract_opt donationAddress) : unit contract option) with\n    Some contract -> contract\n  | None -> ((failwith "Not a contract") : unit contract)\n\nlet donationAmount : tez = (Tezos.get_amount ()) / 10n\n\nlet operations : operation list =\n    // Pedro will get 90% of the amount\n    let op = match ((Tezos.get_amount ()) - donationAmount) with\n      | Some x -> Tezos.transaction () x receiver\n      | None -> (failwith "Insufficient balance")\n    in\n    [ op ; Tezos.transaction () donationAmount donationReceiver ]\n'))),(0,a.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=bonus",group:"bonus"},'const ownerAddress = ("tz1TGu6TN5GSez2ndXXeDX6LgUDvLzPLqgYV" as address);\nconst donationAddress = ("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx" as address);\n\nconst receiver : contract<unit> =\n  match ((Tezos.get_contract_opt (ownerAddress)) as option<contract<unit>>) {\n    when(Some(contract)): contract;\n    when(None()): ((failwith ("Not a contract")) as contract<unit>)\n  };\n\nconst donationReceiver : contract<unit>  =\n  match ((Tezos.get_contract_opt (donationAddress)) as option<contract<unit>>) {\n    when(Some(contract)): contract;\n    when(None()): ((failwith ("Not a contract")) as contract<unit>)\n  };\n\nconst donationAmount = ((Tezos.get_amount ()) / 10n) as tez;\n\n// Pedro will get 90% of the amount\nconst op1 = match ((Tezos.get_amount ()) - donationAmount) {\n  when(Some(x)): Tezos.transaction (unit, x, receiver);\n  when(None()): failwith ("Insufficient balance")\n};\nconst op2 = Tezos.transaction (unit, donationAmount, donationReceiver);\nconst operations : list<operation> = list([ op1 , op2 ]);\n'))),(0,a.kt)("p",null,"This will result into two operations being subsequently executed on the blockchain:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Donation transfer (10%)"),(0,a.kt)("li",{parentName:"ul"},"Pedro's profits (90%)")))}d.isMDXComponent=!0}}]);