"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[46934],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>d});var a=n(67294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var o=a.createContext({}),p=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(o.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,s=e.mdxType,i=e.originalType,o=e.parentName,m=r(e,["components","mdxType","originalType","parentName"]),c=p(n),d=s,g=c["".concat(o,".").concat(d)]||c[d]||u[d]||i;return n?a.createElement(g,l(l({ref:t},m),{},{components:n})):a.createElement(g,l({ref:t},m))}));function d(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var i=n.length,l=new Array(i);l[0]=c;var r={};for(var o in t)hasOwnProperty.call(t,o)&&(r[o]=t[o]);r.originalType=e,r.mdxType="string"==typeof e?e:s,l[1]=r;for(var p=2;p<i;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},48720:(e,t,n)=>{n.d(t,{D:()=>s.Z,Z:()=>i});var a=n(67294),s=n(75402);const i=function(e){return a.createElement(s.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},62345:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>r,default:()=>c,frontMatter:()=>l,metadata:()=>o,toc:()=>m});var a=n(87462),s=(n(67294),n(3905)),i=n(48720);const l={title:"Sets"},r=void 0,o={unversionedId:"data-types/sets",id:"data-types/sets",title:"Sets",description:"Sets are collections of elements of the same type without any duplicates.",source:"@site/../docs/data-types/sets.md",sourceDirName:"data-types",slug:"/data-types/sets",permalink:"/previews/ligo/external-link-icon/docs/next/data-types/sets",draft:!1,tags:[],version:"current",frontMatter:{title:"Sets"},sidebar:"docs",previous:{title:"Records",permalink:"/previews/ligo/external-link-icon/docs/next/data-types/records"},next:{title:"Maps",permalink:"/previews/ligo/external-link-icon/docs/next/data-types/maps"}},p={},m=[{value:"Sizing",id:"sizing",level:2},{value:"Searching",id:"searching",level:2},{value:"Adding elements",id:"adding-elements",level:2},{value:"Removing elements",id:"removing-elements",level:2},{value:"Accessing elements",id:"accessing-elements",level:2},{value:"Processing sets",id:"processing-sets",level:2},{value:"Looping over sets",id:"looping-over-sets",level:3},{value:"Folding sets",id:"folding-sets",level:3},{value:"Mapping sets",id:"mapping-sets",level:3},{value:"Updating elements",id:"updating-elements",level:3},{value:"Iterating over sets",id:"iterating-over-sets",level:3}],u={toc:m};function c(e){let{components:t,...n}=e;return(0,s.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Sets are collections of elements of the same type without any duplicates.\nSets can be empty of contain any number of elements."),(0,s.kt)("p",null,"Sets are similar to  to ",(0,s.kt)("a",{parentName:"p",href:"./lists"},"lists")," because they are both collections of elements of the same type.\nThe main differences between sets and lists are:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Sets cannot contain duplicate entries, while lists can"),(0,s.kt)("li",{parentName:"ul"},"Sets are always automatically sorted, while you can put the elements of a list in any order")),(0,s.kt)("p",null,"Like lists, the type of sets is parameterised over the type of its elements.\nLike list elements, set elements must all have the same type."),(0,s.kt)("p",null,"The empty set is denoted by the predefined value ",(0,s.kt)("inlineCode",{parentName:"p"},"Set.empty"),".\nTo create a non-empty set, pass a list of literal values to the function ",(0,s.kt)("inlineCode",{parentName:"p"},"Set.literal"),", which returns a set containing them, minus any duplicates."),(0,s.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=sets",group:"sets"},"let empty_set : int set = Set.empty\nlet set1 : int set = Set.literal [3; 2; 2; 1]\n")),(0,s.kt)("admonition",{type:"note"},(0,s.kt)("p",{parentName:"admonition"},"The element ",(0,s.kt)("inlineCode",{parentName:"p"},"2")," is repeated in the list, but not in the set made from it.\nLIGO automatically removes duplicate elements in sets.")),(0,s.kt)("p",null,"To build a set from a list of arbitrary values (including variables and expressions, not just literal values), you must use ",(0,s.kt)("inlineCode",{parentName:"p"},"Set.of_list")," instead of ",(0,s.kt)("inlineCode",{parentName:"p"},"Set.literal"),", as in this example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=sets",group:"sets"},"let two = 2\nlet set2 : int set = Set.of_list [3; two; two; two + two; 1]\n")),(0,s.kt)("p",null,"For functions that work with sets, see the predefined ",(0,s.kt)("a",{parentName:"p",href:"../reference/set-reference/?lang=cameligo"},"module Set"),".")),(0,s.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=sets",group:"sets"},"const empty_set: set<int> = Set.empty;\nconst set1: set<int> = Set.literal([3, 2, 2, 1]);\n")),(0,s.kt)("admonition",{type:"note"},(0,s.kt)("p",{parentName:"admonition"},"The element ",(0,s.kt)("inlineCode",{parentName:"p"},"2")," is repeated in the list, but not in the set made from it.\nLIGO automatically removed the duplicate.")),(0,s.kt)("p",null,"To build a set from a list of arbitrary values (including variables and expressions, not just literal values), you must use ",(0,s.kt)("inlineCode",{parentName:"p"},"Set.of_list")," instead of ",(0,s.kt)("inlineCode",{parentName:"p"},"Set.literal"),", as in this example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=sets",group:"sets"},"const two = 2;\nconst set2 : set<int> = Set.of_list([3, two, two, two + two, 1]);\n")),(0,s.kt)("p",null,"For functions that work with sets, see the predefined ",(0,s.kt)("a",{parentName:"p",href:"../reference/set-reference/?lang=jsligo"},"namespace Set"),".")),(0,s.kt)("p",null,"Set elements are automatically sorted by increasing values, so the type of the elements must be ",(0,s.kt)("em",{parentName:"p"},"comparable"),", that is, they obey a total order (any two elements can be compared)."),(0,s.kt)("h2",{id:"sizing"},"Sizing"),(0,s.kt)("p",null,"The predefined functions ",(0,s.kt)("inlineCode",{parentName:"p"},"Set.size")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"Set.cardinal")," return the number of elements in a given set."),(0,s.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=cardinal",group:"cardinal"},"let my_set : int set = Set.literal [3; 2; 2; 1]\nlet cardinal : nat = Set.size my_set // = 3\n"))),(0,s.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=cardinal",group:"cardinal"},"const my_set: set<int> = Set.literal([3, 2, 2, 1]);\nconst cardinal: nat = Set.size(my_set); // == 3\n"))),(0,s.kt)("h2",{id:"searching"},"Searching"),(0,s.kt)("p",null,"The function ",(0,s.kt)("inlineCode",{parentName:"p"},"Set.mem")," tests for membership in a given set."),(0,s.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=set_membership",group:"set_membership"},"let my_set : int set = Set.literal [3; 2; 2; 1]\nlet contains_3 : bool = Set.mem 3 my_set // = true\n"))),(0,s.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=set_membership",group:"set_membership"},"const my_set: set<int> = Set.literal([3, 2, 2, 1]);\nconst contains_3: bool = Set.mem(3, my_set); // == true\n"))),(0,s.kt)("h2",{id:"adding-elements"},"Adding elements"),(0,s.kt)("p",null,"To add an element to a set, pass the element and the set to the ",(0,s.kt)("inlineCode",{parentName:"p"},"Set.add")," function, which returns a new set.\nIf the element was already present in the given set, the resulting set is the same as the original one."),(0,s.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=set_adding",group:"set_adding"},"let my_set : int set = Set.literal [3; 2; 2; 1]\nlet with_4 : int set = Set.add 4 my_set\n"))),(0,s.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=set_adding",group:"set_adding"},"const my_set: set<int> = Set.literal([3, 2, 2, 1]);\nconst with_4: set<int> = Set.add(4, my_set);\n"))),(0,s.kt)("h2",{id:"removing-elements"},"Removing elements"),(0,s.kt)("p",null,"To remove an element from a set, pass the element and the set to the ",(0,s.kt)("inlineCode",{parentName:"p"},"Set.remove")," function, which returns a new set.\nIf the element is not already present, the new set is the same as the old one."),(0,s.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=set_removing",group:"set_removing"},"let my_set : int set = Set.literal [3; 2; 2; 1]\nlet new_set = Set.remove 3 my_set\nlet contains_3 = Set.mem 3 new_set // = false\n"))),(0,s.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=set_removing",group:"set_removing"},"const my_set: set<int> = Set.literal([3, 2, 2, 1]);\nconst new_set = Set.remove(3, my_set);\nconst contains_3 = Set.mem(3, new_set); // == false\n"))),(0,s.kt)("h2",{id:"accessing-elements"},"Accessing elements"),(0,s.kt)("p",null,"You cannot access elements directly in sets, such as getting the element with an arbitrary index.\nThe main way to get elements from sets is to use ",(0,s.kt)("inlineCode",{parentName:"p"},"Set.mem")," to see if a specified element is in a set.\nYou can also use loops and the other functions listed below to process a set and access specific elements."),(0,s.kt)("h2",{id:"processing-sets"},"Processing sets"),(0,s.kt)("p",null,"Aside from adding and removing elements from sets, you can use loops and functions that iterate over every element in a set."),(0,s.kt)("h3",{id:"looping-over-sets"},"Looping over sets"),(0,s.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("p",null,"There is no loop over sets in CameLIGO.")),(0,s.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("p",null,"You can use a ",(0,s.kt)("inlineCode",{parentName:"p"},"for")," loop to iterate over the elements in the set, in increasing order, in the form ",(0,s.kt)("inlineCode",{parentName:"p"},"for (const <variable> of <set>) <block>"),".\nThis statement means that the block of statements (or a single statement) runs once for each element in the set (",(0,s.kt)("inlineCode",{parentName:"p"},"<variable>"),") ranging over the elements of the set from left to right."),(0,s.kt)("p",null,"Here is an example where the integers in a set are summed up."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=set_looping",group:"set_looping"},"function sum_elt (s: set<int>) {\n  let sum = 0;\n  for (const e of s) sum = sum + e;\n  return sum;\n};\n"))),(0,s.kt)("h3",{id:"folding-sets"},"Folding sets"),(0,s.kt)("p",null,"Folding a set runs the same function on each element in a set and returns a single value.\nThe function takes two arguments: an ",(0,s.kt)("em",{parentName:"p"},"accumulator")," and the current set element, with which it produces a new accumulator to pass to the next iteration of the function.\nFolding lists allows you to compute a partial result that becomes complete when the traversal of the data structure is over."),(0,s.kt)("p",null,"Two ways to fold sets are available:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"The function ",(0,s.kt)("inlineCode",{parentName:"li"},"Set.fold")," iterates over the set in increasing order of its elements."),(0,s.kt)("li",{parentName:"ul"},"The function ",(0,s.kt)("inlineCode",{parentName:"li"},"Set.fold_desc")," iterates over the set in decreasing order of its elements.")),(0,s.kt)("p",null,"These functions take the same parameters, but the function that they run on the set elements is different.\nIn the ",(0,s.kt)("inlineCode",{parentName:"p"},"Set.fold")," function, the first parameter is the accumulator and the second parameter is the current element in the set.\nIn the ",(0,s.kt)("inlineCode",{parentName:"p"},"Set.fold_desc")," function, the first parameter is the current element in the set and the second parameter is the accumulator."),(0,s.kt)("p",null,"For a more detailed explanation of fold functions, see ",(0,s.kt)("a",{parentName:"p",href:"./lists#folding-lists"},"Folding lists"),"."),(0,s.kt)("p",null,"These examples use fold functions to turn a set into a list that is either sorted in increasing or decreasing order:"),(0,s.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=set_folding",group:"set_folding"},"let s : int set = Set.literal [1; 2; 3]\n// incr = [3; 2; 1]\nlet incr : int list = Set.fold (fun (a,i) -> i::a) s []\n// decr = [1; 2; 3]\nlet decr : int list = Set.fold_desc (fun (i,a) -> i::a) s []\n"))),(0,s.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=set_folding",group:"set_folding"},"const s: set<int> = Set.literal([1, 2, 3]);\n// incr == [3, 2, 1]\nconst incr: list<int> = Set.fold (([a,i]) => ([i,...a] as list<int>), s, []);\n// decr == [1, 2, 3]\nconst decr: list<int> = Set.fold_desc (([i,a]) => ([i,...a] as list<int>), s, []);\n"))),(0,s.kt)("h3",{id:"mapping-sets"},"Mapping sets"),(0,s.kt)("p",null,"Mapping a set runs the same function on each element in a set and returns a new set with the result of each function operation.\nThis is called a ",(0,s.kt)("em",{parentName:"p"},"map operation"),", not to be confused with the map data type.\nTo map a set, use the ",(0,s.kt)("inlineCode",{parentName:"p"},"Set.map")," function, as in this example:"),(0,s.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=set_mapping",group:"set_mapping"},"let s : int set = Set.literal [5; 1; 2; 2]\n// plus_one = Set.literal [6; 2; 3]\nlet plus_one : int set = Set.map (fun i -> i + 1) s\n"))),(0,s.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=set_mapping",group:"set_mapping"},"const s: set<int> = Set.literal([5,1,2,2]);\n// plus_one == Set.literal([6,2,3])\nconst plus_one: set<int> = Set.map(i => i + 1, s);\n"))),(0,s.kt)("h3",{id:"updating-elements"},"Updating elements"),(0,s.kt)("p",null,"Previous sections show how to add and remove an element from a given set.\nThe function ",(0,s.kt)("inlineCode",{parentName:"p"},"Set.update")," can do both depending on a boolean value: if true, then the given value is added to the set, otherwise it is removed (if present)."),(0,s.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=set_updating",group:"set_updating"},"let nats : int set = Set.literal [3; 2; 2; 1]\nlet set_with_5 = Set.update 5 true nats\nlet set_without_3 = Set.update 3 false nats\n"))),(0,s.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=set_updating",group:"set_updating"},"const nats: set<int> = Set.literal([3, 2, 2, 1]);\nconst set_with_5 = Set.update(5, true, nats);\nconst set_without_3 = Set.update(3, false, nats);\n"))),(0,s.kt)("p",null,"Similarly, the function ",(0,s.kt)("inlineCode",{parentName:"p"},"Set.filter_map")," applies the same function to every element in a set.\nIf the function returns a ",(0,s.kt)("inlineCode",{parentName:"p"},"None")," option, the element stays the same, but if it returns a ",(0,s.kt)("inlineCode",{parentName:"p"},"Some")," option, the element is replaced with the value in the option."),(0,s.kt)("p",null,"This example uses ",(0,s.kt)("inlineCode",{parentName:"p"},"Set.filter_map")," to remove all even numbers from a set:"),(0,s.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=set_updating",group:"set_updating"},"let f x = if x mod 2 = 0n then None else Some x\n// odds = Set.literal [3, 1]\nlet odds = Set.filter_map f nats\n"))),(0,s.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=set_updating",group:"set_updating"},'const f = x => x % 2 == (0 as nat) ?\n               ["None" as "None"] :\n               ["Some" as "Some", x];\n// odds == Set.literal([3, 1])\nconst odds = Set.filter_map(f, nats);\n'))),(0,s.kt)("h3",{id:"iterating-over-sets"},"Iterating over sets"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"Set.iter")," function is similar to the ",(0,s.kt)("inlineCode",{parentName:"p"},"Set.map")," function because it runs the same function on every element in a set.\nHowever, the ",(0,s.kt)("inlineCode",{parentName:"p"},"Set.iter")," function returns a value of type unit, so it cannot change the set.\nTherefore, this function is useful only to produce side effects, such as checking that each element of a set is within a certain range, and fail with an error otherwise."),(0,s.kt)("p",null,"This example iterates over a set to check that all its elements (integers) are greater than 3:"),(0,s.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=set_iterating",group:"set_iterating"},"let assert_all_greater_than_3 (s : int set) : unit =\n  Set.iter (fun i -> Assert.assert (i > 3)) s\n"))),(0,s.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=set_iterating",group:"set_iterating"},"const assert_all_greater_than_3 =\n  (s: set<int>): unit => Set.iter(i => Assert.assert(i > 3), s);\n"))))}c.isMDXComponent=!0}}]);