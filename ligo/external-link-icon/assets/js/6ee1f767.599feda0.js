"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[95834],{3905:(t,e,n)=>{n.d(e,{Zo:()=>p,kt:()=>d});var a=n(67294);function r(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function o(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function s(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?o(Object(n),!0).forEach((function(e){r(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function i(t,e){if(null==t)return{};var n,a,r=function(t,e){if(null==t)return{};var n,a,r={},o=Object.keys(t);for(a=0;a<o.length;a++)n=o[a],e.indexOf(n)>=0||(r[n]=t[n]);return r}(t,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);for(a=0;a<o.length;a++)n=o[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(r[n]=t[n])}return r}var c=a.createContext({}),l=function(t){var e=a.useContext(c),n=e;return t&&(n="function"==typeof t?t(e):s(s({},e),t)),n},p=function(t){var e=l(t.components);return a.createElement(c.Provider,{value:e},t.children)},m={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},u=a.forwardRef((function(t,e){var n=t.components,r=t.mdxType,o=t.originalType,c=t.parentName,p=i(t,["components","mdxType","originalType","parentName"]),u=l(n),d=r,g=u["".concat(c,".").concat(d)]||u[d]||m[d]||o;return n?a.createElement(g,s(s({ref:e},p),{},{components:n})):a.createElement(g,s({ref:e},p))}));function d(t,e){var n=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var o=n.length,s=new Array(o);s[0]=u;var i={};for(var c in e)hasOwnProperty.call(e,c)&&(i[c]=e[c]);i.originalType=t,i.mdxType="string"==typeof t?t:r,s[1]=i;for(var l=2;l<o;l++)s[l]=n[l];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},48720:(t,e,n)=>{n.d(e,{D:()=>r.Z,Z:()=>o});var a=n(67294),r=n(75402);const o=function(t){return a.createElement(r.Z.Consumer,null,(e=>{let{syntax:n}=e;return n===t.syntax?t.children:a.createElement(a.Fragment,null)}))}},20072:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>s,metadata:()=>c,toc:()=>p});var a=n(87462),r=(n(67294),n(3905)),o=n(48720);const s={id:"entrypoints",title:"Entrypoints"},i=void 0,c={unversionedId:"syntax/contracts/entrypoints",id:"syntax/contracts/entrypoints",title:"Entrypoints",description:"The entrypoints of a contract represent the different ways that it can be called, similar to a method or function in many programming languages or an endpoint of an API.",source:"@site/../docs/syntax/contracts/entrypoints.md",sourceDirName:"syntax/contracts",slug:"/syntax/contracts/entrypoints",permalink:"/previews/ligo/external-link-icon/docs/next/syntax/contracts/entrypoints",draft:!1,tags:[],version:"current",frontMatter:{id:"entrypoints",title:"Entrypoints"},sidebar:"docs",previous:{title:"Contracts",permalink:"/previews/ligo/external-link-icon/docs/next/syntax/contracts/"},next:{title:"Operations",permalink:"/previews/ligo/external-link-icon/docs/next/syntax/contracts/operation"}},l={},p=[{value:"Parameters",id:"parameters",level:2},{value:"Return values",id:"return-values",level:2},{value:"Logic",id:"logic",level:2},{value:"Storing and sending tez",id:"storing-and-sending-tez",level:2},{value:"Access control",id:"access-control",level:2},{value:"Calling other contracts",id:"calling-other-contracts",level:2},{value:"Scoping",id:"scoping",level:2},{value:"The default entrypoint",id:"the-default-entrypoint",level:2},{value:"The main function",id:"the-main-function",level:2},{value:"Workaround for the deprecation of the <code>main</code> function",id:"workaround-for-the-deprecation-of-the-main-function",level:3}],m={toc:p};function u(t){let{components:e,...n}=t;return(0,r.kt)("wrapper",(0,a.Z)({},m,n,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The entrypoints of a contract represent the different ways that it can be called, similar to a method or function in many programming languages or an endpoint of an API.\nA contract can have any number of internal functions, but only the functions designated as entrypoints can be called by outside consumers and other contracts."),(0,r.kt)("p",null,"Contracts must have at least one entrypoint, and they can have as many as needed.\nFor example, the following contract provides four entrypoints.\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"increment")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"decrement")," entrypoints increase or decrease a value in storage, the ",(0,r.kt)("inlineCode",{parentName:"p"},"reset")," entrypoint sets the value to 0, and the ",(0,r.kt)("inlineCode",{parentName:"p"},"default")," entrypoint increases the value by 1."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=incdec",group:"incdec"},"module IncDec = struct\n  type storage = int\n  type result = operation list * storage\n\n  (* Four entrypoints *)\n  [@entry] let increment (delta : int) (storage : storage) : result =\n    [], storage + delta\n  [@entry] let default (() : unit) (storage : storage) : result =\n    increment 1 storage\n  [@entry] let decrement (delta : int) (storage : storage) : result =\n    [], storage - delta\n  [@entry] let reset (() : unit) (_ : storage) : result =\n    [], 0\nend\n"))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=incdec",group:"incdec"},"export namespace IncDec {\n  type storage = int;\n  type result = [list<operation>, storage];\n\n  // Four entrypoints\n\n  // @entry\n  const increment = (delta: int, storage: storage): result =>\n    [[], storage + delta];\n\n  // @entry\n  const default = (_u: unit, storage: storage): result =>\n    increment(1, storage)\n\n  // @entry\n  const decrement = (delta: int, storage: storage): result =>\n    [[], storage - delta];\n\n  // @entry\n  const reset = (_p: unit, _s: storage): result =>\n    [[], 0];\n};\n"))),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("p",null,"To call an entrypoint, pass the name of the entrypoint with an initial capital and the parameter.\nFor example, this ",(0,r.kt)("inlineCode",{parentName:"p"},"run dry-run")," command calls the ",(0,r.kt)("inlineCode",{parentName:"p"},"increment")," entrypoint in the previous contract:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"ligo run dry-run -m IncDec gitlab-pages/docs/syntax/contracts/src/entrypoints/incdec.mligo 'Increment(5)' '4'\n")),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"The entrypoint name in the ",(0,r.kt)("inlineCode",{parentName:"p"},"dry-run")," command always starts with a capital letter, even if the entrypoint name in the source code starts with a lower case letter."))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("p",null,"To call an entrypoint, you can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"run dry-run")," command, as in this example, which calls the ",(0,r.kt)("inlineCode",{parentName:"p"},"increment")," entrypoint in the previous contract:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"ligo run dry-run -m IncDec gitlab-pages/docs/syntax/contracts/src/entrypoints/incdec.jsligo '[\"Increment\" as \"Increment\", 5]' '4'\n")),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"The parameter is a ",(0,r.kt)("a",{parentName:"p",href:"../../data-types/variants"},"variant")," type where the constructor is the name of the entrypoint with the first letter capitalized and the value is the parameter to pass to the entrypoint.\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"ligo run dry-run")," command uses this format because Tezos smart contracts don't actually have multiple entrypoints; they are compiled to run code based on the parameter that callers pass.\nThe LIGO compiler compiles the contract to include a parameter that runs the code that corresponds to the entrypoint."),(0,r.kt)("p",{parentName:"admonition"},"For more information about this internal behaviour, see ",(0,r.kt)("a",{parentName:"p",href:"https://docs.tezos.com/smart-contracts/entrypoints#implementation-details-the-default-entrypoint"},"Implementation details: the default entrypoint")," on docs.tezos.com."))),(0,r.kt)("p",null,"The response shows an empty list of transactions to run next and the new state of the storage:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"( LIST_EMPTY() , 9 )\n")),(0,r.kt)("h2",{id:"parameters"},"Parameters"),(0,r.kt)("p",null,"LIGO entrypoints always receive two parameters:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A parameter passed by the caller"),(0,r.kt)("li",{parentName:"ul"},"The current value of the contract storage")),(0,r.kt)("p",null,"The caller provides only the first parameter; the LIGO framework provides the current value of the contract storage."),(0,r.kt)("p",null,"The caller-provided parameter can be of any type, including:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Unit, to indicate no information"),(0,r.kt)("li",{parentName:"ul"},"A primitive data type such as integer or string"),(0,r.kt)("li",{parentName:"ul"},"A complex data type such as a tuple or list")),(0,r.kt)("p",null,"Although technically speaking the entrypoint receives only one parameter from the caller, it can behave as though it receives multiple parameters by setting a complex type as the parameter type and destructuring the parameter into multiple variables.\nFor example, this entrypoint accepts a parameter that consists of an integer, a string, and a Boolean:"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=complex_param",group:"complex_param"},"type complexParam = int * string * bool\n\ntype storage = int * string\ntype return_type = operation list * storage\n\n[@entry] let dosomething (param : complexParam) (storage : storage) : return_type =\n  let (intParam, stringParam, boolParam) = param in\n  if boolParam then\n    [], (intParam, stringParam)\n  else\n    [], storage\n"))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=complex_param",group:"complex_param"},"type complexParam = [ int, string, bool ];\n\ntype storage = [int, string];\ntype return_type = [list<operation>, storage];\n\n// @entry\nconst dosomething = (param: complexParam, storage: storage): return_type => {\n  const [intParam, stringParam, boolParam] = param;\n  if (boolParam) return [[], [intParam, stringParam]];\n  return [[], storage];\n}\n"))),(0,r.kt)("h2",{id:"return-values"},"Return values"),(0,r.kt)("p",null,"LIGO entrypoints must return a tuple that contains these values:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A list of operations to run after the entrypoint completes, such as calls to other smart contracts or transfers of tez to accounts"),(0,r.kt)("li",{parentName:"ul"},"The new value of the contract storage, even if the entrypoint did not change it")),(0,r.kt)("p",null,"Unlike functions and API endpoints, entrypoints do not return a value directly to the caller.\nTo return data from a smart contract, you can use one of these methods:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Use ",(0,r.kt)("a",{parentName:"li",href:"views"},"views")," to return data to smart contracts or off-chain applications"),(0,r.kt)("li",{parentName:"ul"},"Use ",(0,r.kt)("a",{parentName:"li",href:"events"},"events")," to return data to off-chain applications"),(0,r.kt)("li",{parentName:"ul"},"Include a callback parameter that sends information to another smart contract by calling one of its entrypoints")),(0,r.kt)("h2",{id:"logic"},"Logic"),(0,r.kt)("p",null,"An entrypoint may run logic based on:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The contract storage"),(0,r.kt)("li",{parentName:"ul"},"The parameters that senders pass"),(0,r.kt)("li",{parentName:"ul"},"Transaction context values such as ",(0,r.kt)("inlineCode",{parentName:"li"},"Tezos.get_amount")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"Tezos.get_sender")),(0,r.kt)("li",{parentName:"ul"},"The table of constants")),(0,r.kt)("p",null,"Entrypoints cannot access information outside of Tezos, such as calling external\nAPIs.\nIf an entrypoint needs information from outside Tezos it must use oracles;\nsee ",(0,r.kt)("a",{parentName:"p",href:"https://docs.tezos.com/smart-contracts/oracles"},"Oracles")," on docs.tezos.com\nand ",(0,r.kt)("a",{parentName:"p",href:"https://opentezos.com/smart-contracts/oracles/"},"Using and trusting Oracles"),"\non opentezos.com."),(0,r.kt)("h2",{id:"storing-and-sending-tez"},"Storing and sending tez"),(0,r.kt)("p",null,"Smart contracts are a type of account and can store and send tez.\nBy default, contracts accept any tez sent to them."),(0,r.kt)("p",null,"If you don't want an entrypoint to accept tez, check how much tez was included with the transaction and fail the transaction if it is more than zero, as in this example:"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=c",group:"c"},'type parameter = unit\ntype storage = unit\ntype result = operation list * storage\n\n[@entry]\nlet no_tokens (action : parameter) (storage : storage) : result =\n  if Tezos.get_amount () > 0tez then\n    failwith "This contract does not accept tokens."\n  else ([], storage)\n'))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=c",group:"c"},'type parameter = unit;\ntype storage = unit;\ntype result = [list<operation>, storage];\n\n// @entry\nconst no_tokens = (action: parameter, storage: storage): result => {\n  if (Tezos.get_amount() > (0 as tez))\n    return failwith("This contract does not accept tokens.");\n  return [[], storage];\n};\n'))),(0,r.kt)("p",null,"To send tez, create a transaction with ",(0,r.kt)("inlineCode",{parentName:"p"},"Tezos.Operarion.transaction"),"\nand return it in the list of operations at the end of the entrypoint,\nas in this example:"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=send_tez",group:"send_tez"},'type storage = unit\ntype return_value = operation list * storage\n\n[@entry]\nlet give5tez (_ : unit) (storage : storage) : return_value =\n  if Tezos.get_balance () >= 5tez then\n    let receiver_contract = match Tezos.get_contract_opt (Tezos.get_sender ()) with\n      Some contract -> contract\n    | None -> failwith "Couldn\'t find account" in\n    let operation = Tezos.Operation.transaction unit 5tez receiver_contract in\n    [operation], storage\n  else\n    [], storage\n'))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=send_tez",group:"send_tez"},'type storage = unit;\ntype return_value = [list<operation>, storage];\n\n// @entry\nconst give5tez = (_: unit, storage: storage): return_value => {\n  let operations: list<operation> = [];\n  if (Tezos.get_balance() >= (5 as tez)) {\n    const receiver_contract =\n      $match(Tezos.get_contract_opt(Tezos.get_sender()), {\n        "Some": contract => contract,\n        "None": () => failwith("Couldn\'t find account")\n      });\n    operations =\n     [Tezos.Operation.transaction(unit, 5 as tez, receiver_contract)]\n  }\n  return [operations, storage];\n}\n'))),(0,r.kt)("h2",{id:"access-control"},"Access control"),(0,r.kt)("p",null,"This example shows how ",(0,r.kt)("inlineCode",{parentName:"p"},"Tezos.get_sender")," can be used to deny access to an\nentrypoint:"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=c",group:"c"},'let owner = ("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx": address)\n\n[@entry]\nlet owner_only (action : parameter) (storage: storage) : result =\n  if Tezos.get_sender () <> owner then failwith "Access denied."\n  else ([], storage)\n'))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=c",group:"c"},'const owner: address = "tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx";\n\n// @entry\nconst owner_only = (action: parameter, storage: storage): result => {\n  if (Tezos.get_sender() != owner) return failwith("Access denied.");\n  return [[], storage];\n};\n'))),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"The entrypoint in the previous example uses ",(0,r.kt)("inlineCode",{parentName:"p"},"Tezos.get_sender")," instead of ",(0,r.kt)("inlineCode",{parentName:"p"},"Tezos.get_source")," to prevent a security flaw.\nFor more information, see the ",(0,r.kt)("a",{parentName:"p",href:"/previews/ligo/external-link-icon/docs/next/tutorials/security/#incorrect-authorisation-checks"},"Security tutorial"),".")),(0,r.kt)("h2",{id:"calling-other-contracts"},"Calling other contracts"),(0,r.kt)("p",null,"An entrypoint can create any number of calls to other entrypoints in its contract and to other contracts.\nHowever, as described in ",(0,r.kt)("a",{parentName:"p",href:"https://docs.tezos.com/smart-contracts/logic/operations"},"Operations")," on docs.tezos.com, these calls happen after the entrypoint code has completed."),(0,r.kt)("p",null,"To call other entrypoints or contracts, create an operation and return it in the list of operations at the end of the entrypoint, as in this example:"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=call_entrypoint",group:"call_entrypoint"},'type storage = unit\ntype return_value = operation list * storage\n\n[@entry] let callContract (param : (address * string)) (storage : storage): return_value =\n  let (addr, parameter) = param in\n  let receiver_contract = match Tezos.get_contract_opt(addr) with\n    Some contract -> contract\n  | None -> failwith "Couldn\'t find contract" in\n  let operations = [Tezos.Operation.transaction parameter 0tez receiver_contract] in\n  operations, storage\n'))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=call_entrypoint",group:"call_entrypoint"},'type storage = unit;\ntype return_value = [list<operation>, storage];\n\n// @entry\nconst callContract = (param: [address, string], storage: storage): return_value => {\n  const [addr, parameter] = param;\n  const receiver_contract =\n    $match(Tezos.get_contract_opt(addr), {\n      "Some": contract => contract,\n      "None": () => failwith("Couldn\'t find contract")\n    });\n  const operations =\n    [Tezos.Operation.transaction(parameter, 0 as tez, receiver_contract)]\n  return [operations, storage];\n}\n'))),(0,r.kt)("p",null,"It's important to remember that the transactions an entrypoint creates do not run until after the entrypoint code has completed.\nThe entrypoint cannot take advantage of any changes that these transactions make.\nFor example, if an entrypoint creates a transaction that sends tez to another contract and then checks its balance again before the end of the entrypoint, the balance is the same as it was at the start of the entrypoint.\nIts balance changes only when it returns the transaction at the end of the entrypoint code and that transaction runs."),(0,r.kt)("h2",{id:"scoping"},"Scoping"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("p",null,"Like other functions in CameLIGO, entrypoints are implicitly exported from modules.\nOther contracts can refer to those entrypoints.\nFor example, here is a contract that re-uses entrypoints from another contract:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo"},"module ContractA = struct\n  type storage_type = int\n  type return_type = operation list * storage_type\n\n  [@entry]\n  let increment (delta : int) (storage : storage_type) : return_type =\n    [], storage + delta\n\n  [@entry]\n  let decrement (delta : int) (storage : storage_type) : return_type =\n    [], storage - delta\nend\n\nmodule ContractB = struct\n  type storage_type = int\n  type return_type = operation list * storage_type\n\n  [@entry]\n  let add = ContractA.increment\n\n  [@entry]\n  let sub = ContractA.decrement\nend\n"))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("p",null,"Unlike other functions in JsLIGO, entrypoints are implicitly exported from namespaces as if they had an ",(0,r.kt)("inlineCode",{parentName:"p"},"export")," keyword.\nOther contracts can refer to those entrypoints.\nFor example, here is a contract that re-uses entrypoints from another contract even though the entrypoints are not explicitly exported:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=exported_entrypoints",group:"exported_entrypoints"},"namespace ContractA {\n  type storage_type = int;\n  type return_type = [list<operation>, storage_type];\n\n  // @entry\n  const increment = (delta: int, storage: storage_type): return_type => [[], storage + delta];\n\n  // @entry\n  const decrement = (delta: int, storage: storage_type): return_type => [[], storage - delta];\n\n  // @entry\n  const reset = (_: unit, _s: storage_type): return_type => [[], 0];\n}\n\nnamespace ContractB {\n  type storage_type = int;\n  export type return_type = [list<operation>, storage_type];\n\n  // @entry\n  const add = ContractA.increment;\n\n  // @entry\n  const sub = ContractA.decrement;\n}\n"))),(0,r.kt)("h2",{id:"the-default-entrypoint"},"The default entrypoint"),(0,r.kt)("p",null,"The name ",(0,r.kt)("inlineCode",{parentName:"p"},"default")," has a special meaning for a Tezos entrypoint.\nIt denotes the default entrypoint that is called unless another is specified."),(0,r.kt)("p",null,"For more information about the default entrypoint and its internal behavior, see ",(0,r.kt)("a",{parentName:"p",href:"https://docs.tezos.com/smart-contracts/entrypoints#implementation-details-the-default-entrypoint"},"Implementation details: the default entrypoint")," on docs.tezos.com."),(0,r.kt)("p",null,"If a contract has only one entrypoint, that entrypoint becomes the default entrypoint and loses its name.\nFor example, this contract has only one entrypoint, which is named ",(0,r.kt)("inlineCode",{parentName:"p"},"increment"),".\nWhen it is compiled it becomes the default entrypoint, so the test calls the ",(0,r.kt)("inlineCode",{parentName:"p"},"default")," entrypoint instead of ",(0,r.kt)("inlineCode",{parentName:"p"},"increment"),":"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=lost_entrypoint_name",group:"lost_entrypoint_name"},'module OneEntrypoint = struct\n  type storage = int\n  type return_type = operation list * storage\n\n  [@entry]\n  let increment (_ : unit) (storage : storage) : return_type =\n    [], storage + 1\n\nend\n\nlet test_one_entrypoint =\n  let initial_storage = 42 in\n  let contract = Test.Originate.contract (contract_of OneEntrypoint) initial_storage 0tez in\n  let _ : nat = Test.Contract.transfer_exn (Test.Typed_address.get_entrypoint "default" contract.taddr) unit 0tez in\n  Assert.assert ((Test.Typed_address.get_storage contract.taddr) = initial_storage + 1)\n'))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=lost_entrypoint_name",group:"lost_entrypoint_name"},'namespace OneEntrypoint {\n  type storage = int;\n  type return_type = [list<operation>, storage];\n\n  // @entry\n  const increment = (_: unit, storage: storage): return_type =>\n    [[], storage + 1];\n};\n\nconst test_one_entrypoint = (() => {\n  let initial_storage = 42;\n  let contract =\n    Test.Originate.contract(contract_of(OneEntrypoint),\n                            initial_storage,\n                            0 as tez);\n  Test.Contract.transfer_exn(Test.Typed_address.get_entrypoint("default", contract.taddr), unit, 0 as tez);\n  return Assert.assert(Test.Typed_address.get_storage(contract.taddr) == initial_storage + 1);\n})();\n'))),(0,r.kt)("h2",{id:"the-main-function"},"The main function"),(0,r.kt)("p",null,"In earlier versions of LIGO, it was possible to write a contract that had a single main function named ",(0,r.kt)("inlineCode",{parentName:"p"},"main")," that branched according to the parameter passed to it.\nThis way, contracts could behave as though they had multiple entrypoints while having only a single function.\nWhile it is still possible to define a single function called ",(0,r.kt)("inlineCode",{parentName:"p"},"main")," and mark it as the sole entry point using ",(0,r.kt)("inlineCode",{parentName:"p"},"@entry"),", this is not what most contracts should do."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"This feature is deprecated. Future versions of LIGO will not allow the declaration of a single ",(0,r.kt)("inlineCode",{parentName:"strong"},"main")," function. A workaround is given at the end of this section.")),(0,r.kt)("p",null,"A common way to code a contract using a single main function is to use a variant type as its parameter and branch the code according to the parameter.\nIn the following example, the storage contains a counter of type ",(0,r.kt)("inlineCode",{parentName:"p"},"nat")," and a name of type ",(0,r.kt)("inlineCode",{parentName:"p"},"string"),".\nDepending on the parameter of the contract, either the counter or the name is updated."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=contract_main",group:"contract_main"},"type parameter =\n  Action_A of nat\n| Action_B of string\n\ntype storage = {\n  counter : nat;\n  name    : string\n}\n\ntype result = operation list * storage\n\nlet entry_A (n : nat) (store : storage) : result =\n  [], {store with counter = n}\n\nlet entry_B (s : string) (store : storage) : result =\n  [], {store with name = s}\n\n[@entry]\nlet main (action : parameter) (store: storage) : result =\n  match action with\n    Action_A n -> entry_A n store\n  | Action_B s -> entry_B s store\n"))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=contract_main",group:"contract_main"},'export type parameter =\n| ["Action_A", nat]\n| ["Action_B", string];\n\nexport type storage = {\n  counter : nat,\n  name    : string\n};\n\ntype result = [list<operation>, storage];\n\nconst entry_A = (n: nat, store: storage): result =>\n  [[], {...store, counter: n}];\n\nconst entry_B = (s: string, store: storage): result =>\n  [[], {...store, name: s}];\n\n// @entry\nconst main = (action: parameter, store: storage): result =>\n  $match(action, {\n    "Action_A": n => entry_A(n, store),\n    "Action_B": s => entry_B(s, store)\n  });\n'))),(0,r.kt)("p",null,"To call a contract that has a single main function instead of separate entrypoints, pass the parameter value without an entrypoint name.\nFor example, this ",(0,r.kt)("inlineCode",{parentName:"p"},"run dry-run")," command passes the ",(0,r.kt)("inlineCode",{parentName:"p"},"Action_A")," variant to the contract in the previous example:"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"ligo run dry-run gitlab-pages/docs/syntax/contracts/src/entrypoints/contract_main.mligo 'Action_A(5n)' '(5n, \"hello\")'\n"))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'ligo run dry-run gitlab-pages/docs/syntax/contracts/src/entrypoints/contract_main.jsligo \'["Action_A" as "Action_A", 5 as nat]\' \'[5n, "hello"]\'\n'))),(0,r.kt)("h3",{id:"workaround-for-the-deprecation-of-the-main-function"},"Workaround for the deprecation of the ",(0,r.kt)("inlineCode",{parentName:"h3"},"main")," function"),(0,r.kt)("p",null,"In most cases, adding ",(0,r.kt)("inlineCode",{parentName:"p"},"[@entry]")," for CameLIGO or ",(0,r.kt)("inlineCode",{parentName:"p"},"@entry")," for JsLIGO\nbefore the existing ",(0,r.kt)("inlineCode",{parentName:"p"},"main")," function should suffice. However in cases\nwhere it is not possible or desirable to convert an existing\n",(0,r.kt)("inlineCode",{parentName:"p"},"contract_main")," contract to the new ",(0,r.kt)("inlineCode",{parentName:"p"},"@entry")," format (e.g. generated\ncode or a code review process that forbids making changes to an\nalready-audited file), the deprecation can be circumvented by adding a\nproxy file which declares a single entry point and calls the existing\n",(0,r.kt)("inlineCode",{parentName:"p"},"main")," function, as follows:"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=contract_main_proxy",group:"contract_main_proxy"},"module C = Gitlab_pages.Docs.Syntax.Contracts.Src.Entrypoints.Contract_main\n\nmodule Proxy = struct\n  [@entry]\n  let proxy (p : C.parameter) (s : C.storage) : operation list * C.storage =\n    C.main p s\nend\n")),(0,r.kt)("p",null,"The contract can then be compiled using the following command:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"ligo compile contract --library . -m Proxy gitlab-pages/docs/syntax/contracts/src/entrypoints-contracts/contract_main_proxy.mligo\n"))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=contract_main_proxy",group:"contract_main_proxy"},'import * as C from "gitlab-pages/docs/syntax/contracts/src/entrypoints/contract_main.jsligo";\n\nnamespace Proxy {\n  // @entry\n  const proxy = (p: C.parameter, s: C.storage): [list<operation>, C.storage] =>\n    C.main(p, s)\n}\n')),(0,r.kt)("p",null,"The contract can then be compiled using the following command:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"ligo compile contract --library . -m Proxy \\ gitlab-pages/docs/syntax/contracts/src/entrypoints-contracts/contract_main_proxy.jsligo\n"))),(0,r.kt)("p",null,"Notice that to compile a parameter for this contract, now we need to\npass either ",(0,r.kt)("inlineCode",{parentName:"p"},"-e proxy")," or construct a value using the ",(0,r.kt)("inlineCode",{parentName:"p"},"Proxy"),"\nconstructor:"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},'ligo compile parameter --library . -m Proxy -e proxy \\ gitlab-pages/docs/advanced/src/entrypoints-contracts/contract_main_proxy.mligo \\\n  "Action_A(42n)"\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},'ligo compile parameter --library . -m Proxy \\ gitlab-pages/docs/advanced/src/entrypoints-contracts/contract_main_proxy.mligo \\\n  "Proxy(Action_A(42n))"\n'))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},'ligo compile parameter --library . -m Proxy -e proxy \\ gitlab-pages/docs/syntax/contracts/src/entrypoints-contracts/contract_main_proxy.jsligo \\\n  "["Action_A" as "Action_A", 42 as nat]"\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},'ligo compile parameter --library . -m Proxy \\ gitlab-pages/docs/syntax/contracts/src/entrypoints-contracts/contract_main_proxy.jsligo \\\n  "["Proxy" as "Proxy", ["Action_A" as "Action_A", 42 as nat]]"\n'))))}u.isMDXComponent=!0}}]);