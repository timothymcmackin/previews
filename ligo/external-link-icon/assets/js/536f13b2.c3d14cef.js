"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[75877],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>d});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),m=c(n),d=r,f=m["".concat(s,".").concat(d)]||m[d]||u[d]||o;return n?a.createElement(f,i(i({ref:t},p),{},{components:n})):a.createElement(f,i({ref:t},p))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},38671:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var a=n(87462),r=(n(67294),n(3905));const o={id:"cameligo-ocaml-syntax-diff",title:"What are the differences between syntaxes of CameLIGO and OCaml?"},i=void 0,l={unversionedId:"faq/cameligo-ocaml-syntax-diff",id:"faq/cameligo-ocaml-syntax-diff",title:"What are the differences between syntaxes of CameLIGO and OCaml?",description:"Most of the CameLIGO syntax follows the OCaml syntax, however, there are a few syntactic shortcuts available in one but not the other.",source:"@site/../docs/faq/cameligo-ocaml-syntax-diff.md",sourceDirName:"faq",slug:"/faq/cameligo-ocaml-syntax-diff",permalink:"/previews/ligo/external-link-icon/docs/next/faq/cameligo-ocaml-syntax-diff",draft:!1,tags:[],version:"current",frontMatter:{id:"cameligo-ocaml-syntax-diff",title:"What are the differences between syntaxes of CameLIGO and OCaml?"},sidebar:"faq",previous:{title:"How to catch an error thrown in a view ?",permalink:"/previews/ligo/external-link-icon/docs/next/faq/catch-error-view"},next:{title:"Is there a way to advance time in LIGO tests ?",permalink:"/previews/ligo/external-link-icon/docs/next/faq/tezos-now-advance-time"}},s={},c=[{value:"Consecutive &#39;-&#39; operators",id:"consecutive---operators",level:3},{value:"Unary &#39;+&#39; operator",id:"unary--operator",level:3},{value:"&#39;type in&#39; statements",id:"type-in-statements",level:3},{value:"Entry point declarations",id:"entry-point-declarations",level:3},{value:"Semicolons in <code>begin ... end</code> sequences",id:"semicolons-in-begin--end-sequences",level:3},{value:"Name punning",id:"name-punning",level:3}],p={toc:c};function u(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Most of the CameLIGO syntax follows the OCaml syntax, however, there are a few syntactic shortcuts available in one but not the other."),(0,r.kt)("h3",{id:"consecutive---operators"},"Consecutive '-' operators"),(0,r.kt)("p",null,"In OCaml, you can do :"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},"let y = - -1 (* In OCaml *)\n")),(0,r.kt)("p",null,"But this has been forbidden in CameLIGO, you have to add parentheses instead:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo"},"let y = -(-1) (* In CameLIGO *)\n")),(0,r.kt)("h3",{id:"unary--operator"},"Unary '+' operator"),(0,r.kt)("p",null,"This is possible in OCaml but not CameLIGO :"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},"let x = +1 (* In OCaml *)\n")),(0,r.kt)("h3",{id:"type-in-statements"},"'type in' statements"),(0,r.kt)("p",null,"In CameLIGO, you can declare types locally to an expression.\nFor example, here is a function returning a list of integers :"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo"},"(* In CameLIGO *)\nlet res =\n  type t = int list in\n  let x : t = [42] in\n  43 :: x\n")),(0,r.kt)("h3",{id:"entry-point-declarations"},"Entry point declarations"),(0,r.kt)("p",null,"Although it is possible to execute code at the top-level using e.g. ",(0,r.kt)("inlineCode",{parentName:"p"},"ligo run test contract.mligo"),",\na CameLIGO program will need one or more entry points in order to be published as an on-chain contract."),(0,r.kt)("p",null,'These are "main" functions which can be invoked by sending a transaction to\nthe blockchain. An entry point must have the type\n',(0,r.kt)("inlineCode",{parentName:"p"},"parameter -> storage -> operation list * storage"),", where the ",(0,r.kt)("inlineCode",{parentName:"p"},"storage")," type\nmust be the same for all entry points in a given contract, but different\nentry points will typically use different parameter types."),(0,r.kt)("p",null,"An entry point will take the value of the parameter passed in the\ntransaction, and the value of the permanent on-chain storage, and will\nreturn a list of new transactions initiated from the contract\n(i.e. transfers of zero or more tokens to other contracts or to\nimplicit account addresses), and a new value for the on-chain\nstorage. The next transaction sent to that contract will use the\nupdated storage, and so on. In order to provide a pure function that\nmay consult the storage without modifying it, one can use ",(0,r.kt)("inlineCode",{parentName:"p"},"@view"),"\ninstead of ",(0,r.kt)("inlineCode",{parentName:"p"},"@entry"),". A ",(0,r.kt)("em",{parentName:"p"},"view")," can be called by another contract\nwithout generating a transaction (i.e., the call is performed\nsynchronously, instead of returning a delayed transaction which would\nrun after the end of this contract's execution), and the view can\nreturn any value (since it cannot produce new transactions nor an\nupdated storage, it simply returns the desired output value)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo"},'type storage = string\ntype result = operation list * storage\n\n[@entry] let hello (_u : unit) (_store : storage) : result =\n  [], "hello"\n\n[@entry] let big (_u : unit) (store : storage) : result =\n  [], store ^ " big"\n\ntype planet = Earth | Mars | Earth2\n\n[@view] let world (p : planet) (store : storage) : string =\n  let world = match p with\n    | Earth -> " pale blue dot"\n    | Mars -> " pale red dot"\n    | Earth2 -> failwith "backup planet not found"\n  in\n  store ^ " " ^ world\n')),(0,r.kt)("h3",{id:"semicolons-in-begin--end-sequences"},"Semicolons in ",(0,r.kt)("inlineCode",{parentName:"h3"},"begin ... end")," sequences"),(0,r.kt)("p",null,"In OCaml, the last instruction of a ",(0,r.kt)("inlineCode",{parentName:"p"},"begin ... end")," sequence can be terminated by a semicolon ",(0,r.kt)("inlineCode",{parentName:"p"},";"),", but not in CameLIGO."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=semicolons",group:"semicolons"},"(* In CameLIGO *)\ntype storage = int\n\n[@entry]\nlet main (_p : unit) (s : storage) : operation list * storage =\n  let tests =\n    begin\n      Assert.assert (1 = 1);\n      Assert.assert (2 = 2) // no semicolon here\n    end\n  in\n  [], s\n")),(0,r.kt)("h3",{id:"name-punning"},"Name punning"),(0,r.kt)("p",null,"Name punning permits record assignments without repeating the right-hand side if it is the same as the record field name.\nAlthough possible in OCaml, this is not yet avaiable in CameLIGO."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},"(* In OCaml *)\ntype point = {\n  x : int;\n  y : int;\n}\n\nlet x = 24\nlet y = 42\n\nlet p_assign_without_punning : point = {x = x; y = y}\nlet p_assign_with_punning    : point = {x; y}  (* Unavailable in CameLIGO *)\n")))}u.isMDXComponent=!0}}]);