"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[65313],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>m});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),c=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},d=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=c(a),m=r,h=u["".concat(s,".").concat(m)]||u[m]||p[m]||i;return a?n.createElement(h,o(o({ref:t},d),{},{components:a})):n.createElement(h,o({ref:t},d))}));function m(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var c=2;c<i;c++)o[c]=a[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},48720:(e,t,a)=>{a.d(t,{D:()=>r.Z,Z:()=>i});var n=a(67294),r=a(75402);const i=function(e){return n.createElement(r.Z.Consumer,null,(t=>{let{syntax:a}=t;return a===e.syntax?e.children:n.createElement(n.Fragment,null)}))}},54335:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var n=a(87462),r=(a(67294),a(3905)),i=a(48720);const o={id:"security",title:"Smart contract security"},l=void 0,s={unversionedId:"tutorials/security/security",id:"version-1.9.2/tutorials/security/security",title:"Smart contract security",description:"In this article, we will cover the basics of Tezos smart contract security. We will describe several potential vulnerabilities that stem from developers' misconceptions about the distributed nature of blockchains. We will also suggest ways to protect your contracts against these kinds of attacks.",source:"@site/versioned_docs/version-1.9.2/tutorials/security/security.md",sourceDirName:"tutorials/security",slug:"/tutorials/security/",permalink:"/previews/ligo/external-link-icon/docs/tutorials/security/",draft:!1,tags:[],version:"1.9.2",frontMatter:{id:"security",title:"Smart contract security"},sidebar:"docs",previous:{title:"Optimisation guide",permalink:"/previews/ligo/external-link-icon/docs/tutorials/optimisation/"}},c={},d=[{value:"Resource constraints",id:"resource-constraints",level:2},{value:"Transaction ordering",id:"transaction-ordering",level:2},{value:"Timestamps",id:"timestamps",level:2},{value:"Reentrancy and call injection",id:"reentrancy-and-call-injection",level:2},{value:"Transactions to untrusted contracts",id:"transactions-to-untrusted-contracts",level:2},{value:"Incorrect authorisation checks",id:"incorrect-authorisation-checks",level:2}],p={toc:d};function u(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"In this article, we will cover the basics of Tezos smart contract security. We will describe several potential vulnerabilities that stem from developers' misconceptions about the distributed nature of blockchains. We will also suggest ways to protect your contracts against these kinds of attacks."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Disclaimer:")),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"This guide is aimed at giving the reader an overview of popular attacks on smart contracts and distributed applications. It is not an exhaustive list of all the possible attack vectors. Please, use your own judgement."),(0,r.kt)("li",{parentName:"ol"},"The descriptions in this document are valid for the protocol 008_PtEdo2Zk (Edo). Since Tezos is an upgradeable blockchain, some of the blockchain mechanics may change in case a new proposal is adopted.")),(0,r.kt)("h2",{id:"resource-constraints"},"Resource constraints"),(0,r.kt)("p",null,"Tezos limits the resources available to the contracts. It bounds operations size so that nodes can broadcast the operations over the network in a reasonable time. It also places a limit on the computations the bakers need to perform to validate an operation \u2013 the ",(0,r.kt)("strong",{parentName:"p"},"gas limit.")," When you develop your contract, you need to bear these limits in mind."),(0,r.kt)("p",null,"Let us look at a seemingly innocent wallet contract that stores an event log:"),(0,r.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo"},'type parameter = Fund | Send of address * tez\n\ntype transaction = Incoming of address * tez | Outgoing of address * tez\n\ntype storage = {owner : address; transactionLog : transaction list}\n\ntype result = operation list * storage\n\nlet do_send (dst, @amount : address * tez) =\n  let callee = Tezos.get_contract_opt dst in\n  match callee with\n    Some contract ->\n      let op = Tezos.transaction () @amount contract in\n      Outgoing (dst, @amount), [op]\n  | None -> (failwith "Could not send tokens" : transaction * operation list)\n\nlet do_fund (from, @amount : address * tez) =\n  Incoming (from, @amount), ([] : operation list)\n\n[@entry]\nlet fund (_ : unit) (s : storage) : result =\n  let tx, ops = do_fund (Tezos.get_sender (), Tezos.get_amount ()) in\n  ops, { s with transactionLog = tx :: s.transactionLog }\n\n[@entry]\nlet send (args : address * tez) (s : storage) =\n  let u = assert ((Tezos.get_sender ()) = s.owner && (Tezos.get_amount ()) = 0mutez) in\n  let tx, ops = do_send args in\n  ops, { s with transactionLog = tx :: s.transactionLog }\n'))),(0,r.kt)("p",null,"This contract:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Can receive funds sent to it via the ",(0,r.kt)("inlineCode",{parentName:"li"},"Fund")," entrypoint."),(0,r.kt)("li",{parentName:"ol"},"Can send some tez via the ",(0,r.kt)("inlineCode",{parentName:"li"},"Send")," entrypoint callable by the owner."),(0,r.kt)("li",{parentName:"ol"},"Stores a log of all the operations.")),(0,r.kt)("p",null,"What can go wrong? To answer this question, we will need to dive a bit into how Tezos processes transactions and what limits it places on them."),(0,r.kt)("p",null,"To guarantee that the nodes spend reasonable time processing transactions, Tezos requires that the execution consumes no more than a certain amount of ",(0,r.kt)("em",{parentName:"p"},"gas")," (in the current protocol, it is 1 040 000 gas units)."),(0,r.kt)("p",null,"But in Tezos, the amount of gas consumed depends on the size of the storage! All non-lazy (i.e. non-BigMap) storage entries get fetched, deserialised, and type-checked upon each contract invocation. It means that:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Our contract will be more and more expensive to call with every transaction made."),(0,r.kt)("li",{parentName:"ol"},"Eventually, when the gas consumption is too high, every transaction will hit the upper bound, which will render the contract unusable.")),(0,r.kt)("p",null,"In this particular case the best solution would be to use an off-chain indexer that would monitor and record the transactions to the contract. If you are sure you need an event log in the contract storage, you should at least store the logs in a big map, e.g., indexed incrementally."),(0,r.kt)("p",null,"Generally, you need to think about whether the side effect of gas consumption can halt the execution prematurely. Here are the tips that can help you reduce the risk of potential gas exhaustion."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Limit the size of non-lazy storage:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Do not store data extendable by the users (e.g., event logs, a set of token holders) in non-lazy containers."),(0,r.kt)("li",{parentName:"ul"},"If using non-lazy containers is absolutely required, place an upper bound on the size of non-lazy containers."),(0,r.kt)("li",{parentName:"ul"},"Limit the maximum size of strings and byte strings."),(0,r.kt)("li",{parentName:"ul"},"Do not put untrusted lambdas in storage."),(0,r.kt)("li",{parentName:"ul"},"Be careful with all unbounded types, including ",(0,r.kt)("inlineCode",{parentName:"li"},"nat"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"int"),", etc. Although exploiting gas exhaustion attacks with non-container types may be harder, it is still possible."))),(0,r.kt)("li",{parentName:"ol"},"Ensure that your contract logic does not allow attackers to increase the interpretation cost, e.g., by forcing future transactions to run a huge loop.")),(0,r.kt)("h2",{id:"transaction-ordering"},"Transaction ordering"),(0,r.kt)("p",null,"It is crucial to understand that all blockchains, including Tezos, are distributed systems where block producers \u2013 bakers in Tezos \u2013 are free to include, censor, and reorder transactions within a block. For most of the practical applications, this does not pose a threat. However, in some cases, especially in Decentralised Finance (DeFi) applications, bakers can use their power to gain economic benefit from reordering or censoring out user transactions."),(0,r.kt)("p",null,"Aside from bakers, other actors can indirectly influence the transaction ordering as well. Attackers can set higher fees or use accounts with lower counter values to make bakers put the attackers' transactions in front of others."),(0,r.kt)("p",null,"A classic example of a system vulnerable to this kind of attacks is a decentralised exchange with an on-chain orderbook, like this one (let us assume just one asset pair for clarity):"),(0,r.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},"type order = {price : nat; volume : nat}\n\ntype storage = {bids : order list; asks : order list}\n\ntype parameter = Buy of order | Sell of order\n\nlet buy (order, s : order * storage) = ...\nlet sell (order, s : order * storage) = ...\nlet main (p, s : parameter * storage) = ...\n"))),(0,r.kt)("p",null,"An attacker may notice some transaction, for example, a request to buy some big volume of asset. They may then ",(0,r.kt)("em",{parentName:"p"},"front-run")," this transaction and, anticipating the price going up, insert a ",(0,r.kt)("em",{parentName:"p"},"buy")," order at the current price before the trader's transaction. Thus, they can benefit from the price change by selling the asset at a higher price."),(0,r.kt)("p",null,"In fact, if the front-runner is a baker, the so-called ",(0,r.kt)("em",{parentName:"p"},"miner extracted value")," ",(0,r.kt)("a",{parentName:"p",href:"https://arxiv.org/pdf/1904.05234.pdf"},"poses a big risk")," to security of blockchains in general. You should avoid letting miners get rewards from transaction ordering. In this particular case, moving the order book off-chain would be a good option."),(0,r.kt)("h2",{id:"timestamps"},"Timestamps"),(0,r.kt)("p",null,"Aside from transaction ordering, bakers can manipulate other variables you might want to rely on. A classic example of such a value is ",(0,r.kt)("inlineCode",{parentName:"p"},"Tezos.get_now"),". Previously, it used to be equal to the current block timestamp. This behaviour has been changed to eliminate straightforward manipulations. Since Tezos is a distributed system, there is no way to make sure the block was produced ",(0,r.kt)("em",{parentName:"p"},"exactly")," at the specified time. Thus, bakers could slightly adjust the timestamp to make a transaction produce a different result."),(0,r.kt)("p",null,"In the current protocol, ",(0,r.kt)("inlineCode",{parentName:"p"},"Tezos.get_now")," is equal to the ",(0,r.kt)("em",{parentName:"p"},"previous")," block timestamp plus a fixed value. Although ",(0,r.kt)("inlineCode",{parentName:"p"},"Tezos.get_now")," becomes less manipulable with this new behaviour, the only assumption you can make is that the operation goes through ",(0,r.kt)("em",{parentName:"p"},"roughly about")," the specified timestamp. And, of course, you should never use ",(0,r.kt)("inlineCode",{parentName:"p"},"Tezos.get_now")," as a source of randomness."),(0,r.kt)("h2",{id:"reentrancy-and-call-injection"},"Reentrancy and call injection"),(0,r.kt)("p",null,"Tezos features a rather unconventional model of execution:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"The contract state is updated ",(0,r.kt)("em",{parentName:"li"},"after")," the computations are completed."),(0,r.kt)("li",{parentName:"ol"},"The contracts cannot emit operations in the middle of execution."),(0,r.kt)("li",{parentName:"ol"},"Internal operations are ",(0,r.kt)("em",{parentName:"li"},"queued."))),(0,r.kt)("p",null,"The first two points resemble the Checks-Effects-Interactions pattern popular in Solidity. In Ethereum, it is considered a best practice, and Tezos enforces this on the protocol level. Such restrictions help  prevent reentrancy attacks: if the state of your contract is updated ",(0,r.kt)("em",{parentName:"p"},"before")," someone makes a reentrant call, this call would be treated as a regular one and should do no harm."),(0,r.kt)("p",null,"Consider the following snippet in Solidity:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"function withdraw(uint256 amount) {\n  uint256 balance = balances[beneficiary];\n  require(balance >= amount);\n  uint256 new_balance = balance - amount;\n  beneficiary.call.value(amount)();\n  balances[beneficiary] = new_balance;\n}\n")),(0,r.kt)("p",null,"You may notice that the ",(0,r.kt)("em",{parentName:"p"},"effect")," of updating the storage happens after ",(0,r.kt)("em",{parentName:"p"},"interaction")," \u2013 transferring the ",(0,r.kt)("inlineCode",{parentName:"p"},"amount")," to the beneficiary. This contract has a reentrancy vulnerability: the contract execution would get paused during the transfer, and the beneficiary can call ",(0,r.kt)("inlineCode",{parentName:"p"},"withdraw")," again ",(0,r.kt)("em",{parentName:"p"},"before")," their balance is updated."),(0,r.kt)("p",null,"It is quite hard to repeat this attack on Tezos, where the contract storage is always updated ",(0,r.kt)("em",{parentName:"p"},"before")," any interactions:"),(0,r.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo"},'type storage = {beneficiary : address; balances : (address, tez) map}\n\ntype parameter = tez * (unit contract)\n\nlet withdraw (param, s : parameter * storage) =\n  let @amount, beneficiary = param in\n  let beneficiary_addr = Tezos.address beneficiary in\n  let @balance =\n    match (Map.find_opt beneficiary_addr s.balances) with\n      Some v -> v\n    | None -> 0mutez in\n  let new_balance = match @balance - @amount with\n    | Some x -> x\n    | None -> (failwith "Insufficient balance" : tez)\n  in\n  let op = Tezos.transaction () @amount beneficiary in\n  let new_balances =\n    Map.update beneficiary_addr (Some new_balance) s.balances in\n  [op], {s with balances = new_balances}\n'))),(0,r.kt)("p",null,"Notice that the code flow is similar: we first check whether the beneficiary has enough balance, then forge an operation that sends the money, and finally we update the balances mapping. The difference is that in Tezos the operations are not executed immediately: we store the operation and later return it as a result of the entrypoint. Hence, the balances are updated by the time the operation is executed, so the reentrancy attack is mitigated."),(0,r.kt)("p",null,'However, in some cases reentrancy attacks are still possible, especially if contracts are supposed to "wait" for a callback in an indeterminate state. If you, for example, choose to store balances in a separate contract, your execution flow will need a lot more interactions than sending one internal operation:'),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Current call"),(0,r.kt)("th",{parentName:"tr",align:null},"Treasury state after"),(0,r.kt)("th",{parentName:"tr",align:null},"Queued operations"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Treasury %withdraw")),(0,r.kt)("td",{parentName:"tr",align:null},"Waiting for balances"),(0,r.kt)("td",{parentName:"tr",align:null},"[",(0,r.kt)("inlineCode",{parentName:"td"},"Balances %getBalance"),"]")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Balances %getBalance")),(0,r.kt)("td",{parentName:"tr",align:null},"Waiting for balances"),(0,r.kt)("td",{parentName:"tr",align:null},"[",(0,r.kt)("inlineCode",{parentName:"td"},"Treasury %withdrawContinuation"),"]")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Treasury %withdrawContinuation")),(0,r.kt)("td",{parentName:"tr",align:null},"Sent"),(0,r.kt)("td",{parentName:"tr",align:null},"[Send tez to ",(0,r.kt)("inlineCode",{parentName:"td"},"Beneficiary"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"Balances %setNewBalance"),"]")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Send tez to ",(0,r.kt)("inlineCode",{parentName:"td"},"Beneficiary")),(0,r.kt)("td",{parentName:"tr",align:null},"Sent"),(0,r.kt)("td",{parentName:"tr",align:null},"[",(0,r.kt)("inlineCode",{parentName:"td"},"Balances %setNewBalance"),"]")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Balances %setNewBalance")),(0,r.kt)("td",{parentName:"tr",align:null},"Sent"),(0,r.kt)("td",{parentName:"tr",align:null})))),(0,r.kt)("p",null,"In this example, the Treasury contract uses a callback mechanism to get the sender balance. In an intermediate state between ",(0,r.kt)("inlineCode",{parentName:"p"},"%withdraw")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"%withdrawContinuation"),", the balances request has already been sent but the funds have not been withdrawn yet, and the balances have not been updated. This opens up a possibility for a call injection attack."),(0,r.kt)("p",null,"For example, here is what happens if an attacker tries to call ",(0,r.kt)("inlineCode",{parentName:"p"},"%withdraw")," twice within a single transaction:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Step"),(0,r.kt)("th",{parentName:"tr",align:null},"Current call"),(0,r.kt)("th",{parentName:"tr",align:null},"Queued operations"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Evil %attack")),(0,r.kt)("td",{parentName:"tr",align:null},"[",(0,r.kt)("inlineCode",{parentName:"td"},"Treasury %withdraw"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"Treasury %withdraw"),"]")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Treasury %withdraw")),(0,r.kt)("td",{parentName:"tr",align:null},"[",(0,r.kt)("inlineCode",{parentName:"td"},"Balances %getBalance"),"]")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"3"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Treasury %withdraw")),(0,r.kt)("td",{parentName:"tr",align:null},"[",(0,r.kt)("inlineCode",{parentName:"td"},"Balances %getBalance"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"Balances %getBalance"),"]")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Balances %getBalance")),(0,r.kt)("td",{parentName:"tr",align:null},"[",(0,r.kt)("inlineCode",{parentName:"td"},"Balances %getBalance"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"Treasury %withdrawContinuation"),"]")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"5"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Balances %getBalance")),(0,r.kt)("td",{parentName:"tr",align:null},"[",(0,r.kt)("inlineCode",{parentName:"td"},"Treasury %withdrawContinuation"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"Treasury %withdrawContinuation"),"]")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"6"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Treasury %withdrawContinuation")),(0,r.kt)("td",{parentName:"tr",align:null},"[",(0,r.kt)("inlineCode",{parentName:"td"},"Treasury %withdrawContinuation"),", Send tez to ",(0,r.kt)("inlineCode",{parentName:"td"},"Beneficiary"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"Balances %setNewBalance"),"]")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"7"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Treasury %withdrawContinuation")),(0,r.kt)("td",{parentName:"tr",align:null},"[Send tez to ",(0,r.kt)("inlineCode",{parentName:"td"},"Beneficiary"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"Balances %setNewBalance"),", Send tez to ",(0,r.kt)("inlineCode",{parentName:"td"},"Beneficiary"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"Balances %setNewBalance"),"]")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"8"),(0,r.kt)("td",{parentName:"tr",align:null},"Send tez to ",(0,r.kt)("inlineCode",{parentName:"td"},"Beneficiary")),(0,r.kt)("td",{parentName:"tr",align:null},"[",(0,r.kt)("inlineCode",{parentName:"td"},"Balances %setNewBalance"),", Send tez to ",(0,r.kt)("inlineCode",{parentName:"td"},"Beneficiary"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"Balances %setNewBalance"),"]")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"9"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Balances %setNewBalance")),(0,r.kt)("td",{parentName:"tr",align:null},"[Send tez to ",(0,r.kt)("inlineCode",{parentName:"td"},"Beneficiary"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"Balances %setNewBalance"),"]")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"10"),(0,r.kt)("td",{parentName:"tr",align:null},"Send tez to ",(0,r.kt)("inlineCode",{parentName:"td"},"Beneficiary")),(0,r.kt)("td",{parentName:"tr",align:null},"[",(0,r.kt)("inlineCode",{parentName:"td"},"Balances %setNewBalance"),"]")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"11"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Balances %setNewBalance")),(0,r.kt)("td",{parentName:"tr",align:null})))),(0,r.kt)("p",null,"The attacker successfully withdraws money twice using the fact that by the time the second ",(0,r.kt)("inlineCode",{parentName:"p"},"%withdraw")," is called, the balance has not been updated yet."),(0,r.kt)("h2",{id:"transactions-to-untrusted-contracts"},"Transactions to untrusted contracts"),(0,r.kt)("p",null,'When emitting a transaction to an untrusted contract, you can not assume that it will "play by the rules". Rather, you should always bear in mind that the callee may fail, causing the entire operation to fail, or emit other operations you do not expect.'),(0,r.kt)("p",null,"Let us consider the following example:"),(0,r.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo"},'type storage = {owner : address; beneficiaries : address list}\n\nlet send_rewards (beneficiary_addr : address) =\n  let maybe_contract =\n    Tezos.get_contract_opt beneficiary_addr in\n  let beneficiary =\n    match maybe_contract with\n      Some contract -> contract\n    | None -> (failwith "CONTRACT_NOT_FOUND" : unit contract) in\n  Tezos.transaction () 5000000mutez beneficiary\n\nlet main (p, s : unit * storage) =\n  if (Tezos.get_sender ()) <> s.owner\n  then (failwith "ACCESS_DENIED" : operation list * storage)\n  else\n    let ops = List.map send_rewards s.beneficiaries in\n    ops, s\n'))),(0,r.kt)("p",null,"The contract emits a bunch of operations that transfer 5 tez to each of the beneficiaries listed in storage. The flaw here is that one of the receiver contracts may fail, preventing others from receiving the reward. This may be intentional censorship or a bug in the receiver contract \u2013 in either case, the contract gets stuck."),(0,r.kt)("p",null,"Instead of making a batch transfer, it is better to let beneficiaries withdraw their funds individually. This way, if the receiver contract fails, it would not affect other withdrawals."),(0,r.kt)("h2",{id:"incorrect-authorisation-checks"},"Incorrect authorisation checks"),(0,r.kt)("p",null,"When developing a contract, you may often want to restrict access to certain entrypoint. You need to somehow ensure that:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"The request comes from an authorised entity"),(0,r.kt)("li",{parentName:"ol"},"This entity cannot be tricked into sending this request.")),(0,r.kt)("p",null,"You may be tempted to use ",(0,r.kt)("inlineCode",{parentName:"p"},"Tezos.get_source")," instruction \u2013 it returns the address of an implicit account who injected the operation \u2013 but this violates our second requirement. It is easy to ask the owner of this implicit account to make a seemingly innocent transfer to a malicious contract that, in turn, emits an operation to a restricted entrypoint. The attacker contract may disguise itself as some blockchain game or a DAO, but neither the caller would be aware of its side-effects nor the callee would notice the presence of the intermediary. You should ",(0,r.kt)("strong",{parentName:"p"},"never")," use ",(0,r.kt)("inlineCode",{parentName:"p"},"Tezos.get_source")," for authorisation purposes."),(0,r.kt)("p",null,"Checking whether ",(0,r.kt)("inlineCode",{parentName:"p"},"Tezos.get_sender")," \u2013 the address of the immediate caller \u2013 is authorised to perform an operation is better: since the request comes directly from the authorised entity, we can be more certain this call is intended. Such an approach is a decent default choice if both conditions hold true:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"The sender contract is well secured against emitting arbitrary operations. For instance, it must not contain ",(0,r.kt)("a",{parentName:"li",href:"https://gitlab.com/tzip/tzip/-/blob/master/proposals/tzip-4/tzip-4.md#view-entrypoints"},'"view" entrypoints')," as defined in ",(0,r.kt)("a",{parentName:"li",href:"https://gitlab.com/tzip/tzip/-/blob/master/proposals/tzip-4/tzip-4.md"},"TZIP-4"),"."),(0,r.kt)("li",{parentName:"ol"},"You only need to authorise an immediate caller and not the contracts somewhere up in the call chain.")),(0,r.kt)("p",null,'If any of these conditions is not met, you need to use a more advanced technique called "tickets". Tickets are much like "contract signatures": a contract may issue a ticket that authorises a certain action. A ticket holds the data of any type, and a number \u2013 ticket ',(0,r.kt)("em",{parentName:"p"},"amount"),". A ticket can not be copied but it can be split. If you split a ticket of amount ",(0,r.kt)("inlineCode",{parentName:"p"},"N"),", you would get two tickets with amounts ",(0,r.kt)("inlineCode",{parentName:"p"},"M")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"K")," such that ",(0,r.kt)("inlineCode",{parentName:"p"},"N = M + K"),". You can also join two tickets if they have the same data and are issued by the same contract. In this case, you would get a new ticket with the sum of the amounts."),(0,r.kt)("p",null,"To check whether an action is authorised, you need to see if the ticket meets the following conditions:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"The ticket issuer has enough permissions to perform this action."),(0,r.kt)("li",{parentName:"ol"},'The ticket amount and data are correct (the definition of "correct" is application-specific, e.g., the amount may mean the number of tokens to spend or the number of ',(0,r.kt)("em",{parentName:"li"},"times")," the action can be executed).")),(0,r.kt)("p",null,'We recommend using the sender-based authorisation only in simple scenarios, e.g., when the contract has a single "owner" contract controlled by an implicit account. Otherwise, it is better to use ticket-based authorisation.'))}u.isMDXComponent=!0}}]);