"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[51344],{3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>g});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function p(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?p(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):p(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},p=Object.keys(e);for(n=0;n<p.length;n++)a=p[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var p=Object.getOwnPropertySymbols(e);for(n=0;n<p.length;n++)a=p[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=n.createContext({}),l=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},m=function(e){var t=l(e.components);return n.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,p=e.originalType,s=e.parentName,m=r(e,["components","mdxType","originalType","parentName"]),c=l(a),g=i,d=c["".concat(s,".").concat(g)]||c[g]||u[g]||p;return a?n.createElement(d,o(o({ref:t},m),{},{components:a})):n.createElement(d,o({ref:t},m))}));function g(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var p=a.length,o=new Array(p);o[0]=c;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r.mdxType="string"==typeof e?e:i,o[1]=r;for(var l=2;l<p;l++)o[l]=a[l];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},96896:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>g,frontMatter:()=>p,metadata:()=>r,toc:()=>l});var n=a(87462),i=(a(67294),a(3905));const p={title:"Maps"},o=void 0,r={unversionedId:"data-types/maps",id:"data-types/maps",title:"Maps",description:"Maps are a data structure that associates keys to values.",source:"@site/../docs/data-types/maps.md",sourceDirName:"data-types",slug:"/data-types/maps",permalink:"/previews/ligo/external-link-icon/docs/next/data-types/maps",draft:!1,tags:[],version:"current",frontMatter:{title:"Maps"},sidebar:"docs",previous:{title:"Sets",permalink:"/previews/ligo/external-link-icon/docs/next/data-types/sets"},next:{title:"tez",permalink:"/previews/ligo/external-link-icon/docs/next/data-types/tez"}},s={},l=[{value:"Creating maps",id:"creating-maps",level:2},{value:"Sizing maps",id:"sizing-maps",level:2},{value:"Searching for elements",id:"searching-for-elements",level:2},{value:"Adding elements",id:"adding-elements",level:2},{value:"Removing elements",id:"removing-elements",level:2},{value:"Updating elements",id:"updating-elements",level:2},{value:"Working with maps as a whole",id:"working-with-maps-as-a-whole",level:2},{value:"Folding maps",id:"folding-maps",level:3},{value:"Mapping maps",id:"mapping-maps",level:3},{value:"Iterating over maps",id:"iterating-over-maps",level:3},{value:"Looping",id:"looping",level:2}],m=(u="Syntax",function(e){return console.warn("Component "+u+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.kt)("div",e)});var u;const c={toc:l};function g(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Maps are a data structure that associates keys to values.\nTogether, a key and its value make up a ",(0,i.kt)("em",{parentName:"p"},"binding"),", also called an ",(0,i.kt)("em",{parentName:"p"},"element"),".\nThe keys must all be the same type and the values must be the same type.\nKeys must be unique within a map."),(0,i.kt)("p",null,"The predefined type ",(0,i.kt)("inlineCode",{parentName:"p"},"map")," has two parameters: the first is the type of the keys, and the second is the type of the associated values."),(0,i.kt)("p",null,"Internally, LIGO sorts maps in increasing order by their keys.\nTherefore, the type of the keys must be ",(0,i.kt)("em",{parentName:"p"},"comparable"),", which means that Michelson allows them to be compared.\nMost primitive types are comparable, including strings, ints, nats, and addresses.\nTo create more complex keys, you can use a ",(0,i.kt)("a",{parentName:"p",href:"./tuples"},"tuple")," of two comparable types.\nFor more information about Michelson types and which types are comparable, see ",(0,i.kt)("a",{parentName:"p",href:"https://octez.tezos.com/docs/active/michelson.html"},"Michelson")," in the Octez reference."),(0,i.kt)("admonition",{title:"Maps and big-maps",type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Maps are appropriate for small data sets and data sets that you want to load all at once, such as if you want to run logic on every element or check their lengths.\nFor data sets that may become larger, consider using a ",(0,i.kt)("a",{parentName:"p",href:"./big_maps"},"Big-map"),".\nBig-maps can be more efficient for larger data sets because only the elements that you access are loaded, which reduces gas fees.\nHowever, this means that contracts can't do things that require them to load the entire big-map.")),(0,i.kt)("h2",{id:"creating-maps"},"Creating maps"),(0,i.kt)("p",null,"To create a map, you can use the predefined value ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.empty")," or create a non-empty map by passing a list of pairs of keys and values to the function ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.literal"),".\nThis example creates a map type that uses a string for the key and a list of strings for the value:"),(0,i.kt)(m,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=maps",group:"maps"},'type word       = string\ntype definition = string list\ntype dictionary = (word, definition) map\n\nlet empty_dict : dictionary = Map.empty\n\nlet dictionary : dictionary =\n  Map.literal [\n    ("one", ["The number 1."; "A member of a group."]);\n    ("two", ["The number 2"])]\n')),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.literal")," predefined function builds a map from a list of key-value pairs, ",(0,i.kt)("inlineCode",{parentName:"p"},"(<key>, <value>)"),".\nNote that each binding in the list is separated with a semicolon (",(0,i.kt)("inlineCode",{parentName:"p"},";"),")."),(0,i.kt)("p",null,"For reference, see the predefined ",(0,i.kt)("a",{parentName:"p",href:"../reference/map-reference"},"module Map"),".")),(0,i.kt)(m,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=maps",group:"maps"},'type word       = string;\ntype definition = list<string>;\ntype dictionary = map<word, definition>;\n\nconst empty_dict: dictionary = Map.empty;\n\nconst dictionary: dictionary =\n  Map.literal([\n    ["one", (["The number 1.", "A member of a group."])],\n    ["two", (["The number 2."])]]);\n')),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.literal")," predefined function builds a map from a list of key-value pairs, ",(0,i.kt)("inlineCode",{parentName:"p"},"[<key>, <value>]"),"."),(0,i.kt)("p",null,"For reference, see the predefined ",(0,i.kt)("a",{parentName:"p",href:"../reference/map-reference"},"namespace Map"),".")),(0,i.kt)("h2",{id:"sizing-maps"},"Sizing maps"),(0,i.kt)("p",null,"The predefined function ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.size")," returns the number of bindings\n(elements) in a given map."),(0,i.kt)(m,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=map_size",group:"map_size"},'let my_map : (int, string) map =\n  Map.literal [(1,"one"); (2,"two")]\nlet size : nat = Map.size my_map // = 2\n'))),(0,i.kt)(m,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=map_size",group:"map_size"},'const my_map: map<int,string> =\n  Map.literal([[1, "one"], [2, "two"]]);\nconst size: nat = Map.size(my_map); // == 2\n'))),(0,i.kt)("h2",{id:"searching-for-elements"},"Searching for elements"),(0,i.kt)("p",null,"The predefined function ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.mem")," returns true if a value exists in the map for a given key."),(0,i.kt)(m,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=map_searching",group:"map_searching"},'let my_map : (int, string) map =\n  Map.literal [(1,"one"); (2,"two")]\nlet contains_2 : bool = Map.mem 2 my_map // = true\n'))),(0,i.kt)(m,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=map_searching",group:"map_searching"},'const my_map: map<int,string> =\n  Map.literal([[1, "one"], [2, "two"]]);\nconst contains_2: bool = Map.mem(2, my_map); // == true\n'))),(0,i.kt)("p",null,"To get the value for a key, use the ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.find_opt")," function, which returns an ",(0,i.kt)("a",{parentName:"p",href:"./variants#options"},"option"),".\nIf the key exists in the map, the option is ",(0,i.kt)("inlineCode",{parentName:"p"},"Some()")," with the value.\nIf the key does not exist in the map, the option is ",(0,i.kt)("inlineCode",{parentName:"p"},"None()"),"."),(0,i.kt)("p",null,"Because the return value of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.find_opt")," function is an option, you must account for missing keys in the map by ",(0,i.kt)("a",{parentName:"p",href:"./variants#matching"},"matching")," the return value, as in this example:"),(0,i.kt)(m,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=map_searching",group:"map_searching"},'let value_option : string option = Map.find_opt 2 my_map\nlet value key map =\n  match Map.find_opt key map with\n    Some value -> value\n  | None -> failwith "No value."\n'))),(0,i.kt)(m,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=map_searching",group:"map_searching"},'const value_option: option<string> = Map.find_opt(2, my_map);\nconst value = (key, map) =>\n  $match(Map.find_opt(key, map), {\n    "Some": (value) => value,\n    "None": () => failwith("No value."),\n  });\n'))),(0,i.kt)("p",null,"As shorthand, you can use the function ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.find"),".\nThis function behaves like the previous example: it returns the value for a key if it exists or fails with the message ",(0,i.kt)("inlineCode",{parentName:"p"},"MAP FIND")," if the value does not exist."),(0,i.kt)("h2",{id:"adding-elements"},"Adding elements"),(0,i.kt)("p",null,"To add an element to a map, pass the key and value to the ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.add")," function.\nIf the key already exists, the corresponding value is updated."),(0,i.kt)(m,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=map_adding",group:"map_adding"},'let my_map : (int, string) map = Map.literal [(1, "one"); (2, "two")]\nlet new_map = Map.add 3 "three" my_map\nlet contains_3 = Map.mem 3 new_map // = true\n'))),(0,i.kt)(m,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=map_adding",group:"map_adding"},'const my_map: map<int,string> = Map.literal([[1, "one"], [2, "two"]]);\nconst new_map = Map.add(3, "three", my_map);\nconst contains_3 = Map.mem(3, new_map); // == true\n'))),(0,i.kt)("h2",{id:"removing-elements"},"Removing elements"),(0,i.kt)("p",null,"The function ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.remove")," creates a map containing the elements of a given map, without the element with the given key.\nIf the element is not already present, the new map is the same as the old one."),(0,i.kt)(m,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=map_removing",group:"map_removing"},'let my_map : (int, string) map = Map.literal [(1, "one"); (2, "two")]\nlet new_map = Map.remove 2 my_map\nlet contains_3 = Map.mem 2 new_map // = false\n'))),(0,i.kt)(m,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=map_removing",group:"map_removing"},'const my_map: map<int,string> = Map.literal([[1, "one"], [2, "two"]]);\nconst new_map = Map.remove(2, my_map);\nconst contains_3 = Map.mem(2, new_map); // == false\n'))),(0,i.kt)("h2",{id:"updating-elements"},"Updating elements"),(0,i.kt)("p",null,"Previous sections show how to add and remove an element from a map.\nThe function ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.update")," can do both depending whether some value is given for the new binding or not."),(0,i.kt)("p",null,"To update a map in this way, pass the key and an option with the value.\nIf the option is ",(0,i.kt)("inlineCode",{parentName:"p"},"Some(value)"),", the function adds the element, replacing any element with the given key.\nIf the option is ",(0,i.kt)("inlineCode",{parentName:"p"},"None()"),", the function removes the element with the given key if it exists.\nIn either case, the function returns a new map, as in these examples:"),(0,i.kt)(m,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=map_updating",group:"map_updating"},'let my_map : (int, string) map = Map.literal [(1,"one"); (2,"two")]\nlet map_with_3 = Map.update 3 (Some "three") my_map\nlet contains_3 = Map.mem 3 map_with_3 // = true\nlet map_without_2 = Map.update 2 None my_map\nlet contains_2 = Map.mem 2 map_without_2 // = false\n'))),(0,i.kt)(m,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=map_updating",group:"map_updating"},'const my_map: map<int,string> = Map.literal([[1,"one"],[2,"two"]]);\nconst map_with_3 = Map.update (3, ["Some" as "Some", "three"], my_map);\nconst contains_3 = Map.mem(3, map_with_3); // == true\nconst map_without_2 = Map.update(2, ["None" as "None"], my_map);\nconst contains_2 = Map.mem(2, map_without_2); // == false\n'))),(0,i.kt)("p",null,"To simultaneously update a map and obtain the value of the updated element, use the function ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.get_and_update"),".\nThis function allows you to extract a value from a map for use, as in this example:"),(0,i.kt)(m,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=map_updating",group:"map_updating"},'// three = Some "three"\nlet three, map_without_3 = Map.get_and_update 3 None map_with_3\n'))),(0,i.kt)(m,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=map_updating",group:"map_updating"},'// three == ["Some" as "Some", "three"]\nconst [three, map_without_3] = Map.get_and_update(3, ["None" as "None"], map_with_3);\n'))),(0,i.kt)("h2",{id:"working-with-maps-as-a-whole"},"Working with maps as a whole"),(0,i.kt)("p",null,"As described earlier, you can run logic on an entire map, but not a big-map.\nLIGO runs logic on entire maps by applying a ",(0,i.kt)("em",{parentName:"p"},"functional iterator")," to each element in the map.\nIn JsLIGO, you can also loop through the elements in a map, but this is not possible in CameLIGO."),(0,i.kt)("h3",{id:"folding-maps"},"Folding maps"),(0,i.kt)("p",null,"A map ",(0,i.kt)("em",{parentName:"p"},"fold"),", known in some other languages as a ",(0,i.kt)("em",{parentName:"p"},"reduce"),", runs the same function on each element in a map and returns a single value that is the result of those functions.\nThe function that you pass to the ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.fold")," function receives two arguments:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("em",{parentName:"li"},"accumulator"),", which is the result of the previous function iteration"),(0,i.kt)("li",{parentName:"ul"},"The value of the current element")),(0,i.kt)("p",null,"Each iteration of the function returns a new accumulator, which is passed to the next function.\nThe result of the last function iteration is the return value of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.fold")," function.\nThe ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.fold")," function iterates over the map in increasing order of its keys."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.fold")," function accepts these parameters:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"The fold function"),(0,i.kt)("li",{parentName:"ol"},"The map to fold"),(0,i.kt)("li",{parentName:"ol"},"The starting value for  the accumulator")),(0,i.kt)("p",null,"For example, this code calculates the sum of the nats in a map.\nAt each iteration, the accumulator is the value of the sum of the elements up to that point."),(0,i.kt)(m,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=map_folding",group:"map_folding"},'let my_map : (string, nat) map = Map.literal [\n  ("Alice", 1n);\n  ("Bob", 4n);\n  ("Charlie", 5n);\n]\n\nlet fold_function = fun (acc, element : nat * (string * nat)) ->\n  let _key, value = element in\n  acc + value\n\nlet map_sum = Map.fold fold_function my_map 0 (* 10 *)\n')),(0,i.kt)("p",null,"For reference, see the predefined ",(0,i.kt)("a",{parentName:"p",href:"../reference/map-reference"},"module Map"),".")),(0,i.kt)(m,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=map_folding",group:"map_folding"},'const my_map: map<string, nat> = Map.literal([\n  ["Alice", 1 as nat],\n  ["Bob", 4 as nat],\n  ["Charlie", 5 as nat],\n]);\n\nconst fold_function = ([acc, element]: [nat, [string, nat]]): nat => {\n  const [_key, value] = element;\n  return acc + value;\n}\n\nconst map_sum: nat = Map.fold(fold_function, my_map, 0 as nat); // 10 as nat\n'))),(0,i.kt)("h3",{id:"mapping-maps"},"Mapping maps"),(0,i.kt)("p",null,"The ",(0,i.kt)("em",{parentName:"p"},"mapping")," operation (not to be confused with the map type itself) runs the same function on every value in a map and returns the resulting map.\nUnlike folding, mapping operates on each element in the map independently from the others and returns a new map."),(0,i.kt)("p",null,"The function that you pass to the ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.map")," function receives the key and value of the current element and returns the new value for the same key.\nYou cannot change the key with this function; the new map has the same keys as the old map."),(0,i.kt)("p",null,"The following example takes a map of integers and squares each integer, producing a map with the same keys and the squared values:"),(0,i.kt)(m,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=map_mapping",group:"map_mapping"},'let my_map : (string, int) map = Map.literal [\n  ("Alice", 2);\n  ("Bob", 5);\n  ("Charlie", 8);\n]\n\nlet squared_map : (string, int) map = Map.map (fun (_k, v : string * int) : int -> v * v) my_map\n'))),(0,i.kt)(m,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=map_mapping",group:"map_mapping"},'const my_map: map<string, int> = Map.literal([\n  ["Alice", 2],\n  ["Bob", 5],\n  ["Charlie", 8],\n]);\n\nconst squared_map: map<string, int> = Map.map(([_k, v]) => v * v, my_map);\n'))),(0,i.kt)("h3",{id:"iterating-over-maps"},"Iterating over maps"),(0,i.kt)("p",null,"An ",(0,i.kt)("em",{parentName:"p"},"iterated operation")," is a fold over a map that returns the value of type ",(0,i.kt)("inlineCode",{parentName:"p"},"unit"),", that is, its only use is to produce side-effects.\nFor example, iterating over maps can be useful if you want to verify that each element in a map meets certain criteria, and fail with an error otherwise."),(0,i.kt)("p",null,"To iterate over a map, pass the function to apply to each element to the ",(0,i.kt)("inlineCode",{parentName:"p"},"Map.iter")," function.\nThis example iterates over a map of integers and fails if any of them are not greater than 3:"),(0,i.kt)(m,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=map_iterating",group:"map_iterating"},"let assert_all_greater_than_3 (m : (int, int) map) : unit =\n  Map.iter (fun (_, v) -> Assert.assert (v > 3)) m\n"))),(0,i.kt)(m,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=map_iterating",group:"map_iterating"},"const assert_all_greater_than_3 =\n  (m: map<int,int>) : unit => Map.iter(([_k, v]) => Assert.assert(v > 3), m);\n"))),(0,i.kt)("h2",{id:"looping"},"Looping"),(0,i.kt)(m,{syntax:"cameligo",mdxType:"Syntax"},"There is no loop over maps in CameLIGO."),(0,i.kt)(m,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"To iterate through all of the elements in a map, in increasing order of the keys, use the ",(0,i.kt)("inlineCode",{parentName:"p"},"for")," loop in the form ",(0,i.kt)("inlineCode",{parentName:"p"},"for (const <variable> of <map>) <block>"),".\nIn this loop, the ",(0,i.kt)("inlineCode",{parentName:"p"},"<block>")," of statements (or a single statement) runs once for each ",(0,i.kt)("inlineCode",{parentName:"p"},"<variable>")," ranging over the elements of the map ",(0,i.kt)("inlineCode",{parentName:"p"},"<map>")," in increasing order."),(0,i.kt)("p",null,"Here is an example that adds the values in a map:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=map_looping",group:"map_looping"},"function sum_val (m: map<int, int>) {\n  let sum = 0;\n  // The key is discarded.\n  for (const [_key, val] of m) sum = sum + val;\n  return sum;\n};\n"))))}g.isMDXComponent=!0}}]);