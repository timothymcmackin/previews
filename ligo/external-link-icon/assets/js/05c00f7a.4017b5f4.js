"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9087],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>x});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),y=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=y(e.components);return a.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),d=y(n),x=i,c=d["".concat(s,".").concat(x)]||d[x]||m[x]||o;return n?a.createElement(c,l(l({ref:t},p),{},{components:n})):a.createElement(c,l({ref:t},p))}));function x(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,l=new Array(o);l[0]=d;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r.mdxType="string"==typeof e?e:i,l[1]=r;for(var y=2;y<o;y++)l[y]=n[y];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},48720:(e,t,n)=>{n.d(t,{D:()=>i.Z,Z:()=>o});var a=n(67294),i=n(75402);const o=function(e){return a.createElement(i.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},99191:(e,t,n)=>{n.d(t,{Z:()=>p});var a=n(23746),i=n(67294),o=n(52263),l=n(48720),r=n(87552);function s(){return s=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},s.apply(this,arguments)}const{Prism:y}=n(23746);y.languages={...y.languages,cameligo:{...y.languages.ocaml,comment:[/(^|[^\\])\/\*[\s\S]*?\*\//,/\(\*[\s\S]*?\*\)/,/\/\/.*/]},jsligo:y.languages.typescript};const p=function(e){const{siteConfig:{themeConfig:{prism:t={}}}}=(0,o.Z)(),n=t.singleTheme||r.Z,[y,p]=(0,i.useState)(!1);return(0,i.useEffect)((()=>{p(!0)}),[]),i.createElement(l.D.Consumer,null,(t=>{let{syntax:o}=t;return o===e.syntax?i.createElement(a.default,s({},a.defaultProps,{key:y,language:e.syntax,code:e.children,theme:n}),(e=>{let{className:t,tokens:n,getLineProps:a,getTokenProps:o}=e;return i.createElement("h4",{className:t,style:{backgroundColor:"var(--ifm-background-color)",fontFamily:"var(--ifm-font-family-monospace)",lineHeight:"var(--ifm-pre-line-height)",fontSize:"1.1rem",fontWeight:"bold",padding:0,whiteSpace:"break-spaces",marginTop:"3rem"}},n.map(((e,t)=>i.createElement("div",a({line:e,key:t}),e.map(((e,t)=>i.createElement("span",o({token:e,key:t}))))))))})):i.createElement("div",null)}))}},30098:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>s,default:()=>x,frontMatter:()=>r,metadata:()=>y,toc:()=>m});var a=n(87462),i=(n(67294),n(3905)),o=n(48720),l=n(99191);const r={id:"toplevel-reference",title:"toplevel",hide_table_of_contents:!0},s=void 0,y={unversionedId:"reference/toplevel-reference",id:"reference/toplevel-reference",title:"toplevel",description:"type string",source:"@site/../docs/reference/toplevel.md",sourceDirName:"reference",slug:"/reference/toplevel-reference",permalink:"/previews/ligo/external-link-icon/docs/next/reference/toplevel-reference",draft:!1,tags:[],version:"current",frontMatter:{id:"toplevel-reference",title:"toplevel",hide_table_of_contents:!0},sidebar:"API",previous:{title:"set",permalink:"/previews/ligo/external-link-icon/docs/next/reference/set-reference"},next:{title:"crypto",permalink:"/previews/ligo/external-link-icon/docs/next/reference/crypto-reference"}},p={},m=[],d={toc:m};function x(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type string"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type string"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type bytes"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type bytes"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type int"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type int"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type nat"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type nat"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type unit"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type unit"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type operation"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type operation"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type tez"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type tez"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type address"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type address"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type signature"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type signature"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type key"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type key"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type key_hash"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type key_hash"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type timestamp"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type timestamp"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type list"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type list"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type big_map"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type big_map"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type map"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type map"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type set"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type set"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type contract"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type contract"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type michelson_or"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type michelson_or"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type michelson_pair"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type michelson_pair"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type chain_id"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type chain_id"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type baker_hash"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type baker_hash"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type pvss_key"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type pvss_key"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type sapling_state"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type sapling_state"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type sapling_transaction"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type sapling_transaction"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type baker_operation"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type baker_operation"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type bls12_381_g1"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type bls12_381_g1"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type bls12_381_g2"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type bls12_381_g2"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type bls12_381_fr"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type bls12_381_fr"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type never"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type never"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type ticket"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type ticket"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type chest"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type chest"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type chest_key"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type chest_key"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type external_ediv"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type external_ediv"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type external_and"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type external_and"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type external_or"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type external_or"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type external_xor"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type external_xor"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type external_lsl"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type external_lsl"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type external_lsr"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type external_lsr"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type external_bytes"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type external_bytes"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type ('param, 'storage) entrypoint = 'param -> 'storage -> (operation list * 'storage)"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type entrypoint<param, storage> = (_: param) => (_: storage) => [list<operation>, storage]"),"Type of entrypoints",(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type bool = bool"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type bool = bool"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"Type of the booleans. Note: Values ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"false")," are\npredefined constants such that ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," equals ",(0,i.kt)("inlineCode",{parentName:"p"},"True")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),"\nequals ",(0,i.kt)("inlineCode",{parentName:"p"},"False"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"Type of the booleans. Note: Values ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"false")," are\npredefined constants.")),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type 'a option = 'a option"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type option<a> = option<a>"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"Type of optional values. They are useful, for example, when a\nfunction can fail, but the caller wants to be able to handle the\nfailure, which is then denoted by the result ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),". Note:\nAssertions and ",(0,i.kt)("inlineCode",{parentName:"p"},"failwith")," do not allow handling.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"Type of optional values. They are useful, for example, when a\nfunction can fail, but the caller wants to be able to handle the\nfailure, which is then denoted by the result ",(0,i.kt)("inlineCode",{parentName:"p"},"None()"),". Note:\nAssertions and ",(0,i.kt)("inlineCode",{parentName:"p"},"failwith")," do not allow handling.")),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val unit : unit"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"unit: unit"),"Unit type. It is useful for typing side-effects, for example failures, some iterators and implicit accounts.",(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val ignore : 'a.'a -> unit"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"ignore: <a>(_: a) => unit"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"ignore v")," evaluates ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," and ignores its value, returning\ninstead the unit value. This is useful when the argument of ",(0,i.kt)("inlineCode",{parentName:"p"},"ignore"),"\nperforms side-effects.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"ignore(v)")," evaluates ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," and ignores its value, returning\ninstead the unit value. This is useful when the argument of ",(0,i.kt)("inlineCode",{parentName:"p"},"ignore"),"\nperforms side-effects.")),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val failwith : 'err 'a.'err -> 'a"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"failwith: <err, a>(_: err) => a"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"failwith e")," terminates the execution with the value ",(0,i.kt)("inlineCode",{parentName:"p"},"e"),",\nstanding for an error. Note: Using a string for an error message can\nbe costly in terms of size.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"failwith(e)")," terminates the execution with the value ",(0,i.kt)("inlineCode",{parentName:"p"},"e"),",\nstanding for an error. Note: Using a string for an error message can\nbe costly in terms of size.")),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val bytes : 'a.'a -> 'a external_bytes"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"bytes: <a>(_: a) => external_bytes<a>"),(0,i.kt)("p",null,"The function ",(0,i.kt)("inlineCode",{parentName:"p"},"bytes")," encodes an integer or a natural number to bytes\nusing the big-endian encoding. For integers, negative numbers are\nconsidered in two's complement representation."),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val abs : int -> nat"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"abs: (_: int) => nat"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"abs i")," is the absolute value of ",(0,i.kt)("inlineCode",{parentName:"p"},"i"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"abs(i)")," is the absolute value of ",(0,i.kt)("inlineCode",{parentName:"p"},"i"),".")),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val is_nat : int -> nat option"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"is_nat: (_: int) => option<nat>"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"is_nat i")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"Some n"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," is the absolute value of\n",(0,i.kt)("inlineCode",{parentName:"p"},"i"),", if, and only if, ",(0,i.kt)("inlineCode",{parentName:"p"},"i")," is positive or zero.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"is_nat(i)")," is ",(0,i.kt)("inlineCode",{parentName:"p"},'["Some" as "Some", n]'),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," is the\nabsolute value of ",(0,i.kt)("inlineCode",{parentName:"p"},"i"),", if, and only if, ",(0,i.kt)("inlineCode",{parentName:"p"},"i")," is positive or zero.")),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val int : 'a.'a -> int"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"int: <a>(_: a) => int"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"int v")," casts the value ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," to an integer."),(0,i.kt)("p",null,"For natural numbers, the function ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," is the identity cast from\n",(0,i.kt)("inlineCode",{parentName:"p"},"nat")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"int"),". For BLS12-381 field elements, the returned value is\nalways between 0 (inclusive) and the order of the BLS12-381 field\n(exclusive). For bytes, the function ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," decodes the bytes using the\nbig-endian encoding, where negative numbers are considered in two's\ncomplement representation.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"int(v)")," casts the value ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," to an integer."),(0,i.kt)("p",null,"For natural numbers, the function ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," is the identity cast from\n",(0,i.kt)("inlineCode",{parentName:"p"},"nat")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"int"),". For BLS12-381 field elements, the returned value is\nalways between 0 (inclusive) and the order of the BLS12-381 field\n(exclusive). For bytes, the function ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," decodes the bytes using the\nbig-endian encoding, where negative numbers are considered in two's\ncomplement representation.")),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val nat : bytes -> nat"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"nat: (_: bytes) => nat"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"nat b")," casts the bytes ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," into a natural number.")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"nat(b)")," casts the bytes ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," into a natural number.")),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val ediv : 'a 'b.'a -> 'b -> ('a, 'b) external_ediv"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"ediv: <a, b>(left: a, right: b) => external_ediv<a, b>"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"ediv z1 z2"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"z1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"z2")," are either of type ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," or\n",(0,i.kt)("inlineCode",{parentName:"p"},"nat"),", returns ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," if ",(0,i.kt)("inlineCode",{parentName:"p"},"z2")," is zero; otherwise, it returns the pair\n",(0,i.kt)("inlineCode",{parentName:"p"},"(q,r)"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"q")," is the quotient and ",(0,i.kt)("inlineCode",{parentName:"p"},"r")," the positive remainder, as\nis the convention of the mathematical Euclidian division. The function\n",(0,i.kt)("inlineCode",{parentName:"p"},"ediv")," is also overloaded to work on values of type ",(0,i.kt)("inlineCode",{parentName:"p"},"tez"),". When ",(0,i.kt)("inlineCode",{parentName:"p"},"z1"),"\nand ",(0,i.kt)("inlineCode",{parentName:"p"},"z2")," are of type ",(0,i.kt)("inlineCode",{parentName:"p"},"tez")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"z2")," is nonzero, we get a ",(0,i.kt)("inlineCode",{parentName:"p"},"nat"),"\nquotient and a ",(0,i.kt)("inlineCode",{parentName:"p"},"tez")," remainder. When ",(0,i.kt)("inlineCode",{parentName:"p"},"z1")," is a ",(0,i.kt)("inlineCode",{parentName:"p"},"tez")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"z2")," is a\nnonzero ",(0,i.kt)("inlineCode",{parentName:"p"},"nat"),", the calls yields a quotient and a remainder both of\ntype ",(0,i.kt)("inlineCode",{parentName:"p"},"tez"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The call ",(0,i.kt)("inlineCode",{parentName:"p"},"ediv(z1, z2)"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"z1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"z2")," are either of type ",(0,i.kt)("inlineCode",{parentName:"p"},"int"),"\nor ",(0,i.kt)("inlineCode",{parentName:"p"},"nat"),", returns ",(0,i.kt)("inlineCode",{parentName:"p"},"None()")," if ",(0,i.kt)("inlineCode",{parentName:"p"},"z2")," is zero; otherwise, it returns the\npair ",(0,i.kt)("inlineCode",{parentName:"p"},"[q,r]"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"q")," is the quotient and ",(0,i.kt)("inlineCode",{parentName:"p"},"r")," the positive\nremainder, as is the convention of the mathematical Euclidian\ndivision. The function ",(0,i.kt)("inlineCode",{parentName:"p"},"ediv")," is also overloaded to work on values of\ntype ",(0,i.kt)("inlineCode",{parentName:"p"},"tez"),". When ",(0,i.kt)("inlineCode",{parentName:"p"},"z1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"z2")," are of type ",(0,i.kt)("inlineCode",{parentName:"p"},"tez")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"z2")," is nonzero,\nwe get a ",(0,i.kt)("inlineCode",{parentName:"p"},"nat")," quotient and a ",(0,i.kt)("inlineCode",{parentName:"p"},"tez")," remainder. When ",(0,i.kt)("inlineCode",{parentName:"p"},"z1")," is a ",(0,i.kt)("inlineCode",{parentName:"p"},"tez"),"\nand ",(0,i.kt)("inlineCode",{parentName:"p"},"z2")," is a nonzero ",(0,i.kt)("inlineCode",{parentName:"p"},"nat"),", the calls yields a quotient and a\nremainder both of type ",(0,i.kt)("inlineCode",{parentName:"p"},"tez"),".")),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type 'elt big_set = 'elt Big_set.t"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type big_set<elt> = Big_set.t<elt>"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The type of the big sets is based on ",(0,i.kt)("inlineCode",{parentName:"p"},"big_map"),".")),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The type of the big sets is based on ",(0,i.kt)("inlineCode",{parentName:"p"},"big_map"),".")),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type dynamic_entrypoints = (nat, bytes) big_map"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type dynamic_entrypoints = big_map<nat, bytes>"),"Dynamic entrypoints",(0,i.kt)("p",null,"   Dynamic entrypoints are lazy entrypoints stored in the contract within\na big_map. They can then be updated or removed without deploying a new\ncontract."),(0,i.kt)("p",null,"   A contract with dynamic entrypoints must have at least one ",(0,i.kt)("inlineCode",{parentName:"p"},"@entry"),"\ndeclaration (as any other contract); it also must obey some\nconvention on storage type definition and have at least one\n",(0,i.kt)("inlineCode",{parentName:"p"},"@dyn_entry")," declaration."),(0,i.kt)("p",null,"   LIGO will then include the defined dynamic entries into the\ncontract initial storage."),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type dynamic_entrypoint"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type dynamic_entrypoint"),"A value of type `dynamic_entrypoint` denotes a typed key in an dynamic entrypoint",(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type michelson_program"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type michelson_program"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type typed_address"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type typed_address"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type mutation"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type mutation"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type michelson_contract"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type michelson_contract"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type pbt_gen"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type pbt_gen"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type int64"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type int64"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type views"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type views"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type test_exec_error_balance_too_low = { contract_balance : tez; contract_too_low : address; spend_request : tez }"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type test_exec_error_balance_too_low = { contract_balance: tez; contract_too_low: address; spend_request: tez }"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type test_exec_error = | Balance_too_low of test_exec_error_balance_too_low | Other of string | Rejected of (michelson_program * address)"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},'type test_exec_error = ["Balance_too_low", test_exec_error_balance_too_low] | ["Other", string] | ["Rejected", michelson_program, address]'),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type test_exec_result = | Fail of test_exec_error | Success of nat"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},'type test_exec_result = ["Fail", test_exec_error] | ["Success", nat]'),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type test_baker_policy = | By_account of address | By_round of int | Excluding of address list"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},'type test_baker_policy = ["By_account", address] | ["By_round", int] | ["Excluding", list<address>]'),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type 'a pbt_test = 'a pbt_gen * 'a -> bool"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type pbt_test<a> = [pbt_gen<a>, (_: a) => bool]"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type 'a pbt_result = | Fail of 'a | Success"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},'type pbt_result<a> = ["Fail", a] | ["Success"]'),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type 's unforged_ticket = { amount : nat; ticketer : address; value : 's }"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type unforged_ticket<s> = { amount: nat; ticketer: address; value: s }"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type ('param, 'storage) module_contract = ('param * 'storage) -> (operation list * 'storage) * 'storage views * dynamic_entrypoints option"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type module_contract<param, storage> = [(_: [param, storage]) => [list<operation>, storage], views<storage>, option<dynamic_entrypoints>]"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type ('param, 'storage) origination_result = { addr : ('param, 'storage) typed_address; code : ('param, 'storage) michelson_contract; size : int }"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type origination_result<param, storage> = { addr: typed_address<param, storage>; code: michelson_contract<param, storage>; size: int }"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"type implicit_address = (unit, unit) typed_address"),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"type implicit_address = typed_address<unit, unit>"))}x.isMDXComponent=!0},23746:(e,t,n)=>{n.r(t),n.d(t,{Prism:()=>a.Z,default:()=>c,defaultProps:()=>l});var a=n(87410);const i={plain:{backgroundColor:"#2a2734",color:"#9a86fd"},styles:[{types:["comment","prolog","doctype","cdata","punctuation"],style:{color:"#6c6783"}},{types:["namespace"],style:{opacity:.7}},{types:["tag","operator","number"],style:{color:"#e09142"}},{types:["property","function"],style:{color:"#9a86fd"}},{types:["tag-id","selector","atrule-id"],style:{color:"#eeebff"}},{types:["attr-name"],style:{color:"#c4b9fe"}},{types:["boolean","string","entity","url","attr-value","keyword","control","directive","unit","statement","regex","atrule","placeholder","variable"],style:{color:"#ffcc99"}},{types:["deleted"],style:{textDecorationLine:"line-through"}},{types:["inserted"],style:{textDecorationLine:"underline"}},{types:["italic"],style:{fontStyle:"italic"}},{types:["important","bold"],style:{fontWeight:"bold"}},{types:["important"],style:{color:"#c4b9fe"}}]};var o=n(67294),l={Prism:a.Z,theme:i};function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(){return s=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},s.apply(this,arguments)}var y=/\r\n|\r|\n/,p=function(e){0===e.length?e.push({types:["plain"],content:"\n",empty:!0}):1===e.length&&""===e[0].content&&(e[0].content="\n",e[0].empty=!0)},m=function(e,t){var n=e.length;return n>0&&e[n-1]===t?e:e.concat(t)},d=function(e,t){var n=e.plain,a=Object.create(null),i=e.styles.reduce((function(e,n){var a=n.languages,i=n.style;return a&&!a.includes(t)||n.types.forEach((function(t){var n=s({},e[t],i);e[t]=n})),e}),a);return i.root=n,i.plain=s({},n,{backgroundColor:null}),i};function x(e,t){var n={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&-1===t.indexOf(a)&&(n[a]=e[a]);return n}const c=function(e){function t(){for(var t=this,n=[],a=arguments.length;a--;)n[a]=arguments[a];e.apply(this,n),r(this,"getThemeDict",(function(e){if(void 0!==t.themeDict&&e.theme===t.prevTheme&&e.language===t.prevLanguage)return t.themeDict;t.prevTheme=e.theme,t.prevLanguage=e.language;var n=e.theme?d(e.theme,e.language):void 0;return t.themeDict=n})),r(this,"getLineProps",(function(e){var n=e.key,a=e.className,i=e.style,o=s({},x(e,["key","className","style","line"]),{className:"token-line",style:void 0,key:void 0}),l=t.getThemeDict(t.props);return void 0!==l&&(o.style=l.plain),void 0!==i&&(o.style=void 0!==o.style?s({},o.style,i):i),void 0!==n&&(o.key=n),a&&(o.className+=" "+a),o})),r(this,"getStyleForToken",(function(e){var n=e.types,a=e.empty,i=n.length,o=t.getThemeDict(t.props);if(void 0!==o){if(1===i&&"plain"===n[0])return a?{display:"inline-block"}:void 0;if(1===i&&!a)return o[n[0]];var l=a?{display:"inline-block"}:{},r=n.map((function(e){return o[e]}));return Object.assign.apply(Object,[l].concat(r))}})),r(this,"getTokenProps",(function(e){var n=e.key,a=e.className,i=e.style,o=e.token,l=s({},x(e,["key","className","style","token"]),{className:"token "+o.types.join(" "),children:o.content,style:t.getStyleForToken(o),key:void 0});return void 0!==i&&(l.style=void 0!==l.style?s({},l.style,i):i),void 0!==n&&(l.key=n),a&&(l.className+=" "+a),l})),r(this,"tokenize",(function(e,t,n,a){var i={code:t,grammar:n,language:a,tokens:[]};e.hooks.run("before-tokenize",i);var o=i.tokens=e.tokenize(i.code,i.grammar,i.language);return e.hooks.run("after-tokenize",i),o}))}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.render=function(){var e=this.props,t=e.Prism,n=e.language,a=e.code,i=e.children,o=this.getThemeDict(this.props),l=t.languages[n];return i({tokens:function(e){for(var t=[[]],n=[e],a=[0],i=[e.length],o=0,l=0,r=[],s=[r];l>-1;){for(;(o=a[l]++)<i[l];){var d=void 0,x=t[l],c=n[l][o];if("string"==typeof c?(x=l>0?x:["plain"],d=c):(x=m(x,c.type),c.alias&&(x=m(x,c.alias)),d=c.content),"string"==typeof d){var g=d.split(y),k=g.length;r.push({types:x,content:g[0]});for(var T=1;T<k;T++)p(r),s.push(r=[]),r.push({types:x,content:g[T]})}else l++,t.push(x),n.push(d),a.push(0),i.push(d.length)}l--,t.pop(),n.pop(),a.pop(),i.pop()}return p(r),s}(void 0!==l?this.tokenize(t,a,l,n):[a]),className:"prism-code language-"+n,style:void 0!==o?o.root:{},getLineProps:this.getLineProps,getTokenProps:this.getTokenProps})},t}(o.Component)},87552:(e,t,n)=>{n.d(t,{Z:()=>a});const a={plain:{color:"#bfc7d5",backgroundColor:"#292d3e"},styles:[{types:["comment"],style:{color:"rgb(105, 112, 152)",fontStyle:"italic"}},{types:["string","inserted"],style:{color:"rgb(195, 232, 141)"}},{types:["number"],style:{color:"rgb(247, 140, 108)"}},{types:["builtin","char","constant","function"],style:{color:"rgb(130, 170, 255)"}},{types:["punctuation","selector"],style:{color:"rgb(199, 146, 234)"}},{types:["variable"],style:{color:"rgb(191, 199, 213)"}},{types:["class-name","attr-name"],style:{color:"rgb(255, 203, 107)"}},{types:["tag","deleted"],style:{color:"rgb(255, 85, 114)"}},{types:["operator"],style:{color:"rgb(137, 221, 255)"}},{types:["boolean"],style:{color:"rgb(255, 88, 116)"}},{types:["keyword"],style:{fontStyle:"italic"}},{types:["doctype"],style:{color:"rgb(199, 146, 234)",fontStyle:"italic"}},{types:["namespace"],style:{color:"rgb(178, 204, 214)"}},{types:["url"],style:{color:"rgb(221, 221, 221)"}}]}}}]);