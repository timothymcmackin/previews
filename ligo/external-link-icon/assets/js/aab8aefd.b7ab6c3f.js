"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[99711],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),m=p(n),d=r,h=m["".concat(s,".").concat(d)]||m[d]||c[d]||o;return n?a.createElement(h,i(i({ref:t},u),{},{components:n})):a.createElement(h,i({ref:t},u))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},48720:(e,t,n)=>{n.d(t,{D:()=>r.Z,Z:()=>o});var a=n(67294),r=n(75402);const o=function(e){return a.createElement(r.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},69261:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>u});var a=n(87462),r=(n(67294),n(3905)),o=n(48720);const i={id:"tz-vs-eth",title:"Migrating from Ethereum"},l=void 0,s={unversionedId:"tutorials/tz-vs-eth/tz-vs-eth",id:"version-1.6.0/tutorials/tz-vs-eth/tz-vs-eth",title:"Migrating from Ethereum",description:"This article is aimed at those who have some experience with",source:"@site/versioned_docs/version-1.6.0/tutorials/tz-vs-eth/tz-vs-eth.md",sourceDirName:"tutorials/tz-vs-eth",slug:"/tutorials/tz-vs-eth/",permalink:"/previews/ligo/external-link-icon/docs/1.6.0/tutorials/tz-vs-eth/",draft:!1,tags:[],version:"1.6.0",frontMatter:{id:"tz-vs-eth",title:"Migrating from Ethereum"}},p={},u=[{value:"Languages and libraries",id:"languages-and-libraries",level:2},{value:"Terminology",id:"terminology",level:2},{value:"Types and why they matter",id:"types-and-why-they-matter",level:2},{value:"Contracts and entrypoints",id:"contracts-and-entrypoints",level:2},{value:"Visibility modifiers",id:"visibility-modifiers",level:2},{value:"Lambdas",id:"lambdas",level:2},{value:"Execution model",id:"execution-model",level:2},{value:"Fees",id:"fees",level:2},{value:"Conclusion",id:"conclusion",level:2}],c={toc:u};function m(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This article is aimed at those who have some experience with\ndeveloping smart contracts for Ethereum in Solidity. We will cover the\nkey differences between Solidity and LIGO, compare the execution model\nof Ethereum and Tezos blockchains, and list the features you should be\naware of while developing smart contracts for Tezos."),(0,r.kt)("h2",{id:"languages-and-libraries"},"Languages and libraries"),(0,r.kt)("p",null,"Tezos is an upgradeable blockchain that focuses on\ndecentralisation. It offers a wide variety of languages, frameworks,\nand tools you can use to develop your contracts. In this article, we\nmainly focus on the LIGO language, and the provided examples use the\nTruffle framework for testing. However, many of the points here cover\nthe inherent differences in the blockchain architectures, so they\nshould be valid for other languages and frameworks in the Tezos\necosystem."),(0,r.kt)("p",null,"The current Tezos protocol uses the Michelson language under the\nhood. Michelson is much like EVM in Ethereum, inasmuch as its programs\nare low-level code executed by an embedded virtual\nmachine. Nevertheless, contrary to EVM byte-code, Michelson is a\nstrongly-typed stack-based language designed to be human-readable."),(0,r.kt)("p",null,"Having a human-readable representation of compiled contracts makes it\nharder for compiler bugs to pass unnoticed: everyone can review the\nMichelson code of the contract and even formally prove its\ncorrectness."),(0,r.kt)("p",null,"LIGO is a family of high-level languages. There are several ",(0,r.kt)("em",{parentName:"p"},"flavours"),"\nor ",(0,r.kt)("em",{parentName:"p"},"syntaxes")," of LIGO \u2013 CameLIGO, and JsLIGO. The developers may\nchoose whatever syntax looks more familiar to them."),(0,r.kt)("h2",{id:"terminology"},"Terminology"),(0,r.kt)("p",null,"For those who come from the Ethereum world, the terminology used in\nTezos may be misleading. Tezos developers chose to ",(0,r.kt)("em",{parentName:"p"},"not")," reuse the\nsame terms for similar concepts for a reason: a false sense of\nsimilarity would be a bad friend for those migrating to a different\nblockchain architecture."),(0,r.kt)("p",null,"We will, however, try to associate the terms known to you with the\nterms used in Tezos. Note that this is just an ",(0,r.kt)("em",{parentName:"p"},"association,")," and not\nthe exact equivalence."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Ethereum term"),(0,r.kt)("th",{parentName:"tr",align:null},"Tezos term"),(0,r.kt)("th",{parentName:"tr",align:null},"Notes"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"World state"),(0,r.kt)("td",{parentName:"tr",align:null},"Context"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Account"),(0,r.kt)("td",{parentName:"tr",align:null},"Contract or Account"),(0,r.kt)("td",{parentName:"tr",align:null},'In Tezos, both smart contracts and accounts controlled by private keys are referred to as "contracts"')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Externally-owned account"),(0,r.kt)("td",{parentName:"tr",align:null},"Implicit account"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Contract"),(0,r.kt)("td",{parentName:"tr",align:null},"Smart contract or Originated contract"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Contract deployment"),(0,r.kt)("td",{parentName:"tr",align:null},"Contract origination"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Transaction"),(0,r.kt)("td",{parentName:"tr",align:null},"Operation"),(0,r.kt)("td",{parentName:"tr",align:null},"In Tezos, there is a distinction between transactions that transfer value, contract originations, and other kinds of operations")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"\u2013"),(0,r.kt)("td",{parentName:"tr",align:null},"Transaction"),(0,r.kt)("td",{parentName:"tr",align:null},"One possible type of operation (value transfer or contract invocation)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Miner"),(0,r.kt)("td",{parentName:"tr",align:null},"Baker"),(0,r.kt)("td",{parentName:"tr",align:null},"Tezos uses proof-of-stake, so bakers do not solve proof-of-work puzzles. They do produce new blocks and receive rewards, though")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Contract state"),(0,r.kt)("td",{parentName:"tr",align:null},"Contract storage"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Contract method"),(0,r.kt)("td",{parentName:"tr",align:null},"Entrypoint"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"View method"),(0,r.kt)("td",{parentName:"tr",align:null},"\u2013"),(0,r.kt)("td",{parentName:"tr",align:null},"Currently, Tezos does not provide view functions. You can inspect the storage of the contract, though")))),(0,r.kt)("h2",{id:"types-and-why-they-matter"},"Types and why they matter"),(0,r.kt)("p",null,"If you come from the Solidity world, you may be accustomed to simple types like ",(0,r.kt)("inlineCode",{parentName:"p"},"string")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"uint256"),", structures, and enums. In LIGO, the types are more advanced. They tend to reflect how the values of these types should be used rather than how they are stored. That is why, for example, LIGO has separate types for ",(0,r.kt)("inlineCode",{parentName:"p"},"signature")," and public ",(0,r.kt)("inlineCode",{parentName:"p"},"key")," instead of just using a byte string (",(0,r.kt)("inlineCode",{parentName:"p"},"bytes"),") everywhere. Numeric types follow this philosophy: the numbers have arbitrary precision and are, in practice, bounded only by the transaction gas consumption."),(0,r.kt)("p",null,'Since types are not some purely "technical" concept and have inherent meaning attached to them, it is often a good idea to start thinking about your contract in terms of functions that transform values of one type to values of, possibly, some other type.'),(0,r.kt)("p",null,"You can define new types and type aliases in your code using the ",(0,r.kt)("inlineCode",{parentName:"p"},"type")," keyword:"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=b2",group:"b2"},"type nat_alias = nat\n\ntype token_amount = TokenAmount of nat\n"))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=b2",group:"b2"},'type nat_alias = nat;\n\ntype token_amount = | ["TokenAmount", nat];\n'))),(0,r.kt)("p",null,"As in Solidity, there are record types:"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=b3",group:"b3"},"type creature = {heads_count : nat; legs_count : nat; tails_count : nat}\n"))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=b3",group:"b3"},"type creature = { heads_count: nat, legs_count: nat, tails_count: nat };\n"))),(0,r.kt)("p",null,"There are also ",(0,r.kt)("em",{parentName:"p"},"variant"),' types (or "sum types") \u2013 a more powerful counterpart of Solidity enums that can hold data:'),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=b4",group:"b4"},"type int_option = Number of int | Null\n\nlet x = Number 5\n\nlet y = Null\n")),(0,r.kt)("p",null,"Valid values of this type are regular numbers wrapped in ",(0,r.kt)("inlineCode",{parentName:"p"},"Number")," (e.g., ",(0,r.kt)("inlineCode",{parentName:"p"},"Number 5"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Number 10"),", etc.) or ",(0,r.kt)("inlineCode",{parentName:"p"},"Null"),". Notice how ",(0,r.kt)("inlineCode",{parentName:"p"},"Null")," does not hold any value.")),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=b4",group:"b4"},'type int_option = ["Number", int] | ["Null"];\n\nlet x = Number(5);\n\nlet y = Null ();\n')),(0,r.kt)("p",null,"Valid values of this type are regular numbers wrapped in ",(0,r.kt)("inlineCode",{parentName:"p"},"Number")," (e.g., ",(0,r.kt)("inlineCode",{parentName:"p"},"Number(5)"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Number(10)"),", etc.) or ",(0,r.kt)("inlineCode",{parentName:"p"},"Null"),". Notice how ",(0,r.kt)("inlineCode",{parentName:"p"},"Null()")," does not hold any value.")),(0,r.kt)("p",null,"There is a special built-in parameterised ",(0,r.kt)("inlineCode",{parentName:"p"},"option")," type with ",(0,r.kt)("inlineCode",{parentName:"p"},"Some")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"None")," constructors, so we can rewrite the snippet above as:"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=b5",group:"b5"},"let x = Some 5\n\nlet y : int option = None\n")),(0,r.kt)("p",null,"This is how we express ",(0,r.kt)("em",{parentName:"p"},"nullability"),' in LIGO: instead of using a special ad-hoc value like "zero address", we just say it is an ',(0,r.kt)("inlineCode",{parentName:"p"},"address option"),". We can then use ",(0,r.kt)("inlineCode",{parentName:"p"},"match")," to see if there is something inside:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=b6",group:"b6"},"let x : int option = Some 5\n\nlet x_or_zero =\n  match x with\n    Some value -> value\n  | None -> 0\n"))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=b5",group:"b5"},"let x = Some(5);\n\nlet y: option<int> = None();\n")),(0,r.kt)("p",null,"This is how we express ",(0,r.kt)("em",{parentName:"p"},"nullability"),' in LIGO: instead of using a special ad-hoc value like "zero address", we just say it is an ',(0,r.kt)("inlineCode",{parentName:"p"},"option<address>"),". We can then use ",(0,r.kt)("inlineCode",{parentName:"p"},"match")," to see if there is something inside:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=b6",group:"b6"},"let x = Some (5);\n\nlet x_or_zero  =\n  match(x) {\n    when(Some(value)): value;\n    when(None()): 0\n  };\n"))),(0,r.kt)("p",null,"We can go further and combine variant types with records:"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=b7",group:"b7"},"type committee = {members : address list; quorum : nat}\n\ntype leader = {name : string; address : address}\n\ntype authority = Dictatorship of leader | Democracy of committee\n"))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=b7",group:"b7"},'type committee = {members: list<address>, quorum: nat };\n\ntype leader = {name: string, address: address };\n\ntype authority = ["Dictatorship", leader] | ["Democracy", committee];\n'))),(0,r.kt)("h2",{id:"contracts-and-entrypoints"},"Contracts and entrypoints"),(0,r.kt)("p",null,"In Solidity, you usually define a ",(0,r.kt)("em",{parentName:"p"},"contract")," with ",(0,r.kt)("em",{parentName:"p"},"methods")," and ",(0,r.kt)("em",{parentName:"p"},"fields"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"contract Counter {\n  int public counter;  // storage field\n\n  function increment() public { ... } // method\n  function decrement() public { ... } // method\n}\n")),(0,r.kt)("p",null,"When the contract is compiled, the Solidity compiler automatically adds dispatching logic into the resulting EVM byte-code. The contract inspects the data passed to it and chooses a method based on the first four bytes of the method's signature hash: ",(0,r.kt)("inlineCode",{parentName:"p"},"0xbc1ecb8e")," means ",(0,r.kt)("inlineCode",{parentName:"p"},"increment()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"0x36e44653")," means ",(0,r.kt)("inlineCode",{parentName:"p"},"decrement()"),"."),(0,r.kt)("p",null,"In Tezos, a contract must define a default entrypoint that does the dispatching. It is much like a ",(0,r.kt)("inlineCode",{parentName:"p"},"main")," function in C-like languages. It accepts a typed ",(0,r.kt)("em",{parentName:"p"},"parameter")," (some data that comes with a transaction) and the current value of the contract ",(0,r.kt)("em",{parentName:"p"},"storage")," (the internal state of the contract). The default entrypoint returns a list of internal operations and the new value of the storage."),(0,r.kt)("p",null,"For example, we can simulate Ethereum dispatching behaviour:"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=a2",group:"a2"},'[@entry]\nlet main (parameter : bytes) (storage : int) : operation list * int =\n  if parameter = 0xbc1ecb8e\n  then [], storage + 1\n  else\n    if parameter = 0x36e44653\n    then [], storage - 1\n    else failwith "Unknown entrypoint"\n')),(0,r.kt)("p",null,"However, we can do better. As we discussed, LIGO has a much richer type system than Solidity does. We can encode the entrypoints by marking the functions which are entry points. For our counter contract, we can say, e.g., that the entry points are ",(0,r.kt)("em",{parentName:"p"},"either")," ",(0,r.kt)("inlineCode",{parentName:"p"},"Increment")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Decrement"),", and implement their behaviours as separate functions:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=a3",group:"a3"},"type storage = int\ntype result = operation list * storage\n\n[@entry]\nlet increment (_ : unit) (s : storage) : result = [], s + 1\n\n[@entry]\nlet decrement (_ : unit) (s : storage) : result = [], s - 1\n"))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=a2",group:"a2"},'let main = (parameter: bytes, storage: int): [list<operation>, int] => {\n  if (parameter == 0xbc1ecb8e) {\n    return [[], storage + 1]\n  } else {\n    if (parameter == 0x36e44653) {\n      return [[], storage - 1]\n    } else {\n      return (failwith("Unknown entrypoint"))\n    }\n  }\n};\n')),(0,r.kt)("p",null,"However, we can do better. As we discussed, LIGO has a much richer type system than Solidity does. We can encode the entrypoint directly in the parameter type. that the entry points are ",(0,r.kt)("em",{parentName:"p"},"either")," ",(0,r.kt)("inlineCode",{parentName:"p"},"Increment")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Decrement"),", and implement their behaviours as separate functions:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=a3",group:"a3"},"type storage = int;\ntype result = [list<operation>, int]\n\n@entry\nconst increment = (_u : unit, s : storage) : result => [[], s + 1]\n\n@entry\nconst decrement = (_u : unit, s : storage) : result => [[], s - 1]\n"))),(0,r.kt)("p",null,"We do not need any internal operations, since we neither call other contracts nor transfer money. Here is how we can add arguments to our entrypoints:"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=a4",group:"a4"},"type storage = int\ntype result = operation list * storage\n\n[@entry]\nlet add (i : int) (s : storage) : result = [], s + i\n\n[@entry]\nlet subtract (i : int) (s : storage) : result = [], s - i\n"))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=a4",group:"a4"},"type storage = int;\ntype result = [list<operation>, int]\n\n@entry\nconst add = (i : int, s : storage) : result => [[], s + i]\n\n@entry\nconst subtract = (i : int, s : storage) : result => [[], s - i]\n"))),(0,r.kt)("p",null,"Tezos has special support for parameters encoded with variant types. If the parameter is a variant type, Tezos will treat each constructor as a separate entrypoint (with the first letter lowercased). It is important when we want to call a contract but do not know the full type of its parameter. For example, we can call our counter contract with the following CLI command:"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"tezos-client call contract counter from alice --entrypoint '%subtract' --arg 100")),(0,r.kt)("p",null,"Truffle (and Taquito library, which Truffle for Tezos uses under the hood), also treats entrypoints specially. We can call our ",(0,r.kt)("inlineCode",{parentName:"p"},"add")," entrypoint as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"const Counter = artifacts.require('Counter')\nlet counterInstance = await Counter.deployed()\nawait counterInstance.add(100)\n")),(0,r.kt)("h2",{id:"visibility-modifiers"},"Visibility modifiers"),(0,r.kt)("p",null,"Solidity has visibility modifiers like ",(0,r.kt)("inlineCode",{parentName:"p"},"private")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"public")," for storage entries and contract methods. LIGO has none of these, and you may be wondering why. To answer this, we will first consider storage modifiers and then discuss methods (entrypoints)."),(0,r.kt)("p",null,"It is a popular misconception in the Ethereum world that by marking a storage field ",(0,r.kt)("inlineCode",{parentName:"p"},"private")," you can make this field visible only from inside the contract. Both in Tezos and Ethereum, the contract storage is public. This is due to how blockchains work: nodes need to read contracts' storage to execute and validate the transactions. Tezos allows anyone to inspect storage of any contract with one CLI command. In Ethereum, it is harder but still feasible."),(0,r.kt)("p",null,"Making a storage field ",(0,r.kt)("inlineCode",{parentName:"p"},"public")," in Solidity instructs the compiler to generate a ",(0,r.kt)("inlineCode",{parentName:"p"},"view")," method that returns the value of this field. In Tezos, it is possible to inspect the storage directly, and it is not possible to return values from contract calls. Thus, public and private storage fields are equivalent in Tezos."),(0,r.kt)("p",null,"For contract methods, the dispatching logic defines which functions within the contract are accessible from the outside world. Consider the following snippet:"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=a5",group:"a5"},"type storage = int\ntype result = operation list * storage\n\nlet doMultiplyBy2 (store : storage) : int = store * 2\n\nlet doMultiplyBy4 (store : storage) : int = doMultiplyBy2 (doMultiplyBy2 store)\n\n[@entry] let multiplyBy4 (_ : unit) (s : storage) : result = [], doMultiplyBy4 s\n[@entry] let multiplyBy16 (_ : unit) (s : storage) : result = [], doMultiplyBy4 (doMultiplyBy4 s)\n"))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=a5",group:"a5"},"type storage = int\ntype result = [list<operation>, storage]\n\nlet doMultiplyBy2 = (store : storage) : int => store * 2;\n\nlet doMultiplyBy4 = (store : storage) : int => doMultiplyBy2(doMultiplyBy2(store));\n\n@entry const multiplyBy4 = (_u : unit, s : storage) : result => [[], doMultiplyBy4(s)]\n@entry const multiplyBy16 = (_u : unit, s : storage) : result => [[], doMultiplyBy4(doMultiplyBy4(s))]\n"))),(0,r.kt)("p",null,"Here:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"multiplyBy2")," is ",(0,r.kt)("em",{parentName:"li"},"private")," (in Solidity terms): we cannot call it directly from outside of the contract."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"multiplyBy4")," is ",(0,r.kt)("em",{parentName:"li"},"public:")," we can call it both from inside the contract and using the ",(0,r.kt)("inlineCode",{parentName:"li"},"%multiplyBy4")," entrypoint."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"%multiplyBy16")," is ",(0,r.kt)("em",{parentName:"li"},"external:")," there is no function ",(0,r.kt)("inlineCode",{parentName:"li"},"multiplyBy16")," in the contract so we cannot call it from inside the source code, but there is an entrypoint ",(0,r.kt)("inlineCode",{parentName:"li"},"%multiplyBy16")," encoded in the parameter, so we can use tezos-client or Taquito to call it externally.")),(0,r.kt)("p",null,"There is no analogue of ",(0,r.kt)("inlineCode",{parentName:"p"},"internal")," methods in LIGO because LIGO contracts do not support inheritance."),(0,r.kt)("h2",{id:"lambdas"},"Lambdas"),(0,r.kt)("p",null,"In Tezos, you can accept ",(0,r.kt)("em",{parentName:"p"},"code")," as a parameter. Such functions that you can pass around are called ",(0,r.kt)("em",{parentName:"p"},"lambdas")," in functional languages. Let us say that we want to support arbitrary mathematical operations with the counter value. We can just accept the intended formula as the parameter:"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=a6",group:"a6"},"\ntype storage = int\n\n[@entry]\nlet compute (func : int -> int) (s : storage) : operation list * storage =\n  [], func s\n")),(0,r.kt)("p",null,"We can then call this contract with the parameter of the form ",(0,r.kt)("inlineCode",{parentName:"p"},"Compute (fun (x : int) -> x * x + 2 * x + 1)"),". Try this out with:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"ligo run interpret 'main (Compute (fun (x : int) -> x * x + 2 * x + 1), 3)' --init-file examples/contracts/mligo/Lambda.mligo\n"))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=a6",group:"a6"},"type storage = int;\n\n@entry\nconst compute = (func: ((v : int) => int), s: storage) : [list<operation>, int] =>\n  [[], func(s)]\n")),(0,r.kt)("p",null,"We can then call this contract with the parameter of the form ",(0,r.kt)("inlineCode",{parentName:"p"},"Compute ((x : int) => x * x + 2 * x + 1)"),". Try this out with:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"ligo run interpret 'main([Compute ((x : int) => x * x + 2 * x + 1), 3])' --init-file examples/contracts/jsligo/Lambda.jsligo\n"))),(0,r.kt)("p",null,"The interpreted output is ",(0,r.kt)("inlineCode",{parentName:"p"},"( LIST_EMPTY() , 16 )"),", which is an empty list of operations and the new storage value \u2013 the result of the computation."),(0,r.kt)("p",null,"But this is not all lambdas are capable of. You can, for example, save them in storage:"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=a1",group:"a1"},'type storage = {fn : (int -> int) option; value : int}\ntype result = operation list * storage\n\nlet call (fn : (int -> int) option) (value : int) =\n  match fn with\n    Some f -> f value\n  | None -> failwith "Lambda is not set"\n\n[@entry]\nlet setFunction (fn : int -> int) (s : storage) : result =\n  [], { s with fn = Some fn }\n\n[@entry]\nlet callFunction (_ : unit) (s : storage) : result =\n  [], { s with value = call s.fn s.value }\n')),(0,r.kt)("p",null,"Now we can ",(0,r.kt)("em",{parentName:"p"},"upgrade")," a part of the implementation by calling our contract with ",(0,r.kt)("inlineCode",{parentName:"p"},"SetFunction (fun (x : int) -> ...)"),".")),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=a1",group:"a1"},'type storage = { fn : option<((x : int) => int)>, value : int };\ntype result = [list<operation>, storage];\n\nconst call = (fn: option<((x : int) => int)>, value: int) : int => {\n  return match(fn) {\n    when(Some(f)): f(value);\n    when(None()): failwith("Lambda is not set")\n  }\n};\n\n@entry\nconst setFunction = (fn : ((v : int) => int), s : storage) : result =>\n  [[], {...s, fn: Some(fn)}];\n\n@entry\nconst callFunction = (_u : unit, s : storage) : result =>\n  [[], {...s, value: call(s.fn, s.value)}];\n')),(0,r.kt)("p",null,"Now we can ",(0,r.kt)("em",{parentName:"p"},"upgrade")," a part of the implementation by calling our contract with ",(0,r.kt)("inlineCode",{parentName:"p"},"SetFunction ((x : int) => ...)"),".")),(0,r.kt)("h2",{id:"execution-model"},"Execution model"),(0,r.kt)("p",null,'In Ethereum, you often find yourself "calling" other contracts and splitting your business logic into multiple independent parts. When you call some other contract, the transaction execution is paused until the callee returns the result. We will refer to such invocations as ',(0,r.kt)("em",{parentName:"p"},"direct calls:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"contract Treasury {\n    uint256 public rewardsLeft;\n    IBeneficiary beneficiary;\n\n    function disburseRewards() public {\n        require(rewardsLeft != 0);\n        beneficiary.handleRewards().call.value(rewardsLeft);\n        // the execution is paused until `handleRewards` returns\n        rewardsLeft = 0;\n    }\n}\n")),(0,r.kt)("p",null,"Those of you experienced with Solidity may notice that this contract is not reentrancy-safe: the beneficiary contract may utilise the fact that by the time of the call, ",(0,r.kt)("inlineCode",{parentName:"p"},"rewardsLeft")," storage variable has not been updated. The attacker can ",(0,r.kt)("em",{parentName:"p"},"call back")," into the caller contract, invoking ",(0,r.kt)("inlineCode",{parentName:"p"},"disburseRewards")," until it drains the treasury contract:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"contract Beneficiary {\n    function handleRewards() public payable {\n        Treasury treasury = Treasury(msg.sender);\n        if (msg.sender.balance > treasury.rewardsLeft) {\n            treasury.disburseRewards();\n        }\n    }\n}\n")),(0,r.kt)("p",null,"In Tezos, the execution model is quite different. Contracts communicate via message passing. Messages are called ",(0,r.kt)("em",{parentName:"p"},"internal operations.")," If you want to pass a message to another contract, you need to finish the computation first, and then put an operation into the ",(0,r.kt)("em",{parentName:"p"},"operations queue.")," Here is how it looks like:"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=b1",group:"b1"},'type storage = {rewardsLeft : tez; beneficiaryAddress : address}\n\nlet treasury (p, s : unit * storage) =\n  // We do our computations first\n  let newStorage = {s with rewardsLeft = 0mutez} in\n\n  // Then we find our beneficiary\'s `handleRewards` entrypoint:\n  let beneficiaryOpt = Tezos.get_entrypoint_opt "%handleTransfer" s.beneficiaryAddress in\n  let beneficiary =\n    match beneficiaryOpt with\n      Some contract -> contract\n    | None -> failwith "Beneficiary does not exist" in\n\n  // Then we prepare the internal operation we want to perform\n  let operation = Tezos.transaction () s.rewardsLeft beneficiary in\n\n  // ...and return both the operations and the updated storage\n  ([operation], newStorage)\n'))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=b1",group:"b1"},'type storage = {rewardsLeft: tez, beneficiaryAddress: address };\n\nlet treasury = (p : unit, s : storage) => {\n  // We do our computations first\n  let newStorage = {...s, rewardsLeft: 0mutez};\n\n  // Then we find our beneficiary\'s `handleRewards` entrypoint:\n  let beneficiaryOpt = Tezos.get_entrypoint_opt("%handleTransfer", s.beneficiaryAddress);\n  let beneficiary =\n    match(beneficiaryOpt) {\n     when(Some(contract)): contract;\n     when(None()): failwith("Beneficiary does not exist")\n    };\n\n  // Then we prepare the internal operation we want to perform\n  let operation = Tezos.transaction(unit, s.rewardsLeft, beneficiary);\n\n  // ...and return both the operations and the updated storage\n  return [list([operation]), newStorage];\n};\n'))),(0,r.kt)("p",null,"Note that all the state changes occur ",(0,r.kt)("em",{parentName:"p"},"before")," the internal operation gets executed. This way, Tezos protects us from unintended reentrancy attacks. However, with complex interactions chain, reentrancy attacks may still be possible."),(0,r.kt)("p",null,"It is a common idiom in Ethereum to make read-only calls to other contracts. Tezos does not offer a straightforward way to do it but you might think of using something like a callback mechanism:"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},"type parameter = DoSomething | DoSomethingCont of int\n\nlet doSomething (p, s : unit * int) =\n  (* The callee should call `%doSomethingCont` with the value we want *)\n  let op = Tezos.transaction ... in\n  ([op], s)\n\nlet doSomethingCont (p, s : int * int) = ([] : operation list), p + s\n"))),(0,r.kt)(o.Z,{mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},'type parameter = ["DoSomething"] | ["DoSomethingCont", int];\n\nlet doSomething = ([p, s]: [unit, int]) => {\n  /* The callee should call `%doSomethingCont` with the value we want */\n  let op = Tezos.transaction ...;\n  return [[], s]\n}\n\nlet doSomethingCont = ([p, s]: [int, int]) => [([] as list<operation>), p + s];\n'))),(0,r.kt)("p",null,"However, here you leave your contract in an ",(0,r.kt)("em",{parentName:"p"},"intermediate")," state before making an external call. You would need additional precautions to make such callback-style calls secure. In most cases, you should avoid this pattern."),(0,r.kt)("p",null,"By making contract interactions harder, Tezos incentives you to simplify your architecture. Think about whether you can use lambdas or merge your contracts to avoid complex inter-contract dependencies. If it is possible to ",(0,r.kt)("em",{parentName:"p"},"not")," split your logic into multiple contracts, then avoid the split."),(0,r.kt)("p",null,"You can find more details on how Tezos contracts interact with each other in our ",(0,r.kt)("a",{parentName:"p",href:"/previews/ligo/external-link-icon/docs/1.6.0/tutorials/inter-contract-calls/"},"inter-contract calls")," article."),(0,r.kt)("h2",{id:"fees"},"Fees"),(0,r.kt)("p",null,"Fee model in Tezos is more complicated than the Ethereum one. The most important bits you should know about are:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"In Tezos, you ",(0,r.kt)("em",{parentName:"li"},"burn")," a certain amount of Tez for increasing the size of the stored data. For example, if you add a new entry to a map or replace a string with a longer one, you must burn your Tez tokens."),(0,r.kt)("li",{parentName:"ol"},"When you call a contract, the transaction spends gas for reading, deserialising and type-checking the storage. Also, a certain amount of gas gets spent for serialising and writing the storage back to the context. In practice, it means that ",(0,r.kt)("strong",{parentName:"li"},"the larger your code and storage are, the more expensive it is to call your contract,")," regardless of the number of computations performed. If you have big or unbounded containers in storage, you should most probably use ",(0,r.kt)("inlineCode",{parentName:"li"},"big_map"),"."),(0,r.kt)("li",{parentName:"ol"},"Emitting internal operations is very expensive in terms of gas: there is a fixed cost of 10000 gas for ",(0,r.kt)("inlineCode",{parentName:"li"},"Tezos.get_{contract, entrypoint}_opt")," plus the cost of reading, deserialising, and type-checking the parameter of the callee.")),(0,r.kt)("p",null,"Always test for gas consumption and strive to minimise the size of the data stored on chain and the number of internal operations emitted. You can read more on fees in our ",(0,r.kt)("a",{parentName:"p",href:"/previews/ligo/external-link-icon/docs/1.6.0/tutorials/optimisation/"},"Optimisation guide")," or in the ",(0,r.kt)("a",{parentName:"p",href:"https://medium.com/tqtezos/how-to-minimize-transaction-costs-of-tezos-smart-contracts-9962347faf64"},"Serokell blog post"),"."),(0,r.kt)("h2",{id:"conclusion"},"Conclusion"),(0,r.kt)("p",null,"In this article, we discussed some Solidity patterns and their LIGO counterparts. We also covered the most important aspects of the Tezos execution model and fees. Here is a quick reference table comparing Solidity and LIGO patterns:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Solidity pattern"),(0,r.kt)("th",{parentName:"tr",align:null},"LIGO pattern"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"public")," field"),(0,r.kt)("td",{parentName:"tr",align:null},"A field in the storage record, e.g. ",(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("inlineCode",{parentName:"td"},"type storage = { x : int; y : nat }")),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("inlineCode",{parentName:"td"},"type storage = { x : int, y : nat }")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"private")," field"),(0,r.kt)("td",{parentName:"tr",align:null},"N/A: all fields are public")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"private")," method"),(0,r.kt)("td",{parentName:"tr",align:null},"A regular function, e.g., ",(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("inlineCode",{parentName:"td"},"let func (a : int) = ...")),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("inlineCode",{parentName:"td"},"let func = (a : int) => ...")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"public")," /  ",(0,r.kt)("inlineCode",{parentName:"td"},"external")," method"),(0,r.kt)("td",{parentName:"tr",align:null},"A separate entrypoint in the parameter: ",(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("inlineCode",{parentName:"td"},"type parameter = F of int")),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("inlineCode",{parentName:"td"},'type parameter = ["F", int]')),". ",(0,r.kt)("inlineCode",{parentName:"td"},"main")," entrypoint should dispatch and forward this call to the corresponding function using a match expression")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"internal")," method"),(0,r.kt)("td",{parentName:"tr",align:null},"There is no concept of inheritance in Tezos")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Constructor"),(0,r.kt)("td",{parentName:"tr",align:null},"Set the initial storage upon origination")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Method that returns a value"),(0,r.kt)("td",{parentName:"tr",align:null},"Inspect the contract storage directly")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"contract.doX(...)")),(0,r.kt)("td",{parentName:"tr",align:null},"Emit an internal operation")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint x = contract.getX()")),(0,r.kt)("td",{parentName:"tr",align:null},"Do not do this. Think if you can merge the contracts or reverse the execution flow")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Proxy upgrade pattern"),(0,r.kt)("td",{parentName:"tr",align:null},"Put lambdas to storage and provide means to update them")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"emit Event(...)")),(0,r.kt)("td",{parentName:"tr",align:null},"Event logs are not supported at the moment. There is a ",(0,r.kt)("a",{parentName:"td",href:"https://octez.tezos.com/docs/protocols/014_kathmandu.html#contract-event-logging"},"proposal")," to support event logs in the future")))))}m.isMDXComponent=!0}}]);