"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[51393],{3905:(t,e,n)=>{n.d(e,{Zo:()=>m,kt:()=>g});var a=n(67294);function i(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function s(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function o(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?s(Object(n),!0).forEach((function(e){i(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function r(t,e){if(null==t)return{};var n,a,i=function(t,e){if(null==t)return{};var n,a,i={},s=Object.keys(t);for(a=0;a<s.length;a++)n=s[a],e.indexOf(n)>=0||(i[n]=t[n]);return i}(t,e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(t);for(a=0;a<s.length;a++)n=s[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(i[n]=t[n])}return i}var l=a.createContext({}),u=function(t){var e=a.useContext(l),n=e;return t&&(n="function"==typeof t?t(e):o(o({},e),t)),n},m=function(t){var e=u(t.components);return a.createElement(l.Provider,{value:e},t.children)},p={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},c=a.forwardRef((function(t,e){var n=t.components,i=t.mdxType,s=t.originalType,l=t.parentName,m=r(t,["components","mdxType","originalType","parentName"]),c=u(n),g=i,d=c["".concat(l,".").concat(g)]||c[g]||p[g]||s;return n?a.createElement(d,o(o({ref:e},m),{},{components:n})):a.createElement(d,o({ref:e},m))}));function g(t,e){var n=arguments,i=e&&e.mdxType;if("string"==typeof t||i){var s=n.length,o=new Array(s);o[0]=c;var r={};for(var l in e)hasOwnProperty.call(e,l)&&(r[l]=e[l]);r.originalType=t,r.mdxType="string"==typeof t?t:i,o[1]=r;for(var u=2;u<s;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},48720:(t,e,n)=>{n.d(e,{D:()=>i.Z,Z:()=>s});var a=n(67294),i=n(75402);const s=function(t){return a.createElement(i.Z.Consumer,null,(e=>{let{syntax:n}=e;return n===t.syntax?t.children:a.createElement(a.Fragment,null)}))}},66893:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>u,contentTitle:()=>r,default:()=>c,frontMatter:()=>o,metadata:()=>l,toc:()=>m});var a=n(87462),i=(n(67294),n(3905)),s=n(48720);n(39960);const o={id:"mutation-testing",title:"Mutation testing"},r=void 0,l={unversionedId:"advanced/mutation-testing",id:"version-1.5.0/advanced/mutation-testing",title:"Mutation testing",description:"We assume that the reader is familiar with LIGO's testing framework. A",source:"@site/versioned_docs/version-1.5.0/advanced/mutation-testing.md",sourceDirName:"advanced",slug:"/advanced/mutation-testing",permalink:"/previews/ligo/external-link-icon/docs/1.5.0/advanced/mutation-testing",draft:!1,tags:[],version:"1.5.0",frontMatter:{id:"mutation-testing",title:"Mutation testing"},sidebar:"docs",previous:{title:"Testing LIGO",permalink:"/previews/ligo/external-link-icon/docs/1.5.0/advanced/testing"},next:{title:"Testing Michelson code",permalink:"/previews/ligo/external-link-icon/docs/1.5.0/advanced/michelson_testing"}},u={},m=[{value:"A simple testing example",id:"a-simple-testing-example",level:2},{value:"Mutating a contract",id:"mutating-a-contract",level:2},{value:"Multiple mutations",id:"multiple-mutations",level:2},{value:"Preventing mutation",id:"preventing-mutation",level:2}],p={toc:m};function c(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,a.Z)({},p,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"We assume that the reader is familiar with LIGO's testing framework. A\nreference can be found ",(0,i.kt)("a",{parentName:"p",href:"/previews/ligo/external-link-icon/docs/1.5.0/advanced/testing"},"here"),"."),(0,i.kt)("h2",{id:"a-simple-testing-example"},"A simple testing example"),(0,i.kt)("p",null,"To demonstrate how to use the mutation primitives in the testing\nframework, we will have a look at a basic function that we would like\nto test. Suppose we want to construct a function that takes an integer\nargument and doubles it, tentatively the following one:"),(0,i.kt)(s.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"test-ligo group=twice","test-ligo":!0,group:"twice"},"let twice (x : int) = x + x\n"))),(0,i.kt)(s.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"test-ligo group=twice","test-ligo":!0,group:"twice"},"const twice = (x: int) => x + x;\n"))),(0,i.kt)("p",null,"Assume that we want to make sure that this function works as expected,\nbecause it will be used as part of a major development. We could write\nthe following tests:"),(0,i.kt)(s.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"test-ligo group=twice","test-ligo":!0,group:"twice"},"let simple_tests (f : int -> int) =\n  (* Test 1 *)\n  let () = assert (Test.michelson_equal (Test.run f 0) (Test.eval 0)) in\n  (* Test 2 *)\n  let () = assert (Test.michelson_equal (Test.run f 2) (Test.eval 4))\n  in ()\n\nlet test = simple_tests twice\n"))),(0,i.kt)(s.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"test-ligo group=twice","test-ligo":!0,group:"twice"},"const simple_tests = (f : ((input: int) => int)) : unit => {\n  /* Test 1 */\n  assert (Test.michelson_equal(Test.run(f, 0), Test.eval(0)));\n  /* Test 2 */\n  assert (Test.michelson_equal(Test.run(f, 2), Test.eval(4)));\n};\n\nconst test = simple_tests(twice);\n"))),(0,i.kt)("p",null,"These tests check that ",(0,i.kt)("inlineCode",{parentName:"p"},"twice"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"when run on input ",(0,i.kt)("inlineCode",{parentName:"li"},"0"),", it returns ",(0,i.kt)("inlineCode",{parentName:"li"},"0"),"."),(0,i.kt)("li",{parentName:"ul"},"when run on input ",(0,i.kt)("inlineCode",{parentName:"li"},"2"),", it returns ",(0,i.kt)("inlineCode",{parentName:"li"},"4"),".")),(0,i.kt)("p",null,"The function implemented (",(0,i.kt)("inlineCode",{parentName:"p"},"twice"),") above passes the tests:"),(0,i.kt)(s.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell",metastring:"run",run:!0},"ligo run test gitlab-pages/docs/advanced/src/mutation-testing/twice.mligo\n# Outputs:\n# Everything at the top-level was executed.\n# - test exited with value ().\n"))),(0,i.kt)(s.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell",metastring:"run",run:!0},"ligo run test gitlab-pages/docs/advanced/src/mutation-testing/twice.jsligo\n# Outputs:\n# Everything at the top-level was executed.\n# - test exited with value ().\n"))),(0,i.kt)("p",null,"The implementation is, in fact, correct. However, it is easy to\nmake a mistake and write the following implementation instead:"),(0,i.kt)(s.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"test-ligo group=frontpage","test-ligo":!0,group:"frontpage"},"let twice (x : int) = x * x\n"))),(0,i.kt)(s.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"test-ligo group=frontpage","test-ligo":!0,group:"frontpage"},"const twice = (x: int): int => x * x;\n"))),(0,i.kt)("p",null,"And, in fact, when we run ",(0,i.kt)("inlineCode",{parentName:"p"},"simple_tests")," on this faulty\nimplementation, we will see that it also passes the tests."),(0,i.kt)("p",null,"This is because ",(0,i.kt)("inlineCode",{parentName:"p"},"0 * 0 = 0 + 0 = 0")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"2 * 2 = 2 + 2 = 4"),". What\nlessons can we draw from this?"),(0,i.kt)("p",null,"The function was tested, but nothing guaranteed that\nthe tests are complete enough."),(0,i.kt)("p",null,"Mutation testing tries to help in this area by modifying functions\nwhile keeping the same tests fixed, and alerting if some of the\nmodified functions pass all of the tests: in that situation, the tests\nwere not good enough to separate a good implementation from the\n(possibly) incorrect ones."),(0,i.kt)("p",null,"We can see now how to do mutation testing in LIGO for the original\nimplementation for ",(0,i.kt)("inlineCode",{parentName:"p"},"twice")," (",(0,i.kt)("inlineCode",{parentName:"p"},"x + x"),"). The primitive from the testing\nframework that we will use is"),(0,i.kt)(s.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},"val Test.mutation_test : 'a -> ('a -> 'b) -> ('b * mutation) option\n"))),(0,i.kt)(s.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},"val Test.mutation_test : (value: 'a, tester: ('a -> 'b)) => option <['b, mutation]>\n"))),(0,i.kt)("p",null,"which takes a value to mutate and and a function to apply to altered\nversions of that value (testing function). As soon as the function\ncorrectly terminates (i.e. does not fail) in some value mutation,\n",(0,i.kt)("inlineCode",{parentName:"p"},"Test.mutation_test")," will stop and return the result of the function\napplication, together with a ",(0,i.kt)("inlineCode",{parentName:"p"},"mutation")," describing the change in the\nvalue. If all of the mutations tested fail, then ",(0,i.kt)("inlineCode",{parentName:"p"},"Test.mutation_test"),"\nwill return ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),"."),(0,i.kt)("p",null,"Typically, the values to mutate are functions (i.e. ",(0,i.kt)("inlineCode",{parentName:"p"},"'a")," will be\na function type), and these functions' return type (i.e. ",(0,i.kt)("inlineCode",{parentName:"p"},"'b"),") will be\n",(0,i.kt)("inlineCode",{parentName:"p"},"unit"),"."),(0,i.kt)("p",null,"For the example above, the function that will be applied is ",(0,i.kt)("inlineCode",{parentName:"p"},"simple_tests"),",\nand the value to mutate is ",(0,i.kt)("inlineCode",{parentName:"p"},"twice"),":"),(0,i.kt)(s.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"test-ligo group=twice","test-ligo":!0,group:"twice"},'let test_mutation =\n  match Test.mutation_test twice simple_tests with\n    None -> ()\n  | Some (_, mutation) ->\n      let () = Test.log mutation in\n      Test.println "Some mutation also passes the tests! ^^"\n'))),(0,i.kt)(s.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"test-ligo group=twice","test-ligo":!0,group:"twice"},'const test_mutation =\n  match(Test.mutation_test(twice, simple_tests)) {\n    when(None()): unit;\n    when(Some(pmutation)): do {\n      Test.log(pmutation[1]);\n      Test.println("Some mutation also passes the tests! ^^")\n    }\n  };\n'))),(0,i.kt)("p",null,"Running the tests again, the following output is obtained:"),(0,i.kt)(s.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell",metastring:"run",run:!0},'ligo run test gitlab-pages/docs/advanced/src/mutation-testing/twice.mligo\n# Outputs:\n# Mutation at: File "gitlab-pages/docs/advanced/src/mutation-testing/twice.mligo", line 1, characters 22-27:\n#   1 | let twice (x : int) = x + x\n#   2 |\n#\n# Replacing by: MUL(x ,\n# x).\n# File "gitlab-pages/docs/advanced/src/mutation-testing/twice.mligo", line 17, character 26 to line 18, character 76:\n#  16 |     None -> ()\n#  17 |   | Some (_, mutation) -> let () = Test.log(mutation) in\n#  18 |                           failwith "Some mutation also passes the tests! ^^"\n#\n# Test failed with "Some mutation also passes the tests! ^^"\n'))),(0,i.kt)(s.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell",metastring:"run",run:!0},'ligo run test gitlab-pages/docs/advanced/src/mutation-testing/twice.jsligo\n# Outputs:\n# Mutation at: File "gitlab-pages/docs/advanced/src/mutation-testing/twice.jsligo", line 1, characters 31-36:\n#   1 | let twice = (x : int) : int => x + x;\n#   2 |\n#\n# Replacing by: MUL(x ,\n# x).\n# File "gitlab-pages/docs/advanced/src/mutation-testing/twice.jsligo", line 18, characters 25-77:\n#  17 |     Some: pmutation => { Test.log(pmutation[1]);\n#  18 |                          failwith ("Some mutation also passes the tests! ^^") }\n#  19 |   });\n#\n# Test failed with "Some mutation also passes the tests! ^^"\n'))),(0,i.kt)("p",null,"The primitive ",(0,i.kt)("inlineCode",{parentName:"p"},"Test.mutation_test")," tries out various mutations on\n",(0,i.kt)("inlineCode",{parentName:"p"},"twice"),", and sees if they pass all of the tests. In this scenario, it\nwas discovered that the mutation ",(0,i.kt)("inlineCode",{parentName:"p"},"MUL(x,x)")," also passes the tests:\nthis is the precise case we discussed earlier, when the incorrect\nimplementation ",(0,i.kt)("inlineCode",{parentName:"p"},"x * x")," would not be detected by the tests. We need to\nupdate the test suite. In this case, we could propose to add a new\ntest:"),(0,i.kt)(s.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},"let simple_tests (f : int -> int) =\n  (* Test 1 *)\n  let () = assert (Test.michelson_equal (Test.run f 0) (Test.eval 0)) in\n  (* Test 2 *)\n  let () = assert (Test.michelson_equal (Test.run f 2) (Test.eval 4)) in\n  (* Test 3 *)\n  let () = assert (Test.michelson_equal (Test.run f 1) (Test.eval 2))\n  in ()\n"))),(0,i.kt)(s.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},"const simple_tests = (f : ((input: int) => int)) : unit => {\n  /* Test 1 */\n  assert (Test.michelson_equal(Test.run(f, 0), Test.eval(0)));\n  /* Test 2 */\n  assert (Test.michelson_equal(Test.run(f, 2), Test.eval(4)));\n  /* Test 3 */\n  assert (Test.michelson_equal(Test.run(f, 1), Test.eval(2)));\n};\n"))),(0,i.kt)("p",null,"this verifies that when input ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," is given, output ",(0,i.kt)("inlineCode",{parentName:"p"},"2")," is returned.\nRunning the mutation testing again after this adjustment, no mutation\n(among those tried) will pass the tests, giving extra confidence in\nthe tests proposed:"),(0,i.kt)(s.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell",metastring:"run",run:!0},"ligo run test gitlab-pages/docs/advanced/src/mutation-testing/twice.mligo\n# Outputs:\n# Everything at the top-level was executed.\n# - test exited with value ().\n# - test_mutation exited with value ().\n"))),(0,i.kt)(s.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell",metastring:"run",run:!0},"ligo run test gitlab-pages/docs/advanced/src/mutation-testing/twice.jsligo\n# Outputs:\n# Everything at the top-level was executed.\n# - test exited with value ().\n# - test_mutation exited with value ().\n"))),(0,i.kt)("h2",{id:"mutating-a-contract"},"Mutating a contract"),(0,i.kt)("p",null,"The following is an example on how to mutate a contract. For that, we\nwill use a variation of the canonical LIGO contract with only two\nentrypoints ",(0,i.kt)("inlineCode",{parentName:"p"},"Add")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Sub"),":"),(0,i.kt)(s.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"test-ligo group=mutation-contract","test-ligo":!0,group:"mutation-contract"},"// This is mutation-contract.mligo\nmodule C = struct\n  type storage = int\n\n  // Two entrypoints\n  [@entry] let add (delta : int) (store : storage) : operation list * storage = [],store + delta\n  [@entry] let sub (delta : int) (store : storage) : operation list * storage = [],store - delta\nend\n"))),(0,i.kt)(s.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"test-ligo group=mutation-contract","test-ligo":!0,group:"mutation-contract"},"// This is mutation-contract.jsligo\nexport namespace C {\n  export type storage = int;\n\n  // Two entrypoints\n  @entry const add = (delta: int, store: storage): [list<operation>, storage] => [list([]),store + delta];\n  @entry const sub = (delta: int, store: storage): [list<operation>, storage] => [list([]),store - delta];\n}\n"))),(0,i.kt)("p",null,"Doing mutation testing on a contract with multiple entrypoints can\nhelp in finding out entrypoints that are not covered by the tests."),(0,i.kt)("p",null,"Consider the following test, which deploys a contract passed as\nan argument, and then tests that\nthe entrypoint ",(0,i.kt)("inlineCode",{parentName:"p"},"Add(7)")," works as intended on an initial storage\n",(0,i.kt)("inlineCode",{parentName:"p"},"5"),":"),(0,i.kt)(s.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"test-ligo group=mutation-contract-test","test-ligo":!0,group:"mutation-contract-test"},'(* This is mutation-contract-test.mligo *)\n\n#import "gitlab-pages/docs/advanced/src/mutation-testing/mutation-contract.mligo" "MutationContract"\n\ntype storage = MutationContract.C.storage\ntype param = MutationContract.C parameter_of\nlet initial_storage = 7\n\nlet tester (taddr : (param, storage) typed_address) (_: (param ,storage) michelson_contract) (_:int) : unit =\n  let _ = Test.transfer_exn taddr (Add 7) 1mutez in\n  assert (Test.get_storage taddr = initial_storage + 7)\n\nlet test_original =\n  let orig = Test.originate (contract_of MutationContract.C) initial_storage 0tez in\n  tester orig.addr\n'))),(0,i.kt)(s.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"test-ligo group=mutation-contract-test","test-ligo":!0,group:"mutation-contract-test"},'// This is mutation-contract-test.jsligo\n\n#import "gitlab-pages/docs/advanced/src/mutation-testing/mutation-contract.jsligo" "MutationContract"\ntype storage = int;\ntype param = parameter_of MutationContract.C;\nconst initial_storage = 7;\n\nconst tester = (taddr : typed_address<param, storage>, _c : michelson_contract<param, storage> , _ : int) : unit => {\n  let _xfer = Test.transfer_exn(taddr, Add(7), 1mutez);\n  assert(Test.get_storage(taddr) == initial_storage + 7);\n}\n\nconst test_original = (() => {\n  let orig = Test.originate(contract_of(MutationContract.C), initial_storage, 0tez);\n  return tester(orig.addr);\n})();\n'))),(0,i.kt)("p",null,"For performing mutation testing as before, we write the following test:"),(0,i.kt)(s.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"test-ligo group=mutation-contract-test","test-ligo":!0,group:"mutation-contract-test"},'let test_mutation =\n  match Test.originate_module_and_mutate (contract_of MutationContract.C) initial_storage 0tez tester with\n    None -> ()\n  | Some (_, mutation) ->\n    let () = Test.log(mutation) in\n    (* In a real program, one would write `failwith "A mutation passes"`\n       Since we want to demonstrate the issue without an actual error\n       a milder println is used in this document. *)\n    Test.println "A mutation of the contract still passes the tests!"\n'))),(0,i.kt)(s.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"test-ligo group=mutation-contract-test","test-ligo":!0,group:"mutation-contract-test"},'const test_mutation =\n  match(Test.originate_module_and_mutate(contract_of(MutationContract.C), initial_storage, 0tez, tester)) {\n    when(None()): unit;\n    when(Some(pmutation)): do {\n      let _l = Test.log(pmutation[1]);\n      // In a real program, one would write `failwith "A mutation passes"`\n      // Since we want to demonstrate the issue without an actual error\n      // a milder println is used in this document.\n      let _p = Test.println("A mutation of the contract still passes the tests!");\n    }\n  };\n'))),(0,i.kt)("p",null,"Running this test, the following output is obtained:"),(0,i.kt)(s.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell",metastring:"run",run:!0},'ligo run test --library . gitlab-pages/docs/advanced/src/mutation-testing/mutation-contract-test.mligo\n# Outputs:\n# File "gitlab-pages/docs/advanced/src/mutation-testing/mutation-contract-test.mligo", line 25, characters 4-65:\n#  24 |     let () = Test.log(mutation) in\n#  25 |     failwith "A mutation of the contract still passes the tests!"\n#  26 | \n# \n# An uncaught error occured:\n# Failwith: "A mutation of the contract still passes the tests!"\n# Trace:\n# File "gitlab-pages/docs/advanced/src/mutation-testing/mutation-contract-test.mligo", line 25, characters 4-65\n# Mutation at: File "gitlab-pages/docs/advanced/src/mutation-testing/mutation-contract.mligo", line 8, characters 64-77:\n#   7 | [@entry] let add (delta : int) (store : storage) : result = [], store + delta\n#   8 | [@entry] let sub (delta : int) (store : storage) : result = [], store - delta\n# \n# Replacing by: store + delta.\n'))),(0,i.kt)(s.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell",metastring:"run",run:!0},'ligo run test --library . gitlab-pages/docs/advanced/src/mutation-testing/mutation-contract-test.jsligo\n# Outputs:\n# File "gitlab-pages/docs/advanced/src/mutation-testing/mutation-contract-test.jsligo", line 27, characters 6-68:\n#  26 |       Test.log(pmutation[1]);\n#  27 |       failwith("A mutation of the contract still passes the tests!");\n#  28 |     }\n# \n# An uncaught error occured:\n# Failwith: "A mutation of the contract still passes the tests!"\n# Trace:\n# File "gitlab-pages/docs/advanced/src/mutation-testing/mutation-contract-test.jsligo", line 27, characters 6-68\n# Mutation at: File "gitlab-pages/docs/advanced/src/mutation-testing/mutation-contract.jsligo", line 8, characters 73-86:\n#   7 | @entry const add = (delta : int, store : storage) : result => [list([]), store + delta];\n#   8 | @entry const sub = (delta : int, store : storage) : result => [list([]), store - delta];\n# \n# Replacing by: store + delta.\n'))),(0,i.kt)("p",null,"The mutation testing found that the operation ",(0,i.kt)("inlineCode",{parentName:"p"},"sub")," (corresponding to\nthe entrypoint ",(0,i.kt)("inlineCode",{parentName:"p"},"Sub"),") can be changed with no consequences in the\ntest: we take this as a warning signalling that the test above does not\ncover the ",(0,i.kt)("inlineCode",{parentName:"p"},"Sub")," entrypoint. We can fix this by adding a new call\nto the ",(0,i.kt)("inlineCode",{parentName:"p"},"Sub")," entrypoint in the test above:"),(0,i.kt)(s.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"test-ligo group=mutation-contract-test","test-ligo":!0,group:"mutation-contract-test"},"let tester_add_and_sub (taddr : (param, storage) typed_address) (_ : (param, storage) michelson_contract) (_ : int) : unit =\n  let _ = Test.transfer_exn taddr (Add 7) 1mutez in\n  let () = assert (Test.get_storage taddr = initial_storage + 7) in\n  let _ = Test.transfer_exn taddr (Sub 3) 1mutez in\n  assert (Test.get_storage taddr = initial_storage + 4)\n"))),(0,i.kt)(s.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"test-ligo group=mutation-contract-test","test-ligo":!0,group:"mutation-contract-test"},"const tester_add_and_sub = (taddr : typed_address<param, storage>, _c : michelson_contract<param, storage>, _i : int) : unit => {\n  let _xfer1 = Test.transfer_exn(taddr, Add(7), 1mutez);\n  assert(Test.get_storage(taddr) == initial_storage + 7);\n  let _xfer2 = Test.transfer_exn(taddr, Sub(3), 1mutez);\n  assert(Test.get_storage(taddr) == initial_storage + 4);\n}\n"))),(0,i.kt)("p",null,"Running the updated test, we see that this time no mutation on ",(0,i.kt)("inlineCode",{parentName:"p"},"sub"),"\nwill give the same result."),(0,i.kt)("h2",{id:"multiple-mutations"},"Multiple mutations"),(0,i.kt)("p",null,"There is an alternative version of ",(0,i.kt)("inlineCode",{parentName:"p"},"Test.mutation_test")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Test.originate_module_and_mutate")," that will\ncollect all mutants that make the passed function correctly terminate.\nIts type is similar to that of ",(0,i.kt)("inlineCode",{parentName:"p"},"Test.mutation_test"),", but instead of\nreturning an optional type, it returns a list:"),(0,i.kt)(s.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},"Test.mutation_test_all : 'a -> ('a -> 'b) -> ('b * mutation) list\nTest.originate_and_mutate_all : (('param, 'storage) module_contract) -> 'storage -> tez -> (('param, 'storage) typed_address -> ('param, 'storage) michelson_contract -> int -> b) -> ('b * mutation) list\n"))),(0,i.kt)(s.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},"Test.mutation_test_all : (value: 'a, tester: ('a -> 'b)) => list <['b, mutation]>;\nTest.originate_and_mutate_all : (contract: module_contract<'p, 's>, init: 's, balance: tez, (tester: (originated_address: typed_address<'p, 's>, code: michelson_contract<'p, 's>, size: int) => 'b)) => list<['b, mutation]>\n"))),(0,i.kt)("p",null,"The example above can be modified to collect first all mutants, and\nthen process the list:"),(0,i.kt)(s.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"test-ligo group=mutation-contract-test","test-ligo":!0,group:"mutation-contract-test"},'let test_mutation_all =\n  match Test.originate_and_mutate_all (contract_of MutationContract.C) initial_storage 0tez tester_add_and_sub with\n    [] -> ()\n  | ms -> let () = List.iter (fun ((_, mutation) : unit * mutation) ->\n                              let path = Test.save_mutation "." mutation in\n                              let () = Test.log "saved at:" in\n                              Test.log path) ms in\n          Test.println "Some mutations also pass the tests!"\n'))),(0,i.kt)(s.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"test-ligo group=mutation-contract-test","test-ligo":!0,group:"mutation-contract-test"},'const test_mutation_all =\n  match(Test.originate_and_mutate_all(contract_of(MutationContract.C), initial_storage, 0tez, tester_add_and_sub)) {\n    when([]): unit;\n    when([hd,...tl]): do {\n      let ms = list([hd,...tl]);\n      let _p = Test.println("Some mutations also pass the tests!");\n      for (const m of ms) {\n        let [_, mutation] = m;\n        let path = Test.save_mutation(".", mutation);\n        let _l = Test.log("saved at:");\n        let _p = Test.log(path);\n      };\n    }\n  };\n'))),(0,i.kt)("p",null,"In this case, the list of mutants is processed by saving each mutant\nto a file with the help of:"),(0,i.kt)(s.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},"Test.save_mutation : string -> mutation -> string option\n"))),(0,i.kt)(s.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},"Test.save_mutation : (path: string, mutation: mutation) => option <string>\n"))),(0,i.kt)("p",null,"where the first argument represents the path where the mutation is to\nbe saved, and the second argument is the mutation. This function\nreturns an optional string, representing either: the name of the file\nwhere the mutation was saved or a failure."),(0,i.kt)("h2",{id:"preventing-mutation"},"Preventing mutation"),(0,i.kt)(s.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"In some cases, it might be a good idea to prevent mutation in certain\nplaces. A good example of this can be an assertion that is checking\nsome invariant. To prevent such mutations, the attribute\n",(0,i.kt)("inlineCode",{parentName:"p"},"@no_mutation")," can be used:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"test-ligo group=no_mutation","test-ligo":!0,group:"no_mutation"},"(* This is mutation-contract.mligo *)\ntype storage = int\n\ntype result = operation list * storage\n\n(* Two entrypoints *)\n[@entry]\nlet add (delta : int) (store : storage) : result =\n  [@no_mutation] let _ = assert (0 = 0) in\n  [], store + delta\n\n[@entry] [@no_mutation]\nlet sub (delta : int) (store : storage) : result =\n  [], store - delta\n"))),(0,i.kt)(s.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"In some cases, it might be a good idea to prevent mutation in certain\nplaces. A good example of this can be an assertion that is checking\nsome invariant. To prevent such mutations, the decorator\n",(0,i.kt)("inlineCode",{parentName:"p"},"@no_mutation")," can be used:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"test-ligo group=no_mutation","test-ligo":!0,group:"no_mutation"},"// This is mutation-contract.mligo\ntype storage = int;\n\ntype result = [list<operation>, storage];\n\n// Two entrypoints\n@entry\nconst add = (delta : int, store : storage) : result => {\n  @no_mutation let _a = assert (0 == 0);\n  return [list([]), store + delta];\n};\n\n@entry @no_mutation\nconst sub = (delta : int, store : storage) : result => {\n  return [list([]), store - delta];\n};\n"))),(0,i.kt)("p",null,"In the example, two mutations are prevented. The first one,\nThe second one, it is on\nthe function ",(0,i.kt)("inlineCode",{parentName:"p"},"sub"),", which prevents the mutations presented in the\nexample from the previous sections. is an assertion\nof a silly invariant, ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," equals ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),", that should not be mutated to\nthings like: ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," less than ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," equal ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),", etc."))}c.isMDXComponent=!0}}]);