"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[43973],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>g});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=c(n),g=r,u=m["".concat(l,".").concat(g)]||m[g]||d[g]||i;return n?a.createElement(u,o(o({ref:t},p),{},{components:n})):a.createElement(u,o({ref:t},p))}));function g(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var c=2;c<i;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},48720:(e,t,n)=>{n.d(t,{D:()=>r.Z,Z:()=>i});var a=n(67294),r=n(75402);const i=function(e){return a.createElement(r.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},95586:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>m,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=n(87462),r=(n(67294),n(3905)),i=n(48720);n(39960);const o={id:"testing",title:"Testing LIGO"},s=void 0,l={unversionedId:"advanced/testing",id:"version-1.6.0/advanced/testing",title:"Testing LIGO",description:"Testing LIGO code",source:"@site/versioned_docs/version-1.6.0/advanced/testing.md",sourceDirName:"advanced",slug:"/advanced/testing",permalink:"/previews/ligo/external-link-icon/docs/1.6.0/advanced/testing",draft:!1,tags:[],version:"1.6.0",frontMatter:{id:"testing",title:"Testing LIGO"},sidebar:"docs",previous:{title:"Events",permalink:"/previews/ligo/external-link-icon/docs/1.6.0/contract/events"},next:{title:"Mutation testing",permalink:"/previews/ligo/external-link-icon/docs/1.6.0/advanced/mutation-testing"}},c={},p=[{value:"Testing LIGO code",id:"testing-ligo-code",level:2},{value:"Testing with <code>ligo run test</code>",id:"testing-with-ligo-run-test",level:3},{value:"Transfers and originations with tickets",id:"transfers-and-originations-with-tickets",level:3},{value:"The problem with tickets",id:"the-problem-with-tickets",level:4},{value:"Proxy ticket contracts",id:"proxy-ticket-contracts",level:4},{value:"Usages",id:"usages",level:4},{value:"Transfer",id:"transfer",level:5},{value:"Origination",id:"origination",level:5},{value:"Unit testing a function",id:"unit-testing-a-function",level:3},{value:"Testing with <code>ligo run interpret</code>",id:"testing-with-ligo-run-interpret",level:3},{value:"Event testing",id:"event-testing",level:3},{value:"Testing a contract declared as a module or namespace",id:"testing-a-contract-declared-as-a-module-or-namespace",level:3}],d={toc:p};function m(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"testing-ligo-code"},"Testing LIGO code"),(0,r.kt)("p",null,"The LIGO command-line interpreter provides commands to\ndirectly test your LIGO code. The three main commands we currently\nsupport are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"ligo run test"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"ligo run interpret"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"ligo run dry-run")))),(0,r.kt)("p",null,"We will show how to use the first two, while an example on how to use\nthe third one was already explained\n",(0,r.kt)("a",{parentName:"p",href:"/previews/ligo/external-link-icon/docs/1.6.0/advanced/first-contract#dry-running-a-contract"},"here"),"."),(0,r.kt)("h3",{id:"testing-with-ligo-run-test"},"Testing with ",(0,r.kt)("inlineCode",{parentName:"h3"},"ligo run test")),(0,r.kt)("p",null,"The command ",(0,r.kt)("inlineCode",{parentName:"p"},"ligo run test")," can be used to test a contract using LIGO."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"\u26a0\ufe0f Please keep in mind that this command is still BETA, and that\nthere are features that are work in progress and are subject to\nchange. No real test procedure should rely on this command alone.")),(0,r.kt)("p",null,"When running the ",(0,r.kt)("inlineCode",{parentName:"p"},"ligo run test")," command, LIGO code has access to an\nadditional ",(0,r.kt)("inlineCode",{parentName:"p"},"Test")," module. This module provides ways of originating\ncontracts and executing transactions, as well as additional helper\nfunctions that allow to control different parameters of the Tezos\ntesting library."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note: The LIGO interpreter uses the ",(0,r.kt)("a",{parentName:"p",href:"https://gitlab.com/tezos/tezos/-/tree/master/src/proto_alpha/lib_protocol/test/helpers"},"same library that Tezos internally uses for testing"),".")),(0,r.kt)("p",null,"The function ",(0,r.kt)("inlineCode",{parentName:"p"},"Test.originate")," allows to deploy a contract in the\ntesting environment. It takes a contract, which is represented as a\nfunction of type ",(0,r.kt)("inlineCode",{parentName:"p"},"'parameter -> 'storage -> operation list * 'storage"),",\nan initial storage of type ",(0,r.kt)("inlineCode",{parentName:"p"},"'storage"),", and an initial balance for the\ncontract being deployed. This function deploys the contract, and\nreturns a record value holding: ",(0,r.kt)("inlineCode",{parentName:"p"},"('parameter, 'storage) typed_address"),", the compiled\nprogram in Michelson of type ",(0,r.kt)("inlineCode",{parentName:"p"},"('parameter, 'storage) michelson_contract"),",\nand the size of the program of type ",(0,r.kt)("inlineCode",{parentName:"p"},"int"),"."),(0,r.kt)("p",null,"The storage of a deployed contract can be queried using the\n",(0,r.kt)("inlineCode",{parentName:"p"},"Test.get_storage")," function, that given a typed address ",(0,r.kt)("inlineCode",{parentName:"p"},"('parameter,\n'storage) typed_address"),", returns the ",(0,r.kt)("inlineCode",{parentName:"p"},"'storage")," value."),(0,r.kt)("p",null,"As a concrete example, suppose we have the following contract:"),(0,r.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"test-ligo group=mycontract","test-ligo":!0,group:"mycontract"},"// This is mycontract.mligo\nmodule C = struct\n  type storage = int\n  type result = operation list * storage\n\n  // Two entrypoints\n  [@entry] let increment (delta : int) (store : storage) : result = [],store + delta\n  [@entry] let decrement (delta : int) (store : storage) : result = [],store - delta\n  [@entry] let reset () (_ : storage) : result = [],0\nend\n"))),(0,r.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"test-ligo group=mycontract","test-ligo":!0,group:"mycontract"},"// This is mycontract.jsligo\nnamespace C {\n  export type storage = int;\n  export type result = [list<operation>, storage];\n\n  @entry const increment = (delta : int, store : storage) : result => [[], store + delta];\n  @entry const decrement = (delta : int, store : storage) : result => [[], store - delta];\n  @entry const reset = (_u : unit, _store : storage) : result => [[], 0];\n}\n"))),(0,r.kt)("p",null,"We can deploy it and query the storage right after, to check that the\nstorage is in fact the one which we started with:"),(0,r.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"test-ligo group=mycontract-test","test-ligo":!0,group:"mycontract-test"},'(* This is mycontract-test.mligo *)\n\n#import "gitlab-pages/docs/advanced/src/testing/mycontract.mligo" "MyContract"\ntype param = MyContract.C parameter_of\n\nlet test1 =\n  let initial_storage = 42 in\n  let {addr ; code = _ ; size = _} = Test.originate (contract_of MyContract.C) initial_storage 0tez in\n  assert (Test.get_storage addr = initial_storage)\n'))),(0,r.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"test-ligo group=mycontract-test","test-ligo":!0,group:"mycontract-test"},'// This is mycontract-test.jligo\n\n#import "gitlab-pages/docs/advanced/src/testing/mycontract.mligo" "MyContract"\ntype param = parameter_of MyContract.C\n\nconst run_test1 = () : unit => {\n  let initial_storage = 42 as int;\n  let {addr , code , size} = Test.originate(contract_of(MyContract.C), initial_storage, 0tez);\n  assert (Test.get_storage(addr) == initial_storage);\n};\n\nconst test1 = run_test1();\n'))),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"ligo run test")," sub-command will evaluate all top-level definitions and print any\nentries that begin with the prefix ",(0,r.kt)("inlineCode",{parentName:"p"},"test")," as well as the value that these\ndefinitions evaluate to. If any of the definitions are found to have\nfailed, a message will be issued with the line number where the problem\noccurred."),(0,r.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"ligo run test --library . gitlab-pages/docs/advanced/src/testing/mycontract-test.mligo\n# Outputs:\n# Everything at the top-level was executed.\n# - test1 exited with value ().\n"))),(0,r.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"ligo run test --library . gitlab-pages/docs/advanced/src/testing/mycontract-test.jsligo\n# Outputs:\n# Everything at the top-level was executed.\n# - test1 exited with value ().\n"))),(0,r.kt)("p",null,"The function ",(0,r.kt)("inlineCode",{parentName:"p"},"Test.transfer")," allows to bake a transaction.\nIt takes a target account of type ",(0,r.kt)("inlineCode",{parentName:"p"},"('parameter, 'storage) typed_address"),", the parameter\nof type ",(0,r.kt)("inlineCode",{parentName:"p"},"'parameter")," and an amount of type ",(0,r.kt)("inlineCode",{parentName:"p"},"tez"),". This function\nperforms the transaction, and returns a ",(0,r.kt)("inlineCode",{parentName:"p"},"test_exec_result")," which\ncan be matched on to know whether the transaction was successful or not.\nIn case of success you will get access to the gas consumed by the execution\nof the contract and in case of failure you will get access to a ",(0,r.kt)("inlineCode",{parentName:"p"},"test_exec_error"),"\ndescribing the error.\nThere is an alternative version, called ",(0,r.kt)("inlineCode",{parentName:"p"},"Test.transfer_exn"),"\nwhich performs the transaction and will only return the gas consumption,\nfailing in case that there was an error."),(0,r.kt)("p",null,"We can extend the previous example by executing a transaction that\nincrements the storage after deployment, we also print the gas consumption:"),(0,r.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"test-ligo group=mycontract-test","test-ligo":!0,group:"mycontract-test"},'(* This continues mycontract-test.mligo *)\n\nlet test2 =\n  let initial_storage = 42 in\n  let orig = Test.originate (contract_of MyContract.C) initial_storage 0tez in\n  let gas_cons = Test.transfer_exn orig.addr (Increment (1)) 1mutez in\n  let () = Test.log ("gas consumption",gas_cons) in\n  assert (Test.get_storage orig.addr = initial_storage + 1)\n'))),(0,r.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("p",null,"The syntax ",(0,r.kt)("inlineCode",{parentName:"p"},"do { ... }")," is equivalent to ",(0,r.kt)("inlineCode",{parentName:"p"},"( () => { ... } )()"),", i.e.\nit is a block expression which can contain statements and local declarations."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"test-ligo group=mycontract-test","test-ligo":!0,group:"mycontract-test"},'// This continues mycontract-test.jsligo\n\nconst test2 = do {\n  let initial_storage = 42 as int;\n  let orig = Test.originate(contract_of (MyContract.C), initial_storage, 0tez);\n  let gas_cons = Test.transfer_exn(orig.addr, (Increment (1)), 1mutez);\n  Test.log(["gas consumption", gas_cons]);\n  return (Test.get_storage(orig.addr) == initial_storage + 1);\n}\n'))),(0,r.kt)("p",null,"The environment assumes a source for the operations which can be set\nusing the function ",(0,r.kt)("inlineCode",{parentName:"p"},"Test.set_source : address -> unit"),"."),(0,r.kt)("h3",{id:"transfers-and-originations-with-tickets"},"Transfers and originations with tickets"),(0,r.kt)("p",null,"Originating contract storing tickets or transfering to contract accepting tickets requires some extra steps. We will first explain the problems with tickets\nand then show you how to handle it."),(0,r.kt)("h4",{id:"the-problem-with-tickets"},"The problem with tickets"),(0,r.kt)("p",null,"There is two kind of operations in the protocol : external and internal.\n",(0,r.kt)("inlineCode",{parentName:"p"},"internal operations")," are those created by smart contracts and ",(0,r.kt)("inlineCode",{parentName:"p"},"external operations")," are those created from outside the chain\n(e.g. using ",(0,r.kt)("inlineCode",{parentName:"p"},"Test.originate")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"tezos-client")," for instance) ",(0,r.kt)("a",{parentName:"p",href:"https://octez.tezos.com/docs/active/michelson.html#semantics-of-smart-contracts-and-transactions"},"more information here")),(0,r.kt)("p",null,"In the protocol, both external and internal ",(0,r.kt)("inlineCode",{parentName:"p"},"transfer"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"origination")," operations contains a piece of michelson code representing the ",(0,r.kt)("inlineCode",{parentName:"p"},"parameter"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"initial storage"),".\nNow imagine you have a value of type ",(0,r.kt)("inlineCode",{parentName:"p"},"parameter_ty"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"storage_ty")," containing a ticket, that you want to transfer or originate,\nin the operation data, tickets will be represented in Michelson as pairs:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"> ligo compile expression cameligo 'Tezos.create_ticket 0x0202 10n'\n(Pair \"KT1DUMMYDUMMYDUMMYDUMMYDUMMYDUMu2oHG\" 0x0202 10)\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"ticketer address , ticket value , ticket amount")),(0,r.kt)("p",null,'If we try to apply such an operation, the type wouldn\'t match: ticket of bytes VS some pair.\nThe protocol would not let you do that since you could be creating a ticket out of nowhere unless the operation happens to be forged from within a contract (i.e. "internally")!'),(0,r.kt)("p",null,'In the testing framework - for now - it means using "proxy-contracts" forging the operations using provided a ticket value and a ticket amount.'),(0,r.kt)("h4",{id:"proxy-ticket-contracts"},"Proxy ticket contracts"),(0,r.kt)("p",null,"The LIGO standard library provides a ",(0,r.kt)("inlineCode",{parentName:"p"},"Proxy_ticket")," module which helps in working with tickets in the Testing framework. Here is the interface of ",(0,r.kt)("inlineCode",{parentName:"p"},"Proxy_ticket"),":"),(0,r.kt)("hr",null),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"init_transfer")," accepts:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a function ",(0,r.kt)("inlineCode",{parentName:"li"},"mk_param")," which given a ticket must return a value of your parameter type")),(0,r.kt)("p",null,'and returns the typed address of a "transfer proxy-contract" which can then be used to do multiple transfers of tickets with the same ticketer address'),(0,r.kt)("hr",null),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"transfer")," accepts :"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},'the typed address of a "transfer proxy-contract"'),(0,r.kt)("li",{parentName:"ul"},"the ticket information (value and amount) together with the destination address")),(0,r.kt)("p",null,"and returns a value of type ",(0,r.kt)("inlineCode",{parentName:"p"},"test_exec_result")),(0,r.kt)("hr",null),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"originate")," accepts:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"the ticket information (value and amount)"),(0,r.kt)("li",{parentName:"ul"},"a function ",(0,r.kt)("inlineCode",{parentName:"li"},"mk_storage")," which given a ticket must return a value of your storage type"),(0,r.kt)("li",{parentName:"ul"},"your contract (having a ticket in its storage type)")),(0,r.kt)("hr",null),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note: Functions ",(0,r.kt)("inlineCode",{parentName:"p"},"mk_param")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"mk_storage")," will be executed in the proxy contract itself")),(0,r.kt)("p",null,"Find more detailed information on the API of ",(0,r.kt)("a",{parentName:"p",href:"/previews/ligo/external-link-icon/docs/1.6.0/reference/test.proxy-ticket-reference"},(0,r.kt)("inlineCode",{parentName:"a"},"Proxy_ticket")," here")),(0,r.kt)("h4",{id:"usages"},"Usages"),(0,r.kt)("h5",{id:"transfer"},"Transfer"),(0,r.kt)("p",null,"Here is an example using ",(0,r.kt)("inlineCode",{parentName:"p"},"Proxy_ticket.init_transfer")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Proxy_ticket.transfer"),":"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"import the module above as ",(0,r.kt)("inlineCode",{parentName:"li"},"Proxy_ticket")),(0,r.kt)("li",{parentName:"ol"},"define a contract ",(0,r.kt)("inlineCode",{parentName:"li"},"C")," holding a ticket of string in its parameter type. The contract will just store the value of\nthe received ticket and the address of the sender"),(0,r.kt)("li",{parentName:"ol"},"originate contract ",(0,r.kt)("inlineCode",{parentName:"li"},"C")),(0,r.kt)("li",{parentName:"ol"},'initialize a "transfer proxy-contract" providing a function to build a parameter out of a ticket'),(0,r.kt)("li",{parentName:"ol"},"transfer a ticket with a value ",(0,r.kt)("inlineCode",{parentName:"li"},'"hello"')," and an amount of ",(0,r.kt)("inlineCode",{parentName:"li"},"10")," to contract ",(0,r.kt)("inlineCode",{parentName:"li"},"C")),(0,r.kt)("li",{parentName:"ol"},"print the storage of contract ",(0,r.kt)("inlineCode",{parentName:"li"},"C")),(0,r.kt)("li",{parentName:"ol"},"transfer a ticket with a value ",(0,r.kt)("inlineCode",{parentName:"li"},'"world"')," and an amount of ",(0,r.kt)("inlineCode",{parentName:"li"},"5")," to contract ",(0,r.kt)("inlineCode",{parentName:"li"},"C")),(0,r.kt)("li",{parentName:"ol"},"print the storage of contract ",(0,r.kt)("inlineCode",{parentName:"li"},"C"))),(0,r.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"test-ligo group=usage_transfer","test-ligo":!0,group:"usage_transfer"},'module C = struct\n  type param = int * string ticket\n  type storage = string * address\n\n  [@entry]\n  let main (p : param) (_ : storage) : operation list * storage =\n    let (_,ticket) = p in\n    let (_,(v,_)) , _ = Tezos.read_ticket ticket in\n    [] , (v, Tezos.get_sender ())\nend\nlet test_transfer_to_contract =\n  let {addr = main_taddr; code = _ ; size = _} = Test.originate (contract_of C) ("bye",Test.nth_bootstrap_account 1) 1mutez in\n  let main_addr = Test.to_address main_taddr in\n\n  (* Use this address everytime you want to send tickets from the same proxy-contract *)\n  let proxy_taddr =\n    (* mk_param is executed __by the proxy contract__ *)\n    let mk_param : string ticket -> C.param = fun (t : string ticket) -> 42,t in\n    (* initialize a proxy contract in charge of creating and sending your tickets *)\n    Test.Proxy_ticket.init_transfer mk_param\n  in\n  let () = Test.log ("poxy addr:", proxy_taddr) in\n\n  let _ =\n    (* ticket_info lets you control the amount and the value of the tickets you send *)\n    let ticket_info = ("hello", 10n) in\n    (* we send ticket to C through the proxy-contract *)\n    Test.Proxy_ticket.transfer proxy_taddr (ticket_info,main_addr)\n  in\n  let () = Test.log (Test.get_storage main_taddr) in\n  let _ =\n    let ticket_info = ("world",5n) in\n    Test.Proxy_ticket.transfer proxy_taddr (ticket_info,main_addr)\n  in\n  let () = Test.log (Test.get_storage main_taddr) in\n  ()\n'))),(0,r.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"test-ligo group=usage_transfer","test-ligo":!0,group:"usage_transfer"},'namespace C {\n  export type param = [ int , ticket<string>]\n\n  @entry\n  function main (p: param, _s: [string , address]) : [list<operation> , [string , address]] {\n    let [_v,ticket] = p ;\n    let [[_addr,[v,_t]] , _ticket] = Tezos.read_ticket (ticket) ;\n    return ([[] , [v, Tezos.get_sender ()]])\n  };\n}\n\nconst test_transfer_to_contract = do {\n  let {addr : main_taddr, code , size } = Test.originate (contract_of(C), ["bye",Test.nth_bootstrap_account (1)], 1mutez) ;\n  let main_addr = Test.to_address (main_taddr) ;\n\n  /* mk_param is executed __by the proxy contract__ */\n  const mk_param = (t:ticket<string>) : C.param => { return [42,t] } ;\n  /* Use this address everytime you want to send tickets from the same proxy-contract */\n  /* initialize a proxy contract in charge of creating and sending your tickets */\n  let proxy_taddr = Test.Proxy_ticket.init_transfer (mk_param) ;\n  Test.log (["poxy addr:", proxy_taddr]) ;\n\n  /* ticket_info lets you control the amount and the value of the tickets you send */\n  let ticket_info1 = ["hello", 10n];\n  /* we send ticket to main through the proxy-contract */\n  Test.Proxy_ticket.transfer (proxy_taddr, [ticket_info1,main_addr]) ;\n  Test.log (Test.get_storage (main_taddr)) ;\n\n  let ticket_info2 = ["world",5n] ;\n  Test.Proxy_ticket.transfer (proxy_taddr, [ticket_info2,main_addr]) ;\n  Test.log (Test.get_storage (main_taddr));\n};\n'))),(0,r.kt)("p",null,"result:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'> ligo run test transfer_ticket.mligo\n("poxy addr:" , KT1QGANLjYsyJmw1QNww9Jkgb4ccQr6W2gsC)\n("hello" , KT1QGANLjYsyJmw1QNww9Jkgb4ccQr6W2gsC)\n("world" , KT1QGANLjYsyJmw1QNww9Jkgb4ccQr6W2gsC)\nEverything at the top-level was executed.\n- test_transfer_to_contract exited with value ().\n')),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note: note that the sender (stored in the contract) matches the address of the proxy contract")),(0,r.kt)("h5",{id:"origination"},"Origination"),(0,r.kt)("p",null,"Here is an example using ",(0,r.kt)("inlineCode",{parentName:"p"},"Proxy_ticket.originate")," and the type ",(0,r.kt)("inlineCode",{parentName:"p"},"unforged_ticket")," :"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"import the module above as ",(0,r.kt)("inlineCode",{parentName:"li"},"Proxy_ticket")),(0,r.kt)("li",{parentName:"ol"},"define a contract ",(0,r.kt)("inlineCode",{parentName:"li"},"main")," potentially holding a ticket of bytes in its storage. The contract will just reads the ticket\nin its storage if present. Note that we define two version of the contract storage type: one for the contract\nand one for the storage type that we would like to manipulate in our testing logic"),(0,r.kt)("li",{parentName:"ol"},"we define the ",(0,r.kt)("inlineCode",{parentName:"li"},"mk_storage")," function which simply wraps a ticket into an option type"),(0,r.kt)("li",{parentName:"ol"},"we define the ticket information for a ticket of value ",(0,r.kt)("inlineCode",{parentName:"li"},"0x0202")," and an amount of ",(0,r.kt)("inlineCode",{parentName:"li"},"15")),(0,r.kt)("li",{parentName:"ol"},"we call ",(0,r.kt)("inlineCode",{parentName:"li"},"originate")," and retrieve the address of the newly originated contract"),(0,r.kt)("li",{parentName:"ol"},"we use the address to fetch the current contract storage using ",(0,r.kt)("inlineCode",{parentName:"li"},"Test.get_storage_of_address")," and decompile it\nas a ",(0,r.kt)("inlineCode",{parentName:"li"},"human_storage")),(0,r.kt)("li",{parentName:"ol"},"we read the content of the ticket and perform a series of assertions")),(0,r.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"test-ligo group=usage_orig","test-ligo":!0,group:"usage_orig"},'(* originate.mligo *)\n\ntype storage = (bytes ticket) option\ntype unforged_storage = (bytes unforged_ticket) option\n\nlet main (() : unit) (s : storage) : operation list * storage =\n  [] , (\n    match s with\n    | Some ticket ->\n      let (_ , t) = Tezos.read_ticket ticket in\n      Some t\n    | None -> None\n  )\n\nlet test_originate_contract =\n  let mk_storage = fun (t:bytes ticket) -> Some t in\n  let ticket_info = (0x0202, 15n) in\n  let addr = Test.Proxy_ticket.originate ticket_info mk_storage main in\n  let unforged_storage : unforged_storage = Test.Proxy_ticket.get_storage addr in\n\n  (* the ticket \'unforged_storage\' can be manipulated freely without caring about ticket linearity *)\n\n  match unforged_storage with\n  | Some { ticketer ; value ; amount } ->\n    let () = Test.log ("unforged_ticket", unforged_storage) in\n    let () = assert (value = ticket_info.0) in\n    let () = assert (amount = ticket_info.1) in\n    ()\n  | None -> failwith "impossible"\n'))),(0,r.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"test-ligo group=usage_orig","test-ligo":!0,group:"usage_orig"},'type storage = option< ticket<bytes> >\ntype unforged_storage = option< unforged_ticket<bytes> >\n\nconst main = (_p: unit, s: storage) : [ list<operation> , storage] => {\n  let x =\n    match (s) {\n      when(Some(ticket)): ((ticket: ticket<bytes>) => {\n        let [_v , t] = Tezos.read_ticket (ticket) ;\n        return Some (t)\n      })(ticket);\n      when(None()): None()\n    };\n  return [list ([]), x]\n};\n\nconst test_originate_contract = do {\n  const mk_storage = (t:ticket<bytes>) : storage => { return (Some (t)) } ;\n  let ticket_info = [0x0202, 15n];\n  let addr = Test.Proxy_ticket.originate (ticket_info, mk_storage, main) ;\n  let unforged_storage = (Test.Proxy_ticket.get_storage (addr) as unforged_storage) ;\n\n  /* the ticket \'unforged_storage\' can be manipulated freely without caring about ticket linearity */\n\n  match (unforged_storage) {\n    when(Some(x)): do {\n      Test.log (["unforged_ticket", x]) ;\n      let { ticketer , value , amount } = x ;\n      assert (value == ticket_info[0]) ;\n      assert (amount == ticket_info[1]) ;\n      return unit\n    };\n    when(None()): failwith ("impossible")\n  }\n};\n'))),(0,r.kt)("p",null,"result:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'("unforged_ticket" , {amount = 15n ; ticketer = KT1Qp8u3v4seQHPYfpSw6eWvPG8CojH3m18G ; value = 0x0202})\nEverything at the top-level was executed.\n- test_originate_contract exited with value ().\n')),(0,r.kt)("h3",{id:"unit-testing-a-function"},"Unit testing a function"),(0,r.kt)("p",null,"Consider a map binding addresses to amounts and a function removing all entries in that map having an amount less to a given threshold."),(0,r.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=remove-balance",group:"remove-balance"},"(* This is remove-balance.mligo *)\n\ntype balances = (address, tez) map\n\nlet remove_balances_under (b:balances) (threshold:tez) : balances =\n  Map.fold\n    (fun ((acc, (k, v)) : balances * (address * tez)) ->\n       if v < threshold then Map.remove k acc else acc)\n    b b\n"))),(0,r.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=remove-balance",group:"remove-balance"},"// This is remove-balance.jsligo\n\ntype balances = map <address, tez>\n\nconst remove_balances_under = (b : balances, threshold:tez) : balances => {\n  let f = ([acc, kv] : [balances, [address , tez]] ) : balances => {\n    let [k,v] = kv ;\n    if (v < threshold) { return Map.remove (k,acc) } else {return acc}\n  };\n  return Map.fold (f,b,b);\n}\n"))),(0,r.kt)("p",null,"Let us imagine that we want to test this function against a range of thresholds with the LIGO test framework."),(0,r.kt)("p",null,"First, let's include the file under test and reset the state with 5 bootstrap accounts (we are going to use\nthe bootstrap addresses later)"),(0,r.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"test-ligo group=unit-remove-balance-mixed","test-ligo":!0,group:"unit-remove-balance-mixed"},'#include "./gitlab-pages/docs/advanced/src/testing/remove-balance.mligo"\nlet _u = Test.reset_state 5n ([] : tez list)\n'))),(0,r.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"test-ligo group=unit-remove-balance-mixed","test-ligo":!0,group:"unit-remove-balance-mixed"},'#include "./gitlab-pages/docs/advanced/src/testing/remove-balance.jsligo"\nlet _u = Test.reset_state (5n, [] as list <tez>);\n'))),(0,r.kt)("p",null,"Now build the ",(0,r.kt)("inlineCode",{parentName:"p"},"balances")," map that will serve as the input of our test."),(0,r.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"test-ligo group=unit-remove-balance-mixed","test-ligo":!0,group:"unit-remove-balance-mixed"},"let balances : balances =\n  let a1, a2, a3 = Test.nth_bootstrap_account 1, Test.nth_bootstrap_account 2, Test.nth_bootstrap_account 3\n  in Map.literal [(a1, 10tz); (a2, 100tz); (a3, 1000tz)]\n"))),(0,r.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"test-ligo group=unit-remove-balance-mixed","test-ligo":!0,group:"unit-remove-balance-mixed"},"let balances : balances =\n  Map.literal([[Test.nth_bootstrap_account(1), 10tez],\n              [Test.nth_bootstrap_account(2), 100tez],\n              [Test.nth_bootstrap_account(3), 1000tez]]);\n"))),(0,r.kt)("p",null,"Our simple test loop will call ",(0,r.kt)("inlineCode",{parentName:"p"},"remove_balances_under")," with the compiled map\ndefined above, get the size of the resulting map and compare it to an\nexpected value with ",(0,r.kt)("inlineCode",{parentName:"p"},"Test.michelson_equal"),"."),(0,r.kt)("p",null,"The call to ",(0,r.kt)("inlineCode",{parentName:"p"},"balance_under")," and the computation of the size of the resulting map is achieved through the primitive ",(0,r.kt)("inlineCode",{parentName:"p"},"Test.run"),".\nThis primitive runs a function on an input, translating both (function and input)\nto Michelson before running on the Michelson interpreter.\nMore concretely ",(0,r.kt)("inlineCode",{parentName:"p"},"Test.run f v")," performs the following:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Compiles the function argument ",(0,r.kt)("inlineCode",{parentName:"li"},"f")," to Michelson ",(0,r.kt)("inlineCode",{parentName:"li"},"f_mich")),(0,r.kt)("li",{parentName:"ol"},"Compiles the value argument ",(0,r.kt)("inlineCode",{parentName:"li"},"v")," (which was already evaluated) to Michelson ",(0,r.kt)("inlineCode",{parentName:"li"},"v_mich")),(0,r.kt)("li",{parentName:"ol"},"Runs the Michelson interpreter on the code ",(0,r.kt)("inlineCode",{parentName:"li"},"f_mich")," with the initial stack ",(0,r.kt)("inlineCode",{parentName:"li"},"[ v_mich ]"))),(0,r.kt)("p",null,"The function that is being compiled is called ",(0,r.kt)("inlineCode",{parentName:"p"},"tester"),"."),(0,r.kt)("p",null,"We also print the actual and expected sizes for good measure."),(0,r.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"test-ligo group=unit-remove-balance-mixed","test-ligo":!0,group:"unit-remove-balance-mixed"},'let test =\n  List.iter\n    (fun ((threshold , expected_size) : tez * nat) ->\n      let tester (balances, threshold : balances * tez) = Map.size (remove_balances_under balances threshold) in\n      let size = Test.run tester (balances, threshold) in\n      let expected_size = Test.eval expected_size in\n      let () = Test.log ("expected", expected_size) in\n      let () = Test.log ("actual",size) in\n      assert (Test.michelson_equal size expected_size)\n    )\n    [(15tez,2n);(130tez,1n);(1200tez,0n)]\n'))),(0,r.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"test-ligo group=unit-remove-balance-mixed","test-ligo":!0,group:"unit-remove-balance-mixed"},'let test =\n  List.iter\n    ( ([threshold , expected_size] : [tez , nat]) : unit => {\n      let tester = ([balances, threshold] : [balances, tez]) : nat => Map.size (remove_balances_under (balances, threshold));\n      let size = Test.run(tester, [balances, threshold]);\n      let expected_size_ = Test.eval(expected_size) ;\n      let unit_ = Test.log (["expected", expected_size]) ;\n      let unit__ = Test.log (["actual",size]) ;\n      return (assert (Test.michelson_equal (size,expected_size_)))\n    },\n    list ([ [15tez, 2n] , [130tez, 1n] , [1200tez, 0n]]) );\n'))),(0,r.kt)("p",null,"You can now execute the test:"),(0,r.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},'ligo run test --library . gitlab-pages/docs/advanced/src/testing/unit-remove-balance-mixed.mligo\n# Outputs:\n# ("expected" , 2)\n# ("actual" , 2)\n# ("expected" , 1)\n# ("actual" , 1)\n# ("expected" , 0)\n# ("actual" , 0)\n# Everything at the top-level was executed.\n# - test exited with value ().\n'))),(0,r.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},'ligo run test --library . gitlab-pages/docs/advanced/src/testing/unit-remove-balance-mixed.jsligo\n# Outputs:\n# ("expected" , 2)\n# ("actual" , 2)\n# ("expected" , 1)\n# ("actual" , 1)\n# ("expected" , 0)\n# ("actual" , 0)\n# Everything at the top-level was executed.\n# - test exited with value ().\n'))),(0,r.kt)("h3",{id:"testing-with-ligo-run-interpret"},"Testing with ",(0,r.kt)("inlineCode",{parentName:"h3"},"ligo run interpret")),(0,r.kt)("p",null,"The command ",(0,r.kt)("inlineCode",{parentName:"p"},"ligo run interpret")," allows to interpret an expression in a\ncontext initialised by a source file. The interpretation is done using\nMichelson's interpreter."),(0,r.kt)("p",null,"We can see how it works on an example. Suppose we want to test the following\ncontract."),(0,r.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=testme",group:"testme"},"(* This is testme.mligo *)\n\ntype storage = int\ntype result = operation list * storage\n\n[@entry]\nlet increment (delta : int) (store : storage) : result = [], store + delta\n\n[@entry]\nlet decrement (delta : int) (store : storage) : result = [], store - delta\n\n[@entry]\nlet reset (_ : unit) (_ : storage) : result = [], 0\n"))),(0,r.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=testme",group:"testme"},"// This is testme.jsligo\ntype storage = int;\ntype result = [list<operation>, storage];\n\n@entry const increment = (delta: int, store: storage): result => [[], store + delta];\n@entry const decrement = (delta: int, store: storage): result => [[], store - delta];\n@entry const reset = (_u: unit, _store: storage): result => [[], 0];\n"))),(0,r.kt)("p",null,"This contract keeps an integer as storage, and has three entry-points:\none for incrementing the storage, one for decrementing the storage,\nand one for resetting the storage to ",(0,r.kt)("inlineCode",{parentName:"p"},"0"),"."),(0,r.kt)("p",null,"As a simple property, we check whether starting with a storage of\n",(0,r.kt)("inlineCode",{parentName:"p"},"10"),", if we execute the entry-point for incrementing ",(0,r.kt)("inlineCode",{parentName:"p"},"32"),", then we get\na resulting storage of ",(0,r.kt)("inlineCode",{parentName:"p"},"42"),". For checking it, we can interpret the\n",(0,r.kt)("inlineCode",{parentName:"p"},"main")," function:"),(0,r.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},'ligo run interpret "increment 32 10" --init-file gitlab-pages/docs/advanced/src/testing/testme.mligo\n# Outputs:\n# ( LIST_EMPTY() , 42 )\n'))),(0,r.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},'ligo run interpret "increment (32, 10)" --init-file gitlab-pages/docs/advanced/src/testing/testme.jsligo\n# Outputs:\n# ( LIST_EMPTY() , 42 )\n'))),(0,r.kt)("p",null,"With the argument ",(0,r.kt)("inlineCode",{parentName:"p"},"--init-file")," we pass the contract we want to test,\nand the sub-command requires also the expression to evaluate in that\ncontext, in this case, a call to our contract (",(0,r.kt)("inlineCode",{parentName:"p"},"main"),") with parameter\n",(0,r.kt)("inlineCode",{parentName:"p"},"Increment (32)")," and storage ",(0,r.kt)("inlineCode",{parentName:"p"},"10"),". As a result, we can check that the\nresulting storage is ",(0,r.kt)("inlineCode",{parentName:"p"},"42")," (the second component of the pair), and\nthere are no further operations to execute (the first component)."),(0,r.kt)("p",null,"We can tune certain parameters of the execution by passing them as\narguments:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"--amount=AMOUNT (absent=0)\n    AMOUNT is the amount the Michelson interpreter will use for the\n    transaction.\n--balance=BALANCE (absent=0)\n    BALANCE is the balance the Michelson interpreter will use for the\n    contract balance.\n--now=NOW\n    NOW is the NOW value the Michelson interpreter will use\n    (e.g. '2000-01-01T10:10:10Z')\n--sender=SENDER\n    SENDER is the sender the Michelson interpreter transaction will use.\n--source=SOURCE\n    SOURCE is the source the Michelson interpreter transaction will use.\n")),(0,r.kt)("h3",{id:"event-testing"},"Event testing"),(0,r.kt)("p",null,"Here is how you emit events and fetch them from your tests:"),(0,r.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"test-ligo group=test_ex","test-ligo":!0,group:"test_ex"},'module C = struct\n  [@entry] let main (p : int*int) () =\n    [Tezos.emit "%foo" p ; Tezos.emit "%foo" p.0],()\nend\n\nlet test_foo =\n  let orig = Test.originate (contract_of C) () 0tez in\n  let _ = Test.transfer_exn orig.addr (Main (1,2)) 0tez in\n  (Test.get_last_events_from orig.addr "foo" : (int*int) list),(Test.get_last_events_from orig.addr "foo" : int list)\n'))),(0,r.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"test-ligo group=test_ex","test-ligo":!0,group:"test_ex"},'namespace C {\n  @entry\n  let main = (p: [int, int], _: unit) => {\n    let op1 = Tezos.emit("%foo", p);\n    let op2 = Tezos.emit("%foo", p[0]);\n    return [([op1, op2] as list<operation>), unit];\n  };\n}\nlet test = do {\n  let orig = Test.originate(contract_of(C), unit, 0tez);\n  Test.transfer_exn(orig.addr, Main ([1,2]), 0tez);\n  return [Test.get_last_events_from(orig.addr, "foo") as list<[int, int]>, Test.get_last_events_from(orig.addr, "foo") as list<int>];\n};\n'))),(0,r.kt)("h3",{id:"testing-a-contract-declared-as-a-module-or-namespace"},"Testing a contract declared as a module or namespace"),(0,r.kt)("p",null,"When declaring the entry points of a contract using ",(0,r.kt)("inlineCode",{parentName:"p"},"@entry"),", LIGO generates two hidden values in the module:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"an implicit ",(0,r.kt)("inlineCode",{parentName:"li"},"main")," function, which can be obtained using the keyword ",(0,r.kt)("inlineCode",{parentName:"li"},"contract_of(C)")," where ",(0,r.kt)("inlineCode",{parentName:"li"},"C")," is the namespace or module containing the entry points, and"),(0,r.kt)("li",{parentName:"ul"},"the input type for that ",(0,r.kt)("inlineCode",{parentName:"li"},"main")," function, which can be obtained using the keyword ",(0,r.kt)("inlineCode",{parentName:"li"},"parameter_of C"),".")),(0,r.kt)("p",null,"In the example below, ",(0,r.kt)("inlineCode",{parentName:"p"},"contract_of(C)")," is returns the implicitly-declared ",(0,r.kt)("inlineCode",{parentName:"p"},"main")," function that calls the ",(0,r.kt)("inlineCode",{parentName:"p"},"increment")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"decrement")," entry points depending on the argument given, and ",(0,r.kt)("inlineCode",{parentName:"p"},"parameter_of C")," is the ",(0,r.kt)("a",{parentName:"p",href:"https://ligolang.org/docs/language-basics/unit-option-pattern-matching#variant-types"},"variant")," ",(0,r.kt)("inlineCode",{parentName:"p"},'["Increment", int] | ["Decrement", int]'),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=tezos_specific",group:"tezos_specific"},"namespace C {\n  type storage = int;\n\n  @entry\n  const increment = (action: int, store: storage) : [list <operation>, storage] => [[], store + action];\n\n  @entry\n  const decrement = (action: int, store: storage) : [list <operation>, storage] => [[], store - action];\n};\n\nconst testC = do {\n    let initial_storage = 42;\n    let orig = Test.originate(contract_of(C), initial_storage, 0tez);\n    let p : parameter_of C = Increment(1);\n    Test.transfer_exn(orig.addr, p, 1mutez);\n    return assert(Test.get_storage(orig.addr) == initial_storage + 1);\n};\n")),(0,r.kt)("p",null,"The special constructions ",(0,r.kt)("inlineCode",{parentName:"p"},"contract_of(C)")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"parameter_of C")," are not first-class functions, they are special syntax which take a module or namespace name as a parameter. This means for example that ",(0,r.kt)("inlineCode",{parentName:"p"},"some_function(contract_of)")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"contract_of(some_variable)")," are invalid uses of the syntax (a literal module or parameter name must always be passed as part of the syntax)."))}m.isMDXComponent=!0}}]);