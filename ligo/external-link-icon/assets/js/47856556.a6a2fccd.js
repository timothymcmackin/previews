"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[79707],{3905:(t,e,n)=>{n.d(e,{Zo:()=>l,kt:()=>g});var a=n(67294);function r(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function o(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function s(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?o(Object(n),!0).forEach((function(e){r(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function i(t,e){if(null==t)return{};var n,a,r=function(t,e){if(null==t)return{};var n,a,r={},o=Object.keys(t);for(a=0;a<o.length;a++)n=o[a],e.indexOf(n)>=0||(r[n]=t[n]);return r}(t,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);for(a=0;a<o.length;a++)n=o[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(r[n]=t[n])}return r}var c=a.createContext({}),p=function(t){var e=a.useContext(c),n=e;return t&&(n="function"==typeof t?t(e):s(s({},e),t)),n},l=function(t){var e=p(t.components);return a.createElement(c.Provider,{value:e},t.children)},d={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},u=a.forwardRef((function(t,e){var n=t.components,r=t.mdxType,o=t.originalType,c=t.parentName,l=i(t,["components","mdxType","originalType","parentName"]),u=p(n),g=r,m=u["".concat(c,".").concat(g)]||u[g]||d[g]||o;return n?a.createElement(m,s(s({ref:e},l),{},{components:n})):a.createElement(m,s({ref:e},l))}));function g(t,e){var n=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var o=n.length,s=new Array(o);s[0]=u;var i={};for(var c in e)hasOwnProperty.call(e,c)&&(i[c]=e[c]);i.originalType=t,i.mdxType="string"==typeof t?t:r,s[1]=i;for(var p=2;p<o;p++)s[p]=n[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},48720:(t,e,n)=>{n.d(e,{D:()=>r.Z,Z:()=>o});var a=n(67294),r=n(75402);const o=function(t){return a.createElement(r.Z.Consumer,null,(e=>{let{syntax:n}=e;return n===t.syntax?t.children:a.createElement(a.Fragment,null)}))}},7199:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>p,contentTitle:()=>i,default:()=>u,frontMatter:()=>s,metadata:()=>c,toc:()=>l});var a=n(87462),r=(n(67294),n(3905)),o=n(48720);const s={id:"operation",title:"Operations"},i=void 0,c={unversionedId:"syntax/contracts/operation",id:"version-1.9.2/syntax/contracts/operation",title:"Operations",description:"The final stack after a Tezos contract execution is a pair containing a new storage and a list of operations.",source:"@site/versioned_docs/version-1.9.2/syntax/contracts/operation.md",sourceDirName:"syntax/contracts",slug:"/syntax/contracts/operation",permalink:"/previews/ligo/external-link-icon/docs/syntax/contracts/operation",draft:!1,tags:[],version:"1.9.2",frontMatter:{id:"operation",title:"Operations"},sidebar:"docs",previous:{title:"Entrypoints",permalink:"/previews/ligo/external-link-icon/docs/syntax/contracts/entrypoints"},next:{title:"Events",permalink:"/previews/ligo/external-link-icon/docs/syntax/contracts/events"}},p={},l=[{value:"Creating transactions",id:"creating-transactions",level:2},{value:"Sending tez",id:"sending-tez",level:3},{value:"Calling a contract",id:"calling-a-contract",level:3},{value:"Originating contracts",id:"originating-contracts",level:2},{value:"Changing delegation",id:"changing-delegation",level:2},{value:"Emitting events",id:"emitting-events",level:2}],d={toc:l};function u(t){let{components:e,...n}=t;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The final stack after a Tezos contract execution is a pair containing a new storage and a list of operations.\nCommon types of operations that smart contracts create include:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Transfers (calling a smart contract or transferring tez to an account)"),(0,r.kt)("li",{parentName:"ul"},"Deploying (originating) a smart contract"),(0,r.kt)("li",{parentName:"ul"},"Changing the delegation for the current smart contract"),(0,r.kt)("li",{parentName:"ul"},"Emitting an ",(0,r.kt)("a",{parentName:"li",href:"../../syntax/contracts/events"},"event"))),(0,r.kt)("p",null,"For this reason, LIGO entrypoints always return a list of operations and the new state of the contract storage.\nThe list can include any number of operations of any type."),(0,r.kt)("p",null,"As described in ",(0,r.kt)("a",{parentName:"p",href:"https://docs.tezos.com/smart-contracts/logic/operations"},"Operations")," on docs.tezos.com, operations do not run immediately when the operation object is created.\nInstead, operations are added to a stack of operations to run after the code of the entrypoint is complete.\nFor example, if a contract checks its balance with the ",(0,r.kt)("inlineCode",{parentName:"p"},"Tezos.Next.get_balance")," function, creates an operation to transfer tez to another account, and then checks its balance again in the same entrypoint execution, the balance is the same because the transfer operation has not run yet.\nFor more detailed examples, see ",(0,r.kt)("a",{parentName:"p",href:"https://docs.tezos.com/smart-contracts/logic/operations"},"Operations")," on docs.tezos.com."),(0,r.kt)("p",null,"There are no literal values of type operation.\nInstead, such values are created using the following functions from the standard library: ",(0,r.kt)("inlineCode",{parentName:"p"},"Tezos.Next.Operation.transaction")," (transfer), ",(0,r.kt)("inlineCode",{parentName:"p"},"Tezos.Next.Operation.create_contract")," (origination), ",(0,r.kt)("inlineCode",{parentName:"p"},"Tezos.Next.Operation.set_delegate")," (delegation), and ",(0,r.kt)("inlineCode",{parentName:"p"},"Tezos.Next.Operation.Emit")," (emission of event).\nFor the operation to run, these operation values must be included in the list of operations returned at the end of the entrypoint code."),(0,r.kt)("h2",{id:"creating-transactions"},"Creating transactions"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Tezos.Next.Operation.transaction")," function creates a transaction operation, which can be a call to a smart contract (including the same contract) or a transfer of tez to a user account (implicit account).\nIts parameters are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The parameter to pass"),(0,r.kt)("li",{parentName:"ul"},"The amount of tez to send"),(0,r.kt)("li",{parentName:"ul"},"The address to call")),(0,r.kt)("h3",{id:"sending-tez"},"Sending tez"),(0,r.kt)("p",null,"To send tez to a user account, pass ",(0,r.kt)("inlineCode",{parentName:"p"},"unit")," as the parameter and the address of the account as the address to call, as in this example, which sends 5 tez to the account that calls it:"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=send_tez",group:"send_tez"},'type storage = unit\ntype return_value = operation list * storage\n\n[@entry] let give5tez (_ : unit) (storage : storage) : return_value =\n  if Tezos.Next.get_balance () >= 5tez then\n    let receiver_contract = match Tezos.Next.get_contract_opt (Tezos.Next.get_sender ()) with\n      Some contract -> contract\n    | None -> failwith "Couldn\'t find account" in\n    let operation = Tezos.Next.Operation.transaction unit 5tez receiver_contract in\n    [operation], storage\n  else\n    [], storage\n'))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=send_tez",group:"send_tez"},'type storage = unit;\ntype return_value = [list<operation>, storage];\n\n@entry\nconst give5tez = (_: unit, storage: storage): return_value => {\n  let operations: list<operation> = [];\n  if (Tezos.Next.get_balance() >= 5tez) {\n    const receiver_contract = match(Tezos.Next.get_contract_opt(Tezos.Next.get_sender())) {\n      when(Some(contract)): contract;\n      when(None): failwith("Couldn\'t find account");\n    };\n    operations = [Tezos.Next.Operation.transaction(unit, 5tez, receiver_contract)];\n  }\n  return [operations, storage];\n}\n'))),(0,r.kt)("h3",{id:"calling-a-contract"},"Calling a contract"),(0,r.kt)("p",null,"To call another contract, you must get the parameter to pass to the contract, which includes the entrypoint, if the contract uses them.\nThe following example shows two contracts, A and B.\nB stores contract A's address and calls its entrypoints.\nTo get the correct parameter for the transaction, contract B uses the ",(0,r.kt)("inlineCode",{parentName:"p"},"parameter_of")," keyword to create a parameter that represents a call to contract A's entrypoints."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=operation_transaction",group:"operation_transaction"},'module Test = Test.Next\n\ntype \'storage return = operation list * \'storage\n\nmodule A = struct\n    type storage = int\n\n    [@entry]\n    let add (delta : int) (storage : storage) : storage return =\n      [], storage + delta\n\n    [@entry]\n    let sub (delta : int) (storage : storage) : storage return =\n      [], storage - delta\n  end\n\nmodule B = struct\n    type storage = address\n\n    [@entry]\n    let increment (value : int) (stored_address : storage) : storage return =\n      let contract = Tezos.Next.get_contract stored_address in\n      let parameter : A parameter_of = Add value in\n      let operation = Tezos.Next.Operation.transaction parameter 0tez contract in\n    [operation], stored_address\n\n    [@entry]\n    let decrement (value : int) (stored_address : storage) : storage return =\n      let contract = Tezos.Next.get_contract stored_address in\n      let parameter : A parameter_of = Sub value in\n      let operation = Tezos.Next.Operation.transaction parameter 0tez contract in\n    [operation], stored_address\n  end\n\nlet test =\n  // Originate contract A\n  let contract_A = Test.Originate.contract (contract_of A) 0 0tez in\n  let contract_A_address = Test.Typed_address.to_address contract_A.taddr in\n\n  // Originate contract B with the address of contract A in its storage\n  let contract_B = Test.Originate.contract (contract_of B) contract_A_address 0tez in\n\n  // Call contract B\n  let _ = Test.Contract.transfer_exn (Test.Typed_address.get_entrypoint "increment" contract_B.taddr) 10 0tez in\n  let _ = Test.Contract.transfer_exn (Test.Typed_address.get_entrypoint "decrement" contract_B.taddr) 2 0tez in\n\n  let newNumber = Test.Typed_address.get_storage contract_A.taddr in\n  Assert.assert (newNumber = 8)\n'))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=operation_transaction",group:"operation_transaction"},'import Test = Test.Next;\n\ntype @return<storage> = [list<operation>, storage];\n\nnamespace A {\n  type storage = int;\n\n  @entry\n  const add = (delta: int, storage: storage): @return<storage> =>\n    [[], storage + delta];\n\n  @entry\n  const sub = (delta: int, storage: storage): @return<storage> =>\n    [[], storage - delta];\n}\n\nnamespace B {\n  type storage = address;\n\n  @entry\n  const increment = (value: int, stored_address: storage): @return<storage> => {\n    const contract = Tezos.Next.get_contract(stored_address);\n    const parameter = Add(value) as parameter_of A;\n    const operation = Tezos.Next.Operation.transaction(parameter, 0tez, contract);\n    return [[operation], stored_address];\n  }\n\n  @entry\n  const decrement = (value: int, stored_address: storage): @return<storage> => {\n    const contract = Tezos.Next.get_contract(stored_address);\n    const parameter = Sub(value) as parameter_of A;\n    const operation = Tezos.Next.Operation.transaction(parameter, 0tez, contract);\n    return [[operation], stored_address];\n  }\n}\n\nconst test = () => {\n  // Originate contract A\n  const contract_A = Test.Originate.contract(contract_of(A), 0, 0tez);\n  const contract_A_address = Test.Typed_address.to_address(contract_A.taddr);\n\n  // Originate contract B with the address of contract A in its storage\n  const contract_B = Test.Originate.contract(contract_of(B), contract_A_address, 0tez);\n\n  // Call contract B\n  Test.Contract.transfer_exn(Test.Typed_address.get_entrypoint("increment", contract_B.taddr), 10 as int, 0tez);\n  Test.Contract.transfer_exn(Test.Typed_address.get_entrypoint("decrement", contract_B.taddr), 2 as int, 0tez);\n\n  const newNumber = Test.Typed_address.get_storage(contract_A.taddr);\n  Assert.assert(newNumber == 8);\n}\n\nconst result = test();\n'))),(0,r.kt)("p",null,"If you don't have the LIGO code of the contract to use the ",(0,r.kt)("inlineCode",{parentName:"p"},"parameter_of")," keyword, you can often get the information to call the contract from the code of the deployed contract.\nFor example, contract A in the previous example compiles to this Michelson code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-michelson"},"{ parameter (or (int %sub) (int %add)) ;\n  storage int ;\n  code { UNPAIR ; IF_LEFT { SWAP ; SUB } { ADD } ; NIL operation ; PAIR } }\n")),(0,r.kt)("p",null,"Michelson contracts don't have separate code for each entrypoint; instead, they accept a parameter that indicates which code to run.\nIn most cases, the parameter is annotated with the names of the entrypoints from the source code, whether that source code is in LIGO or another high-level Tezos language.\nIn this case, the annotations ",(0,r.kt)("inlineCode",{parentName:"p"},"%sub")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"%add")," indicate the parameters to pass to run the code from the ",(0,r.kt)("inlineCode",{parentName:"p"},"sub")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"add")," entrypoints from the source code."),(0,r.kt)("p",null,"LIGO can use these annotations to parse the parameter and format the call to the contract.\nFor example, this contract uses the ",(0,r.kt)("inlineCode",{parentName:"p"},"Tezos.Next.get_entrypoint")," function to create a contract address that includes the parameter that indicates the entrypoint.\nThen it passes the parameter value for the entrypoint without the entrypoint name as the first parameter of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Tezos.Next.Operation.transaction")," function:"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=operation_transaction",group:"operation_transaction"},'module C = struct\n    type storage = address\n\n    [@entry]\n    let increment (value : int) (stored_address : storage) : storage return =\n      let contract = Tezos.Next.get_entrypoint "%add" stored_address in\n      let operation = Tezos.Next.Operation.transaction value 0tez contract in\n    [operation], stored_address\n\n    [@entry]\n    let decrement (value : int) (stored_address : storage) : storage return =\n      let contract = Tezos.Next.get_entrypoint "%sub" stored_address in\n      let operation = Tezos.Next.Operation.transaction value 0tez contract in\n    [operation], stored_address\n  end\n'))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=operation_transaction",group:"operation_transaction"},'namespace C {\n  type storage = address;\n\n  @entry\n  const increment = (value: int, stored_address: storage): @return<storage> => {\n    const contract = Tezos.Next.get_entrypoint("%add", stored_address);\n    const operation = Tezos.Next.Operation.transaction(value, 0tez, contract);\n    return [[operation], stored_address];\n  }\n\n  @entry\n  const decrement = (value: int, stored_address: storage): @return<storage> => {\n    const contract = Tezos.Next.get_entrypoint("%sub", stored_address);\n    const operation = Tezos.Next.Operation.transaction(value, 0tez, contract);\n    return [[operation], stored_address];\n  }\n}\n'))),(0,r.kt)("p",null,"If you don't have the source code or annotated parameter of the target contract, you must create the parameter as described in ",(0,r.kt)("a",{parentName:"p",href:"../../syntax/contracts/interop"},"Interoperability"),"."),(0,r.kt)("p",null,"For example, the parameter of contract A minus the annotations looks like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-michelson"},"(or (int) (int))\n")),(0,r.kt)("p",null,"This code means that the contract accepts the parameter ",(0,r.kt)("inlineCode",{parentName:"p"},"(Left int)")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"(Right int)"),", which correspond to the ",(0,r.kt)("inlineCode",{parentName:"p"},"sub")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"add")," entrypoints in contract A.\nFor example, to pass 5 to the code for the ",(0,r.kt)("inlineCode",{parentName:"p"},"sub")," entrypoint, the client passes ",(0,r.kt)("inlineCode",{parentName:"p"},"(Left 5)")," to the contract."),(0,r.kt)("p",null,"You can construct this parameter in LIGO code with the ",(0,r.kt)("inlineCode",{parentName:"p"},"michelson_pair")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"michelson_or")," types.\nIn this case, the parameter is a Michelson option type that takes a  ",(0,r.kt)("inlineCode",{parentName:"p"},"M_left")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"M_right")," value.\nFor example, to create the parameter ",(0,r.kt)("inlineCode",{parentName:"p"},"(Left 5)"),", use this code:"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},'type contract_a_param = (int, "sub", int, "add") michelson_or\nlet pass_5_to_sub : contract_a_param = M_left 5\n'))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},'type contract_a_param = michelson_or<[int, "sub", int, "add"]>;\nconst pass_5_to_sub: contract_a_param = M_left(5);\n'))),(0,r.kt)("p",null,"This example contract uses this method to construct the parameter for contract A from the Michelson value and then uses that parameter to call it:"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=operation_transaction",group:"operation_transaction"},'module D = struct\n  type storage = address\n  type contract_a_param = (int, "sub", int, "add") michelson_or\n\n  [@entry]\n  let increment (value : int) (stored_address : storage) : storage return =\n    let pass_to_add : contract_a_param = M_right value in\n    let contract = Tezos.Next.get_contract stored_address in\n    let operation = Tezos.Next.Operation.transaction pass_to_add 0tez contract in\n  [operation], stored_address\n\n  [@entry]\n  let decrement (value : int) (stored_address : storage) : storage return =\n    let pass_to_sub : contract_a_param = M_left value in\n    let contract = Tezos.Next.get_contract stored_address in\n    let operation = Tezos.Next.Operation.transaction pass_to_sub 0tez contract in\n  [operation], stored_address\nend\n'))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=operation_transaction",group:"operation_transaction"},'namespace D {\n  type storage = address;\n  type contract_a_param = michelson_or<[int, "sub", int, "add"]>;\n\n  @entry\n  const increment = (value: int, stored_address: storage): @return<storage> => {\n    const pass_to_add: contract_a_param = M_right(value);\n    const contract = Tezos.Next.get_contract(stored_address);\n    const operation = Tezos.Next.Operation.transaction(pass_to_add, 0tez, contract);\n    return [[operation], stored_address];\n  }\n\n  @entry\n  const decrement = (value: int, stored_address: storage): @return<storage> => {\n    const pass_to_sub: contract_a_param = M_left(value);\n    const contract = Tezos.Next.get_contract(stored_address);\n    const operation = Tezos.Next.Operation.transaction(pass_to_sub, 0tez, contract);\n    return [[operation], stored_address];\n  }\n}\n'))),(0,r.kt)("p",null,"For information about constructing more complicated parameters, see ",(0,r.kt)("a",{parentName:"p",href:"../../syntax/contracts/interop"},"Interoperability"),"."),(0,r.kt)("h2",{id:"originating-contracts"},"Originating contracts"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Tezos.Next.Operation.create_contract")," function creates an operation to originate a contract.\nIts parameters are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The code of the new contract as a function"),(0,r.kt)("li",{parentName:"ul"},"The delegate for the new contract, as an option"),(0,r.kt)("li",{parentName:"ul"},"The amount of tez for the contract's initial balance"),(0,r.kt)("li",{parentName:"ul"},"The initial storage value for the contract")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Tezos.Next.Operation.create_contract")," function returns the operation and the address of the new contract.\nHowever, a contract cannot originate a contract and call it in the same entrypoint execution because the origination operation must run first, and as described previously, operations do not run until the entrypoint execution is complete.\nCalling the ",(0,r.kt)("inlineCode",{parentName:"p"},"Tezos.Next.get_contract_opt")," function on that address returns ",(0,r.kt)("inlineCode",{parentName:"p"},"None")," until the new contract is actually originated."),(0,r.kt)("p",null,"This example originates a simple contract:"),(0,r.kt)(o.Z,{syntex:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=origination",group:"origination"},'type return = operation list * string\n\n[@entry]\nlet main (_ : string) (storage : string) : return =\n  let entrypoint (_ : nat) (storage : string) =\n    (([] : operation list), storage) in\n  let op, _addr : operation * address =\n    Tezos.Next.Operation.create_contract\n      entrypoint\n      (None : key_hash option)\n      300000000mutez\n      "one"\n  in [op], storage\n'))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=origination",group:"origination"},'type @return = [list<operation>, string];\n\n@entry\nconst main = (_: string, storage: string) : @return => {\n  const entrypoint = (_param: nat, storage: string) =>\n    [list([]), storage];\n  const [op, _addr]: [operation, address] =\n    Tezos.Next.Operation.create_contract(entrypoint,\n                          (None() as option<key_hash>),\n                          300000000mutez,\n                          "one");\n  return [[op], storage];\n}\n'))),(0,r.kt)("h2",{id:"changing-delegation"},"Changing delegation"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Tezos.Next.Operation.set_delegate")," function creates an operation that changes the delegate for the current contract.\nIts parameter is an option with the public key hash of the new delegate or ",(0,r.kt)("inlineCode",{parentName:"p"},"None")," to withdraw delegation.\nThe operation (not the function itself) fails if the new key hash is the same as the current delegate or is not registered as a delegate."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=set_delegate",group:"set_delegate"},"[@entry]\nlet changeDelegate (new_delegate : key_hash) (storage : unit) : operation list * unit =\n  [Tezos.Next.Operation.set_delegate (Some new_delegate)], storage\n"))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=set_delegate",group:"set_delegate"},"@entry\nconst changeDelegate = (new_delegate: key_hash, storage: unit): [list<operation>, unit] =>\n  [[Tezos.Next.Operation.set_delegate (Some(new_delegate))], storage];\n"))),(0,r.kt)("h2",{id:"emitting-events"},"Emitting events"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Tezos.Next.Operation.Emit")," function creates an event emission operation.\nIts parameters are the tag for the event and the payload for the event.\nFor more information about events, see ",(0,r.kt)("a",{parentName:"p",href:"../../syntax/contracts/events"},"Events"),"."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=event_emit",group:"event_emit"},'[@entry]\nlet emitEvents (_ : unit) (storage : int) : operation list * int =\n  let event1 : operation = Tezos.Next.Operation.emit "%emitEvents" "hi" in\n  let event2 : operation = Tezos.Next.Operation.emit "%emitEvents" 6 in\n  [event1; event2], storage\n'))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=event_emit",group:"event_emit"},'@entry\nconst emitEvents = (_: unit, storage: int): [list<operation>, int] => {\n  const event1: operation = Tezos.Next.Operation.emit("%emitEvents", "hi");\n  const event2: operation = Tezos.Next.Operation.emit("%emitEvents", 6);\n  return [[event1, event2], storage];\n}\n'))))}u.isMDXComponent=!0}}]);