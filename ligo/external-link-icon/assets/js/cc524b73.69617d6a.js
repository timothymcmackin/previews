"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[11073],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>u});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=p(n),u=o,h=m["".concat(l,".").concat(u)]||m[u]||d[u]||i;return n?a.createElement(h,r(r({ref:t},c),{},{components:n})):a.createElement(h,r({ref:t},c))}));function u(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,r[1]=s;for(var p=2;p<i;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},48720:(e,t,n)=>{n.d(t,{D:()=>o.Z,Z:()=>i});var a=n(67294),o=n(75402);const i=function(e){return a.createElement(o.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},32143:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>s,default:()=>m,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var a=n(87462),o=(n(67294),n(3905)),i=n(48720);const r={title:"Migrating to LIGO v1.0"},s=void 0,l={unversionedId:"intro/upgrade-v1",id:"intro/upgrade-v1",title:"Migrating to LIGO v1.0",description:"Version 1.0 of LIGO includes breaking changes, so you must update your source code when you upgrade your installation of LIGO as described in Installation.",source:"@site/../docs/intro/upgrade-v1.md",sourceDirName:"intro",slug:"/intro/upgrade-v1",permalink:"/previews/ligo/external-link-icon/docs/next/intro/upgrade-v1",draft:!1,tags:[],version:"current",frontMatter:{title:"Migrating to LIGO v1.0"},sidebar:"docs",previous:{title:"Starting from a template",permalink:"/previews/ligo/external-link-icon/docs/next/intro/template"},next:{title:"Migrating to LIGO v2.0",permalink:"/previews/ligo/external-link-icon/docs/next/intro/upgrade-v2"}},p={},c=[{value:"Changes to the <code>main</code> entrypoint",id:"changes-to-the-main-entrypoint",level:2},{value:"Changes to parameters for views and entrypoints",id:"changes-to-parameters-for-views-and-entrypoints",level:2},{value:"Changes to <code>contract_of</code> and <code>parameter_of</code>",id:"changes-to-contract_of-and-parameter_of",level:2},{value:"<code>export</code> and <code>@private</code> now have the expected effect",id:"export-and-private-now-have-the-expected-effect",level:2},{value:"The comb layout is now used by default",id:"the-comb-layout-is-now-used-by-default",level:2},{value:"Decorators in and out of comments",id:"decorators-in-and-out-of-comments",level:2},{value:"Field and tuple component access",id:"field-and-tuple-component-access",level:2},{value:"Changes to CLI commands",id:"changes-to-cli-commands",level:2},{value:"Mutation testing",id:"mutation-testing",level:2},{value:"Kathmandu protocol deprecated",id:"kathmandu-protocol-deprecated",level:2},{value:"Package management: use ligo.json instead of package.json or esy.json",id:"package-management-use-ligojson-instead-of-packagejson-or-esyjson",level:2},{value:"Changes specific to JsLIGO",id:"changes-specific-to-jsligo",level:2},{value:"Short notation for <code>tez</code> and <code>mutez</code>",id:"short-notation-for-tez-and-mutez",level:3},{value:"New bitwise operators",id:"new-bitwise-operators",level:3},{value:"Changes to pattern matching",id:"changes-to-pattern-matching",level:3},{value:"A single underscore is now a valid variable name",id:"a-single-underscore-is-now-a-valid-variable-name",level:3},{value:"Imports are now automatically re-exported",id:"imports-are-now-automatically-re-exported",level:3},{value:"<code>true</code> and <code>false</code> are reserved words",id:"true-and-false-are-reserved-words",level:3},{value:"Changes specific to CameLIGO",id:"changes-specific-to-cameligo",level:2},{value:"Field and tuple component access",id:"field-and-tuple-component-access-1",level:3}],d={toc:c};function m(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Version 1.0 of LIGO includes breaking changes, so you must update your source code when you upgrade your installation of LIGO as described in ",(0,o.kt)("a",{parentName:"p",href:"./installation"},"Installation"),"."),(0,o.kt)("h2",{id:"changes-to-the-main-entrypoint"},"Changes to the ",(0,o.kt)("inlineCode",{parentName:"h2"},"main")," entrypoint"),(0,o.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("p",null,"The LIGO compiler no longer auto-detects a function named ",(0,o.kt)("inlineCode",{parentName:"p"},"main")," as the sole entrypoint of a contract.\nSimilarly, you can no longer specify entrypoints and views by passing functions to the ",(0,o.kt)("inlineCode",{parentName:"p"},"--entrypoint")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"--view")," command-line arguments.\nNow, use multiple entrypoints and views denoted with the ",(0,o.kt)("inlineCode",{parentName:"p"},"[@entry]")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"[@view]")," attributes."),(0,o.kt)("p",null,"In the same way, the ",(0,o.kt)("inlineCode",{parentName:"p"},"Test.originate")," function now takes as an argument a module containing multiple entry points instead of a single function."),(0,o.kt)("p",null,"Contracts can still have a single function named ",(0,o.kt)("inlineCode",{parentName:"p"},"main")," decorated with ",(0,o.kt)("inlineCode",{parentName:"p"},"[@entry]")," that manages all entrypoints for the contract, but this code structure is deprecated.\nFor more information and for workarounds to help you migrate contracts with a single ",(0,o.kt)("inlineCode",{parentName:"p"},"main")," function, see ",(0,o.kt)("a",{parentName:"p",href:"../syntax/contracts/entrypoints"},"Entrypoints")," and ",(0,o.kt)("a",{parentName:"p",href:"../syntax/contracts/entrypoints#the-main-function"},"The main function"),".")),(0,o.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("p",null,"The LIGO compiler no longer auto-detects a function named ",(0,o.kt)("inlineCode",{parentName:"p"},"main")," as the sole entrypoint of a contract.\nSimilarly, you can no longer specify entrypoints and views by passing functions to the ",(0,o.kt)("inlineCode",{parentName:"p"},"--entrypoint")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"--view")," command-line arguments.\nNow, use multiple entrypoints and views denoted with the ",(0,o.kt)("inlineCode",{parentName:"p"},"@entry")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"@view")," decorators."),(0,o.kt)("p",null,"In the same way, the ",(0,o.kt)("inlineCode",{parentName:"p"},"Test.originate")," function now takes as an argument a module containing multiple entry points instead of a single function."),(0,o.kt)("p",null,"Contracts can still have a single function named ",(0,o.kt)("inlineCode",{parentName:"p"},"main")," decorated with ",(0,o.kt)("inlineCode",{parentName:"p"},"@entry")," that manages all entrypoints for the contract, but this code structure is deprecated.\nFor more information and for workarounds to help you migrate contracts with a single ",(0,o.kt)("inlineCode",{parentName:"p"},"main")," function, see ",(0,o.kt)("a",{parentName:"p",href:"../syntax/contracts/entrypoints"},"Entrypoints")," and ",(0,o.kt)("a",{parentName:"p",href:"../syntax/contracts/entrypoints#the-main-function"},"The main function"),".")),(0,o.kt)("h2",{id:"changes-to-parameters-for-views-and-entrypoints"},"Changes to parameters for views and entrypoints"),(0,o.kt)("p",null,"Views and entrypoints used to accept the parameter and current storage as a tuple.\nNow, they accept these values as separate parameters."),(0,o.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("p",null,"For example, this view uses the old syntax:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},"(* Prior to LIGO 1.0 *)\n[@entry]\nlet set_storage (new_storage, _old_storage : int * int): operation list * int = ([], new_storage)\n\n[@view]\nlet get_storage ((), storage : unit * int): int = storage\n")),(0,o.kt)("p",null,"This equivalent view uses the new syntax:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo"},"[@entry]\nlet set_storage (new_storage : int)  (_old_storage : int): operation list * int = ([], new_storage)\n\n[@view]\nlet get_storage () (storage : int): int = storage\n"))),(0,o.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("p",null,"For example, this view uses the old syntax:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},"// Prior to LIGO 1.0\n@entry\nconst set_storage = ([new_storage, _old_storage] : [int, int]): [list<operation>, int] => [[], new_storage]\n\n@view\nconst get_storage = ([_, storage] : [unit, int]): int => storage\n")),(0,o.kt)("p",null,"This equivalent view uses the new syntax:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo"},"// @entry\nconst set_storage = (new_storage: int, _old_storage: int): [list<operation>, int] => [[], new_storage]\n\n// @view\nconst get_storage = (_: unit, storage: int): int => storage\n\n"))),(0,o.kt)("h2",{id:"changes-to-contract_of-and-parameter_of"},"Changes to ",(0,o.kt)("inlineCode",{parentName:"h2"},"contract_of")," and ",(0,o.kt)("inlineCode",{parentName:"h2"},"parameter_of")),(0,o.kt)("p",null,"The aforementioned changes to entrypoints, views, and the ",(0,o.kt)("inlineCode",{parentName:"p"},"main")," function affect how contracts are tested.\nBeginning in version 0.64.2, the behavior of ",(0,o.kt)("inlineCode",{parentName:"p"},"contract_of")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"parameter_of")," in tests has changed."),(0,o.kt)("p",null,"For examples of how to use ",(0,o.kt)("inlineCode",{parentName:"p"},"contract_of"),", see ",(0,o.kt)("a",{parentName:"p",href:"../testing"},"Testing"),".\nFor examples of how to use ",(0,o.kt)("inlineCode",{parentName:"p"},"parameter_of"),", see ",(0,o.kt)("a",{parentName:"p",href:"../data-types/contracts-type"},"Contracts"),"."),(0,o.kt)("h2",{id:"export-and-private-now-have-the-expected-effect"},(0,o.kt)("inlineCode",{parentName:"h2"},"export")," and ",(0,o.kt)("inlineCode",{parentName:"h2"},"@private")," now have the expected effect"),(0,o.kt)("p",null,"Previously, all declarations were exported regardless whether ",(0,o.kt)("inlineCode",{parentName:"p"},"export"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"@private")," or neither was used."),(0,o.kt)("p",null,"In LIGO v1.0, JsLIGO definitions which are not marked with ",(0,o.kt)("inlineCode",{parentName:"p"},"export")," or designated as an entrypoint are not exported, and CameLIGO definitions which are marked with ",(0,o.kt)("inlineCode",{parentName:"p"},"@private")," are not exported.\nIn other words, the default for JsLIGO is now to make definitions private unless specified otherwise with ",(0,o.kt)("inlineCode",{parentName:"p"},"export")," of ",(0,o.kt)("inlineCode",{parentName:"p"},"@entry"),", and the default for CameLIGO is now to make definitions public unless specified otherwise with ",(0,o.kt)("inlineCode",{parentName:"p"},"[@private]"),"."),(0,o.kt)("p",null,"Furthermore, in JsLIGO nested namespaces need to be exported in order to be accessed.\nFor example, this code accesses a declaration that is inside another module; this is possible only because the declaration is exported:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=namespace-export",group:"namespace-export"},"namespace Foo {\n    export namespace Bar {\n        export const x = 1\n    }\n}\n\nconst y = Foo.Bar.x\n")),(0,o.kt)("h2",{id:"the-comb-layout-is-now-used-by-default"},"The comb layout is now used by default"),(0,o.kt)("p",null,"LIGO can format types in Michelson in two basic layouts: combs and trees.\nPreviously, LIGO used trees by default, but in LIGO v1, it uses combs by default."),(0,o.kt)("p",null,"As described in ",(0,o.kt)("a",{parentName:"p",href:"../syntax/contracts/interop"},"Interoperability"),", sometimes you need to match the layout of Michelson values, such as when you call a contract that accepts parameters in combs or trees.\nYou can use the ",(0,o.kt)("inlineCode",{parentName:"p"},"@layout")," decorator in JsLIGO or the ",(0,o.kt)("inlineCode",{parentName:"p"},"[@layout]")," attribute in CameLIGO to set the layout of a type."),(0,o.kt)("p",null,"For more info on why this change happened, see ",(0,o.kt)("a",{parentName:"p",href:"/blog/layout-comb-why"},"Why did the default datatype layout change to ",(0,o.kt)("inlineCode",{parentName:"a"},"@layout comb"),"?")),(0,o.kt)("p",null,"If your project has a stable ABI that other tools rely on, you might need to manually set the type of entrypoint arguments and return types with the ",(0,o.kt)("inlineCode",{parentName:"p"},"@layout")," decorator in JsLIGO or the ",(0,o.kt)("inlineCode",{parentName:"p"},"[@layout]")," attribute in CameLIGO."),(0,o.kt)("p",null,"Combs and trees can perform differently, so you can try setting types such as variants with many cases as combs or trees and comparing the size and gas consumption of the compiled contracts."),(0,o.kt)("h2",{id:"decorators-in-and-out-of-comments"},"Decorators in and out of comments"),(0,o.kt)("p",null,"Prior to version 1.0, JsLIGO some decorators were put in comments, as in this example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},"// @entry\nconst my_entry_point = (_: unit, n: int) : [list<operation>, int] => [[], n];\n")),(0,o.kt)("p",null,"Now, some decorators are in comments, others not when the TypeScript\nallows it, as in this example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo"},"// @entry\nconst my_entry_point = (_: unit, n: int) : [list<operation>, int] => [[], n];\n\n")),(0,o.kt)("p",null,"For more information, see ",(0,o.kt)("a",{parentName:"p",href:"../syntax/decorators"},"Decorators"),"."),(0,o.kt)("h2",{id:"field-and-tuple-component-access"},"Field and tuple component access"),(0,o.kt)("p",null,"Fields can be accessed with dot notation ",(0,o.kt)("inlineCode",{parentName:"p"},"stuff.y")," and brackets ",(0,o.kt)("inlineCode",{parentName:"p"},'stuff["y"]')," interchangeably:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo"},'const stuff = {\n    x : "foo",\n    y : { universe : [42, "life", true] }\n};\n\nconst part : bool = stuff.y["universe"][2];\n')),(0,o.kt)("h2",{id:"changes-to-cli-commands"},"Changes to CLI commands"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The internal command ",(0,o.kt)("inlineCode",{parentName:"p"},"ligo daemon")," was removed in v0.69.0 (",(0,o.kt)("a",{parentName:"p",href:"./changelog#0690"},"changelog"),").\nThere should be no noticeable change for the user because the new language server (used by tools such as the VsCode plug-in) does not use this command any more.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Starting from v0.64.2 (",(0,o.kt)("a",{parentName:"p",href:"./changelog#0642"},"changelog"),"), the transpilation commands now take the arguments ",(0,o.kt)("inlineCode",{parentName:"p"},"--from-syntax")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"--to-syntax")," instead of the argument ",(0,o.kt)("inlineCode",{parentName:"p"},"--syntax")," for the source syntax and an unnamed parameter for the destination syntax.\nThe destination syntax can still be inferred from the filename given to the ",(0,o.kt)("inlineCode",{parentName:"p"},"-o")," argument, such as ",(0,o.kt)("inlineCode",{parentName:"p"},"-o dest.jsligo"),".")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The command ",(0,o.kt)("inlineCode",{parentName:"p"},"ligo mutate")," has been removed; use ",(0,o.kt)("a",{parentName:"p",href:"../testing/mutation-testing"},"Mutation testing")," instead."))),(0,o.kt)("h2",{id:"mutation-testing"},"Mutation testing"),(0,o.kt)("p",null,"Support for CST mutation testing was dropped in v0.66.0 (",(0,o.kt)("a",{parentName:"p",href:"./changelog#0660"},"changelog"),").\nHowever, AST mutation testing is still supported; see ",(0,o.kt)("a",{parentName:"p",href:"../testing/mutation-testing"},"Mutation testing"),"."),(0,o.kt)("h2",{id:"kathmandu-protocol-deprecated"},"Kathmandu protocol deprecated"),(0,o.kt)("p",null,"Starting from v0.64.2 (",(0,o.kt)("a",{parentName:"p",href:"./changelog#0642"},"changelog"),"), the Kathmandu protocol is deprecated.\nIf you need to recompile an old LIGO contract for an outdated protocol version, you can use the compiler version that the project was developed with."),(0,o.kt)("h2",{id:"package-management-use-ligojson-instead-of-packagejson-or-esyjson"},"Package management: use ligo.json instead of package.json or esy.json"),(0,o.kt)("p",null,"To separate LIGO package management from JavaScript package management toolchains such as Node.JS, LIGO now uses a separate manifest in the file ",(0,o.kt)("inlineCode",{parentName:"p"},"ligo.json"),"."),(0,o.kt)("p",null,"As part of this change, LIGO no longer uses the ",(0,o.kt)("inlineCode",{parentName:"p"},"esy")," tool for package management, and the ",(0,o.kt)("inlineCode",{parentName:"p"},"installation.json")," file, formerly located at ",(0,o.kt)("inlineCode",{parentName:"p"},"_esy/ligo/installation.json"),", should now be moved to ",(0,o.kt)("inlineCode",{parentName:"p"},"_ligo/ligo/installation.json"),"."),(0,o.kt)("h2",{id:"changes-specific-to-jsligo"},"Changes specific to JsLIGO"),(0,o.kt)("h3",{id:"short-notation-for-tez-and-mutez"},"Short notation for ",(0,o.kt)("inlineCode",{parentName:"h3"},"tez")," and ",(0,o.kt)("inlineCode",{parentName:"h3"},"mutez")),(0,o.kt)("p",null,"You can now write ",(0,o.kt)("inlineCode",{parentName:"p"},"3tez")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"3mutez")," instead of ",(0,o.kt)("inlineCode",{parentName:"p"},"3 as tez")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"3 as mutez"),"."),(0,o.kt)("h3",{id:"new-bitwise-operators"},"New bitwise operators"),(0,o.kt)("p",null,"The following operators have been added, and can be used with ",(0,o.kt)("inlineCode",{parentName:"p"},"nat")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"bytes"),":"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"&"),": Bitwise ",(0,o.kt)("em",{parentName:"li"},"and")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"|"),": Bitwise ",(0,o.kt)("em",{parentName:"li"},"or")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"^"),": Bitwise ",(0,o.kt)("em",{parentName:"li"},"xor")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"<<"),": Bitwise left shift (the shift amount is always a ",(0,o.kt)("inlineCode",{parentName:"li"},"nat\\, even when shifting "),"bytes`)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},">>"),": Bitwise right shift (the shift amount is always a ",(0,o.kt)("inlineCode",{parentName:"li"},"nat\\, even when shifting "),"bytes`)")),(0,o.kt)("p",null,"Here are examples of these operators in context:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo"},"const zero: nat = (2 as nat) & (1 as nat); // Bitwise and\nconst two_bytes: bytes = 0x11 & 0x10\n\nconst five: nat = (4 as nat) | (1 as nat); // Bitwise or\nconst three_bytes: bytes = 0x11 | 0x10\n\nconst three: nat = (2 as nat) ^ (1 as nat); // Bitwise xor\nconst one_byte: bytes = 0x11 ^ 0x10\n\nconst four: nat = (2 as nat) << (1 as nat) // Bitwise left shift\nconst five_one_two: bytes = 0x0100 << (1 as nat)\n\nconst one: nat = (2 as nat) >> (1 as nat); // Bitwise right shift\nconst zero_bytes: bytes = 0x01 >> (1 as nat)\n")),(0,o.kt)("p",null,"For more information, see ",(0,o.kt)("a",{parentName:"p",href:"../data-types/bytes#bitwise-operations"},"Bitwise operations"),"."),(0,o.kt)("h3",{id:"changes-to-pattern-matching"},"Changes to pattern matching"),(0,o.kt)("p",null,"JsLIGO's pattern matching is inspired by the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/tc39/proposal-pattern-matching"},"ECMAScript Pattern Matching proposal"),".\nThis section covers some of the changes this implies:"),(0,o.kt)("p",null,"The new ",(0,o.kt)("inlineCode",{parentName:"p"},"when")," keyword makes pattern matching more explicit.\nSpecifically, pattern matching uses the ",(0,o.kt)("inlineCode",{parentName:"p"},"when")," keyword instead of a function that takes an object with cases as fields."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"do { ... }")," expression is equivalent to the ",(0,o.kt)("inlineCode",{parentName:"p"},"(() => { ... }) ()")," thunk.\nIt allows a block of code containing statements (like ",(0,o.kt)("inlineCode",{parentName:"p"},"const xyz = ...")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"return 42"),") to be used where an expression is expected."),(0,o.kt)("p",null,"For example, this is a pattern match prior to JsLIGO 1.0:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},'const force_positive = (key: string, dict: map<string, int>) => {\n  return match(Map.find_opt (key, dict), {\n    Some: (val : int) => {\n        if (val >= 0) {\n            return val;\n        } else {\n            failwith("Negative value.");\n        }\n    },\n    None: () => failwith("Not found.")\n  });\n}\n')),(0,o.kt)("p",null,"This is an equivalent match in JsLIGO 1.0:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo"},'const force_positive = (key: string, dict: map<string, int>) =>\n  $match(Map.find_opt (key, dict), {\n    "Some": val =>\n       (() => { if (val >= 0) return val; else failwith("Negative value") })(),\n    "None": () => failwith("Not found.")\n  });\n')),(0,o.kt)("p",null,"Pattern-matching on lists in version 1.0 uses the syntaxes ",(0,o.kt)("inlineCode",{parentName:"p"},"when([])")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"when([head, ...tail])"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo"},'type storage = [int, list <int>];\ntype parameter = list <int>;\ntype returnx = [list <operation>, storage];\n\nfunction main (p : parameter, s : storage) : returnx {\n  const storage =\n    $match(List.head_and_tail(p), {\n      "None": () => s,\n      "Some": ([hd, tl]) => [s[0] + hd, tl]\n    });\n  return [[], storage];\n};\n')),(0,o.kt)("p",null,"Furthermore, there are a few changes to how patterns are written:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Patterns for parameterless constructors take a ",(0,o.kt)("inlineCode",{parentName:"li"},"()")," within the ",(0,o.kt)("inlineCode",{parentName:"li"},"when(...)"),"; for example ",(0,o.kt)("inlineCode",{parentName:"li"},"Nil: () => 1")," becomes ",(0,o.kt)("inlineCode",{parentName:"li"},"when(Nil()): 1")),(0,o.kt)("li",{parentName:"ul"},"Patterns that match a constructor containing a tuple work similarly; for example ",(0,o.kt)("inlineCode",{parentName:"li"},"Cons: (pair) => pair.1 + f(pair.2)")," becomes ",(0,o.kt)("inlineCode",{parentName:"li"},"when(Cons(pair)) => pair.1 + f(pair.2)")),(0,o.kt)("li",{parentName:"ul"},"Patterns with one variable per parameter are written as expected: ",(0,o.kt)("inlineCode",{parentName:"li"},"Foo: (a, b) => a + b")," becomes ",(0,o.kt)("inlineCode",{parentName:"li"},"when(Foo(a, b)): a + b"))),(0,o.kt)("p",null,"For more information, see ",(0,o.kt)("a",{parentName:"p",href:"../data-types/variants#matching"},"Matching"),"."),(0,o.kt)("h3",{id:"a-single-underscore-is-now-a-valid-variable-name"},"A single underscore is now a valid variable name"),(0,o.kt)("p",null,"Previously, following the convention of some functional languages, you could use a single underscore character (",(0,o.kt)("inlineCode",{parentName:"p"},"_"),") to discard the value bound to it, as in this example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},'// Prior to JsLIGO 1.0\nconst f = () => {\n  let _ = some_check();\n  return match (foobar) {\n    when([]) : "empty list";\n    when([_, ..._]): "non-empty list";\n  };\n}\n')),(0,o.kt)("p",null,"Instead, a single underscore is now a normal variable name, following the JavaScript and TypeScript convention, where the underscore is used as a short name for a namespace containing many utilities, such as an alias for the ",(0,o.kt)("inlineCode",{parentName:"p"},"lodash")," library.\nThis means that the code above should now assign unique names to the discarded value, as in this example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},'// don\'t do this anymore\nconst f = () => {\n  let _chk = some_check();\n  return match (foobar) {\n    when([]) : "empty list";\n    when([_hd, ..._tl]): "non-empty list";\n  };\n}\n')),(0,o.kt)("p",null,"If multiple variables named with a single underscore are declared in the same scope, the compiler now throws an error (duplicate block-scoped variable) just as in TypeScript.\nHowever, it is still possible to shadow a variable named ",(0,o.kt)("inlineCode",{parentName:"p"},"_")," within a smaller scope.\nFor example, if the variable is globally defined as an alias for another module, a function can still specify a variable named ",(0,o.kt)("inlineCode",{parentName:"p"},"_")," as an argument name and shadow the global definition.\nShadowing variables in this way can cause issues and therefore you should review your code for such cases."),(0,o.kt)("h3",{id:"imports-are-now-automatically-re-exported"},"Imports are now automatically re-exported"),(0,o.kt)("p",null,"When you import a module with the ",(0,o.kt)("inlineCode",{parentName:"p"},"#import")," directive, it is automatically re-exported.\nFor example, if a file imports the file ",(0,o.kt)("inlineCode",{parentName:"p"},"foo.jsligo")," with the code ",(0,o.kt)("inlineCode",{parentName:"p"},'#import "foo.jsligo" "Foo"'),", a third file importing ",(0,o.kt)("inlineCode",{parentName:"p"},"bar.jsligo")," as ",(0,o.kt)("inlineCode",{parentName:"p"},"Bar")," can write ",(0,o.kt)("inlineCode",{parentName:"p"},"Bar.Foo.x")," to access the ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," defined in ",(0,o.kt)("inlineCode",{parentName:"p"},"foo.jsligo"),"."),(0,o.kt)("p",null,"For more information, see ",(0,o.kt)("a",{parentName:"p",href:"../compiling/preprocessor#import"},(0,o.kt)("inlineCode",{parentName:"a"},"#import")),"."),(0,o.kt)("h3",{id:"true-and-false-are-reserved-words"},(0,o.kt)("inlineCode",{parentName:"h3"},"true")," and ",(0,o.kt)("inlineCode",{parentName:"h3"},"false")," are reserved words"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"true")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"false")," are now keywords, not variables, and cannot be shadowed by a local variable declaration."),(0,o.kt)("h2",{id:"changes-specific-to-cameligo"},"Changes specific to CameLIGO"),(0,o.kt)("h3",{id:"field-and-tuple-component-access-1"},"Field and tuple component access"),(0,o.kt)("p",null,"Fields and tuple components can be accessed with the same dot notation:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo"},'let stuff = {\n    x = "foo";\n    y = (42, "life", { universe = true });\n}\n\nlet part : bool = stuff.y.2.universe\n')))}m.isMDXComponent=!0}}]);