"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[78164],{3905:(n,e,t)=>{t.d(e,{Zo:()=>d,kt:()=>c});var a=t(67294);function i(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function r(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,a)}return t}function o(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?r(Object(t),!0).forEach((function(e){i(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function l(n,e){if(null==n)return{};var t,a,i=function(n,e){if(null==n)return{};var t,a,i={},r=Object.keys(n);for(a=0;a<r.length;a++)t=r[a],e.indexOf(t)>=0||(i[t]=n[t]);return i}(n,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);for(a=0;a<r.length;a++)t=r[a],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(i[t]=n[t])}return i}var s=a.createContext({}),p=function(n){var e=a.useContext(s),t=e;return n&&(t="function"==typeof n?n(e):o(o({},e),n)),t},d=function(n){var e=p(n.components);return a.createElement(s.Provider,{value:e},n.children)},u={inlineCode:"code",wrapper:function(n){var e=n.children;return a.createElement(a.Fragment,{},e)}},m=a.forwardRef((function(n,e){var t=n.components,i=n.mdxType,r=n.originalType,s=n.parentName,d=l(n,["components","mdxType","originalType","parentName"]),m=p(t),c=i,g=m["".concat(s,".").concat(c)]||m[c]||u[c]||r;return t?a.createElement(g,o(o({ref:e},d),{},{components:t})):a.createElement(g,o({ref:e},d))}));function c(n,e){var t=arguments,i=e&&e.mdxType;if("string"==typeof n||i){var r=t.length,o=new Array(r);o[0]=m;var l={};for(var s in e)hasOwnProperty.call(e,s)&&(l[s]=e[s]);l.originalType=n,l.mdxType="string"==typeof n?n:i,o[1]=l;for(var p=2;p<r;p++)o[p]=t[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},48720:(n,e,t)=>{t.d(e,{D:()=>i.Z,Z:()=>r});var a=t(67294),i=t(75402);const r=function(n){return a.createElement(i.Z.Consumer,null,(e=>{let{syntax:t}=e;return t===n.syntax?n.children:a.createElement(a.Fragment,null)}))}},39753:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>p,contentTitle:()=>l,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var a=t(87462),i=(t(67294),t(3905)),r=t(48720);const o={title:"Numbers"},l=void 0,s={unversionedId:"data-types/numbers",id:"data-types/numbers",title:"Numbers",description:"In LIGO, there are two types of numbers: integers and natural",source:"@site/../docs/data-types/numbers.md",sourceDirName:"data-types",slug:"/data-types/numbers",permalink:"/previews/ligo/external-link-icon/docs/next/data-types/numbers",draft:!1,tags:[],version:"current",frontMatter:{title:"Numbers"},sidebar:"docs",previous:{title:"Type annotations",permalink:"/previews/ligo/external-link-icon/docs/next/data-types/type-annotations"},next:{title:"Booleans",permalink:"/previews/ligo/external-link-icon/docs/next/data-types/booleans"}},p={},d=[{value:"Casting",id:"casting",level:2},{value:"Adding",id:"adding",level:2},{value:"Subtracting",id:"subtracting",level:2},{value:"Negating",id:"negating",level:2},{value:"Multiplying",id:"multiplying",level:2},{value:"Dividing",id:"dividing",level:2},{value:"Checking positivity",id:"checking-positivity",level:2},{value:"Bitwise operations",id:"bitwise-operations",level:2},{value:"Increment and decrement operators",id:"increment-and-decrement-operators",level:2}],u={toc:d};function m(n){let{components:e,...t}=n;return(0,i.kt)("wrapper",(0,a.Z)({},u,t,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"In LIGO, there are two types of numbers: integers and natural\nnumbers."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Integer literals are the same found in mainstream programming\nlanguages, for example, ",(0,i.kt)("inlineCode",{parentName:"li"},"10"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"-6")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"0"),", but there is only one\ncanonical zero: ",(0,i.kt)("inlineCode",{parentName:"li"},"0")," (so, for instance, ",(0,i.kt)("inlineCode",{parentName:"li"},"-0")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"00")," are invalid).")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Natural numbers are written as digits followed by the suffix ",(0,i.kt)("inlineCode",{parentName:"li"},"n"),",\nlike so: ",(0,i.kt)("inlineCode",{parentName:"li"},"12n"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"0n"),", and the same restriction on zero as integers\napplies: ",(0,i.kt)("inlineCode",{parentName:"li"},"0n")," is the only way to specify the natural zero."))),(0,i.kt)("p",null,"Contrary to integral numbers in other programming languages, numbers\nin LIGO have arbitrary-precision, that is, they do not overflow or\nunderflow."),(0,i.kt)("p",null,"Digits of large numbers can be separated by an underscore, to increase\nreadability."),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=int_and_nat",group:"int_and_nat"},"// The following are integers\nlet zero = 0\nlet million = 1_000_000 // Grouping in French\nlet baekman = 100_0000 // Grouping in Korean\n\n// The following are natural numbers\nlet zero_nat = 0n\nlet million_nat = 1_000_000n\nlet baekman_nat = 100_0000n\n")),(0,i.kt)("p",null,"As a form of documentation, a type can be ascribed to each constant:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=typed_int_and_nat",group:"typed_int_and_nat"},"let zero : int = 0\nlet million : int = 1_000_000\nlet baekman : int = 100_0000\n\nlet zero_nat : nat = 0n\nlet million_nat : nat = 1_000_000n\nlet baekman_nat : nat = 100_0000n\n"))),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=int_and_nat",group:"int_and_nat"},"// The following are integers\nconst zero = 0\nconst million = 1_000_000 // Grouping in French\nconst baekman = 100_0000 // Grouping in Korean\n\n// The following are natural numbers\nconst zero_nat = 0n\nconst million_nat = 1_000_000n\nconst baekman_nat = 100_0000n\n")),(0,i.kt)("p",null,"As a form of documentation, a type can be ascribed to each constant:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=typed_int_and_nat",group:"typed_int_and_nat"},"const zero : int = 0\nconst million : int = 1_000_000\nconst baekman : int = 100_0000\n\nconst zero_nat : nat = 0 as nat\nconst million_nat : nat = 1_000_000 as nat\nconst baekman_nat : nat = 100_0000 as nat\n"))),(0,i.kt)("h2",{id:"casting"},"Casting"),(0,i.kt)("p",null,"In mathematics, natural numbers are a strict subset of integers, and\ncan be used in any context where an integer is expected. In LIGO, this\nproperty does not hold true in general. Instead, a given binary\narithmetic operation, say, is defined four times, so it can apply to\nany combination of natural numbers and integers: this is called\n",(0,i.kt)("em",{parentName:"p"},"overloading"),", and some programming languages extend it to\nuser-defined functions (e.g. members in C++) -- but not LIGO."),(0,i.kt)("p",null,"So there are no implicit type casts in LIGO, but we can ",(0,i.kt)("em",{parentName:"p"},"explicitly\ncast")," natural numbers to integers (this is safe in all contexts where\nan integer is valid) by calling the predefined function ",(0,i.kt)("inlineCode",{parentName:"p"},"int"),". The\ninverse cast, from ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"nat")," is called in mathematics the\n",(0,i.kt)("em",{parentName:"p"},"absolute value"),", or ",(0,i.kt)("inlineCode",{parentName:"p"},"abs")," in LIGO."),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=casting",group:"casting"},"let one : int = int 1n // Explicit cast from nat to int\nlet two : nat = abs 2  // Explicit cast from int to nat\n"))),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=casting",group:"casting"},"const one : int = int(1 as nat); // Explicit cast from nat to int\nconst two : nat = abs(2);  // Explicit cast from int to nat\n"))),(0,i.kt)("h2",{id:"adding"},"Adding"),(0,i.kt)("p",null,"Addition in LIGO is accomplished by means of the ",(0,i.kt)("inlineCode",{parentName:"p"},"+")," binary operator,\nwhich is overloaded to apply to any combination of natural numbers and\nintegers, as shown in the following examples. Note that adding an\ninteger to a natural number produces an integer, because the compiler\ncannot determine, in general, whether the result would be always a\nnatural number for all inputs."),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=adding",group:"adding"},"let a : int = 5 + 10    // int + int yields int\nlet b : nat = 5n + 10n  // nat + nat yields nat\nlet c : int = 5n + 10   // nat + int yields int\nlet d : int = 10 + 5n   // int + nat yields int\n// let error : nat = 5n + 10\n"))),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=adding",group:"adding"},"const a : int = 5 + 10;    // int + int yields int\nconst b : nat = (5 as nat) + (10 as nat);  // nat + nat yields nat\nconst c : int = (5 as nat) + 10;   // nat + int yields int\nconst d : int = 10 + (5 as nat);   // int + nat yields int\n// const error : nat = (5 as nat) + 10;\n"))),(0,i.kt)("h2",{id:"subtracting"},"Subtracting"),(0,i.kt)("p",null,"Subtraction in LIGO is accomplished by means of the ",(0,i.kt)("inlineCode",{parentName:"p"},"-")," binary\noperator which is overloaded to apply to any combination of natural\nnumbers and integers, as shown in the following examples. The rule\nwhen subtracting two natural numbers is that the result is an integer\nbecause, in general, the compiler cannot determine whether the value\nof an expression is positive or zero for all inputs."),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=subtracting",group:"subtracting"},"let a : int = 5 - 10   // int - int yields int\nlet b : int = 5n - 2n  // nat - nat yields int\nlet c : int = 10n - 5  // nat - int yields int\nlet d : int = 5 - 10n  // int - nat yields int\n// let error : nat = 5n - 2n\n"))),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=subtracting",group:"subtracting"},"const a : int = 5 - 10;   // int - int yields int\nconst b : int = (5 as nat) - (2 as nat);  // nat - nat yields int\nconst c : int = (10 as nat) - 5;  // nat - int yields int\nconst d : int = 5 - (10 as nat);  // int - nat yields int\n// const error : nat = (5 as nat) - (2 as nat);\n"))),(0,i.kt)("h2",{id:"negating"},"Negating"),(0,i.kt)("p",null,"The arithmetic negation of a number is the same as subtracting that\nnumber from zero, so the negation of a natural numbers yields an\ninteger:"),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=negating",group:"negating"},"let a : int = -5  // - int yields int\nlet b : int = -5n // - nat yields int\n// let error : nat = -5n\n"))),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=negating",group:"negating"},"const a : int = -5;  // - int yields int\nconst b : int = -(5 as nat); // - nat yields int\n// const error : nat = -(5 as nat);\n"))),(0,i.kt)("h2",{id:"multiplying"},"Multiplying"),(0,i.kt)("p",null,"Multiplication in LIGO is accomplished by means of the ",(0,i.kt)("inlineCode",{parentName:"p"},"*")," binary\noperator which is overloaded to apply to any combination of natural\nnumbers and integers, as shown in the following examples. The type\nrules for multiplication are the same as for the addition:"),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=multiplying",group:"multiplying"},"let a : int = 5 * 10   // int * int yields int\nlet b : nat = 5n * 2n  // nat * nat yields nat\nlet c : int = 10n * 5  // nat * int yields int\nlet d : int = 5 * 10n  // int * nat yields int\n"))),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=multiplying",group:"multiplying"},"const a : int = 5 * 10;   // int * int yields int\nconst b : nat = (5 as nat) * (2 as nat);  // nat * nat yields nat\nconst c : int = (10 as nat) * 5;  // nat * int yields int\nconst d : int = 5 * (10 as nat);  // int * nat yields int\n"))),(0,i.kt)("h2",{id:"dividing"},"Dividing"),(0,i.kt)("p",null,"Because LIGO features neither floating-point nor fixed-point\narithmetic, division in LIGO is Euclidean. The predefined binary\noperator ",(0,i.kt)("inlineCode",{parentName:"p"},"/")," returns the quotient and is overloaded like the\nmultiplication. Of course, division by zero triggers an exception that\ninterrups the execution, so the programmer must make sure this case\ncannot happen because the compiler cannot determine, in general, if a\nvariable will have a given value (or not) for all inputs."),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=dividing",group:"dividing"},"let a : int = 10 / 3    // int / int yields int\nlet b : nat = 10n / 3n  // nat / nat yields nat\nlet c : int = 10n / 3   // nat / int yields int\nlet d : int = 10 / 3n   // int / nat yields int\n"))),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=dividing",group:"dividing"},"const a : int = 10 / 3;    // int / int yields int\nconst b : nat = (10 as nat) / (3 as nat);  // nat / nat yields nat\nconst c : int = (10 as nat) / 3;   // nat / int yields int\nconst d : int = 10 / (3 as nat);   // int / nat yields int\n"))),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The binary operator ",(0,i.kt)("inlineCode",{parentName:"p"},"mod")," returns the ",(0,i.kt)("em",null,"positive modulo")," of the\nEuclidean division, that is, the following holds:"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"(n*(a/n)+(a%n) == a) && (0n <= a % n) && (a % n < abs(n))")),(0,i.kt)("p",null,"It is overloaded as the Euclidean division ",(0,i.kt)("inlineCode",{parentName:"p"},"/")," to allow for\nall four combinations of natural numbers and integers."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=mod",group:"mod"},"let a : nat = 120  mod 9  // int mod int yields nat\nlet b : nat = 120n mod 9  // nat mod int yields nat\nlet b : nat = 120n mod 9n // nat mod nat yields nat\nlet c : nat = 120  mod 9n // int mod nat yields nat\n"))),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The binary operator ",(0,i.kt)("inlineCode",{parentName:"p"},"%")," returns the ",(0,i.kt)("em",null,"positive modulo")," of the\nEuclidean division, that is, the following holds:"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"(n*(a/n)+(a%n) == a) && ((0 as nat) <= a % n) && (a % n < abs(n))")),(0,i.kt)("p",null,"It is overloaded as the Euclidean division ",(0,i.kt)("inlineCode",{parentName:"p"},"/")," to allow for all four\ncombinations of natural numbers and integers."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=mod",group:"mod"},"const a : nat = 120 % 9;  // int % int yields nat\nconst b : nat = (120 as nat) % 9;  // nat % int yields nat\nconst c : nat = (120 as nat) % (9 as nat); // nat % nat yields nat\nconst d : nat = 120 % (9 as nat); // int % nat yields nat\n"))),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"For cases when you need both the quotient and the remainder, LIGO\nprovides the ",(0,i.kt)("inlineCode",{parentName:"p"},"ediv")," operation. ",(0,i.kt)("inlineCode",{parentName:"p"},"ediv x y")," returns ",(0,i.kt)("inlineCode",{parentName:"p"},"Some (quotient,\nremainder)"),", unless ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," is zero, in which case it returns ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),". The\nfunction ",(0,i.kt)("inlineCode",{parentName:"p"},"ediv")," is overloaded to accept all the combinations (4) of\nnatural and integer numbers:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=euclidean",group:"euclidean"},"// All below equal Some (7,2)\nlet ediv1 : (int * nat) option = ediv 37  5\nlet ediv2 : (int * nat) option = ediv 37n 5\nlet ediv3 : (nat * nat) option = ediv 37n 5n\nlet ediv4 : (int * nat) option = ediv 37  5n\n"))),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"For cases when you need both the quotient and the remainder, LIGO\nprovides the ",(0,i.kt)("inlineCode",{parentName:"p"},"ediv")," operation. ",(0,i.kt)("inlineCode",{parentName:"p"},"ediv(x,y)")," returns ",(0,i.kt)("inlineCode",{parentName:"p"},"Some (quotient,\nremainder)"),", unless ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," is zero, in which case it returns ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),". The\nfunction ",(0,i.kt)("inlineCode",{parentName:"p"},"ediv")," is overloaded to accept all the combinations (4) of\nnatural and integer numbers:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=euclidean",group:"euclidean"},"// All below equal Some (7,2)\nconst ediv1: option<[int, nat]> = ediv(37, 5);\nconst ediv2: option<[int, nat]> = ediv(37 as nat, 5);\nconst ediv3: option<[nat, nat]> = ediv(37 as nat, 5 as nat);\nconst ediv4: option<[int, nat]> = ediv(37, 5 as nat);\n"))),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"ediv")," operation returns an option type which is ",(0,i.kt)("inlineCode",{parentName:"p"},"Some")," if the result is defined and ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," if it is not, as when you try to divide by zero.\nTo handle option types, see ",(0,i.kt)("a",{parentName:"p",href:"./variants#matching"},"Matching"),"."),(0,i.kt)("h2",{id:"checking-positivity"},"Checking positivity"),(0,i.kt)("p",null,"You can check if a value is a natural number (",(0,i.kt)("inlineCode",{parentName:"p"},"nat"),") by using a\npredefined cast function which accepts an integer (",(0,i.kt)("inlineCode",{parentName:"p"},"int"),") and returns\nan optional natural number (",(0,i.kt)("inlineCode",{parentName:"p"},"nat"),"): if the result is ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),", then the\ngiven integer was positive, otherwise the corresponding natural number\n",(0,i.kt)("inlineCode",{parentName:"p"},"n")," is given with ",(0,i.kt)("inlineCode",{parentName:"p"},"Some(n)"),"."),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=positive",group:"positive"},"let one_is_nat : nat option = is_nat (1)\n"))),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=positive",group:"positive"},"const one_is_nat: option<nat> = is_nat(1);\n"))),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("h2",{id:"bitwise-operations"},"Bitwise operations"),(0,i.kt)("p",null,"You can perform bitwise operations with numbers in these cases:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=bitwise",group:"bitwise"},"// Bitwise and (first operand can be int or nat)\nlet four : nat = 4n land 4n // 4\n// Other bitwise operations require two nats\nlet four_ : nat = 7 land 4n // 4\n// Bitwise or\nlet seven : nat = 7n lor 4n // 7\n// Bitwise xor\nlet three : nat = 7n lxor 4n // 3\n// Bitwise shift left\nlet fourteen : nat = 7n lsl 1n // 14\n// Bitwise shift right\nlet seven_ : nat = 14n land 1n // 7\n"))),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("h2",{id:"increment-and-decrement-operators"},"Increment and decrement operators"),(0,i.kt)("p",null,"The increment operator (",(0,i.kt)("inlineCode",{parentName:"p"},"++"),") adds one to a number, and the decrement operator (",(0,i.kt)("inlineCode",{parentName:"p"},"--"),") subtracts one from a number."),(0,i.kt)("p",null,"You can use these operators as independent statements, as in these examples:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"test-ligo group=increment_ops","test-ligo":!0,group:"increment_ops"},"const testIncDecIndependent = (() => {\n  let value = 0;\n  value++;\n  Assert.assert(value == 1);\n  value--;\n  Assert.assert(value == 0);\n})();\n")),(0,i.kt)("p",null,"You can also use these operators in expressions that do other things.\nThe order of operations for the expressions depends on whether the operator is before or after the value:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In the ",(0,i.kt)("strong",{parentName:"p"},"prefix")," position (",(0,i.kt)("inlineCode",{parentName:"p"},"++p"),") the operator increments the value and returns the updated value for use in the current expression.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In the ",(0,i.kt)("strong",{parentName:"p"},"postfix")," position (",(0,i.kt)("inlineCode",{parentName:"p"},"p++"),") the operator increments the value but returns the old value before the increment for use in the current expression."))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"test-ligo group=increment_ops","test-ligo":!0,group:"increment_ops"},"const testIncEmbedded = (() => {\n  let value = 0;\n  // Prefix increment operator adds one immediately\n  Assert.assert(++value == 1);\n  Assert.assert(value   == 1);\n  // Postfix increment operator adds one after the expression is evaluated\n  Assert.assert(value++ == 1);\n  Assert.assert(value   == 2);\n})();\n"))))}m.isMDXComponent=!0}}]);