"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[78022],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var p=a.createContext({}),l=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=l(e.components);return a.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,p=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),m=l(n),d=o,g=m["".concat(p,".").concat(d)]||m[d]||u[d]||r;return n?a.createElement(g,s(s({ref:t},c),{},{components:n})):a.createElement(g,s({ref:t},c))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,s=new Array(r);s[0]=m;var i={};for(var p in t)hasOwnProperty.call(t,p)&&(i[p]=t[p]);i.originalType=e,i.mdxType="string"==typeof e?e:o,s[1]=i;for(var l=2;l<r;l++)s[l]=n[l];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},48720:(e,t,n)=>{n.d(t,{D:()=>o.Z,Z:()=>r});var a=n(67294),o=n(75402);const r=function(e){return a.createElement(o.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},35937:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>s,metadata:()=>p,toc:()=>c});var a=n(87462),o=(n(67294),n(3905)),r=n(48720);const s={title:"Tuples"},i=void 0,p={unversionedId:"data-types/tuples",id:"data-types/tuples",title:"Tuples",description:"Tuples are a list of a specific number of values in a specific order.",source:"@site/../docs/data-types/tuples.md",sourceDirName:"data-types",slug:"/data-types/tuples",permalink:"/previews/ligo/external-link-icon/docs/next/data-types/tuples",draft:!1,tags:[],version:"current",frontMatter:{title:"Tuples"},sidebar:"docs",previous:{title:"Bytes",permalink:"/previews/ligo/external-link-icon/docs/next/data-types/bytes"},next:{title:"Variants",permalink:"/previews/ligo/external-link-icon/docs/next/data-types/variants"}},l={},c=[{value:"Accessing components (destructuring)",id:"accessing-components-destructuring",level:2}],u={toc:c};function m(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Tuples are a list of a specific number of values in a specific order.\nThe elements in a tuple are called its ",(0,o.kt)("em",{parentName:"p"},"components"),"."),(0,o.kt)("p",null,"Unlike lists and sets, tuples have a specific size and cannot add or remove components.\nAs a result, you can access tuple components in random order by their index (or position).\nAlso unlike lists and sets, tuples can contain components of different types."),(0,o.kt)("p",null,"A common type of tuple is the ",(0,o.kt)("em",{parentName:"p"},"pair"),", a tuple of two components.\nFor example, if you wanted to store coordinates on a two-dimensional grid, you could use a pair ",(0,o.kt)("inlineCode",{parentName:"p"},"(x, y)"),".\nThese coordinates are in a specific order, so ",(0,o.kt)("inlineCode",{parentName:"p"},"(x, y)")," is not equivalent to ",(0,o.kt)("inlineCode",{parentName:"p"},"(y, x)"),".\nThe number of components is fixed, so you cannot add a third component to the tuple after it is defined and make it ",(0,o.kt)("inlineCode",{parentName:"p"},"(x, y, z)"),".\nIn this way, the number of components is part of the type of the tuple, so a tuple with two components does not have the same type as a tuple with three components and therefore cannot be used in the same places, like function parameters."),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"One important use of tuples is in the return values of contract entrypoints.\nEach entrypoint returns a tuple, of which the first component is a list of operations to run and the second is the new value of the contract storage."),(0,o.kt)("p",{parentName:"admonition"},"Tuples also often appear as function parameters, which can be confusing if you assume that they receive individual values.\nFor example, the function that you use for folding (as in ",(0,o.kt)("a",{parentName:"p",href:"./lists#folding-lists"},"Folding lists")," and ",(0,o.kt)("a",{parentName:"p",href:"./sets#folding-sets"},"Folding sets"),") receives a pair as a parameter instead of two separate values.")),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"Parentheses are optional, so the tuple ",(0,o.kt)("inlineCode",{parentName:"p"},"(x,y)")," can be written as ",(0,o.kt)("inlineCode",{parentName:"p"},"x,y")," if the context captures neither ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," nor ",(0,o.kt)("inlineCode",{parentName:"p"},"y"),".")),(0,o.kt)("p",null,"Tuple components can have different types.\nIf a pair contains a first component of type ",(0,o.kt)("inlineCode",{parentName:"p"},"t_1")," and a second component of type ",(0,o.kt)("inlineCode",{parentName:"p"},"t_2"),", its type is written ",(0,o.kt)("inlineCode",{parentName:"p"},"t_1 * t_2"),".\nIf there are more components, the type can be ",(0,o.kt)("inlineCode",{parentName:"p"},"t1 * t2 * ... * t_n"),".\nIn this way, you can think of tuple types as products of types."),(0,o.kt)("p",null,"Tuple types do not have to be defined before they can be used, as in  this example, which implicitly creates a pair of strings:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=tuple",group:"tuple"},'let friends = "Alice", "Bob" // Parentheses are optional\n')),(0,o.kt)("p",null,"However, defining the type of the tuple explicitly can make code easier to read, as in this example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=tuple",group:"tuple"},'type couple = string * string\nlet friends : couple = "Alice", "Bob" // Parentheses are optional\n'))),(0,o.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("p",null,"Tuple components can have different types.\nIf a pair contains a first component of type ",(0,o.kt)("inlineCode",{parentName:"p"},"t_1")," and a second component of type ",(0,o.kt)("inlineCode",{parentName:"p"},"t_2"),", its type is written ",(0,o.kt)("inlineCode",{parentName:"p"},"[t_1, t_2]"),".\nIf there are more components, the type can be ",(0,o.kt)("inlineCode",{parentName:"p"},"[t1, t2, ..., t_n]"),".\nIn this way, you can think of tuple types as products of types."),(0,o.kt)("p",null,"Tuple types do not have to be defined before they can be used, as in this example, which implicitly creates a pair of strings:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=tuple",group:"tuple"},'const friends = ["Alice", "Bob"];\n')),(0,o.kt)("p",null,"However, defining the type of the tuple explicitly can make code easier to read, as in this example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=tuple_alt",group:"tuple_alt"},'type couple = [string, string];\nconst friends: couple = ["Alice", "Bob"];\n'))),(0,o.kt)("p",null,"You can nest tuples to create complex custom data types.\nThis example shows a tuple whose second component is a tuple:"),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=nested",group:"nested"},'type nested_tuple = int * (string * nat)\nlet my_nested_value = (-5, ("Hello", 12))\n'))),(0,o.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=nested",group:"nested"},'type nested_tuple = [int, [string, nat]]\nconst my_nested_value = [-5, ["Hello", 12]];\n'))),(0,o.kt)("h2",{id:"accessing-components-destructuring"},"Accessing components (destructuring)"),(0,o.kt)("p",null,"To get the components of a tuple, you can destructure the tuple into separate variables.\nThis example assigns the values of a pair to two variables:"),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=destructuring",group:"destructuring"},'let friends = "Alice", "Bob" // Parentheses are optional\nlet alice, bob = friends\n')),(0,o.kt)("p",null,"That single definition creates two variables in the current scope: ",(0,o.kt)("inlineCode",{parentName:"p"},"alice")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"bob"),".\nIf you are not going to use any of these variables, give them the name ",(0,o.kt)("inlineCode",{parentName:"p"},"_")," or a name that starts with an underscore to make them into silent variables.\nUsing silent variables prevents the LIGO compiler from warning you about unused variables, as in this example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=destructuring",group:"destructuring"},"let alice, _bob = friends (* This alice shadows the previous one *)\n")),(0,o.kt)("p",null,"You can destructure nested tuples in the same manner:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=destructuring",group:"destructuring"},'let deep = (1, (2n, "Hello"))\nlet _, (_, greeting) = deep // greeting = "Hello"\n')),(0,o.kt)("p",null,"If you don't want to create variables, you can access the components of tuples by their indexes.\nThis example gets the second component of the second component of the nested tuple in the previous example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=destructuring",group:"destructuring"},'let film = deep.1.1 ^ ", Dolly!" // film = "Hello, Dolly!"\n'))),(0,o.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=destructuring",group:"destructuring"},'const friends = ["Alice", "Bob"];\nconst [alice, bob] = friends;\n')),(0,o.kt)("p",null,"That single definition creates two variables in the current scope: ",(0,o.kt)("inlineCode",{parentName:"p"},"alice")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"bob"),".\nIf you are not going to use any of these variables, give them the name ",(0,o.kt)("inlineCode",{parentName:"p"},"_")," or a name that starts with an underscore to make them into silent variables.\nUsing silent variables prevents the LIGO compiler from warning you about unused variables, as in this example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=destructuring",group:"destructuring"},"const [alice2, _bob] = friends;\n")),(0,o.kt)("p",null,"You can destructure nested tuples in the same manner:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=destructuring",group:"destructuring"},'const deep = [1, [2n, "Hello"]];\nconst [_x, [_y, greeting]] = deep; // greeting == "Hello"\n')),(0,o.kt)("p",null,"If you don't want to create variables, you can access the components of tuples by their indexes.\nThis example gets the second component of the second component of the nested tuple in the previous example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=destructuring",group:"destructuring"},'const film = deep[1][1] + ", Dolly!" // film == "Hello, Dolly!"\n'))),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"Tuple indexes start at zero.")))}m.isMDXComponent=!0}}]);