"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[91702],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=p(n),m=o,g=u["".concat(l,".").concat(m)]||u[m]||c[m]||i;return n?a.createElement(g,r(r({ref:t},d),{},{components:n})):a.createElement(g,r({ref:t},d))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,r[1]=s;for(var p=2;p<i;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},48720:(e,t,n)=>{n.d(t,{D:()=>o.Z,Z:()=>i});var a=n(67294),o=n(75402);const i=function(e){return a.createElement(o.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},80673:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>l,toc:()=>d});var a=n(87462),o=(n(67294),n(3905)),i=n(48720);const r={id:"modules",title:"Modules",jsLigoTitle:"Namespaces",hide_title:!0},s=void 0,l={unversionedId:"language-basics/modules",id:"version-1.5.0/language-basics/modules",title:"Modules",description:"Note that in JsLIGO modules are called namespaces.",source:"@site/versioned_docs/version-1.5.0/language-basics/modules.md",sourceDirName:"language-basics",slug:"/language-basics/modules",permalink:"/previews/ligo/external-link-icon/docs/1.5.0/language-basics/modules",draft:!1,tags:[],version:"1.5.0",frontMatter:{id:"modules",title:"Modules",jsLigoTitle:"Namespaces",hide_title:!0}},p={},d=[{value:"Declaring Modules",id:"declaring-modules",level:2},{value:"Using Modules",id:"using-modules",level:2},{value:"Nested Modules: Sub-Modules",id:"nested-modules-sub-modules",level:2},{value:"Modules and Imports: Build System",id:"modules-and-imports-build-system",level:2},{value:"Module Aliases",id:"module-aliases",level:2},{value:"Modules as Contracts",id:"modules-as-contracts",level:2},{value:"Module Inclusion",id:"module-inclusion",level:2},{value:"Module Types",id:"module-types",level:2}],c={toc:d};function u(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("h1",{id:"namespaces"},"Namespaces")),(0,o.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("h1",{id:"modules"},"Modules")),(0,o.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Note that in JsLIGO modules are called ",(0,o.kt)("inlineCode",{parentName:"p"},"namespaces"),"."))),(0,o.kt)("p",null,"Modules are a programming language construction that allows us to\npackage related definitions together. A canonical example of a module\nis a data type and associated operations over it (e.g. stacks or\nqueues). The rest of the program can access these definitions in a\nregular and abstract way, providing maintainability, reusability and\nsafety."),(0,o.kt)("p",null,"For a concrete example, we could create a module that packages a type\nthat represents amounts in a particular currency together with\nfunctions that manipulate these amounts: constants, addition,\nsubtraction, etc. A piece of code that uses this module can be\nagnostic concerning how the type is actually represented inside the\nmodule: it is said to be abstract."),(0,o.kt)("h2",{id:"declaring-modules"},"Declaring Modules"),(0,o.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("p",null,"Modules are introduced using the ",(0,o.kt)("inlineCode",{parentName:"p"},"module")," keyword. For example, the\nfollowing code defines a module ",(0,o.kt)("inlineCode",{parentName:"p"},"EURO")," that packages together a type,\ncalled ",(0,o.kt)("inlineCode",{parentName:"p"},"t"),", together with an operation ",(0,o.kt)("inlineCode",{parentName:"p"},"add")," that sums two values of\nthe given currency, as well as constants for zero and one."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=EURO",group:"EURO"},"module EURO =\n  struct\n    type t = nat\n    let add (a , b : t * t) : t = a + b\n    let zero : t = 0n\n    let one : t = 1n\n  end\n")),(0,o.kt)("p",null,"As we can see, in CameLIGO we also use a ",(0,o.kt)("inlineCode",{parentName:"p"},"struct ... end")," block to\ngroup together the definitions made in the module.")),(0,o.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("p",null,"Modules are introduced using the ",(0,o.kt)("inlineCode",{parentName:"p"},"namespace")," keyword. For example, the\nfollowing code defines a module ",(0,o.kt)("inlineCode",{parentName:"p"},"EURO")," that packages together a type,\ncalled ",(0,o.kt)("inlineCode",{parentName:"p"},"t"),", together with an operation ",(0,o.kt)("inlineCode",{parentName:"p"},"add")," that sums two values of\nthe given currency, as well as constants for zero and one."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=EURO",group:"EURO"},"namespace EURO {\n  export type t = nat;\n  export const add = (a: t, b: t) : t => a + b;\n  export const zero: t = 0n;\n  export const one: t = 1n\n}\n")),(0,o.kt)("p",null,"In this example you will also notice the ",(0,o.kt)("inlineCode",{parentName:"p"},"export")," keyword. A statement\nwithin a module can be accessed from outside the module if it is\nexported.")),(0,o.kt)("h2",{id:"using-modules"},"Using Modules"),(0,o.kt)("p",null,"We can access a module's components by using the selection operator\n",(0,o.kt)("inlineCode",{parentName:"p"},"."),".  Let us suppose that our storage keeps a value in euros using the\npreviously defined module ",(0,o.kt)("inlineCode",{parentName:"p"},"EURO"),". Then, we can write a ",(0,o.kt)("inlineCode",{parentName:"p"},"main")," entry\npoint that increments the storage value each time it is called."),(0,o.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=EURO",group:"EURO"},"type storage = EURO.t\n\n[@entry]\nlet main (_action : unit) (store : storage) : operation list * storage =\n  [], EURO.add (store, EURO.one)\n"))),(0,o.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=EURO",group:"EURO"},"type storage = EURO.t;\n\n@entry\nlet main = (_action: unit, store: storage): [list<operation>, storage] =>\n  [list([]), EURO.add (store, EURO.one)];\n"))),(0,o.kt)("p",null,"In principle, we could change the implementation of ",(0,o.kt)("inlineCode",{parentName:"p"},"EURO"),", without\nhaving to change the ",(0,o.kt)("inlineCode",{parentName:"p"},"storage")," type or the function ",(0,o.kt)("inlineCode",{parentName:"p"},"main"),". For\nexample, if we decide later that we should support manipulating\nnegative values, we could change ",(0,o.kt)("inlineCode",{parentName:"p"},"EURO")," as follows:"),(0,o.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=EURO2",group:"EURO2"},"module EURO =\n  struct\n    type t = int\n    let add (a, b : t * t) : t = a + b\n    let zero : t = 0\n    let one : t = 1\n  end\n"))),(0,o.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=EURO2",group:"EURO2"},"namespace EURO {\n  export type t = int;\n  export const add = (a: t, b: t) : t => a + b;\n  export const zero: t = 0;\n  export const one: t = 1;\n}\n"))),(0,o.kt)("p",null,"Notice that the code in ",(0,o.kt)("inlineCode",{parentName:"p"},"main")," still works, and no change is\nneeded. Abstraction accomplished!"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"\u26a0\ufe0f Please note that code using the module ",(0,o.kt)("inlineCode",{parentName:"p"},"EURO")," might still break\nthe abstraction if it directly uses the underlying representation of\n",(0,o.kt)("inlineCode",{parentName:"p"},"EURO.t"),". Client code should always try to respect the interface\nprovided by the module, and not make assumptions on its current\nunderlying representation (e.g. ",(0,o.kt)("inlineCode",{parentName:"p"},"EURO.t")," is a transparent alias\nof ",(0,o.kt)("inlineCode",{parentName:"p"},"nat"),"; future versons of LIGO might make this an opaque/abstract type).")),(0,o.kt)("h2",{id:"nested-modules-sub-modules"},"Nested Modules: Sub-Modules"),(0,o.kt)("p",null,"Modules can be nested, which means that we can define a module inside\nanother module. Let's see how that works, and define a variant of\n",(0,o.kt)("inlineCode",{parentName:"p"},"EURO")," in which the constants are all grouped inside using a sub-module."),(0,o.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=EURO3",group:"EURO3"},"module EURO =\n  struct\n    type t = nat\n\n    let add (a, b : t * t) : t = a + b\n\n    module CONST =\n      struct\n        let zero : t = 0n\n        let one : t = 1n\n      end\n  end\n"))),(0,o.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=EURO3",group:"EURO3"},"namespace EURO {\n  export type t = nat;\n\n  export let add = (a: t, b: t): t => a + b;\n\n  export namespace CONST {\n    export let zero: t = 0n;\n    export let one: t = 1n;\n  };\n};\n"))),(0,o.kt)("p",null,"To access nested modules we simply apply the selection operator more\nthan once:"),(0,o.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=EURO3",group:"EURO3"},"type storage = EURO.t\n\n[@entry]\nlet main (_action : unit) (store : storage) : operation list * storage =\n [], EURO.add (store, EURO.CONST.one)\n"))),(0,o.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=EURO3",group:"EURO3"},"type storage = EURO.t;\n\n@entry\nlet main = (_action: unit, store: storage) : [list<operation>, storage] =>\n [list([]), EURO.add (store, EURO.CONST.one)]\n"))),(0,o.kt)("h2",{id:"modules-and-imports-build-system"},"Modules and Imports: Build System"),(0,o.kt)("p",null,"Modules also allow us to separate our code in different files: when we\nimport a file, we obtain a module encapsulating all the definitions in\nit. This will become very handy for organising large contracts, as we\ncan divide it into different files, and the module system keeps the naming\nspace clean."),(0,o.kt)("p",null,"Generally, we will take a set of definitions that can be naturally\ngrouped by functionality, and put them together in a separate\nfile."),(0,o.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("p",null,"For example, in CameLIGO, we can create a file ",(0,o.kt)("inlineCode",{parentName:"p"},"imported.mligo"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=imported",group:"imported"},"type t = nat\n\nlet add (a , b : t * t) : t = a + b\n\nlet zero : t = 0n\nlet one : t = 1n\n"))),(0,o.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("p",null,"For example, in JsLIGO, we can create a file ",(0,o.kt)("inlineCode",{parentName:"p"},"imported.jsligo"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=imported",group:"imported"},"export type t = nat;\n\nexport const add = (a: t, b: t): t => a + b;\n\nexport const zero: t = 0n;\nexport const one: t = 1n;\n"))),(0,o.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("p",null,"Later, in another file, we can import ",(0,o.kt)("inlineCode",{parentName:"p"},"imported.mligo")," as a module, and\nuse its definitions. For example, we could create a ",(0,o.kt)("inlineCode",{parentName:"p"},"importer.mligo"),"\nthat imports all definitions from ",(0,o.kt)("inlineCode",{parentName:"p"},"imported.mligo")," as the module\n",(0,o.kt)("inlineCode",{parentName:"p"},"EURO"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=importer",group:"importer"},'#import "gitlab-pages/docs/language-basics/src/modules/imported.mligo" "EURO"\n\ntype storage = EURO.t\n\n[@entry]\nlet main (_action : unit) (store : storage) : operation list * storage =\n ([], EURO.add(store, EURO.one))\n'))),(0,o.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("p",null,"Later, in another file, we can import ",(0,o.kt)("inlineCode",{parentName:"p"},"imported.jsligo")," as a module, and\nuse its definitions. For example, we could create a ",(0,o.kt)("inlineCode",{parentName:"p"},"importer.jsligo"),"\nthat imports all definitions from ",(0,o.kt)("inlineCode",{parentName:"p"},"imported.jsligo")," as the module\n",(0,o.kt)("inlineCode",{parentName:"p"},"EURO"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=importer",group:"importer"},'#import "gitlab-pages/docs/language-basics/src/modules/imported.jsligo" "EURO"\n\ntype storage = EURO.t;\n\n@entry\nconst main = (_action: unit, store: storage): [list<operation>, storage] =>\n  [list([]), EURO.add(store, EURO.one)];\n'))),(0,o.kt)("p",null,"We can compile the file that uses the ",(0,o.kt)("inlineCode",{parentName:"p"},"#import")," statement directly,\nwithout having to mention the imported file."),(0,o.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"ligo compile contract --library . gitlab-pages/docs/language-basics/src/modules/importer.mligo\n"))),(0,o.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"ligo compile contract --library . gitlab-pages/docs/language-basics/src/modules/importer.jsligo\n"))),(0,o.kt)("h2",{id:"module-aliases"},"Module Aliases"),(0,o.kt)("p",null,"LIGO supports module aliases, that is, modules that work as synonyms\nto other (previously defined) modules. This feature can be useful if\nwe could implement a module using a previously defined one, but in the\nfuture, we might need to change it."),(0,o.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=EURO",group:"EURO"},"module US_DOLLAR = EURO\n"))),(0,o.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=EURO",group:"EURO"},"import US_DOLLAR = EURO;\n"))),(0,o.kt)("h2",{id:"modules-as-contracts"},"Modules as Contracts"),(0,o.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("p",null,"When a module contains declarations that are tagged with the attribute\n",(0,o.kt)("inlineCode",{parentName:"p"},"@entry"),", then a contract can be obtained from such module. All\ndeclarations in the module tagged as ",(0,o.kt)("inlineCode",{parentName:"p"},"@entry")," are grouped, and a\ndispatcher contract is generated."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=contract",group:"contract"},"module C = struct\n  [@entry] let increment (p : int) (s : int) : operation list * int = [], s + p\n  [@entry] let decrement (p : int) (s : int) : operation list * int = [], s - p\nend\n"))),(0,o.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("p",null,"When a module contains declarations that are tagged with the ",(0,o.kt)("inlineCode",{parentName:"p"},"@entry"),"\ndecorator, then a contract can be obtained from such module. All\ndeclarations in the module tagged as ",(0,o.kt)("inlineCode",{parentName:"p"},"@entry")," are grouped, and a\ndispatcher contract is generated."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=contract",group:"contract"},"namespace C {\n  @entry\n  const increment = (p : int, s : int) : [list<operation>, int] => [list([]), s + p];\n  @entry\n  const decrement = (p : int, s : int) : [list<operation>, int] => [list([]), s - p];\n};\n"))),(0,o.kt)("p",null,"A module can be compiled as a contract using ",(0,o.kt)("inlineCode",{parentName:"p"},"-m"),":"),(0,o.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"ligo compile contract gitlab-pages/docs/language-basics/src/modules/contract.mligo -m C\n"))),(0,o.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"ligo compile contract gitlab-pages/docs/language-basics/src/modules/contract.jsligo -m C\n"))),(0,o.kt)("p",null,"To access the contract from the module, the primitive ",(0,o.kt)("inlineCode",{parentName:"p"},"contract_of"),"\ncan be used. The type of the parameter generated for the module can be\nobtaining using the primitive ",(0,o.kt)("inlineCode",{parentName:"p"},"parameter_of"),". This is particularly\nuseful when working with the testing framework, in conjunction with the\nfunction ",(0,o.kt)("inlineCode",{parentName:"p"},"Test.originate"),":"),(0,o.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=contract",group:"contract"},"let test =\n  let orig = Test.originate (contract_of C) 0 0tez in\n  let _ = Test.transfer_exn orig.addr (Increment 42) 0tez\n  in assert (42 = Test.get_storage orig.addr)\n"))),(0,o.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=contract",group:"contract"},"const test = do {\n  let orig = Test.originate(contract_of(C), 0, 0tez);\n  Test.transfer_exn(orig.addr, (Increment (42)), 1mutez);\n  return assert(Test.get_storage(orig.addr) == 42);\n};\n"))),(0,o.kt)("h2",{id:"module-inclusion"},"Module Inclusion"),(0,o.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},"When writing a new version of a given contract derived from a module, it is often needed to add new features, that is, new types and values, for example when implementing the next version of a standard. This can be achieved by defining a new module that includes the types and values of the old one, and defines new ones.",(0,o.kt)("p",null,"The inclusion of a module ",(0,o.kt)("inlineCode",{parentName:"p"},"M")," is specified with a field ",(0,o.kt)("inlineCode",{parentName:"p"},"include M"),",\nlike so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=contract",group:"contract"},"module FA0 = struct\n  type t = unit\n  [@entry] let transfer (_ : unit) (_ : t) : operation list * t = [], ()\nend\n\nmodule FA0Ext = struct\n  include FA0\n  [@entry] let transfer2 (a : unit) (b : t) = transfer a b\nend\n"))),(0,o.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},"This feature is not available in JsLIGO."),(0,o.kt)("h2",{id:"module-types"},"Module Types"),(0,o.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("p",null,"Until now, we dealt with implicit module types, also know as\nsignatures. Having explicitly declared module types enable abstraction\nand reusability by inclusion of signatures. Module types are defined\nlike in OCaml:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=contract2",group:"contract2"},"module type FA0_SIG = sig\n  type t\n  [@entry] val transfer : unit -> t -> operation list * t\nend\n\nmodule type FA0Ext_SIG = sig\n  include FA0_SIG\n  [@entry] val transfer2 : unit -> t -> operation list * t\nend\n")),(0,o.kt)("p",null,"Notice how ",(0,o.kt)("inlineCode",{parentName:"p"},"t")," in the type of ",(0,o.kt)("inlineCode",{parentName:"p"},"transfer2")," refers to ",(0,o.kt)("inlineCode",{parentName:"p"},"t")," in the\nsignature ",(0,o.kt)("inlineCode",{parentName:"p"},"FA0_SIG")," and remains abstract. We can now revisit the\nexamples above by constraining the module definitions with the module\ntypes:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=contract2",group:"contract2"},"module FA0 : FA0_SIG = struct\n  type t = unit\n  [@entry] let transfer (_ : unit) (_ : t) : operation list * t = [], ()\nend\n\nmodule FA0Ext : FA0Ext_SIG = struct\n  include FA0\n  [@entry] let transfer2 (a : unit) (b : t) = transfer a b\nend\n")),(0,o.kt)("p",null,"Note how module definitions must instantiate any abstract type (here\n",(0,o.kt)("inlineCode",{parentName:"p"},"FA0Impl.t"),"). Also, when a module is constrained by a signature, it\nmust implement the types and values in the latter, but no more: this\nis a filtering semantics.")),(0,o.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("p",null,"Until now, we dealt with implicit types of namespaces, also know as\ninterfaces. Having explicitly declared interface enable more\nexpressivity and type safety. Interfaces are introduced by the keyword\n",(0,o.kt)("inlineCode",{parentName:"p"},"interface")," and their bodies lists names of types and values paired\nwith their type, like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=contract2",group:"contract2"},"interface FA0_INTF {\n  type storage;\n  @entry const add : (s : int, k : storage) => [list<operation>, storage];\n}\n")),(0,o.kt)("p",null,"An interface can then be used to constrain a namespace definition,\nensuring that said namespace contains ",(0,o.kt)("em",{parentName:"p"},"at least")," the types and values\nlisted in the given interface, like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=contract2",group:"contract2"},"namespace FA0 implements FA0_INTF {\n  export type storage = int;\n  @entry const add = (s : int, k : int) : [list<operation>, int] => [list([]), s + k];\n  @entry const extra = (s : int, k : int) : [list<operation>, int] => [list([]), s - k];\n}\n")),(0,o.kt)("p",null,"Interfaces can be extended by inheritance, like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=contract2",group:"contract2"},"interface FABase_INTF {\n  type t;\n};\n\ninterface FA0_INTF extends FABase_INTF {\n  @entry const transfer : (_u : unit, s : t) => [list<operation>, t];\n};\n\ninterface FA0Ext_INTF extends FA0_INTF {\n  @entry const transfer1 : (_u : unit, s : t) => [list<operation>, t];\n};\n\ninterface FA1_INTF extends FABase_INTF {\n  @entry const transfer2 : (_u : unit, s : t) => [list<operation>, t];\n};\n")),(0,o.kt)("p",null,"Note how the abstract type ",(0,o.kt)("inlineCode",{parentName:"p"},"t")," in ",(0,o.kt)("inlineCode",{parentName:"p"},"FABase_INTF")," remains abstract."),(0,o.kt)("p",null,"It is possible to design diamond inheritance, that is, inheriting\ntwice the same base interface, like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=contract2",group:"contract2"},"interface FAAll_INTF extends FA0Ext_INTF, FA1_INTF {\n  @entry const transfer3 : (_u : unit, s : t) => [list<operation>, t];\n  @view const v1 : (_u : unit, s : t) => t;\n  @entry const opt_val? : (i : int, s : t) => [list<operation>, t];\n}\n")),(0,o.kt)("p",null,"Here, the abstract type ",(0,o.kt)("inlineCode",{parentName:"p"},"t")," was inherited twice from\n",(0,o.kt)("inlineCode",{parentName:"p"},"FABase_INTF"),". Note the ",(0,o.kt)("em",{parentName:"p"},"optional value")," ",(0,o.kt)("inlineCode",{parentName:"p"},"opt_val"),", distinghished as\nsuch by a question mark: ",(0,o.kt)("inlineCode",{parentName:"p"},"opt_val?"),". This means that a namespace\nimplementing ",(0,o.kt)("inlineCode",{parentName:"p"},"FAAll_INTF")," can choose not to implement\n",(0,o.kt)("inlineCode",{parentName:"p"},"opt_val"),". The implementation of an interface can be done as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=contract2",group:"contract2"},'namespace FAAll_wo_opt_val implements FAAll_INTF {\n  export type t = int;\n\n  @entry const transfer = (_u : unit, s : t) : [list<operation>, t] => [list([]), s];\n  @entry const transfer1 = (_u : unit, s : t) : [list<operation>, t] => [list([]), s];\n  @entry const transfer2 = (_u : unit, s : t) : [list<operation>, t] => [list([]), s];\n  @entry const transfer3 = (_u : unit, s : t) : [list<operation>, t] => [list([]), s];\n  @view const v1 = (_u : unit, s : t) : t => s;\n\n  /* "foo", "transfer4" and "v2" are not in "FAAll_INTF", but can\n     nevertheless be added here, because "implements" does not filter,\n     but only have the compiler check that the fields in the interface\n     are implemented. */\n\n  export const foo = (s : t) : t => s;\n  @entry const transfer4 = (_u : unit, s : t) : [list<operation>, t] => [list([]), s];\n  @view const v2 = (_u : unit, s : t) : t => s;\n}\n\n'))))}u.isMDXComponent=!0}}]);