"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[69680],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>u});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},y={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),d=p(n),u=r,m=d["".concat(l,".").concat(u)]||d[u]||y[u]||s;return n?a.createElement(m,o(o({ref:t},c),{},{components:n})):a.createElement(m,o({ref:t},c))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,o=new Array(s);o[0]=d;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:r,o[1]=i;for(var p=2;p<s;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},48720:(e,t,n)=>{n.d(t,{D:()=>r.Z,Z:()=>s});var a=n(67294),r=n(75402);const s=function(e){return a.createElement(r.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},99874:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var a=n(87462),r=(n(67294),n(3905)),s=n(48720);const o={id:"types",title:"Data types"},i=void 0,l={unversionedId:"data-types/types",id:"data-types/types",title:"Data types",description:"LIGO is strongly and statically typed.",source:"@site/../docs/data-types/types.md",sourceDirName:"data-types",slug:"/data-types/types",permalink:"/previews/ligo/external-link-icon/docs/next/data-types/types",draft:!1,tags:[],version:"current",frontMatter:{id:"types",title:"Data types"},sidebar:"docs",previous:{title:"Keywords",permalink:"/previews/ligo/external-link-icon/docs/next/syntax/keywords"},next:{title:"Type annotations",permalink:"/previews/ligo/external-link-icon/docs/next/data-types/type-annotations"}},p={},c=[{value:"Built-in types",id:"built-in-types",level:2},{value:"Type aliases",id:"type-aliases",level:2},{value:"Custom types",id:"custom-types",level:2}],y={toc:c};function d(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},y,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"LIGO is strongly and statically typed.")),(0,r.kt)("p",null,"This means that the LIGO compiler must know what type each variable is to compile to Michelson, which is also strongly and statically typed.\nThe compiler also uses type information to check how contracts process data, ensuring that each function's expectations are met.\nIf it passes the test, your contract will not fail at run-time due to some inconsistent assumptions on your data.\nThis test is called ",(0,r.kt)("em",{parentName:"p"},"type checking"),"."),(0,r.kt)("p",null,"LIGO types are built on top of Michelson's type system, so there are many similarities but not a one-to-one match between LIGO types and Michelson types.\nFor information on Michelson types, see ",(0,r.kt)("a",{parentName:"p",href:"https://octez.tezos.com/docs/active/michelson.html"},"Michelson: the language of Smart Contracts in Tezos")," in the Octez documentation."),(0,r.kt)("p",null,"Types and type annotations work in a way similar to TypeScript and OCaml; see ",(0,r.kt)("a",{parentName:"p",href:"./type-annotations"},"Type annotations"),"."),(0,r.kt)("h2",{id:"built-in-types"},"Built-in types"),(0,r.kt)("p",null,"For reference, you can find all the LIGO built-in types ",(0,r.kt)("a",{parentName:"p",href:"https://gitlab.com/ligolang/ligo/-/blob/dev/src/main/build/ligo_lib/std_lib.mligo#L1-33"},"here"),"."),(0,r.kt)("h2",{id:"type-aliases"},"Type aliases"),(0,r.kt)("p",null,"You can create aliases for types to give them more precise names, which can increase readability and maintainability of your code.\nThe following example creates an alias of the string type named ",(0,r.kt)("inlineCode",{parentName:"p"},"breed")," to indicate variables that describe animal breeds.\nThen it creates a function that accepts variables of that type:"),(0,r.kt)(s.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=a",group:"a"},'type breed = string\nlet dog_breed_1 : breed = "Saluki"\nlet dog_breed_2 : string = "Shiba Inu"\n\nlet greet_dogs (dogs : breed list) : string =\n  List.fold (fun (a, b : breed * breed) -> String.concats [a; ", "; b]) dogs "Hello"\n\nlet greeting = greet_dogs [dog_breed_1; dog_breed_2]\n'))),(0,r.kt)(s.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=a",group:"a"},'type breed = string;\nconst dog_breed_1: breed = "Saluki";\nconst dog_breed_2: string = "Shiba Inu";\n\nconst greet_dogs = (dogs: list<breed>): string =>\n  List.fold(([a, b]: [breed, breed]) => String.concats([a, ", ", b]), dogs, "Hello");\n'))),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Type aliases are not separate types.\nTypes and their aliases are interchangeable.\nAs shown in the previous example, you can pass any string to a function that accepts an alias of a string type.")),(0,r.kt)("h2",{id:"custom-types"},"Custom types"),(0,r.kt)("p",null,"You can create custom types with the ",(0,r.kt)("inlineCode",{parentName:"p"},"type")," keyword.\nThen you can use those types in other places, as in this example, which creates a type to represent a map that uses addresses as keys and amounts of tez as values:"),(0,r.kt)(s.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=b",group:"b"},'type account_balances = (address, tez) map\n\nlet ledger : account_balances =\n  Map.literal\n    [(("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx" : address), 10mutez)]\n'))),(0,r.kt)(s.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=b",group:"b"},'type account_balances = map<address, tez>;\n\nconst ledger : account_balances =\n  Map.literal([["tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx" as address, 10 as mutez]]);\n'))))}d.isMDXComponent=!0}}]);