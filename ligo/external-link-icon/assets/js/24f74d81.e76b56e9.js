"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[36534],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>d});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var r=a.createContext({}),p=function(e){var t=a.useContext(r),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(r.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,l=e.originalType,r=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),c=p(n),d=i,h=c["".concat(r,".").concat(d)]||c[d]||u[d]||l;return n?a.createElement(h,s(s({ref:t},m),{},{components:n})):a.createElement(h,s({ref:t},m))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=n.length,s=new Array(l);s[0]=c;var o={};for(var r in t)hasOwnProperty.call(t,r)&&(o[r]=t[r]);o.originalType=e,o.mdxType="string"==typeof e?e:i,s[1]=o;for(var p=2;p<l;p++)s[p]=n[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},48720:(e,t,n)=>{n.d(t,{D:()=>i.Z,Z:()=>l});var a=n(67294),i=n(75402);const l=function(e){return a.createElement(i.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},49988:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>c,frontMatter:()=>s,metadata:()=>r,toc:()=>m});var a=n(87462),i=(n(67294),n(3905)),l=n(48720);const s={title:"Lists"},o=void 0,r={unversionedId:"data-types/lists",id:"data-types/lists",title:"Lists",description:"Lists are linear collections of elements of the same type.",source:"@site/../docs/data-types/lists.md",sourceDirName:"data-types",slug:"/data-types/lists",permalink:"/previews/ligo/external-link-icon/docs/next/data-types/lists",draft:!1,tags:[],version:"current",frontMatter:{title:"Lists"},sidebar:"docs",previous:{title:"Variants",permalink:"/previews/ligo/external-link-icon/docs/next/data-types/variants"},next:{title:"Records",permalink:"/previews/ligo/external-link-icon/docs/next/data-types/records"}},p={},m=[{value:"Accessing elements",id:"accessing-elements",level:2},{value:"Adding elements",id:"adding-elements",level:2},{value:"Removing elements",id:"removing-elements",level:2},{value:"Processing lists",id:"processing-lists",level:2},{value:"Looping over lists",id:"looping-over-lists",level:3},{value:"Folding lists",id:"folding-lists",level:3},{value:"Mapping lists",id:"mapping-lists",level:3},{value:"Updating elements",id:"updating-elements",level:3},{value:"Iterating over lists",id:"iterating-over-lists",level:3}],u={toc:m};function c(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Lists are linear collections of elements of the same type.\nElements can appear more than once in a list, because only their order in the collection matters.\nLists can be empty or contain any number of elements."),(0,i.kt)("p",null,"In this context, ",(0,i.kt)("em",{parentName:"p"},"linear")," means that you cannot access elements in random order.\nTo access a specific element, you must visit the elements sequentially.\nThe first element is called the ",(0,i.kt)("em",{parentName:"p"},"head"),", and the sub-list after the head is called the ",(0,i.kt)("em",{parentName:"p"},"tail"),". For those familiar with algorithmic data structure, you can think of a list a ",(0,i.kt)("em",{parentName:"p"},"stack"),", where the top is written on the left."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"One important use of lists is in the return values of contract entrypoints.\nEach entrypoint returns a tuple, of which the first component is a list of operations to run.")),(0,i.kt)("p",null,"Lists are similar to ",(0,i.kt)("a",{parentName:"p",href:"./sets"},"sets")," because they are both collections of elements of the same type.\nThe main differences between lists and sets are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Sets cannot contain duplicate entries, while lists can"),(0,i.kt)("li",{parentName:"ul"},"Sets are always automatically sorted, while you can put the elements of a list in any order and LIGO retains that order")),(0,i.kt)("p",null,'The type for lists is polymorphic, that is, parameterised by the type of the list elements, so to define a list you must specify the type of the elements.\nDevelopers say that they are defining a "list of integers", a "list of natural numbers," and so on for lists of other types.\nThis example shows how to define lists of integers, but you can create lists of any type as long as all of the elements have the same type:'),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=lists",group:"lists"},"let empty_list : int list = []\nlet my_list : int list = [1; 2; 2] (* The head is 1, the tail is [2; 2] *)\n")),(0,i.kt)("p",null,"For functions that work with lists, see the predefined ",(0,i.kt)("a",{parentName:"p",href:"../reference/list-reference/?lang=cameligo"},"module List"),".")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=lists",group:"lists"},"const empty_list: list<int> = [];\nconst my_list: list<int> = [1, 2, 2]; // The head is 1, the tail is [2, 2]\n")),(0,i.kt)("p",null,"The syntax for a literal list value is the same as for a tuple.\nTherefore, in some cases, you may need to use the ",(0,i.kt)("inlineCode",{parentName:"p"},"list")," function to cast a value to make it a list instead of a tuple.\nIn the previous example, the ",(0,i.kt)("inlineCode",{parentName:"p"},"my_list")," variable is a list because of the type annotation.\nHowever, if you assign a literal list value to a variable when the context is ambiguous, you must cast it with the ",(0,i.kt)("inlineCode",{parentName:"p"},"list")," function or else LIGO assumes that it is a tuple, as in this example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=lists",group:"lists"},"const my_literal_tuple = [1, 2, 3]; // Assumed to be a tuple\nconst my_literal_list = list([1, 2, 3]); // Casted to a list\n")),(0,i.kt)("p",null,"For functions that work with lists, see the predefined ",(0,i.kt)("a",{parentName:"p",href:"../reference/list-reference/?lang=jsligo"},"namespace List"),".")),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Because lists can contain any type of element, it can be convenient to use polymorphism to create functions that can operate on lists of any type.\nFor more information, see ",(0,i.kt)("a",{parentName:"p",href:"./parametric_types#polymorphic-functions"},"Polymorphic functions"),".")),(0,i.kt)("h2",{id:"accessing-elements"},"Accessing elements"),(0,i.kt)("p",null,"You cannot access elements directly in lists, such as getting the element with an arbitrary index.\nOne common way to access list elements is to access the first element (the head) or the rest of the elements (the tail) separately.\nLIGO provides the functions ",(0,i.kt)("inlineCode",{parentName:"p"},"List.head")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"List.tail")," to access list elements as options, as in these examples:"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=access",group:"access"},'let my_list : int list = [1; 2; 3]\nlet head_option : int option = List.head my_list\nlet head = match head_option with\n| Some value -> value\n| None -> failwith "Failed to get the head of the list"\nlet tail_option : int list option = List.tail my_list\nlet tail = match tail_option with\n| Some value -> value\n| None -> failwith "Failed to get the tail of the list"\n'))),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=access",group:"access"},'const my_list: list<int> = [1, 2, 3];\nconst head_option: option<int> = List.head(my_list);\nconst head = $match(head_option, {\n  "Some": value => value,\n  "None": () => failwith("Failed to get the head of the list"),\n});\nconst tail_option: option<list<int>> = List.tail(my_list);\nconst tail = $match(tail_option, {\n  "Some": value => value,\n  "None": () => failwith("Failed to get the tail of the list"),\n});\n')),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"In JsLIGO, you cannot access an arbitrary element in a list by its index, as in ",(0,i.kt)("inlineCode",{parentName:"p"},"my_list[4]"),"."))),(0,i.kt)("p",null,"Another way to access elements in lists is to process every element in the list, as described in ",(0,i.kt)("a",{parentName:"p",href:"#processing-lists"},"Processing lists"),"."),(0,i.kt)("h2",{id:"adding-elements"},"Adding elements"),(0,i.kt)("p",null,"You can add an element to the beginning of a list to become the new head (or, in terms of a stack, by ",(0,i.kt)("em",{parentName:"p"},"pushing an element on top"),").\nThis operation is usually called ",(0,i.kt)("em",{parentName:"p"},"consing")," in functional languages."),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The ",(0,i.kt)("em",{parentName:"p"},"cons operator"),' is infix and noted "',(0,i.kt)("inlineCode",{parentName:"p"},"::"),'". It is not symmetric: on\nthe left lies the element to cons, and, on the right, a list on which\nto cons.'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=consing",group:"consing"},"let short_list = [1; 2; 2]\n// long_list = [5; 1; 2; 2]\nlet long_list : int list = 5 :: short_list\n")),(0,i.kt)("p",null,"There is also a predefined function ",(0,i.kt)("inlineCode",{parentName:"p"},"List.cons"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=consing",group:"consing"},"// longer_list = [6; 5; 1; 2; 2]\nlet longer_list = List.cons 6 long_list\n"))),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The ",(0,i.kt)("em",{parentName:"p"},"cons operator"),' is infix and noted "',(0,i.kt)("inlineCode",{parentName:"p"},", ..."),'". It is not symmetric:\non the left lies the element to cons, and, on the right, a list on\nwhich to cons.'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=consing",group:"consing"},"const short_list: list<int> = [1, 2, 2];\n// long_list == [5,1,2,2]\nconst long_list: list<int> = [5, ...short_list];\n")),(0,i.kt)("p",null,"There is also a predefined function ",(0,i.kt)("inlineCode",{parentName:"p"},"List.cons"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=consing",group:"consing"},"// longer_list == [6, 5, 1, 2, 2]\nconst longer_list = List.cons(6, long_list);\n"))),(0,i.kt)("h2",{id:"removing-elements"},"Removing elements"),(0,i.kt)("p",null,"There is no direct way to remove a specific element from a list.\nYou can use loops and the other functions listed below to process a list and filter elements out.\nFor example, you can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"List.update_with")," function to remove certain elements as described in ",(0,i.kt)("a",{parentName:"p",href:"#updating-elements"},"Updating elements"),"."),(0,i.kt)("p",null,"If you need to add and remove elements frequently, consider using a ",(0,i.kt)("a",{parentName:"p",href:"./sets"},"set"),".\nSets have a dedicated ",(0,i.kt)("inlineCode",{parentName:"p"},"Set.remove")," function that removes elements."),(0,i.kt)("h2",{id:"processing-lists"},"Processing lists"),(0,i.kt)("p",null,"Aside from retrieving the head and tail of a list, you can use loops and functions that iterate over every element in a list."),(0,i.kt)("h3",{id:"looping-over-lists"},"Looping over lists"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"There is no loop over lists in CameLIGO.")),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"You can use a ",(0,i.kt)("inlineCode",{parentName:"p"},"for")," loop to iterate over the elements in the list, from left to right, in the form ",(0,i.kt)("inlineCode",{parentName:"p"},"for (const <variable> of <list>) <block>"),".\nThis statement means that the block of statements (or a single statement) runs once for each element in the list (",(0,i.kt)("inlineCode",{parentName:"p"},"<variable>"),") ranging over the elements of the list from left to right."),(0,i.kt)("p",null,"This example uses a ",(0,i.kt)("inlineCode",{parentName:"p"},"for")," loop to get the sum of the integers in a list:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=list_looping",group:"list_looping"},"function sum_list (l: list<int>) {\n  let sum = 0;\n  for (const i of l) sum = sum + i;\n  return sum;\n};\n"))),(0,i.kt)("h3",{id:"folding-lists"},"Folding lists"),(0,i.kt)("p",null,"Folding a list runs the same function on each element in a list and returns a single value.\nThe function takes two arguments: an ",(0,i.kt)("em",{parentName:"p"},"accumulator")," and the current list element, with which it produces a new accumulator to pass to the next iteration of the function.\nFolding lists allows you to compute a partial result that becomes complete when the traversal of the data structure is over."),(0,i.kt)("p",null,"The fold functions ",(0,i.kt)("inlineCode",{parentName:"p"},"List.fold_left")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"List.fold_right")," take the same three parameters ",(0,i.kt)("strong",{parentName:"p"},"in different orders"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The function to run on each element, which receives a tuple containing the accumulator and the current element"),(0,i.kt)("li",{parentName:"ul"},"The initial value for the accumulator"),(0,i.kt)("li",{parentName:"ul"},"The list of elements to fold")),(0,i.kt)("p",null,"Both functions take the function to run first.\nThe ",(0,i.kt)("inlineCode",{parentName:"p"},"fold_left")," function takes the initial value second and the list to fold last, while the ",(0,i.kt)("inlineCode",{parentName:"p"},"fold_right")," function takes the list to fold second and the initial value last."),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"These fold functions have these forms:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"List.fold_left fold_function initial_value list\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"List.fold_right fold_function list initial_value\n")),(0,i.kt)("p",null,"In this way, you can fold lists from left to right or right to left."),(0,i.kt)("p",null,"One way to tell them apart is to look where the folded function, and the fold itself, keep the accumulator in their signatures. Take for example a function ",(0,i.kt)("inlineCode",{parentName:"p"},"f"),", a list ",(0,i.kt)("inlineCode",{parentName:"p"},"[1; 2; 3]"),", and an initial accumulator ",(0,i.kt)("inlineCode",{parentName:"p"},"init"),".\nThen the ",(0,i.kt)("inlineCode",{parentName:"p"},"fold_left")," function is equivalent to:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"List.fold_left f init [1; 2; 3] = f (f (f (init, 1), 2), 3)\n")),(0,i.kt)("p",null,"And the ",(0,i.kt)("inlineCode",{parentName:"p"},"fold_right")," function is equivalent to:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"List.fold_right f [1; 2; 3] init = f (1, f (2, f (3, init)))\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The type of ",(0,i.kt)("inlineCode",{parentName:"p"},"List.fold_left")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"('a * 'b -> 'a) -> 'a -> 'b list\n-> 'a"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The type of ",(0,i.kt)("inlineCode",{parentName:"p"},"List.fold_right")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"('b * 'a -> 'a) -> 'b list ->\n'a -> 'a"),"."))),(0,i.kt)("p",null,"For example, here are two ways to compute the sum of integers in a list, assuming that the empty list yields ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=folding_lists",group:"folding_lists"},"let sum1 = List.fold_left (fun (a, i) -> a + i) 0 [1; 2; 3]\nlet sum2 = List.fold_right (fun (i, a) -> i + a) [1; 2; 3] 0\n")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"For OCaml users: In OCaml, the folded functions are curryfied, so their types are ",(0,i.kt)("inlineCode",{parentName:"p"},"('a -> 'b -> 'a)")," ",(0,i.kt)("inlineCode",{parentName:"p"},"List.fold_left"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"('b -> 'a -> 'a)")," with ",(0,i.kt)("inlineCode",{parentName:"p"},"List.fold_right"),"."))),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"These folds have these forms:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"List.fold_left (folded, init, list)\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"List.fold_right (folded, list, init)\n")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"List.fold_left")," function is similar to the JavaScript ",(0,i.kt)("inlineCode",{parentName:"p"},"reduce")," function, but note the order of the parameters.")),(0,i.kt)("p",null,"In this way, you can fold lists from left to right or right to left."),(0,i.kt)("p",null,"One way to tell them apart is to look where the folded function, and the fold itself, keep the accumulator in their signatures. Take for example a function ",(0,i.kt)("inlineCode",{parentName:"p"},"f"),", a list ",(0,i.kt)("inlineCode",{parentName:"p"},"[1, 2, 3]"),", and an initial accumulator ",(0,i.kt)("inlineCode",{parentName:"p"},"init"),". Then"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"List.fold_left (f, init, [1;2;3]) = f (f (f (init, 1), 2), 3)\n")),(0,i.kt)("p",null,"and"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"List.fold_right (f, [1;2;3], init) = f (1, (f (2, (f (3, init)))))\n")),(0,i.kt)("p",null,"The type of ",(0,i.kt)("inlineCode",{parentName:"p"},"List.fold_left")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"(p : [a * b => a, a, b list]) => a"),"."),(0,i.kt)("p",null,"The type of ",(0,i.kt)("inlineCode",{parentName:"p"},"List.fold_right")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"(p : [b * a => a, b list, a]) => a"),"."),(0,i.kt)("p",null,"For example, here are two ways to compute the sum of integers in a list, assuming that the empty list yields ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=folding_lists",group:"folding_lists"},"const add1 = ([a, i]) => a + i;\nconst sum1 = List.fold_left(add1, 0, [1, 2, 3]);\nconst add2 = ([i, a]) => i + a;\nconst sum2 = List.fold_right(add2, [1, 2, 3], 0);\n"))),(0,i.kt)("h3",{id:"mapping-lists"},"Mapping lists"),(0,i.kt)("p",null,"Mapping a list runs the same function on each element in a list and returns a new list with the result of each function operation.\nThis is called a ",(0,i.kt)("em",{parentName:"p"},"map operation"),", not to be confused with the map data type.\nTo map a list, use the ",(0,i.kt)("inlineCode",{parentName:"p"},"List.map")," function, as in this example:"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=map_lists",group:"map_lists"},"let plus_one = List.map (fun i -> i + 1) [6; 2; 3; 3]\n"))),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=map_lists",group:"map_lists"},"const plus_one = List.map(i => i + 1, [6, 2, 3, 3]);\n"))),(0,i.kt)("h3",{id:"updating-elements"},"Updating elements"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"List.update_with")," function runs a function on each element in the list and if that function returns true, the element is replaced with a specified value.\nIf it returns false, the element remains.\nThis example takes a list of numbers and changes all of the even numbers to zero without changing the odd numbers:"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=list_updating",group:"list_updating"},"let nats = [0; 1; 2; 3; 4]\nlet evens_zeroed = List.update_with (fun x -> x mod 2 = 0n) 0 nats\n// evens_zeroed = [0; 1; 0; 3; 0]\n"))),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=list_updating",group:"list_updating"},"const nats: list<int> = [0, 1, 2, 3, 4];\nconst evens_zeroed = List.update_with(x => x % 2 == (0 as nat), 0, nats);\n// evens_zeroed == [0, 1, 0, 3, 0]\n"))),(0,i.kt)("p",null,"The function ",(0,i.kt)("inlineCode",{parentName:"p"},"List.update")," is similar, but it replaces elements based on an option value.\nIf the function you pass to it returns ",(0,i.kt)("inlineCode",{parentName:"p"},"Some"),", the value of that option becomes the new value of the element.\nIf it returns ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),", the value of the element stays the same.\nThis example takes a list of numbers and changes all of the even numbers to their square without changing the odd numbers:"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=list_updating",group:"list_updating"},"let f x = if x mod 2 = 0n then None else Some (x*x)\nlet odds_squared = List.update f nats\n// odds_squared = [0; 1; 2; 9; 4]\n"))),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"That function takes an element and returns an optional value: if that\nvalue is ",(0,i.kt)("inlineCode",{parentName:"p"},"None()"),", then the element is left unchanged, otherwise, if\nthe value is ",(0,i.kt)("inlineCode",{parentName:"p"},"Some(v)"),", then the element is replaced in the resulting\nlist by ",(0,i.kt)("inlineCode",{parentName:"p"},"v"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=list_updating",group:"list_updating"},'const f = x =>\n  x % 2 == (0 as nat) ? ["None" as "None"] : ["Some" as "Some", x*x];\nconst odds_squared = List.update(f, nats);\n// odds_squared == [0, 1, 2, 9, 4]\n'))),(0,i.kt)("h3",{id:"iterating-over-lists"},"Iterating over lists"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"List.iter")," function is similar to the ",(0,i.kt)("inlineCode",{parentName:"p"},"List.map")," function because it runs the same function on every element in a list.\nHowever, the ",(0,i.kt)("inlineCode",{parentName:"p"},"List.iter")," function returns a value of type unit, so it cannot change the list.\nTherefore, this function is useful only to produce side effects, such as checking that each element of a list is within a certain range, and fail with an error otherwise."),(0,i.kt)("p",null,"This example iterates over a list to check that all its elements (integers) are greater than 3:"),(0,i.kt)(l.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=list_iterating",group:"list_iterating"},"let assert_all_greater_than_3 (l : int list) : unit =\n  List.iter (fun i -> Assert.assert (i > 3)) l\n"))),(0,i.kt)(l.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=list_iterating",group:"list_iterating"},"const assert_all_greater_than_3 =\n  (l: list<int>): unit => List.iter(i => Assert.assert(i > 3), l);\n"))))}c.isMDXComponent=!0}}]);