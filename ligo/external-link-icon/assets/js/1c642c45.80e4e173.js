"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[81121],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>g});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),u=p(n),g=o,d=u["".concat(s,".").concat(g)]||u[g]||c[g]||r;return n?a.createElement(d,i(i({ref:t},m),{},{components:n})):a.createElement(d,i({ref:t},m))}));function g(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var p=2;p<r;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},48720:(e,t,n)=>{n.d(t,{D:()=>o.Z,Z:()=>r});var a=n(67294),o=n(75402);const r=function(e){return a.createElement(o.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},88839:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>m});var a=n(87462),o=(n(67294),n(3905)),r=n(48720);const i={id:"compiling",title:"Compiling contracts"},l=void 0,s={unversionedId:"compiling/compiling",id:"compiling/compiling",title:"Compiling contracts",description:"You must compile LIGO contracts to Michelson before deploying them.",source:"@site/../docs/compiling/compiling.md",sourceDirName:"compiling",slug:"/compiling/",permalink:"/previews/ligo/external-link-icon/docs/next/compiling/",draft:!1,tags:[],version:"current",frontMatter:{id:"compiling",title:"Compiling contracts"},sidebar:"docs",previous:{title:"Preprocessor",permalink:"/previews/ligo/external-link-icon/docs/next/compiling/preprocessor"},next:{title:"Deploying contracts",permalink:"/previews/ligo/external-link-icon/docs/next/compiling/deploying"}},p={},m=[{value:"Compiling contracts",id:"compiling-contracts",level:2},{value:"Compiling storage",id:"compiling-storage",level:2},{value:"Compiling parameters",id:"compiling-parameters",level:2},{value:"Compiling expressions",id:"compiling-expressions",level:2}],c={toc:m};function u(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"You must compile LIGO contracts to Michelson before deploying them.\nLIGO can also help you compile the initial storage value for a contract and parameters for calls to contracts."),(0,o.kt)("h2",{id:"compiling-contracts"},"Compiling contracts"),(0,o.kt)("p",null,"To compile a LIGO contract, make sure that LIGO is installed as described in ",(0,o.kt)("a",{parentName:"p",href:"../intro/installation"},"Installation"),".\nThen, pass the source file to the ",(0,o.kt)("inlineCode",{parentName:"p"},"ligo compile contract")," command."),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("p",null,"For example, this command compiles a contract that is at the root level of a source file named ",(0,o.kt)("inlineCode",{parentName:"p"},"my_contract.mligo")," and writes it to the file ",(0,o.kt)("inlineCode",{parentName:"p"},"my_contract.tz"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"ligo compile contract my_contract.mligo -o my_contract.tz\n"))),(0,o.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("p",null,"For example, this command compiles a contract that is at the root level of a source file named ",(0,o.kt)("inlineCode",{parentName:"p"},"my_contract.jsligo")," and writes it to the file ",(0,o.kt)("inlineCode",{parentName:"p"},"my_contract.tz"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"ligo compile contract my_contract.jsligo -o my_contract.tz\n"))),(0,o.kt)("p",null,"If the contract is in a module, pass the name of the module to the ",(0,o.kt)("inlineCode",{parentName:"p"},"-m")," argument, as in this example:"),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"ligo compile contract my_contract.mligo -m MyModule -o my_contract.tz\n"))),(0,o.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"ligo compile contract my_contract.jsligo -m MyModule  -o my_contract.tz\n"))),(0,o.kt)("p",null,"Now you can deploy (originate) the contract; see ",(0,o.kt)("a",{parentName:"p",href:"./deploying"},"Deploying contracts"),"."),(0,o.kt)("p",null,"For more information about the ",(0,o.kt)("inlineCode",{parentName:"p"},"ligo compile contract")," command, see ",(0,o.kt)("a",{parentName:"p",href:"../manpages/compile%20contract"},(0,o.kt)("inlineCode",{parentName:"a"},"compile contract")),"."),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"The ",(0,o.kt)("inlineCode",{parentName:"p"},"ligo compile contract")," command does not automatically run tests in the source file.\nTo run tests, use the ",(0,o.kt)("inlineCode",{parentName:"p"},"ligo run test")," command as described in ",(0,o.kt)("a",{parentName:"p",href:"../testing"},"Testing"),".")),(0,o.kt)("h2",{id:"compiling-storage"},"Compiling storage"),(0,o.kt)("p",null,"When you originate a contract, you set the initial value of the contract storage as a Michelson value.\nThe ",(0,o.kt)("inlineCode",{parentName:"p"},"ligo compile storage")," command compiles LIGO expressions to Michelson expressions that you can use for the initial value of the storage."),(0,o.kt)("p",null,"For example, this contract has a complex storage type that includes two records and an address:"),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=compile_storage",group:"compile_storage"},"module ComplexStorage = struct\n  type my_record = {\n    x: int;\n    y: int;\n    z: int;\n  }\n  type my_labels = {\n    a: string;\n    b: string;\n    c: string;\n  }\n  type storage = (my_record * my_labels * address)\n  type return_type = operation list * storage\n\n  [@entry]\n  let noop (_u : unit) (storage : storage) : return_type = [], storage\n\nend\n")),(0,o.kt)("p",null,"To compile an initial storage value for this contract, create a CameLIGO expression of the storage type and pass it to the ",(0,o.kt)("inlineCode",{parentName:"p"},"ligo compile storage")," command, as in this example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'ligo compile storage -m ComplexStorage complexStorage.mligo \\\n  \'{x = 1; y = 2; z = 3}, {a = "A"; b = "B"; c = "C"}, ("tz1QCVQinE8iVj1H2fckqx6oiM85CNJSK9Sx" : address)\'\n'))),(0,o.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=compile_storage",group:"compile_storage"},"namespace ComplexStorage {\n  type my_record = {\n    x: int,\n    y: int,\n    z: int,\n  };\n\n  type my_labels = {\n    a: string,\n    b: string,\n    c: string,\n  };\n\n  type storage = [my_record, my_labels, address];\n  type return_type = [list<operation>, storage];\n\n  // @entry\n  const noop = (_u: unit, storage: storage): return_type => [[], storage];\n}\n")),(0,o.kt)("p",null,"To compile an initial storage value for this contract, create a JsLIGO expression of the storage type and pass it to the ",(0,o.kt)("inlineCode",{parentName:"p"},"ligo compile storage")," command, as in this example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'ligo compile storage -m ComplexStorage complexStorage.jsligo \\\n  \'[{x: 1, y: 2, z: 3}, {a: "A", b: "B", c: "C"}, "tz1QCVQinE8iVj1H2fckqx6oiM85CNJSK9Sx" as address]\'\n'))),(0,o.kt)("p",null,"The result is a Michelson expression that you can use as the initial storage value:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-michelson"},'(Pair (Pair 1 2 3) (Pair "A" "B" "C") "tz1QCVQinE8iVj1H2fckqx6oiM85CNJSK9Sx")\n')),(0,o.kt)("p",null,"If you deploy a contract with the ",(0,o.kt)("inlineCode",{parentName:"p"},"octez-client originate contract")," command, you can pass this expression as the value of the ",(0,o.kt)("inlineCode",{parentName:"p"},"--init")," argument, as in this example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'octez-client originate contract ComplexStorage \\\n  transferring 0 from my_wallet running ComplexStorage.tz \\\n  --init \'(Pair (Pair 1 2 3) (Pair "A" "B" "C") "tz1QCVQinE8iVj1H2fckqx6oiM85CNJSK9Sx")\' --burn-cap 2\n')),(0,o.kt)("p",null,"For more information about the ",(0,o.kt)("inlineCode",{parentName:"p"},"ligo compile storage")," command, see ",(0,o.kt)("a",{parentName:"p",href:"../manpages/compile%20storage"},(0,o.kt)("inlineCode",{parentName:"a"},"compile storage")),"."),(0,o.kt)("h2",{id:"compiling-parameters"},"Compiling parameters"),(0,o.kt)("p",null,"If you have the source code of a LIGO contract, you can use the ",(0,o.kt)("inlineCode",{parentName:"p"},"ligo compile parameter")," command to compile the parameter that another contract or client can use to call it."),(0,o.kt)("p",null,"For example, this contract has an entrypoint that accepts a complex parameter:"),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=compile_param",group:"compile_param"},"module ComplexParam = struct\n  type storage = int\n  type return_type = operation list * storage\n  type paramType = (int list * int list * (string * string))\n\n  let sum_fold = fun (result, i: int * int) -> result + i\n  let mult_fold = fun (result, i: int * int) -> result * i\n\n  [@entry]\n  let complexmath (param : paramType) (_s : storage) : return_type =\n    let list1, list2, str_tuple = param in\n    let sum : int = List.fold sum_fold list1 0 in\n    let product : int = List.fold mult_fold list2 1 in\n    let str1, str2 = str_tuple in\n    let string_diff : int = String.length(str2) - String.length(str1) in\n    let newVal = (sum + product) * string_diff in\n    [], newVal\n\nend\n")),(0,o.kt)("p",null,"To compile a parameter to call this contract, create a CameLIGO expression for the parameter and pass it and the entrypoint name to the ",(0,o.kt)("inlineCode",{parentName:"p"},"ligo compile parameter")," command, as in this example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'ligo compile parameter -m ComplexParam ComplexParam.mligo \'Complexmath([1; 2; 3], [2; 2; 1], ("three", "fifteen"))\'\n'))),(0,o.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=compile_param",group:"compile_param"},"namespace ComplexParam {\n  type storage = int;\n  type returnType = [list<operation>, storage];\n  type paramType = [list<int>, list<int>, [string, string]];\n\n  const sum_fold = ([result, i]: [int, int]): int => result + i;\n  const mult_fold = ([result, i]: [int, int]): int => result * i;\n\n  // @entry\n  function complexmath (param: paramType, _s: storage): returnType {\n    const [list1, list2, str_tuple] = param;\n    const sum: int = List.fold(sum_fold, list1, 0);\n    const product: int = List.fold(mult_fold, list2, 1);\n    const [str1, str2] = str_tuple;\n    const string_diff: int = String.length(str2) - String.length(str1);\n    const newVal = (sum + product) * string_diff;\n    return [[], newVal];\n  }\n\n}\n")),(0,o.kt)("p",null,"To compile a parameter to call this contract, create a JsLIGO expression for the parameter and pass it and the entrypoint name to the ",(0,o.kt)("inlineCode",{parentName:"p"},"ligo compile parameter")," command, as in this example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'ligo compile parameter ComplexParam.jsligo -m ComplexParam\n\'["Complexmath" as "Complexmath", ([[1, 2, 3], [2, 2, 1], ["three", "fifteen"]])]\'\n'))),(0,o.kt)("p",null,"The result is a Michelson expression that represents passing the value to the entrypoint:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-michelson"},'(Pair { 1 ; 2 ; 3 } { 2 ; 2 ; 1 } "three" "fifteen")\n')),(0,o.kt)("p",null,"You can use this expression as the parameter to call the contract, as in this example:"),(0,o.kt)("p",null,"If you deploy a contract with the ",(0,o.kt)("inlineCode",{parentName:"p"},"octez-client originate contract")," command, you can pass this expression as the value of the ",(0,o.kt)("inlineCode",{parentName:"p"},"--init")," argument, as in this example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'octez-client transfer 0 from my_wallet to ComplexParam \\\n  --arg \'(Pair { 1 ; 2 ; 3 } { 2 ; 2 ; 1 } "three" "fifteen")\' \\\n  --burn-cap 1\n')),(0,o.kt)("p",null,"For more information about the ",(0,o.kt)("inlineCode",{parentName:"p"},"ligo compile parameter")," command, see ",(0,o.kt)("a",{parentName:"p",href:"../manpages/compile%20parameter"},(0,o.kt)("inlineCode",{parentName:"a"},"compile parameter")),"."),(0,o.kt)("h2",{id:"compiling-expressions"},"Compiling expressions"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"ligo compile expression")," command is more general than the ",(0,o.kt)("inlineCode",{parentName:"p"},"ligo compile parameter")," command because it does not take any source file into account.\nInstead, it compiles a single LIGO expression to Michelson using only the information you provide to the command, which means that you must provide information like type annotations and the syntax to use."),(0,o.kt)("p",null,"One use of this command is to compile the parameter for a view, which you can not do with the ",(0,o.kt)("inlineCode",{parentName:"p"},"ligo compile parameter")," command.\nFor example, this contract has a view that accepts a complex parameter with multiple numbers and does some math on them:"),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=complexview",group:"complexview"},"type storage_type = int\ntype return_type = operation list * storage_type\n\ntype view_param =\n  int list\n  * int set\n  * int option\n\nmodule Counter = struct\n\n  [@entry]\n  let add (value : int) (storage : storage_type) : return_type =\n    [], storage + value\n\n  [@entry]\n  let sub (value : int) (storage : storage_type) : return_type =\n    [], storage - value\n\n  [@view]\n  let math (param : view_param) (storage : storage_type) : int =\n    let intList, intSet, intOption = param in\n\n    (* Get the sum of the ints in the list *)\n    let listSum = List.fold_left (fun (a, b) -> a + b) 0 intList in\n\n    (* Multiply by the sum of the ints in the set *)\n    let setSum = Set.fold (fun (a, b) -> a + b) intSet 0 in\n    let returnValue = listSum * setSum in\n\n    (* If the option int was provided, subtract it *)\n    match intOption with\n      None -> storage + returnValue\n    | Some value -> storage + returnValue - value\nend\n"))),(0,o.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=complexview",group:"complexview"},'type storage_type = int;\ntype return_type = [list<operation>, storage_type];\n\ntype view_param = [\n  list<int>,\n  [int, int, int],\n  option<int>,\n];\n\nclass Counter {\n\n  @entry\n  add = (value: int, storage: storage_type): return_type =>\n    [[], storage + value];\n\n  @entry\n  sub = (value: int, storage: storage_type): return_type =>\n    [[], storage - value];\n\n  @view\n  math = (param: view_param, storage: storage_type): int => {\n    const [intList, intSet, intOption] = param;\n\n    // Get the sum of the ints in the list\n    let listSum = 0;\n    for (const i of intList) listSum = listSum + i;\n\n    // Multiply by the sum of the ints in the set\n    const [a, b, c] = intSet;\n    const setSum = a + b + c;\n    let returnValue = listSum * setSum;\n\n    // If the option int was provided, subtract it\n    return $match(intOption, {\n      "None": () => storage + returnValue,\n      "Some": (value) => storage + returnValue - value,\n    });\n  }\n}\n'))),(0,o.kt)("p",null,"To compile the parameter to pass to the view, create an expression that matches the parameter for the view, including type annotations to ensure that the command compiles it to the correct types, as in this example:"),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'ligo2 compile expression cameligo "([1; 2; 3; 4] : int list), (Set.literal [1; 2; 3]), Some 2"\n'))),(0,o.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'ligo compile expression jsligo "[([1, 2, 3, 4]: list<int>), Set.literal([1, 2, 3]), [\\"Some\\" as \\"Some\\", 2]]"\n'))),(0,o.kt)("p",null,"The result is a Michelson expression that is the parameter for the view:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-michelson"},"(Pair { 1 ; 2 ; 3 ; 4 } { 1 ; 2 ; 3 } (Some 2))\n")),(0,o.kt)("p",null,"You can use this value as the parameter to call the view, as in this example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'octez-client run view math on contract counter with input "(Pair { 1 ; 2 ; 3 ; 4 } { 1 ; 2 ; 3 } (Some 2))"\n')))}u.isMDXComponent=!0}}]);