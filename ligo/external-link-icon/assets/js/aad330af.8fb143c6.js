"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[97579],{3905:(t,e,a)=>{a.d(e,{Zo:()=>l,kt:()=>_});var n=a(67294);function o(t,e,a){return e in t?Object.defineProperty(t,e,{value:a,enumerable:!0,configurable:!0,writable:!0}):t[e]=a,t}function r(t,e){var a=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),a.push.apply(a,n)}return a}function s(t){for(var e=1;e<arguments.length;e++){var a=null!=arguments[e]?arguments[e]:{};e%2?r(Object(a),!0).forEach((function(e){o(t,e,a[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(a,e))}))}return t}function i(t,e){if(null==t)return{};var a,n,o=function(t,e){if(null==t)return{};var a,n,o={},r=Object.keys(t);for(n=0;n<r.length;n++)a=r[n],e.indexOf(a)>=0||(o[a]=t[a]);return o}(t,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(n=0;n<r.length;n++)a=r[n],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(t,a)&&(o[a]=t[a])}return o}var c=n.createContext({}),d=function(t){var e=n.useContext(c),a=e;return t&&(a="function"==typeof t?t(e):s(s({},e),t)),a},l=function(t){var e=d(t.components);return n.createElement(c.Provider,{value:e},t.children)},p={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},u=n.forwardRef((function(t,e){var a=t.components,o=t.mdxType,r=t.originalType,c=t.parentName,l=i(t,["components","mdxType","originalType","parentName"]),u=d(a),_=o,h=u["".concat(c,".").concat(_)]||u[_]||p[_]||r;return a?n.createElement(h,s(s({ref:e},l),{},{components:a})):n.createElement(h,s({ref:e},l))}));function _(t,e){var a=arguments,o=e&&e.mdxType;if("string"==typeof t||o){var r=a.length,s=new Array(r);s[0]=u;var i={};for(var c in e)hasOwnProperty.call(e,c)&&(i[c]=e[c]);i.originalType=t,i.mdxType="string"==typeof t?t:o,s[1]=i;for(var d=2;d<r;d++)s[d]=a[d];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},46225:(t,e,a)=>{a.r(e),a.d(e,{assets:()=>c,contentTitle:()=>s,default:()=>_,frontMatter:()=>r,metadata:()=>i,toc:()=>d});var n=a(87462),o=(a(67294),a(3905));const r={title:"Part 3: Getting the payouts",pagination_next:null},s=void 0,i={unversionedId:"tutorials/taco-shop/getting-payouts",id:"tutorials/taco-shop/getting-payouts",title:"Part 3: Getting the payouts",description:"Now that the customer-facing entrypoint of the contract is ready, you can set up the administrator-related entrypoint.",source:"@site/../docs/tutorials/taco-shop/getting-payouts.md",sourceDirName:"tutorials/taco-shop",slug:"/tutorials/taco-shop/getting-payouts",permalink:"/previews/ligo/external-link-icon/docs/next/tutorials/taco-shop/getting-payouts",draft:!1,tags:[],version:"current",frontMatter:{title:"Part 3: Getting the payouts",pagination_next:null},sidebar:"docs",previous:{title:"Part 2: Testing the contract",permalink:"/previews/ligo/external-link-icon/docs/next/tutorials/taco-shop/testing-contract"}},c={},d=[{value:"Adding administrator information",id:"adding-administrator-information",level:2},{value:"Testing the new entrypoint",id:"testing-the-new-entrypoint",level:2},{value:"Conclusion",id:"conclusion",level:2}],l=(p="Syntax",function(t){return console.warn("Component "+p+" was not imported, exported, or provided by MDXProvider as global scope"),(0,o.kt)("div",t)});var p;const u={toc:d};function _(t){let{components:e,...a}=t;return(0,o.kt)("wrapper",(0,n.Z)({},u,a,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Now that the customer-facing entrypoint of the contract is ready, you can set up the administrator-related entrypoint.\nIn this case, Pedro needs a way to reset the stock of tacos and send the tez from the contract to his account.\nYou could do this in two entrypoints, but for simplicity this tutorial shows how to do both of these things in one entrypoint named ",(0,o.kt)("inlineCode",{parentName:"p"},"payout"),"."),(0,o.kt)("h2",{id:"adding-administrator-information"},"Adding administrator information"),(0,o.kt)("p",null,"Also for the sake of simplicity, the contract provides no way to change Pedro's account address after the contract is deployed.\nIn production applications, the address of the administrator should be in the contract storage and an entrypoint should allow the current administrator to change the administrator address.\nAs it is, this contract cannot change the administrator address after it is deployed, so use caution."),(0,o.kt)(l,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"In the ",(0,o.kt)("inlineCode",{parentName:"p"},"payout")," entrypoint, add this code to verify that the administrator is calling the entrypoint:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},'// Ensure that only the admin can call this entrypoint\nif (Tezos.get_sender() != storage.admin_address) {\n  failwith("Only the admin can call this entrypoint");\n}\n')),(0,o.kt)("p",{parentName:"li"},"The function ",(0,o.kt)("inlineCode",{parentName:"p"},"Tezos.get_sender")," returns the address of the account that called the smart contract.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Add this code to generate the operation that sends tez to the administrator account:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},'// Create contract object that represents the target account\nconst receiver_contract = $match(Tezos.get_contract_opt(storage.admin_address), {\n  "Some": (contract) => contract,\n  "None": () => failwith("Couldn\'t find account"),\n});\n\n// Create operation to send tez\nconst payout_operation = Tezos.Operation.transaction(unit, Tezos.get_balance(), receiver_contract);\n')),(0,o.kt)("p",{parentName:"li"},"Sending tez to a user account means treating the user account as though it is a smart contract account.\nThis way, sending tez to a user account works in the same way as sending tez to a smart contract."),(0,o.kt)("p",{parentName:"li"},"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Tezos.Operation.transaction")," function creates a Tezos transaction.\nThere are many kinds of internal transactions in Tezos, but most smart contracts deal with these transactions:"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Transferring tez to another account"),(0,o.kt)("li",{parentName:"ul"},"Calling an entrypoint on a smart contract")),(0,o.kt)("p",{parentName:"li"},"Calling an entrypoint on a smart contract (either the current contract or another contract) is beyond the scope of this tutorial.\nFor information, see ",(0,o.kt)("a",{parentName:"p",href:"../../syntax/contracts/operation#calling-a-contract"},"Calling a contract"),"."),(0,o.kt)("p",{parentName:"li"},"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Tezos.Operation.transaction")," function takes these parameters:"),(0,o.kt)("ol",{parentName:"li"},(0,o.kt)("li",{parentName:"ol"},"The parameter to pass, in this case ",(0,o.kt)("inlineCode",{parentName:"li"},"unit"),", which means no value"),(0,o.kt)("li",{parentName:"ol"},"The amount of tez to include with the transaction, in this case all of the tez the contract has, denoted by the ",(0,o.kt)("inlineCode",{parentName:"li"},"Tezos.get_balance")," function"),(0,o.kt)("li",{parentName:"ol"},"The address of the target contract"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Add this code to calculate the new value of the storage, using the existing admin address and the default taco data:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},"// Restore stock of tacos\nconst new_storage: storage = {\n  admin_address: storage.admin_address,\n  taco_data: default_taco_data,\n};\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Replace the ",(0,o.kt)("inlineCode",{parentName:"p"},"payout")," entrypoint's ",(0,o.kt)("inlineCode",{parentName:"p"},"return")," statement with this code:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},"return [[payout_operation], new_storage];\n")),(0,o.kt)("p",{parentName:"li"},"Creating the transaction is not enough to run it; you must return it in the list of operations at the end of the entrypoint."))),(0,o.kt)("p",null,"The complete entrypoint looks like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},'// @entry\nconst payout = (_u: unit, storage: storage): [\n    list<operation>,\n    storage\n  ] => {\n\n  // Ensure that only the admin can call this entrypoint\n  if (Tezos.get_sender() != storage.admin_address) {\n    failwith("Only the admin can call this entrypoint");\n  }\n\n  // Create contract object that represents the target account\n  const receiver_contract = $match(Tezos.get_contract_opt(storage.admin_address), {\n    "Some": (contract) => contract,\n    "None": () => failwith("Couldn\'t find account"),\n  });\n\n  // Create operation to send tez\n  const payout_operation = Tezos.Operation.transaction(unit, Tezos.get_balance(), receiver_contract);\n\n  // Restore stock of tacos\n  const new_storage: storage = {\n    admin_address: storage.admin_address,\n    taco_data: default_taco_data,\n  };\n\n  return [[payout_operation], new_storage];\n}\n'))),(0,o.kt)(l,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"In the ",(0,o.kt)("inlineCode",{parentName:"p"},"payout")," entrypoint, add this code to verify that the administrator is calling the entrypoint:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},'(* Ensure that only the admin can call this entrypoint *)\nlet _ = if (Tezos.get_sender () <> storage.admin_address) then\n  failwith "Only the admin can call this entrypoint" in\n')),(0,o.kt)("p",{parentName:"li"},"The function ",(0,o.kt)("inlineCode",{parentName:"p"},"Tezos.get_sender")," returns the address of the account that called the smart contract.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Add this code to generate the operation that sends tez to the administrator account:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},'(* Create contract object that represents the target account *)\nlet receiver_contract = match Tezos.get_contract_opt storage.admin_address with\n| Some contract -> contract\n| None -> failwith "Couldn\'t find account" in\n\n(* Create operation to send tez *)\nlet payout_operation = Tezos.Operation.transaction unit (Tezos.get_balance ()) receiver_contract in\n')),(0,o.kt)("p",{parentName:"li"},"Sending tez to a user account means treating the user account as though it is a smart contract account.\nThis way, sending tez to a user account works in the same way as sending tez to a smart contract."),(0,o.kt)("p",{parentName:"li"},"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Tezos.Operation.transaction")," function creates a Tezos transaction.\nThere are many kinds of internal transactions in Tezos, but most smart contracts deal with these transactions:"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Transferring tez to another account"),(0,o.kt)("li",{parentName:"ul"},"Calling an entrypoint on a smart contract")),(0,o.kt)("p",{parentName:"li"},"Calling an entrypoint on a smart contract (either the current contract or another contract) is beyond the scope of this tutorial.\nFor information, see ",(0,o.kt)("a",{parentName:"p",href:"../../syntax/contracts/operation#calling-a-contract"},"Calling a contract"),"."),(0,o.kt)("p",{parentName:"li"},"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Tezos.Operation.transaction")," function takes these parameters:"),(0,o.kt)("ol",{parentName:"li"},(0,o.kt)("li",{parentName:"ol"},"The parameter to pass, in this case ",(0,o.kt)("inlineCode",{parentName:"li"},"unit"),", which means no value"),(0,o.kt)("li",{parentName:"ol"},"The amount of tez to include with the transaction, in this case all of the tez the contract has, denoted by the ",(0,o.kt)("inlineCode",{parentName:"li"},"Tezos.get_balance")," function"),(0,o.kt)("li",{parentName:"ol"},"The address of the target contract"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Add this code to calculate the new value of the storage, using the existing admin address and the default taco data:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},"(* Restore stock of tacos *)\nlet new_storage : storage = {\n  admin_address = storage.admin_address;\n  taco_data = default_taco_data\n} in\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Replace the last line of the ",(0,o.kt)("inlineCode",{parentName:"p"},"payout")," entrypoint with this code:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},"[payout_operation], new_storage\n")),(0,o.kt)("p",{parentName:"li"},"Creating the transaction is not enough to run it; you must return it in the list of operations at the end of the entrypoint."))),(0,o.kt)("p",null,"The complete entrypoint looks like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},'[@entry]\nlet payout (_u : unit) (storage : storage) : operation list * storage =\n\n  (* Ensure that only the admin can call this entrypoint *)\n  let _ = if (Tezos.get_sender () <> storage.admin_address) then\n    failwith "Only the admin can call this entrypoint" in\n\n  (* Create contract object that represents the target account *)\n  let receiver_contract = match Tezos.get_contract_opt storage.admin_address with\n  | Some contract -> contract\n  | None -> failwith "Couldn\'t find account" in\n\n  (* Create operation to send tez *)\n  let payout_operation = Tezos.Operation.transaction unit (Tezos.get_balance ()) receiver_contract in\n\n  (* Restore stock of tacos *)\n  let new_storage : storage = {\n    admin_address = storage.admin_address;\n    taco_data = default_taco_data\n  } in\n\n  [payout_operation], new_storage\n'))),(0,o.kt)("p",null,"That's all you need to do to reset the storage and send the contract's tez to the administrator.\nIf you want to extend this logic, try separating the ",(0,o.kt)("inlineCode",{parentName:"p"},"payout")," entrypoint into separate entrypoints for paying out the tez and resetting the stock of tacos."),(0,o.kt)("h2",{id:"testing-the-new-entrypoint"},"Testing the new entrypoint"),(0,o.kt)("p",null,"Of course, after you implement the ",(0,o.kt)("inlineCode",{parentName:"p"},"payout")," entrypoint, you should add tests for it."),(0,o.kt)(l,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"At the end of the test function, add this code to get the current balance of Pedro's account before calling the entrypoint:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},"// Test the payout entrypoint as the administrator\nconst admin_balance_before = Test.Address.get_balance(admin_address);\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Add this code to set the account that smart contract calls come from in the test scenario:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},"Test.State.set_source(admin_address);\n")),(0,o.kt)("p",{parentName:"li"},"Now when you call the ",(0,o.kt)("inlineCode",{parentName:"p"},"Test.Contract.transfer")," function, the transaction comes from Pedro's account.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Add this code to call the ",(0,o.kt)("inlineCode",{parentName:"p"},"payout")," entrypoint and verify that the storage was updated, as in previous tests:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},'const payout_result =\n  Test.Contract.transfer(\n    Test.Typed_address.get_entrypoint("payout", contract.taddr),\n    unit,\n    0 as tez\n  );\n$match(payout_result, {\n  "Success": (_s) => (() => {\n      const storage = Test.Typed_address.get_storage(contract.taddr);\n      // Check that the stock has been reset\n      Assert.assert(\n        eq_in_map(\n          Map.find(1 as nat, TacoShop.default_taco_data),\n          storage.taco_data,\n          1 as nat\n        ));\n      Assert.assert(\n        eq_in_map(\n          Map.find(2 as nat, TacoShop.default_taco_data),\n          storage.taco_data,\n          2 as nat\n        ));\n      Test.IO.log("Successfully reset taco storage");\n    })(),\n    "Fail": (_err) => failwith("Failed to reset taco storage"),\n  });\n'))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Add this code to verify that Pedro's account received the tez from the contract:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},"// Check that the admin account got a payout\nconst admin_balance_after = Test.Address.get_balance(admin_address);\nAssert.assert(Test.Compare.lt(admin_balance_before, admin_balance_after));\n")),(0,o.kt)("p",{parentName:"li"},"The exact amounts differ because calling the ",(0,o.kt)("inlineCode",{parentName:"p"},"payout")," entrypoint costs a small fee, but this code verifies that Pedro's account has more tez in it after calling the ",(0,o.kt)("inlineCode",{parentName:"p"},"payout")," entrypoint.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Add this code to generate a test account and verify that it can't call the ",(0,o.kt)("inlineCode",{parentName:"p"},"payout")," entrypoint because it is not the administrator:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},'// Verify that the entrypoint fails if called by someone else\nconst other_user_account = Test.Account.address(1 as nat);\nTest.State.set_source(other_user_account);\nconst failed_payout_result =\n  Test.Contract.transfer(\n    Test.Typed_address.get_entrypoint("payout", contract.taddr),\n    unit,\n    0 as tez\n  );\n$match(failed_payout_result, {\n  "Success": (_s) => failwith("A non-admin user was able to call the payout entrypoint"),\n  "Fail": (_err) => Test.IO.log("Successfully prevented a non-admin user from calling the payout entrypoint"),\n});\n'))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Run the test with ",(0,o.kt)("inlineCode",{parentName:"p"},"ligo run test taco_shop.jsligo")," and verify that the test runs successfully."))),(0,o.kt)("p",null,"The complete contract and tests looks like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=getting_payouts",group:"getting_payouts"},'namespace TacoShop {\n  export type taco_supply = { current_stock: nat, max_price: tez };\n  export type taco_data = map<nat, taco_supply>;\n  export type admin_address = address;\n  export type storage = {\n    admin_address: admin_address,\n    taco_data: taco_data,\n  };\n\n  export const default_taco_data: taco_data = Map.literal([\n    [1 as nat, { current_stock: 50 as nat, max_price: 50 as tez }],\n    [2 as nat, { current_stock: 20 as nat, max_price: 75 as tez }]\n  ]);\n\n  // Internal function to get the price of a taco\n  const get_taco_price_internal = (taco_kind_index: nat, taco_data: taco_data): tez => {\n    const taco_kind: taco_supply =\n      $match (Map.find_opt(taco_kind_index, taco_data), {\n        "Some": (kind) => kind,\n        "None": () => failwith("Unknown kind of taco"),\n      });\n    return taco_kind.max_price / taco_kind.current_stock;\n  }\n\n  // @view\n  const get_taco_price = (taco_kind_index: nat, storage: storage): tez =>\n    get_taco_price_internal(taco_kind_index, storage.taco_data);\n\n  // Buy a taco\n  // @entry\n  const buy_taco = (taco_kind_index: nat, storage: storage): [\n      list<operation>,\n      storage\n    ] => {\n\n    const { admin_address, taco_data } = storage;\n\n    // Retrieve the kind of taco from the contracts storage or fail\n    const taco_kind: taco_supply =\n      $match (Map.find_opt(taco_kind_index, taco_data), {\n        "Some": (kind) => kind,\n        "None": () => failwith("Unknown kind of taco"),\n      });\n\n    // Get the current price of this type of taco\n    const current_purchase_price = get_taco_price_internal(taco_kind_index, taco_data);\n\n    // Verify that the caller sent the correct amount of tez\n    if ((Tezos.get_amount()) != current_purchase_price) {\n      return failwith("Sorry, the taco you are trying to purchase has a different price");\n    }\n\n    // Verify that there is at least one of this type of taco\n    if (taco_kind.current_stock == (0 as nat)) {\n      return failwith("Sorry, we are out of this type of taco");\n    }\n\n    // Update the storage with the new quantity of tacos\n    const updated_taco_data: taco_data = Map.update(\n      taco_kind_index,\n      ["Some" as "Some", {...taco_kind, current_stock: abs(taco_kind.current_stock - 1) }],\n      taco_data);\n\n    const updated_storage: storage = {\n      admin_address: admin_address,\n      taco_data: updated_taco_data,\n    };\n\n    return [[], updated_storage];\n  }\n\n  // @entry\n  const payout = (_u: unit, storage: storage): [\n      list<operation>,\n      storage\n    ] => {\n\n    // Ensure that only the admin can call this entrypoint\n    if (Tezos.get_sender() != storage.admin_address) {\n      failwith("Only the admin can call this entrypoint");\n    }\n\n    // Create contract object that represents the target account\n    const receiver_contract = $match(Tezos.get_contract_opt(storage.admin_address), {\n      "Some": (contract) => contract,\n      "None": () => failwith("Couldn\'t find account"),\n    });\n\n    // Create operation to send tez\n    const payout_operation = Tezos.Operation.transaction(unit, Tezos.get_balance(), receiver_contract);\n\n    // Restore stock of tacos\n    const new_storage: storage = {\n      admin_address: storage.admin_address,\n      taco_data: default_taco_data,\n    };\n\n    return [[payout_operation], new_storage];\n  }\n};\n\n// Convenience function to get current taco price\nconst get_taco_price = (untyped_address: address, taco_kind_index: nat): tez => {\n  const view_result_option: option<tez> = Tezos.View.call("get_taco_price", taco_kind_index, untyped_address);\n  return $match(view_result_option, {\n    "Some": (cost_mutez) => cost_mutez,\n    "None": () => Test.Assert.failwith("Couldn\'t get the price of the taco."),\n  });\n}\n\n// Convenience function for testing equality in maps\nconst eq_in_map = (r: TacoShop.taco_supply, m: TacoShop.taco_data, k: nat) =>\n  $match(Map.find_opt(k, m), {\n    "None": () => false,\n    "Some": (v) => v.current_stock == r.current_stock && v.max_price == r.max_price\n  });\n\nconst test = (() => {\n\n  // Set the initial storage and deploy the contract\n  const admin_address: address = Test.Account.address(0 as nat);\n  const initial_storage: TacoShop.storage = {\n    admin_address: admin_address,\n    taco_data: TacoShop.default_taco_data,\n  }\n  const contract = Test.Originate.contract(contract_of(TacoShop), initial_storage, 0 as tez);\n\n  // Get the current price of a taco\n  const untyped_address = Test.Typed_address.to_address(contract.taddr);\n  const current_price = get_taco_price(untyped_address, 1 as nat);\n\n  // Purchase a taco\n  const success_result =\n    Test.Contract.transfer(\n      Test.Typed_address.get_entrypoint("buy_taco", contract.taddr),\n      1 as nat,\n      current_price\n    );\n\n  // Verify that the stock was updated\n  $match(success_result, {\n    "Success": (_s) => (() => {\n      const storage = Test.Typed_address.get_storage(contract.taddr);\n      // Check that the stock has been updated correctly\n      Assert.assert(\n        eq_in_map(\n          { current_stock: 49 as nat, max_price: 50000000 as mutez },\n          storage.taco_data,\n          1 as nat\n        ));\n      // Check that the amount of the other taco type has not changed\n      Assert.assert(eq_in_map(\n          { current_stock: 20 as nat, max_price: 75000000 as mutez },\n          storage.taco_data,\n          2 as nat\n        )\n      );\n      Test.IO.log("Successfully bought a taco");\n  })(),\n    "Fail": (err) => failwith(err),\n  });\n\n  // Fail to purchase a taco without sending enough tez\n  const fail_result =\n    Test.Contract.transfer(\n      Test.Typed_address.get_entrypoint("buy_taco", contract.taddr),\n      1 as nat,\n      1 as mutez\n    );\n  $match(fail_result, {\n    "Success": (_s) => failwith("Test was able to buy a taco for the wrong price"),\n    "Fail": (_err) => Test.IO.log("Contract successfully blocked purchase with incorrect price"),\n  });\n\n  // Test the payout entrypoint as the administrator\n  const admin_balance_before = Test.Address.get_balance(admin_address);\n  Test.State.set_source(admin_address);\n  const payout_result =\n    Test.Contract.transfer(\n      Test.Typed_address.get_entrypoint("payout", contract.taddr),\n      unit,\n      0 as tez\n    );\n  $match(payout_result, {\n    "Success": (_s) => (() => {\n        const storage = Test.Typed_address.get_storage(contract.taddr);\n        // Check that the stock has been reset\n        Assert.assert(\n          eq_in_map(\n            Map.find(1 as nat, TacoShop.default_taco_data),\n            storage.taco_data,\n            1 as nat\n          ));\n        Assert.assert(\n          eq_in_map(\n            Map.find(2 as nat, TacoShop.default_taco_data),\n            storage.taco_data,\n            2 as nat\n          ));\n        Test.IO.log("Successfully reset taco storage");\n      })(),\n      "Fail": (_err) => failwith("Failed to reset taco storage"),\n    });\n\n  // Check that the admin account got a payout\n  const admin_balance_after = Test.Address.get_balance(admin_address);\n  Assert.assert(Test.Compare.lt(admin_balance_before, admin_balance_after));\n\n  // Verify that the entrypoint fails if called by someone else\n  const other_user_account = Test.Account.address(1 as nat);\n  Test.State.set_source(other_user_account);\n  const failed_payout_result =\n    Test.Contract.transfer(\n      Test.Typed_address.get_entrypoint("payout", contract.taddr),\n      unit,\n      0 as tez\n    );\n  $match(failed_payout_result, {\n    "Success": (_s) => failwith("A non-admin user was able to call the payout entrypoint"),\n    "Fail": (_err) => Test.IO.log("Successfully prevented a non-admin user from calling the payout entrypoint"),\n  });\n\n}) ();\n'))),(0,o.kt)(l,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"At the end of the test function, replace the last block with this code so the function can continue:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},'let () = match fail_result with\n| Success _s -> failwith "Test was able to buy a taco for the wrong price"\n| Fail _err -> Test.IO.log "Contract successfully blocked purchase with incorrect price" in\n'))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Add this code to get the current balance of Pedro's account before calling the entrypoint:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},"(* Test the payout entrypoint as the administrator *)\nlet admin_balance_before = Test.Address.get_balance admin_address in\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Add this code to set the account that smart contract calls come from in the test scenario:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},"let () = Test.State.set_source admin_address in\n")),(0,o.kt)("p",{parentName:"li"},"Now when you call the ",(0,o.kt)("inlineCode",{parentName:"p"},"Test.Contract.transfer")," function, the transaction comes from Pedro's account.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Add this code to call the ",(0,o.kt)("inlineCode",{parentName:"p"},"payout")," entrypoint and verify that the storage was updated, as in previous tests:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},'let payout_result = Test.Contract.transfer\n  (Test.Typed_address.get_entrypoint "payout" contract.taddr)\n  unit\n  0tez\nin\nlet () = match payout_result with\n| Success _s -> let storage = Test.Typed_address.get_storage contract.taddr in\n  let () = Assert.assert\n    (eq_in_map (Map.find 1n TacoShop.default_taco_data)\n    storage.taco_data\n    1n) in\n  let () = Assert.assert\n    (eq_in_map (Map.find 2n TacoShop.default_taco_data)\n    storage.taco_data\n    2n) in\n  Test.IO.log "Successfully reset taco storage"\n| Fail _err -> failwith "Failed to reset taco storage" in\n'))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Add this code to verify that Pedro's account received the tez from the contract:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},"(* Check that the admin account got a payout *)\nlet admin_balance_after = Test.Address.get_balance admin_address in\nlet () = Assert.assert (Test.Compare.lt admin_balance_before admin_balance_after) in\n")),(0,o.kt)("p",{parentName:"li"},"The exact amounts differ because calling the ",(0,o.kt)("inlineCode",{parentName:"p"},"payout")," entrypoint costs a small fee, but this code verifies that Pedro's account has more tez in it after calling the ",(0,o.kt)("inlineCode",{parentName:"p"},"payout")," entrypoint.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Add this code to generate a test account and verify that it can't call the ",(0,o.kt)("inlineCode",{parentName:"p"},"payout")," entrypoint because it is not the administrator:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},'(* Verify that the entrypoint fails if called by someone else *)\nlet other_user_account = Test.Account.address 1n in\nlet _ = Test.State.set_source other_user_account in\nlet failed_payout_result = Test.Contract.transfer\n  (Test.Typed_address.get_entrypoint "payout" contract.taddr)\n  unit\n  0tez\nin\nmatch failed_payout_result with\n| Success _s -> failwith "A non-admin user was able to call the payout entrypoint"\n| Fail _err -> Test.IO.log "Successfully prevented a non-admin user from calling the payout entrypoint"\n'))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Run the test with ",(0,o.kt)("inlineCode",{parentName:"p"},"ligo run test taco_shop.mligo")," and verify that the test runs successfully."))),(0,o.kt)("p",null,"The completed contract file with the convenience functions and test functions looks like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=getting_payouts",group:"getting_payouts"},'module TacoShop = struct\n  type taco_supply = { current_stock: nat; max_price: tez }\n  type taco_data = (nat, taco_supply) map\n  type admin_address = address\n  type storage = {\n    admin_address: admin_address;\n    taco_data: taco_data;\n  }\n\n  let default_taco_data: taco_data = Map.literal [\n    (1n, { current_stock = 50n; max_price = 50tez });\n    (2n, { current_stock = 20n; max_price = 75tez });\n  ]\n\n  (* Internal function to get the price of a taco *)\n  let get_taco_price_internal (taco_kind_index : nat) (taco_data : taco_data) : tez =\n    let taco_kind : taco_supply =\n      match Map.find_opt taco_kind_index taco_data with\n      | Some kind -> kind\n      | None -> failwith "Unknown kind of taco"\n      in\n      taco_kind.max_price / taco_kind.current_stock\n\n  [@view]\n  let get_taco_price (taco_kind_index : nat) (storage : storage) : tez =\n    get_taco_price_internal taco_kind_index storage.taco_data\n\n  (* Buy a taco *)\n  [@entry]\n  let buy_taco (taco_kind_index : nat) (storage : storage) : operation list * storage =\n\n    let { admin_address; taco_data } = storage in\n\n    (* Retrieve the kind of taco from the contracts storage or fail *)\n    let taco_kind : taco_supply =\n      match Map.find_opt taco_kind_index taco_data with\n      | Some kind -> kind\n      | None -> failwith "Unknown kind of taco" in\n\n    (* Get the current price of this type of taco *)\n    let current_purchase_price = get_taco_price_internal taco_kind_index taco_data in\n\n    (* Verify that the caller sent the correct amount of tez *)\n    let _ = if (Tezos.get_amount () <> current_purchase_price) then\n      failwith "Sorry, the taco you are trying to purchase has a different price" in\n\n    (* Verify that there is at least one of this type of taco *)\n    let _ = if (taco_kind.current_stock = 0n) then\n      failwith "Sorry, we are out of this type of taco" in\n\n    (* Update the storage with the new quantity of tacos *)\n    let updated_taco_data : taco_data = Map.update\n      taco_kind_index\n      (Some { taco_kind with current_stock = abs (taco_kind.current_stock - 1n) })\n      taco_data in\n\n    let updated_storage : storage = {\n      admin_address = admin_address;\n      taco_data = updated_taco_data;\n    } in\n\n    [], updated_storage\n\n  [@entry]\n  let payout (_u : unit) (storage : storage) : operation list * storage =\n\n    (* Ensure that only the admin can call this entrypoint *)\n    let _ = if (Tezos.get_sender () <> storage.admin_address) then\n      failwith "Only the admin can call this entrypoint" in\n\n    (* Create contract object that represents the target account *)\n    let receiver_contract = match Tezos.get_contract_opt storage.admin_address with\n    | Some contract -> contract\n    | None -> failwith "Couldn\'t find account" in\n\n    (* Create operation to send tez *)\n    let payout_operation = Tezos.Operation.transaction unit (Tezos.get_balance ()) receiver_contract in\n\n    (* Restore stock of tacos *)\n    let new_storage : storage = {\n      admin_address = storage.admin_address;\n      taco_data = default_taco_data\n    } in\n\n    [payout_operation], new_storage\n\nend\n\n(* Convenience function to get current taco price *)\nlet get_taco_price (untyped_address : address) (taco_kind_index : nat) : tez =\n  let view_result_option : tez option = Tezos.View.call\n    "get_taco_price"\n    taco_kind_index\n    untyped_address in\n  match view_result_option with\n  | Some cost_mutez -> cost_mutez\n  | None -> Test.Assert.failwith "Couldn\'t get the price of a taco"\n\n(* Convenience function for testing equality in maps *)\nlet eq_in_map (r : TacoShop.taco_supply) (m : TacoShop.taco_data) (k : nat) =\n  match Map.find_opt k m with\n  | None -> false\n  | Some v -> v.current_stock = r.current_stock && v.max_price = r.max_price\n\nlet test =\n\n  (* Set the initial storage and deploy the contract *)\n  let admin_address : address = Test.Account.address 0n in\n  let initial_storage : TacoShop.storage = {\n    admin_address = admin_address;\n    taco_data = TacoShop.default_taco_data\n  } in\n  let contract = Test.Originate.contract (contract_of TacoShop) initial_storage 0tez in\n\n  (* Get the current price of a taco *)\n  let untyped_address = Test.Typed_address.to_address contract.taddr in\n  let current_price = get_taco_price untyped_address 1n in\n\n  (* Purchase a taco *)\n  let success_result =\n    Test.Contract.transfer\n      (Test.Typed_address.get_entrypoint "buy_taco" contract.taddr)\n      1n\n      current_price\n    in\n\n  (* Verify that the stock was updated *)\n  let () = match success_result with\n    | Success _s ->\n      let storage = Test.Typed_address.get_storage contract.taddr in\n      let () = Assert.assert (eq_in_map\n        { current_stock = 49n; max_price = 50000000mutez }\n        storage.taco_data\n        1n\n      ) in\n      let () = Assert.assert (eq_in_map\n        { current_stock = 20n; max_price = 75000000mutez }\n        storage.taco_data\n        2n\n      ) in\n      Test.IO.log "Successfully bought a taco"\n    | Fail err -> failwith err\n    in\n\n  (* Fail to purchase a taco without sending enough tez *)\n  let fail_result = Test.Contract.transfer\n    (Test.Typed_address.get_entrypoint "buy_taco" contract.taddr)\n    1n\n    1mutez in\n  let () = match fail_result with\n  | Success _s -> failwith "Test was able to buy a taco for the wrong price"\n  | Fail _err -> Test.IO.log "Contract successfully blocked purchase with incorrect price" in\n\n  (* Test the payout entrypoint as the administrator *)\n  let admin_balance_before = Test.Address.get_balance admin_address in\n\n  let () = Test.State.set_source admin_address in\n\n  let payout_result = Test.Contract.transfer\n    (Test.Typed_address.get_entrypoint "payout" contract.taddr)\n    unit\n    0tez\n  in\n  let () = match payout_result with\n  | Success _s -> let storage = Test.Typed_address.get_storage contract.taddr in\n    let () = Assert.assert\n      (eq_in_map (Map.find 1n TacoShop.default_taco_data)\n      storage.taco_data\n      1n) in\n    let () = Assert.assert\n      (eq_in_map (Map.find 2n TacoShop.default_taco_data)\n      storage.taco_data\n      2n) in\n    Test.IO.log "Successfully reset taco storage"\n  | Fail _err -> failwith "Failed to reset taco storage" in\n\n  (* Check that the admin account got a payout *)\n  let admin_balance_after = Test.Address.get_balance admin_address in\n  let () = Assert.assert (Test.Compare.lt admin_balance_before admin_balance_after) in\n\n  (* Verify that the entrypoint fails if called by someone else *)\n  let other_user_account = Test.Account.address 1n in\n  let _ = Test.State.set_source other_user_account in\n  let failed_payout_result = Test.Contract.transfer\n    (Test.Typed_address.get_entrypoint "payout" contract.taddr)\n    unit\n    0tez\n  in\n  match failed_payout_result with\n  | Success _s -> failwith "A non-admin user was able to call the payout entrypoint"\n  | Fail _err -> Test.IO.log "Successfully prevented a non-admin user from calling the payout entrypoint"\n'))),(0,o.kt)("p",null,"Now you can allow different users to do different things in the contract."),(0,o.kt)("h2",{id:"conclusion"},"Conclusion"),(0,o.kt)("p",null,"Now you have a contract that Pedro can use to sell tacos and manage the profits and the taco stock.\nFrom here you can expand the contract in many ways, such as:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Adding more types of tacos"),(0,o.kt)("li",{parentName:"ul"},"Changing how the price of tacos is calculated"),(0,o.kt)("li",{parentName:"ul"},"Expanding the administrator functionality"),(0,o.kt)("li",{parentName:"ul"},"Accepting more than the price of the taco as a tip"),(0,o.kt)("li",{parentName:"ul"},"Adding more tests")),(0,o.kt)("p",null,"You can also try deploying the contract to a test network and trying it in a real Tezos environment.\nFor a tutorial that covers deploying a contract, see ",(0,o.kt)("a",{parentName:"p",href:"https://docs.tezos.com/tutorials/smart-contract"},"Deploy a smart contract")," on docs.tezos.com."))}_.isMDXComponent=!0}}]);