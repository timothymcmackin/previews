"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[10669],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>y});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),m=p(n),y=r,u=m["".concat(l,".").concat(y)]||m[y]||c[y]||i;return n?a.createElement(u,o(o({ref:t},d),{},{components:n})):a.createElement(u,o({ref:t},d))}));function y(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},48720:(e,t,n)=>{n.d(t,{D:()=>r.Z,Z:()=>i});var a=n(67294),r=n(75402);const i=function(e){return a.createElement(r.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},99191:(e,t,n)=>{n.d(t,{Z:()=>d});var a=n(23746),r=n(67294),i=n(52263),o=n(48720),s=n(87552);function l(){return l=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},l.apply(this,arguments)}const{Prism:p}=n(23746);p.languages={...p.languages,cameligo:{...p.languages.ocaml,comment:[/(^|[^\\])\/\*[\s\S]*?\*\//,/\(\*[\s\S]*?\*\)/,/\/\/.*/]},jsligo:p.languages.typescript};const d=function(e){const{siteConfig:{themeConfig:{prism:t={}}}}=(0,i.Z)(),n=t.singleTheme||s.Z,[p,d]=(0,r.useState)(!1);return(0,r.useEffect)((()=>{d(!0)}),[]),r.createElement(o.D.Consumer,null,(t=>{let{syntax:i}=t;return i===e.syntax?r.createElement(a.default,l({},a.defaultProps,{key:p,language:e.syntax,code:e.children,theme:n}),(e=>{let{className:t,tokens:n,getLineProps:a,getTokenProps:i}=e;return r.createElement("h4",{className:t,style:{backgroundColor:"var(--ifm-background-color)",fontFamily:"var(--ifm-font-family-monospace)",lineHeight:"var(--ifm-pre-line-height)",fontSize:"1.1rem",fontWeight:"bold",padding:0,whiteSpace:"break-spaces",marginTop:"3rem"}},n.map(((e,t)=>r.createElement("div",a({line:e,key:t}),e.map(((e,t)=>r.createElement("span",i({token:e,key:t}))))))))})):r.createElement("div",null)}))}},7753:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>y,frontMatter:()=>s,metadata:()=>p,toc:()=>c});var a=n(87462),r=(n(67294),n(3905)),i=n(48720),o=n(99191);const s={id:"test-reference",title:"test",hide_table_of_contents:!0},l=void 0,p={unversionedId:"reference/test-reference",id:"version-1.6.0/reference/test-reference",title:"test",description:"The testing framework",source:"@site/versioned_docs/version-1.6.0/reference/test.md",sourceDirName:"reference",slug:"/reference/test-reference",permalink:"/previews/ligo/tacoshop/docs/1.6.0/reference/test-reference",draft:!1,tags:[],version:"1.6.0",frontMatter:{id:"test-reference",title:"test",hide_table_of_contents:!0},sidebar:"API",previous:{title:"pbt",permalink:"/previews/ligo/tacoshop/docs/1.6.0/reference/test.pbt-reference"},next:{title:"proxy_ticket",permalink:"/previews/ligo/tacoshop/docs/1.6.0/reference/test.proxy-ticket-reference"}},d={},c=[],m={toc:c};function y(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The testing framework"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"/previews/ligo/tacoshop/docs/1.6.0/reference/test.pbt-reference"},"module pbt")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"/previews/ligo/tacoshop/docs/1.6.0/reference/test.proxy-ticket-reference"},"module proxy_ticket")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"/previews/ligo/tacoshop/docs/1.6.0/reference/test.next-reference"},"module next")),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val run : 'a 'b.('a -> 'b) -> 'a -> michelson_program"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let run: <a, b>(_: (_: a) => b) => (_: a) => michelson_program"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Michelson.run` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Run a function on an input, all in Michelson. More concretely:\na) compiles the function argument to Michelson ",(0,r.kt)("inlineCode",{parentName:"p"},"f_mich"),"; b)\ncompiles the value argument (which was evaluated already) to\nMichelson ",(0,r.kt)("inlineCode",{parentName:"p"},"v_mich"),"; c) runs the Michelson interpreter on the code\n",(0,r.kt)("inlineCode",{parentName:"p"},"f_mich")," with starting stack ",(0,r.kt)("inlineCode",{parentName:"p"},"[v_mich]"),"."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val eval : 'a.'a -> michelson_program"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let eval: <a>(_: a) => michelson_program"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Michelson.eval` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Compile a LIGO value to Michelson. Currently it is a renaming of\n",(0,r.kt)("inlineCode",{parentName:"p"},"compile_value"),"."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val decompile : 'a.michelson_program -> 'a"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let decompile: <a>(_: michelson_program) => a"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Michelson.decompile` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Decompile a Michelson value to LIGO, following the (mandatory)\ntype annotation. Note: This operation can fail at run-time, in case\nthat the ",(0,r.kt)("inlineCode",{parentName:"p"},"michelson_program")," given cannot be decompiled to something\ncompatible with the annotated type."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val compile_value : 'a.'a -> michelson_program"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let compile_value: <a>(_: a) => michelson_program"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Michelson.eval` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Compile a LIGO value to Michelson."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_total_voting_power : unit -> nat"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let get_total_voting_power: (_: unit) => nat"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `State.get_total_voting_power` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Returns the total voting power of all contracts. The total\nvoting power coincides with the sum of the rolls count of every\ncontract in the voting listings. The voting listings is calculated\nat the beginning of every voting period."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val failwith : 'a 'b.'a -> 'b"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let failwith: <a, b>(_: a) => b"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Assert.failwith` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Cause the testing framework to fail."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val to_contract : 'p 's.('p, 's) typed_address -> 'p contract"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let to_contract: <p, s>(_: typed_address<p, s>) => contract<p>"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Typed_address.to_contract` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Gets the contract corresponding to the default entrypoint of a\ntyped address: the contract parameter in the result will be the\ntype of the default entrypoint (generally ",(0,r.kt)("inlineCode",{parentName:"p"},"'param"),", but this might\ndiffer if ",(0,r.kt)("inlineCode",{parentName:"p"},"'param"),' includes a "default" entrypoint).'),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val set_source : address -> unit"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let set_source: (_: address) => unit"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `State.set_source` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Sets the source for ",(0,r.kt)("inlineCode",{parentName:"p"},"Test.transfer")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Test.originate"),"."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val cast_address : 'a 'b.address -> ('a, 'b) typed_address"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let cast_address: <a, b>(_: address) => typed_address<a, b>"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Address.to_typed_address` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"This function casts an address to a typed address. You will need\nto annotate the result with the type you expect."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val to_address : 'a 'b.('a, 'b) typed_address -> address"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let to_address: <a, b>(_: typed_address<a, b>) => address"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Typed_address.to_address` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_storage : 'p 's.('p, 's) typed_address -> 's"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let get_storage: <p, s>(_: typed_address<p, s>) => s"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Typed_address.get_storage` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Gets the storage of a typed account."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_storage_of_address : 'b.address -> 'b"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let get_storage_of_address: <b>(_: address) => b"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Address.get_storage` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Gets the storage of an account in ",(0,r.kt)("inlineCode",{parentName:"p"},"michelson_program"),"."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_balance_of_address : address -> tez"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let get_balance_of_address: (_: address) => tez"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Address.get_balance` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Gets the balance of an account (given as an address) in tez."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_balance : 'p 's.('p, 's) typed_address -> tez"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let get_balance: <p, s>(_: typed_address<p, s>) => tez"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Typed_address.get_balance` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Gets the balance of an account in tez."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val print : string -> unit"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let print: (_: string) => unit"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `IO.print` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Prints an string to stdout."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val eprint : string -> unit"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let eprint: (_: string) => unit"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `IO.eprint` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Prints an string to stderr."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_voting_power : key_hash -> nat"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let get_voting_power: (_: key_hash) => nat"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `State.get_voting_power` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Return the voting power of a given contract. This voting power\ncoincides with the weight of the contract in the voting listings\n(i.e., the rolls count) which is calculated at the beginning of\nevery voting period."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val nth_bootstrap_contract : nat -> address"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let nth_bootstrap_contract: (_: nat) => address"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Account.Contract.bootstrap` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Returns the address corresponding to the nth bootstrapped\ncontract."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val nth_bootstrap_account : int -> address"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let nth_bootstrap_account: (_: int) => address"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Account.address` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Returns the address of the nth bootstrapped account."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_bootstrap_account : nat -> (address * key * string)"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let get_bootstrap_account: (_: nat) => [address, key, string]"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Account.info` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Returns the address, key and secret key of the nth bootstrapped\naccount."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val nth_bootstrap_typed_address : 'a 'b.nat -> ('a, 'b) typed_address"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let nth_bootstrap_typed_address: <a, b>(_: nat) => typed_address<a, b>"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Account.Contract.bootstrap_typed_address` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Returns the typed address corresponding to the nth bootstrapped\ncontract currently loaded. The types are inferred from those\ncontracts loaded with ",(0,r.kt)("inlineCode",{parentName:"p"},"Test.bootstrap_contract")," (before reset)."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val last_originations : unit -> (address, address list) map"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let last_originations: (_: unit) => map<address, list<address>>"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `State.last_originations` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Returns addresses of orginated accounts in the last transfer. It\nis given in the form of a map binding the address of the source of\nthe origination operation to the addresses of newly originated\naccounts."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val random : 'a.unit -> 'a"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let random: <a>(_: unit) => a"),"This function creates a random value for a chosen type.",(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val new_account : unit -> (string * key)"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let new_account: (_: unit) => [string, key]"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Account.new` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Creates and returns secret key & public key of a new account."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val bake_until_n_cycle_end : nat -> unit"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let bake_until_n_cycle_end: (_: nat) => unit"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `State.bake_until` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"It bakes until a number of cycles pass, so that an account\nregistered as delegate can effectively act as a baker. Note: It\ncan be used in tests to manually advance time."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_time : unit -> timestamp"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let get_time: (_: unit) => timestamp"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val register_delegate : key_hash -> unit"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let register_delegate: (_: key_hash) => unit"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `State.register_delegate` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Registers a ",(0,r.kt)("inlineCode",{parentName:"p"},"key_hash")," corresponding to an account as a delegate."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val stake : key_hash -> tez -> unit"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let stake: (_: key_hash) => (_: tez) => unit"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `State.stake` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val register_constant : michelson_program -> string"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let register_constant: (_: michelson_program) => string"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `State.register_constant` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Registers a global constant, returns its hash as a string. See\nthe documentation for global constants for an example of usage."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val to_typed_address : 'a 'b.'a contract -> ('a, 'b) typed_address"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let to_typed_address: <a, b>(_: contract<a>) => typed_address<a, b>"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Contract.to_typed_address` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val constant_to_michelson_program : string -> michelson_program"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let constant_to_michelson_program: (_: string) => michelson_program"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Michelson.parse` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Turn a constant (as a string) into a ",(0,r.kt)("inlineCode",{parentName:"p"},"michelson_program"),". To be\nused together with ",(0,r.kt)("inlineCode",{parentName:"p"},"Test.register_constant"),"."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val parse_michelson : string -> michelson_program"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let parse_michelson: (_: string) => michelson_program"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Michelson.parse` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Parses Michelson (as string) into a ",(0,r.kt)("inlineCode",{parentName:"p"},"michelson_program"),"."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val restore_context : unit -> unit"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let restore_context: (_: unit) => unit"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `State.restore` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Pops a testing framework context from the stack of contexts, and\nsets it up as the new current context. In case the stack was\nempty, the current context is kept."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val save_context : unit -> unit"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let save_context: (_: unit) => unit"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `State.save` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Takes current testing framework context and saves it, pushing it\ninto a stack of contexts."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val drop_context : unit -> unit"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let drop_context: (_: unit) => unit"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `State.drop` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Drops a testing framework context from the stack of contexts. In\ncase the stack was empty, nothing is done."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val to_string : 'a.'a -> string"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let to_string: <a>(_: a) => string"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `String.show` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Converts a value to a string (same conversion as used by\n",(0,r.kt)("inlineCode",{parentName:"p"},"Test.log"),")."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val to_json : 'a.'a -> string"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let to_json: <a>(_: a) => string"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `String.json` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Converts a value to its JSON representation (as a string)."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val to_debugger_json : 'a.'a -> string"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let to_debugger_json: <a>(_: a) => string"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `String.debugger_json` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val set_baker_policy : test_baker_policy -> unit"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let set_baker_policy: (_: test_baker_policy) => unit"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `State.set_baker_policy` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Forces the baking policy for ",(0,r.kt)("inlineCode",{parentName:"p"},"Test.transfer")," and\n",(0,r.kt)("inlineCode",{parentName:"p"},"Test.originate"),". By default, the first bootstrapped account."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val set_baker : address -> unit"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let set_baker: (_: address) => unit"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `State.set_baker` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Forces the baker for ",(0,r.kt)("inlineCode",{parentName:"p"},"Test.transfer")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Test.originate"),",\nimplemented using ",(0,r.kt)("inlineCode",{parentName:"p"},"Test.set_baker_policy")," with ",(0,r.kt)("inlineCode",{parentName:"p"},"By_account"),". By\ndefault, the first bootstrapped account."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val size : 'p 's.('p, 's) michelson_contract -> int"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let size: <p, s>(_: michelson_contract<p, s>) => int"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Michelson.Contract.size` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Measures the size of a contract."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val compile_contract : 'p 's.(('p * 's) -> (operation list * 's)) -> ('p, 's) michelson_contract"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let compile_contract: <p, s>(_: (_: [p, s]) => [list<operation>, s]) => michelson_contract<p, s>"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Michelson.Contract.compile` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Compiles a contract from an entrypoint function."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val read_contract_from_file : 'p 's.string -> ('p, 's) michelson_contract"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let read_contract_from_file: <p, s>(_: string) => michelson_contract<p, s>"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Michelson.Contract.from_file` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Reads a contract from a ",(0,r.kt)("inlineCode",{parentName:"p"},".tz")," file."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val chr : nat -> string option"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let chr: (_: nat) => option<string>"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `String.chr` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"String consisting of the character represented by a ",(0,r.kt)("inlineCode",{parentName:"p"},"nat")," in the\ninterval ",(0,r.kt)("inlineCode",{parentName:"p"},"[0, 255]"),"."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val nl : string"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let nl: string"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `String.nl` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"String consisting of only a newline."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val println : string -> unit"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let println: (_: string) => unit"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `IO.println` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Prints an string to stdout, ended with a newline."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val set_print_values : unit -> unit"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let set_print_values: (_: unit) => unit"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `IO.set_test_print` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Turns on the printing of ",(0,r.kt)("inlineCode",{parentName:"p"},"test")," prefixed values at the end of\ntests. This is the default behaviour."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val unset_print_values : unit -> unit"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let unset_print_values: (_: unit) => unit"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `IO.unset_test_print` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Turns off the printing of ",(0,r.kt)("inlineCode",{parentName:"p"},"test")," prefixed values at the end of\ntests."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val get_last_events_from : 'a 'p 's.('p, 's) typed_address -> string -> 'a list"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let get_last_events_from: <a, p, s>(_: typed_address<p, s>) => (_: string) => list<a>"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `State.last_events` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Returns the list of all the event payloads emited with a given\ntag by a given address. Any call to this function must be\nannotated with the expected payload type."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val transfer : 'p 's.('p, 's) typed_address -> 'p -> tez -> test_exec_result"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let transfer: <p, s>(_: typed_address<p, s>) => (_: p) => (_: tez) => test_exec_result"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Typed_address.transfer` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Bakes a transaction by sending an amount of tez with a parameter\nfrom the current source to another account. Returns the amount of\ngas consumed by the execution of the contract."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val transfer_exn : 'p 's.('p, 's) typed_address -> 'p -> tez -> nat"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let transfer_exn: <p, s>(_: typed_address<p, s>) => (_: p) => (_: tez) => nat"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Typed_address.transfer_exn` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Bakes a transaction by sending an amount of tez with a parameter\nfrom the current source to another account. Returns the amount of\ngas consumed by the execution of the contract. Similar as\n",(0,r.kt)("inlineCode",{parentName:"p"},"Test.transfer"),", but fails when anything goes wrong."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val log : 'a.'a -> unit"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let log: <a>(_: a) => unit"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `IO.log` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Logs a value."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val reset_state : nat -> tez list -> unit"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let reset_state: (_: nat) => (_: list<tez>) => unit"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `State.reset` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Generates a number of random bootstrapped accounts with a\ndefault amount of ",(0,r.kt)("inlineCode",{parentName:"p"},"4000000")," tez. The passed list can be used to\noverwrite the amount. By default, the state only has two\nbootstrapped accounts. Notice that since Ithaca, a percentage of\nan account's balance is frozen (5% in testing mode) in case the\naccount can be taken to be a validator, and thus\n",(0,r.kt)("inlineCode",{parentName:"p"},"Test.get_balance")," can show a different amount to the one being\nset with ",(0,r.kt)("inlineCode",{parentName:"p"},"Test.reset_state"),"."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val reset_state_at : timestamp -> nat -> tez list -> unit"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let reset_state_at: (_: timestamp) => (_: nat) => (_: list<tez>) => unit"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `State.reset_at` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Generates a number of random bootstrapped accounts with a\ndefault amount of ",(0,r.kt)("inlineCode",{parentName:"p"},"4000000")," tez. The passed list can be used to\noverwrite the amount. By default, the state only has two\nbootstrapped accounts. Notice that since Ithaca, a percentage of\nan account's balance is frozen (5% in testing mode) in case the\naccount can be taken to be a validator, and thus\n",(0,r.kt)("inlineCode",{parentName:"p"},"Test.get_balance")," can show a different amount to the one being\nset with ",(0,r.kt)("inlineCode",{parentName:"p"},"Test.reset_state"),". It also takes a starting timestamp\nfor the genesis block."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val bootstrap_contract : 'p 's.(('p * 's) -> (operation list * 's)) -> 's -> tez -> unit"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let bootstrap_contract: <p, s>(_: (_: [p, s]) => [list<operation>, s]) => (_: s) => (_: tez) => unit"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `State.Reset.add_func_contract` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Setup a bootstrap contract with an entrypoint function, initial\nstorage and initial balance. Bootstrap contracts will be loaded in\norder, and they will be available only after reset."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val mutate_value : 'a.nat -> 'a -> ('a * mutation) option"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let mutate_value: <a>(_: nat) => (_: a) => option<[a, mutation]>"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Mutation.value` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Mutates a value using a natural number as an index for the\navailable mutations, returns an option for indicating whether\nmutation was successful or not."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val save_mutation : string -> mutation -> string option"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let save_mutation: (_: string) => (_: mutation) => option<string>"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Mutation.save` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"This function reconstructs a file from a mutation (second\nargument), and saves it to a file in the directory path (first\nargument). It returns an optional string indicating the filename\nwhere the mutation was saved, or ",(0,r.kt)("inlineCode",{parentName:"p"},"None")," if there was an error."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val sign : string -> bytes -> signature"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let sign: (_: string) => (_: bytes) => signature"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Crypto.sign` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Creates a signature of bytes from a string representing a secret\nkey, it can be checked with ",(0,r.kt)("inlineCode",{parentName:"p"},"Crypto.check"),"."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val add_account : string -> key -> unit"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let add_account: (_: string) => (_: key) => unit"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Account.add` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Adds an account specfied by secret key & public key to the test\ncontext."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val baker_account : (string * key) -> tez option -> unit"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let baker_account: (_: [string, key]) => (_: option<tez>) => unit"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `State.Reset.add_baker` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Adds an account ",(0,r.kt)("inlineCode",{parentName:"p"},"(sk, pk)")," as a baker. The change is only\neffective after ",(0,r.kt)("inlineCode",{parentName:"p"},"Test.reset_state"),"."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val set_big_map : 'a 'b.int -> ('a, 'b) big_map -> unit"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let set_big_map: <a, b>(_: int) => (_: big_map<a, b>) => unit"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `State.set_big_map` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"The testing framework keeps an internal reference to the values\ncorresponding to big map identifiers. This function allows to\noverride the value of a particular big map identifier. It should\nnot be normally needed, except in particular circumstances such as\nusing custom bootstrap contracts that initialize big maps."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val transfer_to_contract : 'p.'p contract -> 'p -> tez -> test_exec_result"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let transfer_to_contract: <p>(_: contract<p>) => (_: p) => (_: tez) => test_exec_result"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Contract.transfer` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Bake a transaction by sending an amount of tez with a parameter\nfrom the current source to a contract. Returns the amount of gas\nconsumed by the execution of the contract."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val transfer_to_contract_exn : 'p.'p contract -> 'p -> tez -> nat"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let transfer_to_contract_exn: <p>(_: contract<p>) => (_: p) => (_: tez) => nat"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Contract.transfer_exn` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Bakes a transaction by sending an amount of tez with a parameter\nfrom the current source to a contract. Returns the amount of gas\nconsumed by the execution of the contract. Similar as\n",(0,r.kt)("inlineCode",{parentName:"p"},"Test.transfer_to_contract"),", but fails when anything goes\nwrong."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val michelson_equal : michelson_program -> michelson_program -> bool"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let michelson_equal: (_: michelson_program) => (_: michelson_program) => bool"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Compare.eq` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Compares two Michelson values."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val to_entrypoint : 'a 'b 'c.string -> ('a, 'b) typed_address -> 'c contract"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let to_entrypoint: <a, b, c>(_: string) => (_: typed_address<a, b>) => contract<c>"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Typed_address.get_entrypoint` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,'Gets the contract corresponding to an entrypoint of a typed\naddress: the contract parameter in the result will be the type of\nthe entrypoint, it needs to be annotated, entrypoint string should\nomit the prefix "%", but if passed a string starting with "%", it\nwill be removed (and a warning emitted).'),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val storage_with_dynamic_entrypoints : 'p 's 's2.('p, 's) module_contract -> 's2 -> { dynamic_entrypoints : dynamic_entrypoints; storage : 's2 }"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let storage_with_dynamic_entrypoints: <p, s, s2>(_: module_contract<p, s>, s: s2) => { dynamic_entrypoints: dynamic_entrypoints; storage: s2 }"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Dynamic_entrypoints.storage` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val originate_contract : 'p 's.('p, 's) michelson_contract -> 's -> tez -> ('p, 's) typed_address"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let originate_contract: <p, s>(_: michelson_contract<p, s>) => (_: s) => (_: tez) => typed_address<p, s>"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Originate.michelson` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Originate a contract with initial storage and initial\nbalance."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val compile_contract_with_views : 'p 's.(('p * 's) -> (operation list * 's)) -> 's views -> ('p, 's) michelson_contract"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let compile_contract_with_views: <p, s>(_: (_: [p, s]) => [list<operation>, s]) => (_: views<s>) => michelson_contract<p, s>"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Michelson.Contract.compile_with_views` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val originate : 'p 's.('p, 's) module_contract -> 's -> tez -> ('p, 's) origination_result"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let originate: <p, s>(_: module_contract<p, s>) => (_: s) => (_: tez) => origination_result<p, s>"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Originate.contract` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Originate a contract with an entrypoint function in curried\nform, initial storage and initial balance."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val compile_contract_from_file : 'p 's.string -> ('p, 's) michelson_contract"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let compile_contract_from_file: <p, s>(_: string) => michelson_contract<p, s>"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Michelson.Contract.from_file` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Compiles a contract with a path to the contract file, an\nentrypoint, and a list of views."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val originate_from_file : 'p 's.string -> 's -> tez -> ('p, 's) origination_result"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let originate_from_file: <p, s>(_: string) => (_: s) => (_: tez) => origination_result<p, s>"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Originate.from_file` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Originate a contract with a path to the contract file, an\nentrypoint, and a list of views, together with an initial storage\nand an initial balance."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val mutation_test : 'a 'b.'a -> ('a -> 'b) -> ('b * mutation) option"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let mutation_test: <a, b>(_: a) => (_: (_: a) => b) => option<[b, mutation]>"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Mutation.func` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Given a value to mutate (first argument), it will try all the\nmutations available of it, passing each one to the function\n(second argument). On the first case of non failure when running\nthe function on a mutation, the value and mutation involved will\nbe returned."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val mutation_test_all : 'a 'b.'a -> ('a -> 'b) -> ('b * mutation) list"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let mutation_test_all: <a, b>(_: a) => (_: (_: a) => b) => list<[b, mutation]>"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Mutation.All.func` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Given a value to mutate (first argument), it will try all the\nmutations of it, passing each one to the function (second\nargument). In case no failure arises when running the function on\na mutation, the failure and mutation involved will be added to the\nlist to be returned."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val originate_from_file_and_mutate : 'b 'p 's.string -> 's -> tez -> ((('p, 's) typed_address * ('p, 's) michelson_contract * int) -> 'b) -> ('b * mutation) option"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let originate_from_file_and_mutate: <b, p, s>(_: string) => (_: s) => (_: tez) => (_: (_: [typed_address<p, s>, michelson_contract<p, s>, int]) => b) => option< [b, mutation] >"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Mutation.from_file` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Given a contract from a file (passed by filepath, entrypoint and\nviews), an initial storage and balance, it will originate mutants\nof the contract and pass the result to the function (last\nargument). On the first case of non failure when running the\nfunction on a mutation, the value and mutation involved will be\nreturned."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val originate_from_file_and_mutate_all : 'b 'p 's.string -> 's -> tez -> ((('p, 's) typed_address * ('p, 's) michelson_contract * int) -> 'b) -> ('b * mutation) list"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let originate_from_file_and_mutate_all: <b, p, s>(_: string) => (_: s) => (_: tez) => (_: (_: [typed_address<p, s>, michelson_contract<p, s>, int]) => b) => list< [b, mutation] >"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Mutation.All.from_file` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Given a contract from a file (passed by filepath, entrypoint and\nviews), an initial storage and balance, it will originate mutants\nof the contract and pass the result to the function (last\nargument). In case no failure arises when running the function on\na mutation, the failure and mutation involved will be added to the\nlist to be returned."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val originate_module_and_mutate : 'p 's 'b.('p, 's) module_contract -> 's -> tez -> (('p, 's) typed_address -> ('p, 's) michelson_contract -> int -> 'b) -> ('b * mutation) option"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let originate_module_and_mutate: <p, s, b>(_: module_contract<p, s>) => (_: s) => (_: tez) => ( _: (_: typed_address<p, s>) => (_: michelson_contract<p, s>) => (_: int) => b ) => option<[b, mutation]>"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Mutation.contract` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Given a contract as a module/namespace, an initial storage and\nbalance, it will originate mutants of the contract and pass the\nresult to the function (last argument). On the first case of non\nfailure when running the function on a mutation, the value and\nmutation involved will be returned."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val originate_and_mutate_all : 'p 's 'b.('p, 's) module_contract -> 's -> tez -> (('p, 's) typed_address -> ('p, 's) michelson_contract -> int -> 'b) -> ('b * mutation) list"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let originate_and_mutate_all: <p, s, b>(_: module_contract<p, s>) => (_: s) => (_: tez) => ( _: (_: typed_address<p, s>) => (_: michelson_contract<p, s>) => (_: int) => b ) => list<[b, mutation]>"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Mutation.All.contract` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)("p",null,"Given a contract as a module/namespace, an initial storage and\nbalance, it will originate mutants of the contract and pass the\nresult to the function (last argument). In case no failure arises\nwhen running the function on a mutation, the failure and mutation\ninvolved will be added to the list to be returned."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val assert : bool -> unit"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let assert: (_: bool) => unit"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Assert.assert` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("p",null,"The call ",(0,r.kt)("inlineCode",{parentName:"p"},"assert cond")," terminates the execution with the string\n",(0,r.kt)("inlineCode",{parentName:"p"},'"failed assertion"')," if, and only if, the boolean condition ",(0,r.kt)("inlineCode",{parentName:"p"},"cond"),"\nis false. The failure is handled by LIGO's testing framework and\nnot by Michelson's interpreter.")),(0,r.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("p",null,"The call ",(0,r.kt)("inlineCode",{parentName:"p"},"assert(cond)")," terminates the execution with the string\n",(0,r.kt)("inlineCode",{parentName:"p"},'"failed assertion"')," if, and only if, the boolean condition ",(0,r.kt)("inlineCode",{parentName:"p"},"cond"),"\nis false. The failure is handled by LIGO's testing framework and\nnot by Michelson's interpreter.")),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val assert_some : 'a.'a option -> unit"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let assert_some: <a>(_: option<a>) => unit"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Assert.some` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("p",null,"The call ",(0,r.kt)("inlineCode",{parentName:"p"},"assert_some opt")," terminates the execution with the\nstring ",(0,r.kt)("inlineCode",{parentName:"p"},'"failed assert some"')," if, and only if, ",(0,r.kt)("inlineCode",{parentName:"p"},"opt")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"None"),".\nThe failure is handled by LIGO's testing framework and\nnot by Michelson's interpreter.")),(0,r.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("p",null,"The call ",(0,r.kt)("inlineCode",{parentName:"p"},"assert_some(opt)")," terminates the execution with the\nstring ",(0,r.kt)("inlineCode",{parentName:"p"},'"failed assert some"')," if, and only if, ",(0,r.kt)("inlineCode",{parentName:"p"},"opt")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"None()"),".\nThe failure is handled by LIGO's testing framework and\nnot by Michelson's interpreter.")),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val assert_none : 'a.'a option -> unit"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let assert_none: <a>(_: option<a>) => unit"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Assert.none` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("p",null,"The call ",(0,r.kt)("inlineCode",{parentName:"p"},"assert_none opt")," terminates the execution with the string\n",(0,r.kt)("inlineCode",{parentName:"p"},'"failed assert none"')," if, and only if, ",(0,r.kt)("inlineCode",{parentName:"p"},"opt")," is not ",(0,r.kt)("inlineCode",{parentName:"p"},"None"),".\nThe failure is handled by LIGO's testing framework and\nnot by Michelson's interpreter.")),(0,r.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("p",null,"The call ",(0,r.kt)("inlineCode",{parentName:"p"},"assert_none(opt)")," terminates the execution with the string\n",(0,r.kt)("inlineCode",{parentName:"p"},'"failed assert none"')," if, and only if, ",(0,r.kt)("inlineCode",{parentName:"p"},"opt")," is not ",(0,r.kt)("inlineCode",{parentName:"p"},"None()"),".\nThe failure is handled by LIGO's testing framework and\nnot by Michelson's interpreter.")),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val assert_with_error : bool -> string -> unit"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let assert_with_error: (b: bool, s: string) => unit"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Assert.Error.assert` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("p",null,"The call ",(0,r.kt)("inlineCode",{parentName:"p"},"assert_with_error cond error")," terminates the execution\nwith the string ",(0,r.kt)("inlineCode",{parentName:"p"},"error")," (that is, an error message) if, and only\nif, the boolean condition ",(0,r.kt)("inlineCode",{parentName:"p"},"cond")," is false. The failure is handled\nby LIGO's testing framework and not by Michelson's interpreter.")),(0,r.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("p",null,"The call ",(0,r.kt)("inlineCode",{parentName:"p"},"assert_with_error(cond, error)")," terminates the execution\nwith the string ",(0,r.kt)("inlineCode",{parentName:"p"},"error")," (that is, an error message) if, and only\nif, the boolean condition ",(0,r.kt)("inlineCode",{parentName:"p"},"cond")," is false. The failure is handled\nby LIGO's testing framework and not by Michelson's interpreter.")),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val assert_some_with_error : 'a.'a option -> string -> unit"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let assert_some_with_error: <a>(_: option<a>) => (_: string) => unit"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Assert.Error.some` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("p",null,"The call ",(0,r.kt)("inlineCode",{parentName:"p"},"assert_some_with_error opt err")," terminates the execution\nwith the string ",(0,r.kt)("inlineCode",{parentName:"p"},"err")," (that is, an error message) if, and only if,\n",(0,r.kt)("inlineCode",{parentName:"p"},"opt")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"None"),". The failure is handled by LIGO's testing\nframework and not by Michelson's interpreter.")),(0,r.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("p",null,"The call ",(0,r.kt)("inlineCode",{parentName:"p"},"assert_some_with_error(opt, err)")," terminates the\nexecution with the string ",(0,r.kt)("inlineCode",{parentName:"p"},"err")," (that is, an error message) if,\nand only if, ",(0,r.kt)("inlineCode",{parentName:"p"},"opt")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"None()"),". The failure is handled by LIGO's\ntesting framework and not by Michelson's interpreter.")),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val assert_none_with_error : 'a.'a option -> string -> unit"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let assert_none_with_error: <a>(_: option<a>) => (_: string) => unit"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Assert.Error.none` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("p",null,"The call ",(0,r.kt)("inlineCode",{parentName:"p"},"assert_none_with_error opt err")," terminates the execution\nwith the string ",(0,r.kt)("inlineCode",{parentName:"p"},"err")," (that is, an error message) if, and only if,\n",(0,r.kt)("inlineCode",{parentName:"p"},"opt")," is an optional value different from ",(0,r.kt)("inlineCode",{parentName:"p"},"None"),". The failure is\nhandled by LIGO's testing framework and not by Michelson's\ninterpreter.")),(0,r.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("p",null,"The call ",(0,r.kt)("inlineCode",{parentName:"p"},"assert_none_with_error(opt, err)")," terminates the\nexecution with the string ",(0,r.kt)("inlineCode",{parentName:"p"},"err")," (that is, an error message) if,\nand only if, ",(0,r.kt)("inlineCode",{parentName:"p"},"opt")," is an optional value different from\n",(0,r.kt)("inlineCode",{parentName:"p"},"None()"),". The failure is handled by LIGO's testing framework and\nnot by Michelson's interpreter.")),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val equal : 'a.'a -> 'a -> bool"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let equal: <a>(_: a) => (_: a) => bool"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Compare.eq` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("p",null,"The call ",(0,r.kt)("inlineCode",{parentName:"p"},"equal x y")," returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if, and only if, ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),"\nare considered to be equal w.r.t. the order on the underlying\ntype.")),(0,r.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("p",null,"The call ",(0,r.kt)("inlineCode",{parentName:"p"},"equal(x, y)")," returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if, and only if, ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),"\nare considered to be equal w.r.t. the order on the underlying\ntype.")),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val not_equal : 'a.'a -> 'a -> bool"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let not_equal: <a>(_: a) => (_: a) => bool"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Compare.neq` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("p",null,"The call ",(0,r.kt)("inlineCode",{parentName:"p"},"not_equal x y")," returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if, and only if, ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and\n",(0,r.kt)("inlineCode",{parentName:"p"},"y")," are not considered to be equal w.r.t. the order on the\nunderlying type.")),(0,r.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("p",null,"The call ",(0,r.kt)("inlineCode",{parentName:"p"},"not_equal(x, y)")," returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if, and only if, ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and\n",(0,r.kt)("inlineCode",{parentName:"p"},"y")," are not considered to be equal w.r.t. the order on the\nunderlying type.")),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val greater : 'a.'a -> 'a -> bool"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let greater: <a>(_: a) => (_: a) => bool"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Compare.gt` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("p",null,"The call ",(0,r.kt)("inlineCode",{parentName:"p"},"greater x y")," returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if, and only if, ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," is\nconsidered to be greater than ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," w.r.t. the order on the\nunderlying type.")),(0,r.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("p",null,"The call ",(0,r.kt)("inlineCode",{parentName:"p"},"greater(x, y)")," returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if, and only if, ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," is\nconsidered to be greater than ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," w.r.t. the order on the\nunderlying type.")),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val less : 'a.'a -> 'a -> bool"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let less: <a>(_: a) => (_: a) => bool"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Compare.lt` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("p",null,"The call ",(0,r.kt)("inlineCode",{parentName:"p"},"less x y")," returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if, and only if, ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," is\nconsidered to be less than ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," w.r.t. the order on the underlying\ntype.")),(0,r.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("p",null,"The call ",(0,r.kt)("inlineCode",{parentName:"p"},"less(x, y)")," returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if, and only if, ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," is\nconsidered to be less than ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," w.r.t. the order on the underlying\ntype.")),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val greater_or_equal : 'a.'a -> 'a -> bool"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let greater_or_equal: <a>(_: a) => (_: a) => bool"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Compare.ge` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("p",null,"The call ",(0,r.kt)("inlineCode",{parentName:"p"},"greater_or_equal x y")," returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if, and only if,\n",(0,r.kt)("inlineCode",{parentName:"p"},"x")," is considered to be greater or equal than ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," w.r.t. the order\non the underlying type.")),(0,r.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("p",null,"The call ",(0,r.kt)("inlineCode",{parentName:"p"},"greater_or_equal(x, y)")," returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if, and only if,\n",(0,r.kt)("inlineCode",{parentName:"p"},"x")," is considered to be greater or equal than ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," w.r.t. the order\non the underlying type.")),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val less_or_equal : 'a.'a -> 'a -> bool"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let less_or_equal: <a>(_: a) => (_: a) => bool"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Compare.le` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)(i.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("p",null,"The call ",(0,r.kt)("inlineCode",{parentName:"p"},"less_or_equal x y")," returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if, and only if, ",(0,r.kt)("inlineCode",{parentName:"p"},"x"),"\nis considered to be less or equal than ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," w.r.t. the order on the\nunderlying type.")),(0,r.kt)(i.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("p",null,"The call ",(0,r.kt)("inlineCode",{parentName:"p"},"less_or_equal(x, y)")," returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if, and only if, ",(0,r.kt)("inlineCode",{parentName:"p"},"x"),"\nis considered to be less or equal than ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," w.r.t. the order on the\nunderlying type.")),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val create_chest : bytes -> nat -> (chest * chest_key)"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let create_chest: (_: bytes) => (_: nat) => [chest, chest_key]"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Timelock.create` from `Test.Next` is encouraged for a smoother migration.",(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"SyntaxTitle"},"val create_chest_key : chest -> nat -> chest_key"),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"SyntaxTitle"},"let create_chest_key: (_: chest) => (_: nat) => chest_key"),"**Deprecated:** In a future version, `Test` will be replaced by `Test.Next`, and using `Timelock.create_key` from `Test.Next` is encouraged for a smoother migration.")}y.isMDXComponent=!0},23746:(e,t,n)=>{n.r(t),n.d(t,{Prism:()=>a.Z,default:()=>u,defaultProps:()=>o});var a=n(87410);const r={plain:{backgroundColor:"#2a2734",color:"#9a86fd"},styles:[{types:["comment","prolog","doctype","cdata","punctuation"],style:{color:"#6c6783"}},{types:["namespace"],style:{opacity:.7}},{types:["tag","operator","number"],style:{color:"#e09142"}},{types:["property","function"],style:{color:"#9a86fd"}},{types:["tag-id","selector","atrule-id"],style:{color:"#eeebff"}},{types:["attr-name"],style:{color:"#c4b9fe"}},{types:["boolean","string","entity","url","attr-value","keyword","control","directive","unit","statement","regex","atrule","placeholder","variable"],style:{color:"#ffcc99"}},{types:["deleted"],style:{textDecorationLine:"line-through"}},{types:["inserted"],style:{textDecorationLine:"underline"}},{types:["italic"],style:{fontStyle:"italic"}},{types:["important","bold"],style:{fontWeight:"bold"}},{types:["important"],style:{color:"#c4b9fe"}}]};var i=n(67294),o={Prism:a.Z,theme:r};function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(){return l=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},l.apply(this,arguments)}var p=/\r\n|\r|\n/,d=function(e){0===e.length?e.push({types:["plain"],content:"\n",empty:!0}):1===e.length&&""===e[0].content&&(e[0].content="\n",e[0].empty=!0)},c=function(e,t){var n=e.length;return n>0&&e[n-1]===t?e:e.concat(t)},m=function(e,t){var n=e.plain,a=Object.create(null),r=e.styles.reduce((function(e,n){var a=n.languages,r=n.style;return a&&!a.includes(t)||n.types.forEach((function(t){var n=l({},e[t],r);e[t]=n})),e}),a);return r.root=n,r.plain=l({},n,{backgroundColor:null}),r};function y(e,t){var n={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&-1===t.indexOf(a)&&(n[a]=e[a]);return n}const u=function(e){function t(){for(var t=this,n=[],a=arguments.length;a--;)n[a]=arguments[a];e.apply(this,n),s(this,"getThemeDict",(function(e){if(void 0!==t.themeDict&&e.theme===t.prevTheme&&e.language===t.prevLanguage)return t.themeDict;t.prevTheme=e.theme,t.prevLanguage=e.language;var n=e.theme?m(e.theme,e.language):void 0;return t.themeDict=n})),s(this,"getLineProps",(function(e){var n=e.key,a=e.className,r=e.style,i=l({},y(e,["key","className","style","line"]),{className:"token-line",style:void 0,key:void 0}),o=t.getThemeDict(t.props);return void 0!==o&&(i.style=o.plain),void 0!==r&&(i.style=void 0!==i.style?l({},i.style,r):r),void 0!==n&&(i.key=n),a&&(i.className+=" "+a),i})),s(this,"getStyleForToken",(function(e){var n=e.types,a=e.empty,r=n.length,i=t.getThemeDict(t.props);if(void 0!==i){if(1===r&&"plain"===n[0])return a?{display:"inline-block"}:void 0;if(1===r&&!a)return i[n[0]];var o=a?{display:"inline-block"}:{},s=n.map((function(e){return i[e]}));return Object.assign.apply(Object,[o].concat(s))}})),s(this,"getTokenProps",(function(e){var n=e.key,a=e.className,r=e.style,i=e.token,o=l({},y(e,["key","className","style","token"]),{className:"token "+i.types.join(" "),children:i.content,style:t.getStyleForToken(i),key:void 0});return void 0!==r&&(o.style=void 0!==o.style?l({},o.style,r):r),void 0!==n&&(o.key=n),a&&(o.className+=" "+a),o})),s(this,"tokenize",(function(e,t,n,a){var r={code:t,grammar:n,language:a,tokens:[]};e.hooks.run("before-tokenize",r);var i=r.tokens=e.tokenize(r.code,r.grammar,r.language);return e.hooks.run("after-tokenize",r),i}))}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.render=function(){var e=this.props,t=e.Prism,n=e.language,a=e.code,r=e.children,i=this.getThemeDict(this.props),o=t.languages[n];return r({tokens:function(e){for(var t=[[]],n=[e],a=[0],r=[e.length],i=0,o=0,s=[],l=[s];o>-1;){for(;(i=a[o]++)<r[o];){var m=void 0,y=t[o],u=n[o][i];if("string"==typeof u?(y=o>0?y:["plain"],m=u):(y=c(y,u.type),u.alias&&(y=c(y,u.alias)),m=u.content),"string"==typeof m){var g=m.split(p),x=g.length;s.push({types:y,content:g[0]});for(var f=1;f<x;f++)d(s),l.push(s=[]),s.push({types:y,content:g[f]})}else o++,t.push(y),n.push(m),a.push(0),r.push(m.length)}o--,t.pop(),n.pop(),a.pop(),r.pop()}return d(s),l}(void 0!==o?this.tokenize(t,a,o,n):[a]),className:"prism-code language-"+n,style:void 0!==i?i.root:{},getLineProps:this.getLineProps,getTokenProps:this.getTokenProps})},t}(i.Component)},87552:(e,t,n)=>{n.d(t,{Z:()=>a});const a={plain:{color:"#bfc7d5",backgroundColor:"#292d3e"},styles:[{types:["comment"],style:{color:"rgb(105, 112, 152)",fontStyle:"italic"}},{types:["string","inserted"],style:{color:"rgb(195, 232, 141)"}},{types:["number"],style:{color:"rgb(247, 140, 108)"}},{types:["builtin","char","constant","function"],style:{color:"rgb(130, 170, 255)"}},{types:["punctuation","selector"],style:{color:"rgb(199, 146, 234)"}},{types:["variable"],style:{color:"rgb(191, 199, 213)"}},{types:["class-name","attr-name"],style:{color:"rgb(255, 203, 107)"}},{types:["tag","deleted"],style:{color:"rgb(255, 85, 114)"}},{types:["operator"],style:{color:"rgb(137, 221, 255)"}},{types:["boolean"],style:{color:"rgb(255, 88, 116)"}},{types:["keyword"],style:{fontStyle:"italic"}},{types:["doctype"],style:{color:"rgb(199, 146, 234)",fontStyle:"italic"}},{types:["namespace"],style:{color:"rgb(178, 204, 214)"}},{types:["url"],style:{color:"rgb(221, 221, 221)"}}]}}}]);