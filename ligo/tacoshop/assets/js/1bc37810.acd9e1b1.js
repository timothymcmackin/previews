"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[23373],{3905:(t,e,n)=>{n.d(e,{Zo:()=>c,kt:()=>m});var a=n(67294);function s(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function o(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function i(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?o(Object(n),!0).forEach((function(e){s(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function r(t,e){if(null==t)return{};var n,a,s=function(t,e){if(null==t)return{};var n,a,s={},o=Object.keys(t);for(a=0;a<o.length;a++)n=o[a],e.indexOf(n)>=0||(s[n]=t[n]);return s}(t,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);for(a=0;a<o.length;a++)n=o[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(s[n]=t[n])}return s}var l=a.createContext({}),u=function(t){var e=a.useContext(l),n=e;return t&&(n="function"==typeof t?t(e):i(i({},e),t)),n},c=function(t){var e=u(t.components);return a.createElement(l.Provider,{value:e},t.children)},g={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},p=a.forwardRef((function(t,e){var n=t.components,s=t.mdxType,o=t.originalType,l=t.parentName,c=r(t,["components","mdxType","originalType","parentName"]),p=u(n),m=s,d=p["".concat(l,".").concat(m)]||p[m]||g[m]||o;return n?a.createElement(d,i(i({ref:e},c),{},{components:n})):a.createElement(d,i({ref:e},c))}));function m(t,e){var n=arguments,s=e&&e.mdxType;if("string"==typeof t||s){var o=n.length,i=new Array(o);i[0]=p;var r={};for(var l in e)hasOwnProperty.call(e,l)&&(r[l]=e[l]);r.originalType=t,r.mdxType="string"==typeof t?t:s,i[1]=r;for(var u=2;u<o;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},48720:(t,e,n)=>{n.d(e,{D:()=>s.Z,Z:()=>o});var a=n(67294),s=n(75402);const o=function(t){return a.createElement(s.Z.Consumer,null,(e=>{let{syntax:n}=e;return n===t.syntax?t.children:a.createElement(a.Fragment,null)}))}},56326:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>u,contentTitle:()=>r,default:()=>p,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var a=n(87462),s=(n(67294),n(3905)),o=n(48720);const i={id:"mutation-testing",title:"Mutation testing"},r=void 0,l={unversionedId:"testing/mutation-testing",id:"version-1.9.2/testing/mutation-testing",title:"Mutation testing",description:"Mutation testing evaluates the quality of software tests.",source:"@site/versioned_docs/version-1.9.2/testing/mutation-testing.md",sourceDirName:"testing",slug:"/testing/mutation-testing",permalink:"/previews/ligo/tacoshop/docs/testing/mutation-testing",draft:!1,tags:[],version:"1.9.2",frontMatter:{id:"mutation-testing",title:"Mutation testing"},sidebar:"docs",previous:{title:"Testing tickets",permalink:"/previews/ligo/tacoshop/docs/testing/testing-tickets"},next:{title:"Testing Michelson code",permalink:"/previews/ligo/tacoshop/docs/testing/michelson_testing"}},u={},c=[{value:"Mutation testing a simple function",id:"mutation-testing-a-simple-function",level:2},{value:"Mutating a contract",id:"mutating-a-contract",level:2},{value:"Returning multiple mutations",id:"returning-multiple-mutations",level:2},{value:"Preventing mutation",id:"preventing-mutation",level:2}],g={toc:c};function p(t){let{components:e,...n}=t;return(0,s.kt)("wrapper",(0,a.Z)({},g,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Mutation testing evaluates the quality of software tests.\nMutation testing works by creating slightly different versions of code blocks and verifying that they do not pass the same tests that the original code passes.\nIf the mutated versions pass the tests, the tests may not be precise enough to catch potential problems."),(0,s.kt)("p",null,"LIGO's testing suite provides mutation testing tools to ensure that contracts are tested in a precise, thorough way and that the tests catch changes in the contracts."),(0,s.kt)("h2",{id:"mutation-testing-a-simple-function"},"Mutation testing a simple function"),(0,s.kt)("p",null,"For an example of mutation testing, take this simple function that accepts an integer and doubles it:"),(0,s.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"test-ligo group=twice","test-ligo":!0,group:"twice"},"let twice (x : int) = x + x\n"))),(0,s.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"test-ligo group=twice","test-ligo":!0,group:"twice"},"const twice = (x: int) => x + x;\n"))),(0,s.kt)("p",null,"To test this function, you might provide some input and output values as test cases and verify that they match:"),(0,s.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"test-ligo group=twice","test-ligo":!0,group:"twice"},"module Test = Test.Next\nlet simple_tests (f : int -> int) =\n  (* Test 1 *)\n  let () = Assert.assert (Test.Compare.eq (Test.Michelson.run f 0) (Test.Michelson.eval 0)) in\n  (* Test 2 *)\n  let () = Assert.assert (Test.Compare.eq (Test.Michelson.run f 2) (Test.Michelson.eval 4))\n  in ()\n\nlet test = simple_tests twice\n"))),(0,s.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"test-ligo group=twice","test-ligo":!0,group:"twice"},"import Test = Test.Next;\nconst simple_tests = (f : ((input: int) => int)) : unit => {\n  /* Test 1 */\n  Assert.assert(Test.Compare.eq(Test.Michelson.run(f, 0), Test.Michelson.eval(0)));\n  /* Test 2 */\n  Assert.assert(Test.Compare.eq(Test.Michelson.run(f, 2), Test.Michelson.eval(4)));\n};\n\nconst test = simple_tests(twice);\n"))),(0,s.kt)("p",null,"These tests check these use cases of the ",(0,s.kt)("inlineCode",{parentName:"p"},"twice")," function:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"When run on input ",(0,s.kt)("inlineCode",{parentName:"li"},"0"),", it returns ",(0,s.kt)("inlineCode",{parentName:"li"},"0"),"."),(0,s.kt)("li",{parentName:"ul"},"When run on input ",(0,s.kt)("inlineCode",{parentName:"li"},"2"),", it returns ",(0,s.kt)("inlineCode",{parentName:"li"},"4"),".")),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"twice")," function passes the tests:"),(0,s.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell",metastring:"run",run:!0},"ligo run test gitlab-pages/docs/testing/src/mutation-testing/twice.mligo\n# Outputs:\n# Everything at the top-level was executed.\n# - test exited with value ().\n"))),(0,s.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell",metastring:"run",run:!0},"ligo run test gitlab-pages/docs/testing/src/mutation-testing/twice.jsligo\n# Outputs:\n# Everything at the top-level was executed.\n# - test exited with value ().\n"))),(0,s.kt)("p",null,"The implementation does what it intends to do.\nHowever, the implemented function is not the only function that passes the tests.\nSuppose a programmer made a mistake and wrote the implementation of multiplying the input by itself instead of adding it to itself, as in this example:"),(0,s.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"test-ligo group=frontpage","test-ligo":!0,group:"frontpage"},"let twice (x : int) = x * x\n"))),(0,s.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"test-ligo group=frontpage","test-ligo":!0,group:"frontpage"},"const twice = (x: int): int => x * x;\n"))),(0,s.kt)("p",null,"This faulty implementation passes the above tests because its output for each test case is the same as the correct implementation.\nThat result suggests that the tests are not good enough to distinguish a good implementation from incorrect implementations."),(0,s.kt)("p",null,"To help you add more test cases and ensure that the tests are complete, you can use mutation testing to identify different versions of the function (known as ",(0,s.kt)("em",{parentName:"p"},"mutations"),") that pass all of the tests."),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"Test.Next.Mutation.func")," function takes a value to mutate (usually a function) and a test case function to apply to mutated versions of that value.\nIf the test case function terminates correctly, the ",(0,s.kt)("inlineCode",{parentName:"p"},"Test.Next.Mutation.func")," function stops trying mutations and returns a ",(0,s.kt)("inlineCode",{parentName:"p"},"Some")," option with the mutation that passed all of the tests.\nIf no mutation passes the test case function, the ",(0,s.kt)("inlineCode",{parentName:"p"},"Test.Next.Mutation.func")," function returns ",(0,s.kt)("inlineCode",{parentName:"p"},"None"),"."),(0,s.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},"val Test.mutation_test : 'a -> ('a -> 'b) -> ('b * mutation) option\n"))),(0,s.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},"val Test.mutation_test : (value: 'a, tester: ('a -> 'b)) => option <['b, mutation]>\n"))),(0,s.kt)("p",null,"For example, this code tests mutations of the correct ",(0,s.kt)("inlineCode",{parentName:"p"},"twice")," function implementation with the two test cases in the ",(0,s.kt)("inlineCode",{parentName:"p"},"simple_tests")," function:"),(0,s.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"test-ligo group=twice","test-ligo":!0,group:"twice"},'let test_mutation =\n  match Test.Mutation.func twice simple_tests with\n    None -> ()\n  | Some (_, mutation) ->\n      let () = Test.IO.log mutation in\n      Test.IO.println "Some mutation also passes the tests! ^^"\n'))),(0,s.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"test-ligo group=twice","test-ligo":!0,group:"twice"},'const test_mutation =\n  match(Test.Mutation.func(twice, simple_tests)) {\n    when(None()): unit;\n    when(Some(pmutation)): do {\n      Test.IO.log(pmutation[1]);\n      Test.IO.println("Some mutation also passes the tests! ^^")\n    }\n  };\n'))),(0,s.kt)("p",null,"The mutation test returns information about a function that passes all of the tests, in this case the function ",(0,s.kt)("inlineCode",{parentName:"p"},"x * x"),":"),(0,s.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell",metastring:"run",run:!0},'ligo run test gitlab-pages/docs/testing/src/mutation-testing/twice.mligo\n# Outputs:\n# Mutation at: File "gitlab-pages/docs/testing/src/mutation-testing/twice.mligo", line 1, characters 22-27:\n#   1 | let twice (x : int) = x + x\n#   2 | module Test = Test.Next\n#\n# Replacing by: x * x.\n#\n# Some mutation also passes the tests! ^^\n'))),(0,s.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell",metastring:"run",run:!0},'ligo run test gitlab-pages/docs/testing/src/mutation-testing/twice.jsligo\n# Outputs:\n# Mutation at: File "/Users/timothymcmackin/tezos/ligo/gitlab-pages/docs/testing/src/mutation-testing/twice.jsligo", line 1, characters 26-31:\n#   1 | const twice = (x: int) => x + x;\n#   2 | import Test = Test.Next;\n#\n# Replacing by: x * x.\n#\n# Some mutation also passes the tests! ^^\n'))),(0,s.kt)("p",null,"You can use this information to add a test case that the mutation fails, as in this example:"),(0,s.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},"let simple_tests (f : int -> int) =\n  (* Test 1 *)\n  let () = Assert.assert (Test.Compare.eq (Test.Michelson.run f 0) (Test.Michelson.eval 0)) in\n  (* Test 2 *)\n  let () = Assert.assert (Test.Compare.eq (Test.Michelson.run f 2) (Test.Michelson.eval 4)) in\n  (* Test 3 *)\n  let () = Assert.assert (Test.Compare.eq (Test.Michelson.run f 1) (Test.Michelson.eval 2))\n  in ()\n"))),(0,s.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},"const simple_tests = (f : ((input: int) => int)) : unit => {\n  /* Test 1 */\n  Assert.assert (Test.Compare.eq(Test.Michelson.run(f, 0), Test.Michelson.eval(0)));\n  /* Test 2 */\n  Assert.assert (Test.Compare.eq(Test.Michelson.run(f, 2), Test.Michelson.eval(4)));\n  /* Test 3 */\n  Assert.assert (Test.Compare.eq(Test.Michelson.run(f, 1), Test.Michelson.eval(2)));\n};\n"))),(0,s.kt)("p",null,"The new test case verifies that when input ",(0,s.kt)("inlineCode",{parentName:"p"},"1")," is given, output ",(0,s.kt)("inlineCode",{parentName:"p"},"2")," is returned.\nNow you can run the mutation test again and see that no mutation that the test suite tried passes every test, giving extra confidence in the tests:"),(0,s.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell",metastring:"run",run:!0},"ligo run test gitlab-pages/docs/testing/src/mutation-testing/twice.mligo\n# Outputs:\n# Everything at the top-level was executed.\n# - test exited with value ().\n# - test_mutation exited with value ().\n"))),(0,s.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell",metastring:"run",run:!0},"ligo run test gitlab-pages/docs/testing/src/mutation-testing/twice.jsligo\n# Outputs:\n# Everything at the top-level was executed.\n# - test exited with value ().\n# - test_mutation exited with value ().\n"))),(0,s.kt)("h2",{id:"mutating-a-contract"},"Mutating a contract"),(0,s.kt)("p",null,"Mutation testing can also help ensure that tests cover a smart contract thoroughly.\nFor example, this contract has two entrypoints: one that adds a number to a value in storage and one that subtracts a number from a value in storage:"),(0,s.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"test-ligo group=mutation-contract","test-ligo":!0,group:"mutation-contract"},"// This is mutation-contract.mligo\nmodule AddSub = struct\n  type storage = int\n\n  [@entry] let add (delta : int) (storage : storage) : operation list * storage = [], storage + delta\n  [@entry] let sub (delta : int) (storage : storage) : operation list * storage = [], storage - delta\nend\n"))),(0,s.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"test-ligo group=mutation-contract","test-ligo":!0,group:"mutation-contract"},"// This is mutation-contract.jsligo\nexport namespace AddSub {\n  export type storage = int;\n\n  @entry\n  const add = (delta: int, storage: storage): [list<operation>, storage] => [[], storage + delta];\n  @entry\n  const sub = (delta: int, storage: storage): [list<operation>, storage] => [[], storage - delta];\n}\n"))),(0,s.kt)("p",null,"Doing mutation testing on a contract with multiple entrypoints can help find entrypoints that are not covered by the tests."),(0,s.kt)("p",null,"For example, this test deploys a contract and tests that the ",(0,s.kt)("inlineCode",{parentName:"p"},"Add")," entrypoint works.\nNote that the test uses a function named ",(0,s.kt)("inlineCode",{parentName:"p"},"tester")," to deploy the contract and run the tests on it:"),(0,s.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"test-ligo group=mutation-contract-test","test-ligo":!0,group:"mutation-contract-test"},'(* This is mutation-contract-test.mligo *)\n\n#import "gitlab-pages/docs/testing/src/mutation-testing/mutation-contract.mligo" "MutationContract"\nmodule Test = Test.Next\ntype storage = MutationContract.AddSub.storage\ntype param = MutationContract.AddSub parameter_of\nlet initial_storage = 7\n\nlet tester (taddr : (param, storage) typed_address) (_ : (param ,storage) michelson_contract) (_:int) : unit =\n  let _ = Test.Contract.transfer_exn (Test.Typed_address.get_entrypoint "add" taddr) 7 0tez in\n  Assert.assert (Test.Typed_address.get_storage taddr = initial_storage + 7)\n\nlet test_original =\n  let orig = Test.Originate.contract (contract_of MutationContract.AddSub) initial_storage 0tez in\n  tester orig.taddr\n'))),(0,s.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"test-ligo group=mutation-contract-test","test-ligo":!0,group:"mutation-contract-test"},'// This is mutation-contract-test.jsligo\n\n#import "gitlab-pages/docs/testing/src/mutation-testing/mutation-contract.jsligo" "MutationContract"\nimport Test = Test.Next;\ntype storage = int;\ntype param = parameter_of MutationContract.AddSub;\nconst initial_storage = 7;\n\nconst tester = (taddr: typed_address<param, storage>, _c: michelson_contract<param, storage> , _: int): unit => {\n  Test.Contract.transfer_exn(Test.Typed_address.get_entrypoint("add", taddr), 7, 0tez);\n  Assert.assert(Test.Typed_address.get_storage(taddr) == initial_storage + 7);\n}\n\nconst test_original = (() => {\n  let orig = Test.Originate.contract(contract_of(MutationContract.AddSub), initial_storage, 0tez);\n  return tester(orig.taddr);\n})();\n'))),(0,s.kt)("p",null,"This test runs mutation tests on the contract by passing mutations of it to the ",(0,s.kt)("inlineCode",{parentName:"p"},"tester")," function:"),(0,s.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"test-ligo group=mutation-contract-test","test-ligo":!0,group:"mutation-contract-test"},'let test_mutation =\n  match Test.Mutation.contract (contract_of MutationContract.AddSub) initial_storage 0tez tester with\n    None -> ()\n  | Some (_, mutation) ->\n    let () = Test.IO.log(mutation) in\n    (* In a real program, one would write `failwith "A mutation passes"`\n       Since we want to demonstrate the issue without an actual error\n       a milder println is used in this document. *)\n    Test.IO.println "A mutation of the contract still passes the tests!"\n'))),(0,s.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"test-ligo group=mutation-contract-test","test-ligo":!0,group:"mutation-contract-test"},'const test_mutation =\n  match(Test.Mutation.contract(contract_of(MutationContract.AddSub), initial_storage, 0tez, tester)) {\n    when(None()): unit;\n    when(Some(pmutation)): do {\n      Test.IO.log(pmutation[1]);\n      // In a real program, one would write `failwith "A mutation passes"`\n      // Because we want to demonstrate the issue without an actual error\n      // a milder println is used in this document.\n      Test.IO.println("A mutation of the contract still passes the tests!");\n    }\n  };\n'))),(0,s.kt)("p",null,"The test prints a warning about the ",(0,s.kt)("inlineCode",{parentName:"p"},"Sub")," entrypoint:"),(0,s.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell",metastring:"run",run:!0},'ligo run test --library . gitlab-pages/docs/testing/src/mutation-testing/mutation-contract-test.mligo\n# Outputs:\n# Mutation at: File "/Users/timothymcmackin/tezos/ligo/gitlab-pages/docs/testing/src/mutation-testing/mutation-contract.mligo", line 6, characters 86-101:\n#   5 |   [@entry] let add (delta : int) (storage : storage) : operation list * storage = [], storage + delta\n#   6 |   [@entry] let sub (delta : int) (storage : storage) : operation list * storage = [], storage - delta\n#   7 | end\n#\n# Replacing by: storage + delta.\n#\n# A mutation of the contract still passes the tests!\n'))),(0,s.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell",metastring:"run",run:!0},'ligo run test --library . gitlab-pages/docs/testing/src/mutation-testing/mutation-contract-test.jsligo\n# Outputs:\n# Mutation at: File "gitlab-pages/docs/testing/src/mutation-testing/mutation-contract.jsligo", line 8, characters 81-96:\n#   7 |   @entry\n#   8 |   const sub = (delta: int, storage: storage): [list<operation>, storage] => [[], storage - delta];\n#   9 | }\n#\n# Replacing by: storage + delta.\n#\n# A mutation of the contract still passes the tests!\n'))),(0,s.kt)("p",null,"The mutation testing found that the ",(0,s.kt)("inlineCode",{parentName:"p"},"sub")," function can be changed with no consequences in the test.\nThis warning signals that the test does not cover the ",(0,s.kt)("inlineCode",{parentName:"p"},"Sub")," entrypoint thoroughly enough.\nThe following updated test adds a call to the ",(0,s.kt)("inlineCode",{parentName:"p"},"Sub")," entrypoint to test it:"),(0,s.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"test-ligo group=mutation-contract-test","test-ligo":!0,group:"mutation-contract-test"},'let tester_add_and_sub (taddr : (param, storage) typed_address) (_ : (param, storage) michelson_contract) (_ : int) : unit =\n  let _ = Test.Contract.transfer_exn (Test.Typed_address.get_entrypoint "add" taddr) 7 0tez in\n  let () = Assert.assert (Test.get_storage taddr = initial_storage + 7) in\n  let _ = Test.Contract.transfer_exn (Test.Typed_address.get_entrypoint "sub" taddr) 3 0tez in\n  Assert.assert (Test.get_storage taddr = initial_storage + 4)\n\nlet test_mutation_sub =\n  match Test.Mutation.contract (contract_of MutationContract.AddSub) initial_storage 0tez tester_add_and_sub with\n    None -> ()\n  | Some (_, mutation) ->\n    let () = Test.IO.log(mutation) in\n    Test.IO.println "A mutation of the contract still passes the tests!"\n'))),(0,s.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"test-ligo group=mutation-contract-test","test-ligo":!0,group:"mutation-contract-test"},'const tester_add_and_sub = (taddr: typed_address<param, storage>, _c: michelson_contract<param, storage>, _i: int): unit => {\n\n  Test.Contract.transfer_exn(Test.Typed_address.get_entrypoint("add", taddr), 7, 0tez);\n  Assert.assert(Test.Typed_address.get_storage(taddr) == initial_storage + 7);\n  Test.Contract.transfer_exn(Test.Typed_address.get_entrypoint("sub", taddr), 3, 0tez);\n  Assert.assert(Test.Typed_address.get_storage(taddr) == initial_storage + 4);\n}\n\nconst test_mutation_sub =\n  match(Test.Mutation.contract(contract_of(MutationContract.AddSub), initial_storage, 0tez, tester_add_and_sub)) {\n    when(None()): unit;\n    when(Some(pmutation)): do {\n      Test.IO.log(pmutation[1]);\n      Test.IO.println("A mutation of the contract still passes the tests!");\n    }\n  };\n'))),(0,s.kt)("p",null,"When this test runs, it finds that no mutation of the ",(0,s.kt)("inlineCode",{parentName:"p"},"Sub")," entrypoint passes all of the tests and therefore does not print a warning."),(0,s.kt)("h2",{id:"returning-multiple-mutations"},"Returning multiple mutations"),(0,s.kt)("p",null,"In the previous examples, the functions ",(0,s.kt)("inlineCode",{parentName:"p"},"Test.Next.Mutation.func")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"Test.Next.Mutation.contract")," return an option that contains either None or Some with a single mutation that passes the tests.\nTo speed up the process of eliminating mutations, you can use the ",(0,s.kt)("inlineCode",{parentName:"p"},"Test.Next.Mutation.All.func")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"Test.Next.Mutation.All.contract")," functions to get every mutation that passes the tests.\nThese functions return a list of mutations instead of an option."),(0,s.kt)("p",null,"This example gets every mutation that passes the tests for the ",(0,s.kt)("inlineCode",{parentName:"p"},"twice")," function:"),(0,s.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"test-ligo group=twice","test-ligo":!0,group:"twice"},'let get_all_mutations =\n  match Test.Mutation.All.func twice simple_tests with\n    [] -> ()\n  | ms ->\n      let () = Test.IO.println "Some mutation also passes the tests! ^^" in\n      List.iter (fun ((_, mutation) : unit * mutation) -> Test.IO.log mutation) ms\n'))),(0,s.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"test-ligo group=twice","test-ligo":!0,group:"twice"},'const get_all_mutations =\n  match(Test.Mutation.All.func(twice, simple_tests)) {\n    when([]): unit;\n    when([hd,...tl]): do {\n      let mutations = list([hd,...tl]);\n      Test.IO.println("Some mutations also pass the tests!");\n      for (const m of mutations) {\n        let [_, mutation] = m;\n        Test.IO.log(mutation);\n      };\n    }\n  };\n'))),(0,s.kt)("p",null,"In this case, the output is the same because only one mutation passed all of the tests."),(0,s.kt)("p",null,"Similarly, the ",(0,s.kt)("inlineCode",{parentName:"p"},"Test.Next.Mutation.All.contract")," function returns a list of all contract mutations that pass the tests.\nFor example, this test adapts the contract test in the previous section to return every passing mutation:"),(0,s.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"test-ligo group=mutation-contract-test","test-ligo":!0,group:"mutation-contract-test"},'let test_mutation_all =\n  match Test.Mutation.All.contract (contract_of MutationContract.AddSub) initial_storage 0tez tester with\n    [] -> ()\n  | ms ->\n      let () = Test.IO.println "Some mutation also passes the tests! ^^" in\n      List.iter (fun ((_, mutation) : unit * mutation) -> Test.IO.log mutation) ms\n')),(0,s.kt)("p",null,"In this case, the output shows that multiple mutations pass the tests:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},'Mutation at: File "gitlab-pages/docs/testing/src/mutation-testing/mutation-contract.mligo", line 6, characters 86-101:\n  5 |   [@entry] let add (delta : int) (storage : storage) : operation list * storage = [], storage + delta\n  6 |   [@entry] let sub (delta : int) (storage : storage) : operation list * storage = [], storage - delta\n  7 | end\n\nReplacing by: storage + delta.\n\nA mutation of the contract still passes the tests!\nSome mutation also passes the tests! ^^\nMutation at: File "gitlab-pages/docs/testing/src/mutation-testing/mutation-contract.mligo", line 6, characters 86-101:\n  5 |   [@entry] let add (delta : int) (storage : storage) : operation list * storage = [], storage + delta\n  6 |   [@entry] let sub (delta : int) (storage : storage) : operation list * storage = [], storage - delta\n  7 | end\n\nReplacing by: storage / delta.\n\nMutation at: File "gitlab-pages/docs/testing/src/mutation-testing/mutation-contract.mligo", line 6, characters 86-101:\n  5 |   [@entry] let add (delta : int) (storage : storage) : operation list * storage = [], storage + delta\n  6 |   [@entry] let sub (delta : int) (storage : storage) : operation list * storage = [], storage - delta\n  7 | end\n\nReplacing by: storage * delta.\n'))),(0,s.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"test-ligo group=mutation-contract-test","test-ligo":!0,group:"mutation-contract-test"},'const test_mutation_all =\n  match(Test.Mutation.All.contract(contract_of(MutationContract.AddSub), initial_storage, 0tez, tester)) {\n    when([]): unit;\n    when([hd,...tl]): do {\n      let mutations = list([hd,...tl]);\n      let _p = Test.IO.println("Some mutations also pass the tests!");\n      for (const m of mutations) {\n        let [_, mutation] = m;\n        Test.IO.log(mutation);\n      };\n    }\n  };\n')),(0,s.kt)("p",null,"In this case, the output shows that multiple mutations pass the tests:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},'Some mutations also pass the tests!\nMutation at: File "gitlab-pages/docs/testing/src/mutation-testing/mutation-contract.jsligo", line 8, characters 81-96:\n  7 |   @entry\n  8 |   const sub = (delta: int, storage: storage): [list<operation>, storage] => [[], storage - delta];\n  9 | }\n\nReplacing by: storage / delta.\n\nMutation at: File "gitlab-pages/docs/testing/src/mutation-testing/mutation-contract.jsligo", line 8, characters 81-96:\n  7 |   @entry\n  8 |   const sub = (delta: int, storage: storage): [list<operation>, storage] => [[], storage - delta];\n  9 | }\n\nReplacing by: storage * delta.\n\nMutation at: File "gitlab-pages/docs/testing/src/mutation-testing/mutation-contract.jsligo", line 8, characters 81-96:\n  7 |   @entry\n  8 |   const sub = (delta: int, storage: storage): [list<operation>, storage] => [[], storage - delta];\n  9 | }\n\nReplacing by: storage + delta.\n'))),(0,s.kt)("h2",{id:"preventing-mutation"},"Preventing mutation"),(0,s.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("p",null,"In some cases you may want to prevent mutations from changing certain parts of your code that should not change.\nTo prevent such mutations, apply the ",(0,s.kt)("inlineCode",{parentName:"p"},"@no_mutation")," attribute."),(0,s.kt)("p",null,"This example uses this attribute to prevent mutations from changing an invariant, in this case that zero equals zero.\nWith this attribute, the tests will not test meaningless assertions such as that zero is less than zero or that zero equals one.\nIt also uses this attribute to prevent mutations from changing the ",(0,s.kt)("inlineCode",{parentName:"p"},"Sub")," entrypoint, which prevents the warnings from the previous sections:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"test-ligo group=no_mutation","test-ligo":!0,group:"no_mutation"},"(* This is mutation-contract.mligo *)\ntype storage = int\n\ntype result = operation list * storage\n\n(* Two entrypoints *)\n[@entry]\nlet add (delta : int) (store : storage) : result =\n  [@no_mutation] let _ = assert (0 = 0) in\n  [], store + delta\n\n[@entry] [@no_mutation]\nlet sub (delta : int) (store : storage) : result =\n  [], store - delta\n"))),(0,s.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("p",null,"In some cases you may want to prevent mutations from changing certain parts of your code that should not change.\nTo prevent such mutations, apply the ",(0,s.kt)("inlineCode",{parentName:"p"},"@no_mutation")," decorator."),(0,s.kt)("p",null,"This example uses this decorator to prevent mutations from changing an invariant, in this case that zero equals zero.\nWith this decorator, the tests will not test meaningless assertions such as that zero is less than zero or that zero equals one.\nIt also uses this decorator to prevent mutations from changing the ",(0,s.kt)("inlineCode",{parentName:"p"},"Sub")," entrypoint, which prevents the warnings from the previous sections:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"test-ligo group=no_mutation","test-ligo":!0,group:"no_mutation"},"// This is mutation-contract.mligo\ntype storage = int;\n\ntype result = [list<operation>, storage];\n\n// Two entrypoints\n@entry\nconst add = (delta : int, store : storage) : result => {\n  @no_mutation let _a = assert (0 == 0);\n  return [[], store + delta];\n};\n\n@entry @no_mutation\nconst sub = (delta : int, store : storage) : result => {\n  return [[], store - delta];\n};\n"))))}p.isMDXComponent=!0}}]);