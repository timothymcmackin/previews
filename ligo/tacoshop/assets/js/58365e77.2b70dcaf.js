"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[52641],{3905:(e,n,t)=>{t.d(n,{Zo:()=>m,kt:()=>d});var a=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var p=a.createContext({}),s=function(e){var n=a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},m=function(e){var n=s(e.components);return a.createElement(p.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,p=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),c=s(t),d=i,g=c["".concat(p,".").concat(d)]||c[d]||u[d]||o;return t?a.createElement(g,r(r({ref:n},m),{},{components:t})):a.createElement(g,r({ref:n},m))}));function d(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,r=new Array(o);r[0]=c;var l={};for(var p in n)hasOwnProperty.call(n,p)&&(l[p]=n[p]);l.originalType=e,l.mdxType="string"==typeof e?e:i,r[1]=l;for(var s=2;s<o;s++)r[s]=t[s];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},48720:(e,n,t)=>{t.d(n,{D:()=>i.Z,Z:()=>o});var a=t(67294),i=t(75402);const o=function(e){return a.createElement(i.Z.Consumer,null,(n=>{let{syntax:t}=n;return t===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},85981:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>c,frontMatter:()=>r,metadata:()=>p,toc:()=>m});var a=t(87462),i=(t(67294),t(3905)),o=t(48720);const r={id:"math-numbers-tez",title:"Math, Numbers & Tez"},l=void 0,p={unversionedId:"language-basics/math-numbers-tez",id:"language-basics/math-numbers-tez",title:"Math, Numbers & Tez",description:"LIGO offers three built-in numerical types: int, nat and",source:"@site/../docs/language-basics/math-numbers-tez.md",sourceDirName:"language-basics",slug:"/language-basics/math-numbers-tez",permalink:"/previews/ligo/tacoshop/docs/next/language-basics/math-numbers-tez",draft:!1,tags:[],version:"current",frontMatter:{id:"math-numbers-tez",title:"Math, Numbers & Tez"}},s={},m=[{value:"Addition",id:"addition",level:2},{value:"Subtraction",id:"subtraction",level:2},{value:"Multiplication",id:"multiplication",level:2},{value:"Euclidean Division",id:"euclidean-division",level:2},{value:"From <code>int</code> to <code>nat</code> and back",id:"from-int-to-nat-and-back",level:2},{value:"Checking a <code>nat</code>",id:"checking-a-nat",level:2},{value:"Bitwise operations",id:"bitwise-operations",level:2},{value:"Increment operator",id:"increment-operator",level:2},{value:"Decrement operator",id:"decrement-operator",level:2}],u={toc:m};function c(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"LIGO offers three built-in numerical types: ",(0,i.kt)("inlineCode",{parentName:"p"},"int"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"nat")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"tez"),". Values of type ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," are integers; values of type ",(0,i.kt)("inlineCode",{parentName:"p"},"nat")," are\nnatural numbers (integral numbers greater than or equal to zero);\nvalues of type ",(0,i.kt)("inlineCode",{parentName:"p"},"tez")," are units of measure of Tezos tokens."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Integer literals are the same found in mainstream programming\nlanguages, for example, ",(0,i.kt)("inlineCode",{parentName:"p"},"10"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"-6")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),", but there is only one\ncanonical zero: ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," (so, for instance, ",(0,i.kt)("inlineCode",{parentName:"p"},"-0")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"00")," are invalid).")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Natural numbers are written as digits followed by the suffix ",(0,i.kt)("inlineCode",{parentName:"p"},"n"),",\nlike so: ",(0,i.kt)("inlineCode",{parentName:"p"},"12n"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"0n"),", and the same restriction on zero as integers\napplies: ",(0,i.kt)("inlineCode",{parentName:"p"},"0n")," is the only way to specify the natural zero.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Tezos tokens can be specified using literals of three kinds:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"units of millionth of ",(0,i.kt)("inlineCode",{parentName:"li"},"tez"),", using the suffix ",(0,i.kt)("inlineCode",{parentName:"li"},"mutez")," after a\nnatural literal, like ",(0,i.kt)("inlineCode",{parentName:"li"},"10000mutez")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"0mutez"),";"),(0,i.kt)("li",{parentName:"ul"},"units of ",(0,i.kt)("inlineCode",{parentName:"li"},"tez"),", using the suffix ",(0,i.kt)("inlineCode",{parentName:"li"},"tz")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"tez"),", like ",(0,i.kt)("inlineCode",{parentName:"li"},"3tz")," or\n",(0,i.kt)("inlineCode",{parentName:"li"},"3tez"),";"),(0,i.kt)("li",{parentName:"ul"},"decimal amounts of ",(0,i.kt)("inlineCode",{parentName:"li"},"tz")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"tez"),", like ",(0,i.kt)("inlineCode",{parentName:"li"},"12.3tz")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"12.4tez"),".")))),(0,i.kt)("p",null,"Note that large integral values can be expressed using underscores to\nseparate groups of digits, like ",(0,i.kt)("inlineCode",{parentName:"p"},"1_000mutez")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"0.000_004tez"),"."),(0,i.kt)("h2",{id:"addition"},"Addition"),(0,i.kt)("p",null,"Addition in LIGO is accomplished by means of the ",(0,i.kt)("inlineCode",{parentName:"p"},"+")," infix\noperator. Some type constraints apply, for example you cannot add a\nvalue of type ",(0,i.kt)("inlineCode",{parentName:"p"},"tez")," to a value of type ",(0,i.kt)("inlineCode",{parentName:"p"},"nat"),"."),(0,i.kt)("p",null,"In the following example you can find a series of arithmetic\noperations, including various numerical types. However, some bits\nremain in comments as they would otherwise not compile, for example,\nadding a value of type ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," to a value of type ",(0,i.kt)("inlineCode",{parentName:"p"},"tez")," is invalid. Note\nthat adding an integer to a natural number produces an integer."),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=a",group:"a"},"// int + int yields int\nlet a : int = 5 + 10\n\n// nat + int yields int\nlet b : int = 5n + 10\n\n// tez + tez yields tez\nlet c : tez = 5mutez + 0.000_010tez\n\n// tez + int or tez + nat is invalid\n// let d : tez = 5mutez + 10n\n\n// two nats yield a nat\nlet e : nat = 5n + 10n\n\n// nat + int yields an int: invalid\n// let f : nat = 5n + 10\n\nlet g : int = 1_000_000\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Tip: you can use underscores for readability when defining large\nnumbers:"),(0,i.kt)("pre",{parentName:"blockquote"},(0,i.kt)("code",{parentName:"pre",className:"language-cameligo"},"let sum : tez = 100_000mutez\n")))),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=a",group:"a"},"// int + int yields int\nconst a = 5 + 10;\n\n// nat + int yields int\nconst b = 5n + 10;\n\n// tez + tez yields tez\nconst c: tez = 5mutez + 1tez;\n\n// tez + int or tez + nat is invalid:\n// const d : tez = 5mutez + 10n;\n\n// two nats yield a nat\nconst e: nat = 5n + 10n;\n\n// nat + int yields an int: invalid\n// const f : nat = 5n + 10;\n\nconst g = 1_000_000;\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Tip: you can use underscores for readability when defining large\nnumbers:"),(0,i.kt)("pre",{parentName:"blockquote"},(0,i.kt)("code",{parentName:"pre",className:"language-jsligo"},"let sum : tez = 100_000mutez;\n")))),(0,i.kt)("h2",{id:"subtraction"},"Subtraction"),(0,i.kt)("p",null,"Subtraction looks as follows."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"\u26a0\ufe0f Even when subtracting two ",(0,i.kt)("inlineCode",{parentName:"p"},"nats"),", the result is an ",(0,i.kt)("inlineCode",{parentName:"p"},"int"),".")),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=b",group:"b"},"let a : int = 5 - 10\n\n// Subtraction of two nats yields an int\nlet b : int = 5n - 2n\n\n// Therefore the following is invalid\n// let c : nat = 5n - 2n\n"))),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=b",group:"b"},"const a = 5 - 10;\n\n// Subtraction of two nats yields an int\nconst b: int = 5n - 2n;\n\n// Therefore the following is invalid\n// const c : nat = 5n - 2n;\n"))),(0,i.kt)("p",null,"From protocol ",(0,i.kt)("em",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"em"},"Ithaca"))," onwards subtracting values of type ",(0,i.kt)("inlineCode",{parentName:"p"},"tez"),"\nyeilds an optional value (due to the Michelson instruction\n",(0,i.kt)("inlineCode",{parentName:"p"},"SUB_MUTEZ"),")"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=b",group:"b"},"let d : tez option = 5mutez - 1mutez (* Some (4mutez) *)\nlet e : tez option = 1mutez - 5mutez (* None *)\n"))),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=b",group:"b"},"const d : option<tez> = 5mutez - 1mutez; /* Some (4mutez) */\nconst e : option<tez> = 1mutez - 5mutez; /* None */\n"))),(0,i.kt)("h2",{id:"multiplication"},"Multiplication"),(0,i.kt)("p",null,"You can multiply values of the same type, such as:"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=c",group:"c"},"let a : int = 5 * 5\nlet b : nat = 5n * 5n\n\n// You can also multiply `nat` and `tez`\nlet c : tez = 5n * 5mutez\n"))),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=c",group:"c"},"const a = 5 * 5;\nconst b: nat = 5n * 5n;\n\n// You can also multiply `nat` and `tez`\nconst c: tez = 5n * 5mutez;\n"))),(0,i.kt)("h2",{id:"euclidean-division"},"Euclidean Division"),(0,i.kt)("p",null,"In LIGO you can divide ",(0,i.kt)("inlineCode",{parentName:"p"},"int"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"nat"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"tez"),". Here is how:"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"\u26a0\ufe0f Division of two ",(0,i.kt)("inlineCode",{parentName:"p"},"tez")," values results into a ",(0,i.kt)("inlineCode",{parentName:"p"},"nat"),".")),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=d",group:"d"},"let a : int = 10 / 3\nlet b : nat = 10n / 3n\nlet c : nat = 10mutez / 3mutez\n"))),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=d",group:"d"},"const a: int = 10 / 3;\nconst b: nat = 10n / 3n;\nconst c: nat = 10mutez / 3mutez;\n"))),(0,i.kt)("p",null,"LIGO also allows you to compute the remainder of the Euclidean\ndivision. In LIGO, it is a natural number."),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=d",group:"d"},"let a : int = 120\nlet b : int = 9\nlet rem1 : nat = a mod b  // 3\nlet c : nat = 120n\nlet rem2 : nat = c mod b  // 3\nlet d : nat = 9n\nlet rem3 : nat = c mod d  // 3\nlet rem4 : nat = a mod d  // 3\n"))),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"The behaviour of the ",(0,i.kt)("inlineCode",{parentName:"p"},"%")," operator in JsLIGO is different from JavaScript.\nIn JsLIGO, ",(0,i.kt)("inlineCode",{parentName:"p"},"%")," is a modulus operator and in JavaScript it's a remainder\noperator. In the case of positive numbers everything is the same, but\nnot with negative numbers.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=e",group:"e"},"const a = 120;\nconst b = 9;\nconst rem1 = a % b;  // 3\nconst c = 120n;\nconst rem2 = c % b;  // 3\nconst d = 9n;\nconst rem3 = c % d;  // 3\nconst rem4 = a % d;  // 3\n"))),(0,i.kt)("p",null,"For cases when you need both the quotient and the remainder, LIGO provides the\n",(0,i.kt)("inlineCode",{parentName:"p"},"ediv")," operation. ",(0,i.kt)("inlineCode",{parentName:"p"},"ediv x y")," returns ",(0,i.kt)("inlineCode",{parentName:"p"},"Some (quotient, remainder)"),", unless ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),"\nis zero, in which case it returns ",(0,i.kt)("inlineCode",{parentName:"p"},"None")),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=f",group:"f"},"let a : int = 37\nlet b : int = 5\nlet ediv1 : (int * nat) option = ediv a b  // Some (7, 2)\nlet c : nat = 37n\nlet ediv2 : (int * nat) option = ediv c b  // Some (7, 2)\nlet d : nat = 5n\nlet ediv3 : (nat * nat) option = ediv c d  // Some (7, 2)\nlet ediv4 : (int * nat) option = ediv a d  // Some (7, 2)\n"))),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=f",group:"f"},"const a = 37;\nconst b = 5;\nconst ediv1 : option<[int , nat]> = ediv(a, b);  // Some (7, 2)\nconst c = 37n;\nconst ediv2: option<[int , nat]> = ediv(c, b);  // Some (7, 2)\nconst d = 5n;\nconst ediv3: option<[nat , nat]> = ediv(c, d);  // Some (7, 2)\nconst ediv4: option<[int , nat]> = ediv(a, d);  // Some (7, 2)\n"))),(0,i.kt)("h2",{id:"from-int-to-nat-and-back"},"From ",(0,i.kt)("inlineCode",{parentName:"h2"},"int")," to ",(0,i.kt)("inlineCode",{parentName:"h2"},"nat")," and back"),(0,i.kt)("p",null,"You can ",(0,i.kt)("em",{parentName:"p"},"cast")," an ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," to a ",(0,i.kt)("inlineCode",{parentName:"p"},"nat")," and vice versa. Here is how:"),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=e",group:"e"},"let a : int = int (1n)\nlet b : nat = abs (1)\n"))),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=g",group:"g"},"const a = int(1n);\nconst b = abs(1);\n"))),(0,i.kt)("h2",{id:"checking-a-nat"},"Checking a ",(0,i.kt)("inlineCode",{parentName:"h2"},"nat")),(0,i.kt)("p",null,"You can check if a value is a ",(0,i.kt)("inlineCode",{parentName:"p"},"nat")," by using a predefined cast\nfunction which accepts an ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," and returns an optional ",(0,i.kt)("inlineCode",{parentName:"p"},"nat"),": if the\nresult is not ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),", then the provided integer was indeed a natural\nnumber, and not otherwise."),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=e",group:"e"},"let is_a_nat : nat option = is_nat (1)\n"))),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=h",group:"h"},"const is_a_nat = is_nat(1);\n"))),(0,i.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("h2",{id:"bitwise-operations"},"Bitwise operations"),(0,i.kt)("p",null,"You can perform bitwise operations as follows:"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"bitwise operations can be performed mostly with ",(0,i.kt)("inlineCode",{parentName:"p"},"nat"),"'s"),(0,i.kt)("p",{parentName:"blockquote"},"only in case of bitwise and, the first operand can be either ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"nat"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo"},"// Bitwise and (first operand can be int or nat)\nlet four : nat = 4n land 4n // 4\nlet four_ : nat = 7 land 4n // 4\n// Bitwise or\nlet seven : nat = 7n lor 4n // 7\n// Bitwise xor\nlet three : nat = 7n lxor 4n // 3\n// Bitwise shift left\nlet fourteen : nat = 7n lsl 1n // 14\n// Bitwise shift right\nlet seven_ : nat = 14n land 1n // 7\n"))),(0,i.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("h2",{id:"increment-operator"},"Increment operator"),(0,i.kt)("p",null,"Increment opeator increments (adds one to) the value of the binder."),(0,i.kt)("p",null,"In the ",(0,i.kt)("strong",{parentName:"p"},"prefix")," position (",(0,i.kt)("inlineCode",{parentName:"p"},"++p"),") the operator increments the value and returns\nthe latest incremented value."),(0,i.kt)("p",null,"In the ",(0,i.kt)("strong",{parentName:"p"},"postfix")," position (",(0,i.kt)("inlineCode",{parentName:"p"},"p++"),") the operator increments the value but\nreturns the old value before the increment."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"test-ligo group=increment_ops","test-ligo":!0,group:"increment_ops"},"\nconst testInc = (() => {\n  let inc = 0;\n\n  // Prefix increment operator\n  assert(++inc == 1);\n  assert(inc   == 1);\n\n  // Postfix increment operator\n  assert(inc++ == 1);\n  assert(inc   == 2);\n})();\n\n")),(0,i.kt)("h2",{id:"decrement-operator"},"Decrement operator"),(0,i.kt)("p",null,"Decrement opeator decrements (subtracts one from) the value of the binder."),(0,i.kt)("p",null,"In the ",(0,i.kt)("strong",{parentName:"p"},"prefix")," position (",(0,i.kt)("inlineCode",{parentName:"p"},"--p"),") the operator decrements the value and returns\nthe latest decremented value."),(0,i.kt)("p",null,"In the ",(0,i.kt)("strong",{parentName:"p"},"postfix")," position (",(0,i.kt)("inlineCode",{parentName:"p"},"p--"),") the operator decrements the value but\nreturns the old value before the decrement."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"test-ligo group=decrement_ops","test-ligo":!0,group:"decrement_ops"},"\nconst testDec = (() => {\n  let v = 10;\n\n  // Prefix decrement operator\n  assert(--v == 9);\n  assert(v   == 9);\n\n  // Postfix decrement operator\n  assert(v-- == 9);\n  assert(v   == 8);\n})();\n\n"))))}c.isMDXComponent=!0}}]);