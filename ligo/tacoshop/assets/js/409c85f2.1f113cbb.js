"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[53341],{3905:(e,a,t)=>{t.d(a,{Zo:()=>d,kt:()=>u});var n=t(67294);function r(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function o(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function s(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?o(Object(t),!0).forEach((function(a){r(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function i(e,a){if(null==e)return{};var t,n,r=function(e,a){if(null==e)return{};var t,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)t=o[n],a.indexOf(t)>=0||(r[t]=e[t]);return r}(e,a);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)t=o[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var p=n.createContext({}),l=function(e){var a=n.useContext(p),t=a;return e&&(t="function"==typeof e?e(a):s(s({},a),e)),t},d=function(e){var a=l(e.components);return n.createElement(p.Provider,{value:a},e.children)},m={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},c=n.forwardRef((function(e,a){var t=e.components,r=e.mdxType,o=e.originalType,p=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),c=l(t),u=r,g=c["".concat(p,".").concat(u)]||c[u]||m[u]||o;return t?n.createElement(g,s(s({ref:a},d),{},{components:t})):n.createElement(g,s({ref:a},d))}));function u(e,a){var t=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var o=t.length,s=new Array(o);s[0]=c;var i={};for(var p in a)hasOwnProperty.call(a,p)&&(i[p]=a[p]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var l=2;l<o;l++)s[l]=t[l];return n.createElement.apply(null,s)}return n.createElement.apply(null,t)}c.displayName="MDXCreateElement"},48720:(e,a,t)=>{t.d(a,{D:()=>r.Z,Z:()=>o});var n=t(67294),r=t(75402);const o=function(e){return n.createElement(r.Z.Consumer,null,(a=>{let{syntax:t}=a;return t===e.syntax?e.children:n.createElement(n.Fragment,null)}))}},87350:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>s,metadata:()=>p,toc:()=>d});var n=t(87462),r=(t(67294),t(3905)),o=t(48720);const s={id:"maps-records",title:"Records/Objects and Maps"},i=void 0,p={unversionedId:"language-basics/maps-records",id:"language-basics/maps-records",title:"Records/Objects and Maps",description:"So far, we have seen pretty basic data types. LIGO also offers more",source:"@site/../docs/language-basics/maps-records.md",sourceDirName:"language-basics",slug:"/language-basics/maps-records",permalink:"/previews/ligo/tacoshop/docs/next/language-basics/maps-records",draft:!1,tags:[],version:"current",frontMatter:{id:"maps-records",title:"Records/Objects and Maps"}},l={},d=[{value:"Records/Objects",id:"recordsobjects",level:2},{value:"Accessing Record Fields",id:"accessing-record-fields",level:3},{value:"Destructuring Records",id:"destructuring-records",level:3},{value:"Functional Updates",id:"functional-updates",level:3},{value:"Nested updates",id:"nested-updates",level:4},{value:"Comparison",id:"comparison",level:3},{value:"Maps",id:"maps",level:2},{value:"Declaring a Map",id:"declaring-a-map",level:3},{value:"Creating an Empty Map",id:"creating-an-empty-map",level:3},{value:"Creating a Non-empty Map",id:"creating-a-non-empty-map",level:3},{value:"Accessing Map Bindings",id:"accessing-map-bindings",level:3},{value:"Updating a Map",id:"updating-a-map",level:3},{value:"Functional Iteration over Maps",id:"functional-iteration-over-maps",level:3},{value:"Iterated Operation over Maps",id:"iterated-operation-over-maps",level:4},{value:"Map Operations over Maps",id:"map-operations-over-maps",level:4},{value:"Folded Operations over Maps",id:"folded-operations-over-maps",level:4},{value:"Big Maps",id:"big-maps",level:2},{value:"Declaring a Map",id:"declaring-a-map-1",level:3},{value:"Creating an Empty Big Map",id:"creating-an-empty-big-map",level:3},{value:"Creating a Non-empty Map",id:"creating-a-non-empty-map-1",level:3},{value:"Accessing Values",id:"accessing-values",level:3},{value:"Updating Big Maps",id:"updating-big-maps",level:3},{value:"Removing Bindings",id:"removing-bindings",level:3}],m={toc:d};function c(e){let{components:a,...t}=e;return(0,r.kt)("wrapper",(0,n.Z)({},m,t,{components:a,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"So far, we have seen pretty basic data types. LIGO also offers more\ncomplex built-in constructs, such as ",(0,r.kt)("em",{parentName:"p"},"records")," and ",(0,r.kt)("em",{parentName:"p"},"maps"),"."),(0,r.kt)("h2",{id:"recordsobjects"},"Records/Objects"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("p",null,"Records are one-way data of different types can be packed into a\nsingle type. A record is made of a set of ",(0,r.kt)("em",{parentName:"p"},"fields"),", which are made of\na ",(0,r.kt)("em",{parentName:"p"},"field name")," and a ",(0,r.kt)("em",{parentName:"p"},"field type"),". Given a value of a record type, the\nvalue bound to a field can be accessed by giving its field name to a\nspecial operator (",(0,r.kt)("inlineCode",{parentName:"p"},"."),")."),(0,r.kt)("p",null,"Let us first consider an example of record type declaration."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=records1",group:"records1"},"type user = {\n  id       : nat;\n  is_admin : bool;\n  name     : string\n}\n"))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("p",null,"Objects are one-way data of different types can be packed into a\nsingle type. An object is made of a set of ",(0,r.kt)("em",{parentName:"p"},"properties"),", which are\nmade of a ",(0,r.kt)("em",{parentName:"p"},"property name")," and a ",(0,r.kt)("em",{parentName:"p"},"property type"),". Given a value of a\nrecord type, the value bound to a field can be accessed by giving its\nfield name to a special operator (",(0,r.kt)("inlineCode",{parentName:"p"},"."),")."),(0,r.kt)("p",null,"Let us first consider an example of object type declaration."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=records1",group:"records1"},"type user = {\n  id       : nat,\n  is_admin : bool,\n  name     : string\n};\n"))),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("p",null,"And here is how a record value is defined:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=records1",group:"records1"},'let alice : user = {\n  id       = 1n;\n  is_admin = true;\n  name     = "Alice"\n}\n'))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("p",null,"And here is how an object value is defined:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=records1",group:"records1"},'const alice : user = {\n  id       : 1n,\n  is_admin : true,\n  name     : "Alice"\n};\n'))),(0,r.kt)("h3",{id:"accessing-record-fields"},"Accessing Record Fields"),(0,r.kt)("p",null,"If we want the contents of a given field, we use the (",(0,r.kt)("inlineCode",{parentName:"p"},"."),") infix\noperator, like so:"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=records1",group:"records1"},"let alice_admin : bool = alice.is_admin\n"))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=records1",group:"records1"},"const alice_admin = alice.is_admin;\n"))),(0,r.kt)("h3",{id:"destructuring-records"},"Destructuring Records"),(0,r.kt)("p",null,"We can also access fields of a record using the destructuring syntax.\nThis allows accessing multiple fields of a record in a concise manner, like so:"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=records1",group:"records1"},"let user_to_tuple (u : user) =\n  let { id ; is_admin ; name } = u in\n  (id, is_admin, name)\n"))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=records1",group:"records1"},"function userToTuple (u : user) {\n  let { id, is_admin, name } = u;\n  return [id, is_admin, name];\n}\n"))),(0,r.kt)("p",null,"We can ignore some fields of the records we can do so by\nusing ",(0,r.kt)("inlineCode",{parentName:"p"},"_")," (underscore), like so:"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=records1",group:"records1"},"let get_id (u : user) =\n  let { id ; is_admin = _ ; name = _ } = u in\n  id\n"))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=records1",group:"records1"},"function getId (u : user) {\n  let { id, is_admin, name } = u;\n  /* we don't use `is_admin` and `name`\n   so prevent warning with `ignore` */\n  ignore([is_admin, name]);\n  return id\n}\n"))),(0,r.kt)("h3",{id:"functional-updates"},"Functional Updates"),(0,r.kt)("p",null,"Given a record value, it is a common design pattern to update only a\nsmall number of its fields. Instead of copying the fields that are\nunchanged, LIGO offers a way to only update the fields that are\nmodified."),(0,r.kt)("p",null,"One way to understand the update of record values is the ",(0,r.kt)("em",{parentName:"p"},"functional\nupdate"),". The idea is to have an ",(0,r.kt)("em",{parentName:"p"},"expression")," whose value is the\nupdated record."),(0,r.kt)("p",null,"Let us consider defining a function that translates three-dimensional\npoints on a plane."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("p",null,"The syntax for the functional updates of record in CameLIGO follows\nthat of OCaml:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=record_update",group:"record_update"},"type point = {x : int; y : int; z : int}\ntype vector = {dx : int; dy : int}\n\nlet origin : point = {x = 0; y = 0; z = 0}\n\nlet xy_translate (p, vec : point * vector) : point =\n  {p with x = p.x + vec.dx; y = p.y + vec.dy}\n")),(0,r.kt)("p",null,"You can call the function ",(0,r.kt)("inlineCode",{parentName:"p"},"xy_translate")," defined above by running the\nfollowing command of the shell:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},'ligo run evaluate-call \\\n  gitlab-pages/docs/language-basics/src/maps-records/record_update.mligo \\\n  xy_translate "({x=2;y=3;z=1}, {dx=3;dy=4})"\n# Outputs: {z = 1 , y = 7 , x = 5}\n')),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"You have to understand that ",(0,r.kt)("inlineCode",{parentName:"p"},"p")," has not been changed by the\nfunctional update: a nameless new version of it has been created and\nreturned."))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("p",null,"The syntax for the functional updates of record in JsLIGO:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=record_update",group:"record_update"},"type point = {x: int, y: int, z: int}\ntype vector = {dx: int, dy: int}\n\nconst origin = {x: 0, y: 0, z: 0};\n\nconst xy_translate = (p: point, vec: vector) =>\n  ({...p, x: p.x + vec.dx, y: p.y + vec.dy});\n")),(0,r.kt)("p",null,"You can call the function ",(0,r.kt)("inlineCode",{parentName:"p"},"xy_translate")," defined above by running the\nfollowing command of the shell:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},'ligo run evaluate-expr \\\n  gitlab-pages/docs/language-basics/src/maps-records/record_update.jsligo \\\n  "xy_translate({x:2,y:3,z:1}, {dx:3,dy:4})"\n# Outputs: record[x -> 5 , y -> 7 , z -> 1]\n')),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"It is important to understand that ",(0,r.kt)("inlineCode",{parentName:"p"},"p")," has not been changed by the\nfunctional update: a nameless new version of it has been created and\nreturned."))),(0,r.kt)("h4",{id:"nested-updates"},"Nested updates"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("p",null,"A unique feature of LIGO is the ability to perform nested updates on\nrecords. For example if you have the following record structure:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=record_nested_update",group:"record_nested_update"},"type color = Blue | Green\n\ntype preferences = {\n  color : color;\n  other : int\n}\n\ntype account = {\n  id          : int;\n  preferences : preferences\n}\n"))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("p",null,"A unique feature of LIGO is the ability to perform nested updates on records.\nJsLIGO however does not support the specialised syntax as the other syntaxes.\nThe following however also does the trick."),(0,r.kt)("p",null,"For example if you have the following record structure:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=record_nested_update",group:"record_nested_update"},'type color = ["Blue"] | ["Green"];\n\ntype preferences = {\n  color : color,\n  other : int\n};\n\ntype account = {\n  id          : int,\n  preferences : preferences\n};\n'))),(0,r.kt)("p",null,"You can update the nested record with the following code:"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=record_nested_update",group:"record_nested_update"},"let change_color_preference (account : account) (color : color) : account =\n  { account with preferences.color = color }\n"))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=record_nested_update",group:"record_nested_update"},"const change_color_preference = (account : account, color : color) =>\n  ({ ...account, preferences: {...account.preferences, color: color }});\n"))),(0,r.kt)("p",null,"Note that all the records in the path will get updated. In this\nexample, those are ",(0,r.kt)("inlineCode",{parentName:"p"},"account")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"preferences"),"."),(0,r.kt)("p",null,"You can call the function ",(0,r.kt)("inlineCode",{parentName:"p"},"change_color_preference")," defined above by running the\nfollowing command:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},'ligo run evaluate-expr \\\n  gitlab-pages/docs/language-basics/src/maps-records/record_nested_update.jsligo \\\n  "change_color_preference({id:1001, preferences:{color:Blue(), other:1}}, Green())"\n# Outputs: record[id -> 1001 , preferences -> record[color -> Green(unit) , other -> 1]]\n')),(0,r.kt)("h3",{id:"comparison"},"Comparison"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("p",null,"Record types are comparable, which allows to check for equality and\nuse records as key in sets or maps. By default, the ordering of\nrecords is ",(0,r.kt)("strong",{parentName:"p"},"undefined and implementation-dependent"),". Ultimately, the\norder is determined by the translated Michelson type. When using the\n",(0,r.kt)("inlineCode",{parentName:"p"},"@layout comb")," (or ",(0,r.kt)("inlineCode",{parentName:"p"},"@layout:comb"),") attribute, fields are translated in\ntheir order in the record, and records are then ordered with\nlexicographic ordering.")),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("p",null,"Record types are comparable, which allows to check for equality and\nuse records as key in sets or maps. By default, the ordering of\nrecords is ",(0,r.kt)("strong",{parentName:"p"},"undefined and implementation-dependent"),". Ultimately, the\norder is determined by the translated Michelson type. When using the\ndecorator ",(0,r.kt)("inlineCode",{parentName:"p"},'@layout("comb")'),", fields are translated in their order in\nthe record, and objects are then ordered with lexicographic ordering.")),(0,r.kt)("h2",{id:"maps"},"Maps"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Maps")," are a data structure which associate values of the same type to\nvalues of the same type. The former are called ",(0,r.kt)("em",{parentName:"p"},"key")," and the latter\n",(0,r.kt)("em",{parentName:"p"},"values"),". Together they make up a ",(0,r.kt)("em",{parentName:"p"},"binding"),". An additional requirement\nis that the type of the keys must be ",(0,r.kt)("em",{parentName:"p"},"comparable"),", in the Michelson\nsense."),(0,r.kt)("h3",{id:"declaring-a-map"},"Declaring a Map"),(0,r.kt)("p",null,"Here is how a custom map from addresses to a pair of integers is\ndefined."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=maps",group:"maps"},"type move = int * int\ntype register = (address, move) map\n"))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=maps",group:"maps"},"type move = [int, int];\ntype register = map<address, move>;\n"))),(0,r.kt)("h3",{id:"creating-an-empty-map"},"Creating an Empty Map"),(0,r.kt)("p",null,"Here is how to create an empty map."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=maps",group:"maps"},"let empty : register = Map.empty\n"))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=maps",group:"maps"},"const empty: register = Map.empty;\n"))),(0,r.kt)("h3",{id:"creating-a-non-empty-map"},"Creating a Non-empty Map"),(0,r.kt)("p",null,"And here is how to create a non-empty map value:"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=maps",group:"maps"},'let moves : register =\n  Map.literal [\n    (("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx" : address), (1,2));\n    (("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" : address), (0,3))]\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Map.literal")," predefined function builds a map from a list of\nkey-value pair tuples, ",(0,r.kt)("inlineCode",{parentName:"p"},"(<key>, <value>)"),".  Note also the ",(0,r.kt)("inlineCode",{parentName:"p"},";")," to\nseparate individual map entries.  ",(0,r.kt)("inlineCode",{parentName:"p"},'("<string value>": address)')," means\nthat we type-cast a string into an address.")),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=maps",group:"maps"},'const moves : register =\n  Map.literal ([\n    ["tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx" as address, [1,2]],\n    ["tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" as address, [0,3]]]);\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Map.literal")," predefined function builds a map from a list of\nkey-value pair tuples, ",(0,r.kt)("inlineCode",{parentName:"p"},"[<key>, <value>]"),".  Note also the ",(0,r.kt)("inlineCode",{parentName:"p"},",")," to\nseparate individual map entries.  ",(0,r.kt)("inlineCode",{parentName:"p"},'"<string value>" as address')," means\nthat we type-cast a string into an address.")),(0,r.kt)("h3",{id:"accessing-map-bindings"},"Accessing Map Bindings"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=maps",group:"maps"},'let my_balance : move option =\n  Map.find_opt ("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" : address) moves\n'))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=maps",group:"maps"},'const my_balance: option<move> =\n  Map.find_opt("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" as address, moves);\n'))),(0,r.kt)("p",null,"Notice how the value we read is an optional value: this is to force\nthe reader to account for a missing key in the map. This requires\n",(0,r.kt)("em",{parentName:"p"},"pattern matching"),"."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=maps",group:"maps"},'let force_access (key, moves : address * register) : move =\n  match Map.find_opt key moves with\n    Some move -> move\n  | None -> failwith "No move."\n'))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=maps",group:"maps"},'let force_access = (key: address, moves: register) => {\n  return match(Map.find_opt (key, moves)) {\n    when(Some(move)): move;\n    when(None()): failwith("No move.")\n  };\n};\n'))),(0,r.kt)("h3",{id:"updating-a-map"},"Updating a Map"),(0,r.kt)("p",null,"Given a map, we may want to add a new binding, remove one, or modify\none by changing the value associated to an already existing key. All\nthose operations are called ",(0,r.kt)("em",{parentName:"p"},"updates"),"."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("p",null,"We can update a binding in a map in CameLIGO by means of the\n",(0,r.kt)("inlineCode",{parentName:"p"},"Map.update")," built-in function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=maps",group:"maps"},'let assign (m : register) : register =\n  Map.update\n    ("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" : address) (Some (4,9)) m\n')),(0,r.kt)("p",null,"Notice the optional value ",(0,r.kt)("inlineCode",{parentName:"p"},"Some (4,9)")," instead of ",(0,r.kt)("inlineCode",{parentName:"p"},"(4,9)"),". If we had\nuse ",(0,r.kt)("inlineCode",{parentName:"p"},"None")," instead, that would have meant that the binding is removed."),(0,r.kt)("p",null,"As a particular case, we can only add a key and its associated value."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=maps",group:"maps"},'let add (m : register) : register =\n  Map.add\n    ("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" : address) (4,9) m\n'))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("p",null,"We can update a binding in a map in JsLIGO by means of the\n",(0,r.kt)("inlineCode",{parentName:"p"},"Map.update")," built-in function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=maps",group:"maps"},'const assign = (m: register) =>\n  Map.update\n    ("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" as address, Some ([4, 9]), m);\n')),(0,r.kt)("p",null,"Notice the optional value ",(0,r.kt)("inlineCode",{parentName:"p"},"Some ([4,9])")," instead of ",(0,r.kt)("inlineCode",{parentName:"p"},"[4, 9]"),". If we used\n",(0,r.kt)("inlineCode",{parentName:"p"},"None")," instead that would have meant that the binding is removed."),(0,r.kt)("p",null,"As a particular case, we can only add a key and its associated value."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=maps",group:"maps"},'const add = (m: register) =>\n  Map.add\n    ("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" as address, [4, 9], m);\n'))),(0,r.kt)("p",null,"To remove a binding from a map, we need its key."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("p",null,"In CameLIGO, we use the predefined function ",(0,r.kt)("inlineCode",{parentName:"p"},"Map.remove")," as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=maps",group:"maps"},"let delete (key, moves : address * register) : register =\n  Map.remove key moves\n"))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("p",null,"In JsLIGO, we use the predefined function ",(0,r.kt)("inlineCode",{parentName:"p"},"Map.remove")," as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=maps",group:"maps"},"const delete = (key: address, moves: register) =>\n  Map.remove(key, moves);\n"))),(0,r.kt)("h3",{id:"functional-iteration-over-maps"},"Functional Iteration over Maps"),(0,r.kt)("p",null,"A ",(0,r.kt)("em",{parentName:"p"},"functional iterator")," is a function that traverses a data structure\nand calls in turn a given function over the elements of that structure\nto compute some value. Another approach is possible in JsLIGO:\n",(0,r.kt)("em",{parentName:"p"},"loops")," (see the relevant section)."),(0,r.kt)("p",null,"There are three kinds of functional iterations over LIGO maps: the\n",(0,r.kt)("em",{parentName:"p"},"iterated operation"),", the ",(0,r.kt)("em",{parentName:"p"},"map operation")," (not to be confused with the\n",(0,r.kt)("em",{parentName:"p"},"map data structure"),") and the ",(0,r.kt)("em",{parentName:"p"},"fold operation"),"."),(0,r.kt)("h4",{id:"iterated-operation-over-maps"},"Iterated Operation over Maps"),(0,r.kt)("p",null,"The first, the ",(0,r.kt)("em",{parentName:"p"},"iterated operation"),", is an iteration over the map with\nno return value: its only use is to produce side-effects. This can be\nuseful if, for example you would like to check that each value inside\nof a map is within a certain range and fail with an error otherwise."),(0,r.kt)("p",null,"The predefined functional iterator implementing the iterated operation\nover maps is called ",(0,r.kt)("inlineCode",{parentName:"p"},"Map.iter"),". In the following example, the register\nof moves is iterated to check that the start of each move is above\n",(0,r.kt)("inlineCode",{parentName:"p"},"3"),"."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=maps",group:"maps"},"let iter_op (m : register) : unit =\n  let predicate = fun (i,j : address * move) -> assert (j.0 > 3)\n  in Map.iter predicate m\n"))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=maps",group:"maps"},"const assert_all_greater_than_three = (m: register) => {\n  let predicate = ([i, j]: [address, move]) => assert(j[0] > 3);\n  Map.iter(predicate, m);\n};\n"))),(0,r.kt)("h4",{id:"map-operations-over-maps"},"Map Operations over Maps"),(0,r.kt)("p",null,"We may want to change all the bindings of a map by applying to them a\nfunction. This is called a ",(0,r.kt)("em",{parentName:"p"},"map operation"),", not to be confused with\nthe map data structure. The predefined functional iterator\nimplementing the map operation over maps is called ",(0,r.kt)("inlineCode",{parentName:"p"},"Map.map"),". In the\nfollowing example, we add ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," to the ordinate of the moves in the\nregister."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=maps",group:"maps"},"let map_op (m : register) : register =\n  let increment = fun (_,j : address * move) -> j.0, j.1 + 1\n  in Map.map increment m\n"))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=maps",group:"maps"},"const map_op = (m: register) => {\n  let increment = ([_a, j]: [address, move]) => [j[0], j[1] + 1];\n  return Map.map(increment, m);\n};\n"))),(0,r.kt)("h4",{id:"folded-operations-over-maps"},"Folded Operations over Maps"),(0,r.kt)("p",null,"A ",(0,r.kt)("em",{parentName:"p"},"folded operation")," is the most general of iterations. The folded\nfunction takes two arguments: an ",(0,r.kt)("em",{parentName:"p"},"accumulator")," and the structure\n",(0,r.kt)("em",{parentName:"p"},"element")," at hand, with which it then produces a new accumulator. This\nenables having a partial result that becomes complete when the\ntraversal of the data structure is over."),(0,r.kt)("p",null,"The predefined functional iterator implementing the folded operation\nover maps is called ",(0,r.kt)("inlineCode",{parentName:"p"},"Map.fold")," and is used as follows."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=maps",group:"maps"},"let fold_op (m : register) : int =\n  let folded = fun (i,j : int * (address * move)) -> i + j.1.1\n  in Map.fold folded m 5\n"))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=maps",group:"maps"},"const fold_op = (m: register): int => {\n  let folded = ([i, j]: [int, [address, move]]) => i + j[1][1];\n  return Map.fold(folded, m, 5);\n};\n"))),(0,r.kt)("h2",{id:"big-maps"},"Big Maps"),(0,r.kt)("p",null,"Ordinary maps are fine for contracts with a finite lifespan or a\nbounded number of users. For many contracts however, the intention is\nto have a map holding ",(0,r.kt)("em",{parentName:"p"},"many")," entries, potentially millions of\nthem. The cost of loading those entries into the environment each time\na user executes the contract would eventually become too expensive\nwere it not for ",(0,r.kt)("em",{parentName:"p"},"big maps"),". Big maps are a data structure offered by\nMichelson which handles the scaling concerns for us. In LIGO, the\ninterface for big maps is analogous to the one used for ordinary maps."),(0,r.kt)("h3",{id:"declaring-a-map-1"},"Declaring a Map"),(0,r.kt)("p",null,"Here is how we define a big map:"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=big_maps",group:"big_maps"},"type move = int * int\ntype register = (address, move) big_map\n"))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=big_maps",group:"big_maps"},"type move = [int, int];\ntype register = big_map<address, move>;\n"))),(0,r.kt)("h3",{id:"creating-an-empty-big-map"},"Creating an Empty Big Map"),(0,r.kt)("p",null,"Here is how to create an empty big map."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=big_maps",group:"big_maps"},"let empty : register = Big_map.empty\n"))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=big_maps",group:"big_maps"},"const empty: register = Big_map.empty;\n"))),(0,r.kt)("h3",{id:"creating-a-non-empty-map-1"},"Creating a Non-empty Map"),(0,r.kt)("p",null,"And here is how to create a non-empty map value:"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=big_maps",group:"big_maps"},'let moves : register =\n  Big_map.literal [\n    (("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx" : address), (1,2));\n    (("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" : address), (0,3))]\n')),(0,r.kt)("p",null,"The predefined function ",(0,r.kt)("inlineCode",{parentName:"p"},"Big_map.literal")," constructs a big map from a\nlist of key-value pairs ",(0,r.kt)("inlineCode",{parentName:"p"},"(<key>, <value>)"),". Note also the semicolon\nseparating individual map entries.  The annotated value ",(0,r.kt)("inlineCode",{parentName:"p"},'("<string>\nvalue>" : address)')," means that we cast a string into an address.")),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=big_maps",group:"big_maps"},'const moves : register =\n  Big_map.literal([\n    ["tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx" as address, [1, 2]],\n    ["tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" as address, [0, 3]]]);\n')),(0,r.kt)("p",null,"The predefined function ",(0,r.kt)("inlineCode",{parentName:"p"},"Big_map.literal")," constructs a big map from a\nlist of key-value pairs ",(0,r.kt)("inlineCode",{parentName:"p"},"[<key>, <value>]"),". Note also the semicolon\nseparating individual map entries.  The annotated value ",(0,r.kt)("inlineCode",{parentName:"p"},'("<string>\nvalue>" as address)')," means that we cast a string into an address.")),(0,r.kt)("h3",{id:"accessing-values"},"Accessing Values"),(0,r.kt)("p",null,"If we want to access a move from our ",(0,r.kt)("inlineCode",{parentName:"p"},"register")," above, we can use the\npostfix ",(0,r.kt)("inlineCode",{parentName:"p"},"[]")," operator to read the associated ",(0,r.kt)("inlineCode",{parentName:"p"},"move")," value. However,\nthe value we read is an optional value (in our case, of type ",(0,r.kt)("inlineCode",{parentName:"p"},"option\n(move)"),"), to account for a missing key. Here is an example:"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=big_maps",group:"big_maps"},'let my_balance : move option =\n  Big_map.find_opt ("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" : address) moves\n'))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=big_maps",group:"big_maps"},'const my_balance: option<move> =\n  Big_map.find_opt("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" as address, moves);\n'))),(0,r.kt)("h3",{id:"updating-big-maps"},"Updating Big Maps"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("p",null,"We can update a big map in CameLIGO using the ",(0,r.kt)("inlineCode",{parentName:"p"},"Big_map.update"),"\nbuilt-in:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=big_maps",group:"big_maps"},'let updated_map : register =\n  Big_map.update\n    ("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" : address) (Some (4,9)) moves\n'))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("p",null,"We can update a big map in JsLIGO using the ",(0,r.kt)("inlineCode",{parentName:"p"},"Big_map.update"),"\nbuilt-in:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=big_maps",group:"big_maps"},'const updated_map: register =\n  Big_map.update\n    ("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" as address, Some([4, 9]), moves);\n'))),(0,r.kt)("h3",{id:"removing-bindings"},"Removing Bindings"),(0,r.kt)("p",null,"Removing a binding in a map is done differently according to the LIGO\nsyntax."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("p",null,"In CameLIGO, the predefined function which removes a binding in a map\nis called ",(0,r.kt)("inlineCode",{parentName:"p"},"Map.remove")," and is used as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=big_maps",group:"big_maps"},'let updated_map : register =\n  Big_map.remove ("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN": address) moves\n'))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("p",null,"In JsLIGO, the predefined function which removes a binding in a map\nis called ",(0,r.kt)("inlineCode",{parentName:"p"},"Map.remove")," and is used as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=big_maps",group:"big_maps"},'const updated_map_: register =\n  Big_map.remove("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN" as address, moves);\n'))))}c.isMDXComponent=!0}}]);