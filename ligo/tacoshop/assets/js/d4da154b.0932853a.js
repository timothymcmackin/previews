"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[26678],{3905:(t,e,a)=>{a.d(e,{Zo:()=>p,kt:()=>u});var n=a(67294);function o(t,e,a){return e in t?Object.defineProperty(t,e,{value:a,enumerable:!0,configurable:!0,writable:!0}):t[e]=a,t}function r(t,e){var a=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),a.push.apply(a,n)}return a}function i(t){for(var e=1;e<arguments.length;e++){var a=null!=arguments[e]?arguments[e]:{};e%2?r(Object(a),!0).forEach((function(e){o(t,e,a[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(a,e))}))}return t}function s(t,e){if(null==t)return{};var a,n,o=function(t,e){if(null==t)return{};var a,n,o={},r=Object.keys(t);for(n=0;n<r.length;n++)a=r[n],e.indexOf(a)>=0||(o[a]=t[a]);return o}(t,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(n=0;n<r.length;n++)a=r[n],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(t,a)&&(o[a]=t[a])}return o}var c=n.createContext({}),l=function(t){var e=n.useContext(c),a=e;return t&&(a="function"==typeof t?t(e):i(i({},e),t)),a},p=function(t){var e=l(t.components);return n.createElement(c.Provider,{value:e},t.children)},d={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},m=n.forwardRef((function(t,e){var a=t.components,o=t.mdxType,r=t.originalType,c=t.parentName,p=s(t,["components","mdxType","originalType","parentName"]),m=l(a),u=o,h=m["".concat(c,".").concat(u)]||m[u]||d[u]||r;return a?n.createElement(h,i(i({ref:e},p),{},{components:a})):n.createElement(h,i({ref:e},p))}));function u(t,e){var a=arguments,o=e&&e.mdxType;if("string"==typeof t||o){var r=a.length,i=new Array(r);i[0]=m;var s={};for(var c in e)hasOwnProperty.call(e,c)&&(s[c]=e[c]);s.originalType=t,s.mdxType="string"==typeof t?t:o,i[1]=s;for(var l=2;l<r;l++)i[l]=a[l];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},48720:(t,e,a)=>{a.d(e,{D:()=>o.Z,Z:()=>r});var n=a(67294),o=a(75402);const r=function(t){return n.createElement(o.Z.Consumer,null,(e=>{let{syntax:a}=e;return a===t.syntax?t.children:n.createElement(n.Fragment,null)}))}},58941:(t,e,a)=>{a.r(e),a.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>i,metadata:()=>c,toc:()=>p});var n=a(87462),o=(a(67294),a(3905)),r=a(48720);const i={title:"Part 1: Creating a contract"},s=void 0,c={unversionedId:"tutorials/taco-shop/selling-tacos",id:"tutorials/taco-shop/selling-tacos",title:"Part 1: Creating a contract",description:"Meet Pedro, our artisan taco chef, who has decided to open a Taco shop on the Tezos blockchain, using a smart contract.",source:"@site/../docs/tutorials/taco-shop/selling-tacos.md",sourceDirName:"tutorials/taco-shop",slug:"/tutorials/taco-shop/selling-tacos",permalink:"/previews/ligo/tacoshop/docs/next/tutorials/taco-shop/selling-tacos",draft:!1,tags:[],version:"current",frontMatter:{title:"Part 1: Creating a contract"},sidebar:"docs",previous:{title:"Editor Support",permalink:"/previews/ligo/tacoshop/docs/next/intro/editor-support"},next:{title:"Part 2: Testing the contract",permalink:"/previews/ligo/tacoshop/docs/next/tutorials/taco-shop/testing-contract"}},l={},p=[{value:"Learning objectives",id:"learning-objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Syntaxes",id:"syntaxes",level:2},{value:"Pricing",id:"pricing",level:2},{value:"Setting up the data storage",id:"setting-up-the-data-storage",level:2},{value:"Getting the price of tacos",id:"getting-the-price-of-tacos",level:2},{value:"Selling tacos",id:"selling-tacos",level:2},{value:"Providing information to clients",id:"providing-information-to-clients",level:2},{value:"Compiling the contract",id:"compiling-the-contract",level:2}],d={toc:p};function m(t){let{components:e,...a}=t;return(0,o.kt)("wrapper",(0,n.Z)({},d,a,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("div",null,(0,o.kt)("p",null,"Meet Pedro, our artisan taco chef, who has decided to open a Taco shop on the Tezos blockchain, using a smart contract."),(0,o.kt)("p",null,"In this tutorial, to help Pedro open his dream taco shop, you will implement a smart contract that manages supply, pricing, and sales of his tacos to the consumers.\nThis scenario is ideal for a smart contract because smart contracts behave much like vending machines: users send requests to them along with information and money.\nIf the request is correct, the smart contract does something in response, in this case giving the customer an imaginary taco."),(0,o.kt)("br",null),(0,o.kt)("img",{src:"/img/tutorials/get-started/tezos-taco-shop-smart-contract/taco-stand.svg",width:"50%"}),(0,o.kt)("div",{style:{opacity:.7,textAlign:"center",fontSize:"10px"}},"Made by ",(0,o.kt)("a",{href:"https://www.flaticon.com/authors/smashicons",title:"Smashicons"},"Smashicons")," from ",(0,o.kt)("a",{href:"https://www.flaticon.com/",title:"Flaticon"},"www.flaticon.com")," is licensed by ",(0,o.kt)("a",{href:"http://creativecommons.org/licenses/by/3.0/",title:"Creative Commons BY 3.0",target:"_blank"},"CC 3.0 BY"))),(0,o.kt)("h2",{id:"learning-objectives"},"Learning objectives"),(0,o.kt)("p",null,"In this tutorial, you will learn how to:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Set up a smart contract in JsLIGO or CameLIGO"),(0,o.kt)("li",{parentName:"ul"},"Define the storage for the contract"),(0,o.kt)("li",{parentName:"ul"},"Define what requests the contract can accept and how it behaves"),(0,o.kt)("li",{parentName:"ul"},"Write tests that ensure that the contract behaves correctly")),(0,o.kt)("h2",{id:"prerequisites"},"Prerequisites"),(0,o.kt)("p",null,"Before you begin, install LIGO as described in ",(0,o.kt)("a",{parentName:"p",href:"../../intro/installation"},"Installation"),"."),(0,o.kt)("p",null,"Optionally, you can also set up your editor to work with LIGO as described in ",(0,o.kt)("a",{parentName:"p",href:"../../intro/editor-support"},"Editor Support"),"."),(0,o.kt)("h2",{id:"syntaxes"},"Syntaxes"),(0,o.kt)("p",null,"LIGO has two syntaxes:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"JsLIGO is inspired by TypeScript/JavaScript, intended for web developers")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"CameLIGO is inspired by OCaml, intended for functional programmers"))),(0,o.kt)("p",null,"The syntaxes do the same thing and have nearly all the same features, so which one you choose depends on your preference or programming background.\nYou can use either syntax for this tutorial, but you must use the same syntax for the entire contract.\nUse the ",(0,o.kt)("strong",{parentName:"p"},"Syntax Preference")," slider at the top left of this page to select the syntax to use."),(0,o.kt)("h2",{id:"pricing"},"Pricing"),(0,o.kt)("p",null,"Pedro sells two kinds of tacos: ",(0,o.kt)("strong",{parentName:"p"},"el Cl\xe1sico")," and the ",(0,o.kt)("strong",{parentName:"p"},"Especial del Chef"),".\nHis tacos are a rare delicacy and he has a finite amount of each kind, so the price goes up as the stock for the day depletes.\nTaco prices are in tez, the currency of the Tezos blockchain."),(0,o.kt)("p",null,"The cost for one taco is the maximum price for the taco divided by the total number of tacos, as in this formula:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"current_purchase_price = max_price / available_stock\n")),(0,o.kt)("p",null,"For example, the maximum price for an el Cl\xe1sico taco is 50 tez.\nThis table shows the price when there are certain amounts of tacos left:"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Number of tacos available"),(0,o.kt)("th",{parentName:"tr",align:null},"Maximum price"),(0,o.kt)("th",{parentName:"tr",align:null},"Purchase price"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"50"),(0,o.kt)("td",{parentName:"tr",align:null},"50 tez"),(0,o.kt)("td",{parentName:"tr",align:null},"1 tez")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"20"),(0,o.kt)("td",{parentName:"tr",align:null},"50 tez"),(0,o.kt)("td",{parentName:"tr",align:null},"2.5 tez")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"5"),(0,o.kt)("td",{parentName:"tr",align:null},"50 tez"),(0,o.kt)("td",{parentName:"tr",align:null},"10 tez")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"1"),(0,o.kt)("td",{parentName:"tr",align:null},"50 tez"),(0,o.kt)("td",{parentName:"tr",align:null},"50 tez")))),(0,o.kt)("p",null,"The maximum price for an Especial del Chef taco is 75 tez, so the prices are different, as in this table:"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Number of tacos available"),(0,o.kt)("th",{parentName:"tr",align:null},"Maximum price"),(0,o.kt)("th",{parentName:"tr",align:null},"Purchase price"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"20"),(0,o.kt)("td",{parentName:"tr",align:null},"75 tez"),(0,o.kt)("td",{parentName:"tr",align:null},"3.75 tez")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"10"),(0,o.kt)("td",{parentName:"tr",align:null},"75 tez"),(0,o.kt)("td",{parentName:"tr",align:null},"7.5 tez")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"5"),(0,o.kt)("td",{parentName:"tr",align:null},"75 tez"),(0,o.kt)("td",{parentName:"tr",align:null},"15 tez")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"1"),(0,o.kt)("td",{parentName:"tr",align:null},"75 tez"),(0,o.kt)("td",{parentName:"tr",align:null},"75 tez")))),(0,o.kt)("h2",{id:"setting-up-the-data-storage"},"Setting up the data storage"),(0,o.kt)("p",null,"Smart contracts can store persistent data.\nOnly the contract itself can write to its data, but the data is visible to outside users.\nThis data can be in many data types, including simple data types like numbers, Boolean values, and strings, and complex data types like arrays and maps."),(0,o.kt)("p",null,"Because the cost of a taco is determined by a formula, the contract needs to store only two pieces of data for each type of taco: the maximum price and the number of tacos currently in stock.\nLIGO contracts store this type of data in a data type called a map, which is a key-value store where each key is the same data type and each value is the same data type.\nMaps are flexible, so you can add and remove elements.\nLIGO uses maps instead of tables for efficiency; a contract can load only the entry in the map that it needs instead of all of the data, which allows contracts to handle large amounts of data without causing large fees by reading and writing large amounts of data at a time."),(0,o.kt)("p",null,"The key for this map is a natural number (also known as a ",(0,o.kt)("em",{parentName:"p"},"nat"),", an integer zero or greater) and the value is a ",(0,o.kt)("a",{parentName:"p",href:"../../data-types/records"},"Record")," data type that has two fields: a natural number for the current stock of tacos and a tez amount for the maximum price."),(0,o.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Anywhere on your computer, create a folder to store your work for this tutorial with a name such as ",(0,o.kt)("inlineCode",{parentName:"p"},"TacoShopTutorial"),".")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"In the folder, create a file named ",(0,o.kt)("inlineCode",{parentName:"p"},"taco_shop.jsligo")," to store the code of the smart contract.\nYou can create and edit this file in any text editor.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"In the file, create a type named ",(0,o.kt)("inlineCode",{parentName:"p"},"taco_supply")," that represents the value of the map, consisting of a nat for the number of tacos and a tez value for the maximum price:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},"export type taco_supply = { current_stock: nat, max_price: tez };\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Create a map type named ",(0,o.kt)("inlineCode",{parentName:"p"},"taco_data"),", with the key a nat and the value the ",(0,o.kt)("inlineCode",{parentName:"p"},"taco_supply")," type:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},"export type taco_data = map<nat, taco_supply>;\n")),(0,o.kt)("p",{parentName:"li"},"This map can contain the supply and max price for any number of tacos, indexed by a natural number key.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Create an address type to store Pedro's account address, which allows him to lock some features of the contract behind an administrator account:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},"export type admin_address = address;\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Create a type to represent the storage for the contract.\nIn this case, the contract needs to store the taco data map and the administrator address, so the overall contract storage contains those two values:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},"export type storage = {\n  admin_address: admin_address,\n  taco_data: taco_data,\n};\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Create a constant to represent the starting values for the taco data map:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},"export const default_taco_data: taco_data = Map.literal ([\n  [1n, { current_stock: 50n, max_price: 50tez }],\n  [2n, { current_stock: 20n, max_price: 75tez }]\n]);\n")),(0,o.kt)("p",{parentName:"li"},"Note that the natural numbers are indicated with an ",(0,o.kt)("inlineCode",{parentName:"p"},"n")," after the number; otherwise, LIGO assumes that numbers are integers.\nSimilarly, the maximum prices of the tacos are suffixed with ",(0,o.kt)("inlineCode",{parentName:"p"},"tez")," to indicate that they are amounts of tez.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"To keep the code for the contract organized, put the types and values in a namespace named ",(0,o.kt)("inlineCode",{parentName:"p"},"TacoShop"),".\nThe contract looks like this so far:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},"namespace TacoShop {\n  export type taco_supply = { current_stock: nat, max_price: tez };\n  export type taco_data = map<nat, taco_supply>;\n  export type admin_address = address;\n  export type storage = {\n    admin_address: admin_address,\n    taco_data: taco_data,\n  };\n\n  export const default_taco_data: taco_data = Map.literal ([\n    [1n, { current_stock: 50n, max_price: 50tez }],\n    [2n, { current_stock: 20n, max_price: 75tez }]\n  ]);\n\n};\n"))))),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Anywhere on your computer, create a folder to store your work for this tutorial with a name such as ",(0,o.kt)("inlineCode",{parentName:"p"},"TacoShopTutorial"),".")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"In the folder, create a file named ",(0,o.kt)("inlineCode",{parentName:"p"},"taco_shop.mligo")," to store the code of the smart contract.\nYou can create and edit this file in any text editor.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"In the file, create a type named ",(0,o.kt)("inlineCode",{parentName:"p"},"taco_supply")," that represents the value of the map, consisting of a nat for the number of tacos and a tez value for the maximum price:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},"type taco_supply = { current_stock: nat; max_price: tez }\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Create a map type named ",(0,o.kt)("inlineCode",{parentName:"p"},"taco_data"),", with the key a nat and the value the ",(0,o.kt)("inlineCode",{parentName:"p"},"taco_supply")," type:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},"type taco_data = (nat, taco_supply) map\n")),(0,o.kt)("p",{parentName:"li"},"This map can contain the supply and max price for any number of tacos, indexed by a natural number key.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Create an address type to store Pedro's account address, which allows him to lock some features of the contract behind an administrator account:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},"type admin_address = address\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Create a type to represent the storage for the contract.\nIn this case, the contract needs to store the taco data map and the administrator address, so the overall contract storage contains those two values:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},"type storage = {\n  admin_address: admin_address;\n  taco_data: taco_data;\n}\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Create a variable to represent the starting values for the taco data map:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},"let default_taco_data: taco_data = Map.literal [\n  (1n, { current_stock = 50n; max_price = 50tez });\n  (2n, { current_stock = 20n; max_price = 75tez });\n]\n")),(0,o.kt)("p",{parentName:"li"},"Note that the natural numbers are indicated with an ",(0,o.kt)("inlineCode",{parentName:"p"},"n")," after the number; otherwise, LIGO assumes that numbers are integers.\nSimilarly, the maximum prices of the tacos are suffixed with ",(0,o.kt)("inlineCode",{parentName:"p"},"tez")," to indicate that they are amounts of tez.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"To keep the code for the contract organized, put the types and values in a module named ",(0,o.kt)("inlineCode",{parentName:"p"},"TacoShop"),".\nThe contract looks like this so far:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},"module TacoShop = struct\n\n  type taco_supply = { current_stock: nat; max_price: tez }\n  type taco_data = (nat, taco_supply) map\n  type admin_address = address\n  type storage = {\n    admin_address: admin_address;\n    taco_data: taco_data;\n  }\n\n  let default_taco_data: taco_data = Map.literal [\n    (1n, { current_stock = 50n; max_price = 50tez });\n    (2n, { current_stock = 20n; max_price = 75tez });\n  ]\n\nend\n"))))),(0,o.kt)("h2",{id:"getting-the-price-of-tacos"},"Getting the price of tacos"),(0,o.kt)("p",null,"Because the price of tacos changes, it'll be helpful to have a function to get the current price of a certain kind of taco."),(0,o.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("p",null,"Add this function inside the namespace, immediately after the ",(0,o.kt)("inlineCode",{parentName:"p"},"default_taco_data")," constant:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},'// Internal function to get the price of a taco\nconst get_taco_price_internal = (taco_kind_index: nat, taco_data: taco_data): tez => {\n  const taco_kind: taco_supply =\n    match (Map.find_opt (taco_kind_index, taco_data)) {\n      when(Some(kind)): kind;\n      when(None()): failwith("Unknown kind of taco")\n    };\n  return taco_kind.max_price / taco_kind.current_stock;\n}\n'))),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("p",null,"Add this function inside the module, immediately after the ",(0,o.kt)("inlineCode",{parentName:"p"},"default_taco_data")," variable:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},'(* Internal function to get the price of a taco *)\nlet get_taco_price_internal (taco_kind_index : nat) (taco_data : taco_data) : tez =\n  let taco_kind : taco_supply =\n    match Map.find_opt taco_kind_index taco_data with\n    | Some kind -> kind\n    | None -> failwith "Unknown kind of taco"\n    in\n    taco_kind.max_price / taco_kind.current_stock\n'))),(0,o.kt)("p",null,"This code uses the ",(0,o.kt)("inlineCode",{parentName:"p"},"Map.find_opt")," function to get an entry from a map based on a key.\nIt returns an ",(0,o.kt)("a",{parentName:"p",href:"../../data-types/variants#options"},"option")," value, which is a data type that LIGO uses to handle cases where a value may not exist.\nIn this case, the option has the value for that key if the key exists or a ",(0,o.kt)("inlineCode",{parentName:"p"},"None")," value if the key does not exist.\nIf the ",(0,o.kt)("inlineCode",{parentName:"p"},"taco_kind_index")," parameter is not a valid taco ID, the transaction fails."),(0,o.kt)("p",null,"This is an internal function, so external callers can't call it directly.\nLater, you will add a way for external callers to get the current price of a taco."),(0,o.kt)("h2",{id:"selling-tacos"},"Selling tacos"),(0,o.kt)("p",null,"Contracts have one or more ",(0,o.kt)("em",{parentName:"p"},"entrypoints"),", which are a kind of function that clients can call, like endpoints in an API or functions or methods in many other programming languages.\nA contract can have any number of internal functions, but only the functions designated as entrypoints can be called by outside consumers and other contracts."),(0,o.kt)("p",null,"The contract you create in this tutorial has two entrypoints:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"An entrypoint named ",(0,o.kt)("inlineCode",{parentName:"li"},"buy_taco")," which accepts the type of taco to buy and the price of the taco and deducts that type of taco from the current stock in storage"),(0,o.kt)("li",{parentName:"ul"},"An entrypoint named ",(0,o.kt)("inlineCode",{parentName:"li"},"payout")," that sends the tez in the contract to Pedro and restocks the supply of tacos")),(0,o.kt)("p",null,"As described in ",(0,o.kt)("a",{parentName:"p",href:"../../syntax/contracts/entrypoints"},"Entrypoints"),", entrypoints must follow a specific signature to be compiled as entrypoints:"),(0,o.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Entrypoints are functions marked with the ",(0,o.kt)("inlineCode",{parentName:"li"},"@entry")," decorator"),(0,o.kt)("li",{parentName:"ul"},"Entrypoints receive a parameter from the caller and the current state of the contract storage"),(0,o.kt)("li",{parentName:"ul"},"Entrypoints return a tuple consisting of a list of operations to run (such as calls to other smart contracts or transfers of tez) and the new state of the contract storage")),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"In the smart contract file, within the ",(0,o.kt)("inlineCode",{parentName:"p"},"TacoShop")," namespace, add this stub of an entrypoint:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},"// Buy a taco\n@entry\nconst buy_taco = (taco_kind_index: nat, storage: storage): [\n    list<operation>,\n    storage\n  ] => {\n\n    // Entrypoint logic goes here\n\n    return [[], updated_storage];\n  }\n")),(0,o.kt)("p",{parentName:"li"},"Your IDE may show an error that the ",(0,o.kt)("inlineCode",{parentName:"p"},"updated_storage")," value is not defined, but you can ignore this error for now because you will define it in the next few steps."),(0,o.kt)("p",{parentName:"li"},"To call this entrypoint, the caller passes a nat to indicate the type of taco.\nThe function automatically receives the current state of the storage as the last parameter.\nThe line ",(0,o.kt)("inlineCode",{parentName:"p"},"return [[], updated_storage];")," returns an empty list of operations to run and the new state of the storage.\nIn the next few steps, you add logic to verify that the caller sent the correct price and to deduct the taco from the current stock.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Within the entrypoint, add code to get the admin address and the taco data by destructuring the storage parameter:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},"const { admin_address, taco_data } = storage;\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"After this code, add code to get the type of taco that the caller requested based on the ",(0,o.kt)("inlineCode",{parentName:"p"},"taco_kind_index")," parameter:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},'// Retrieve the kind of taco from the contracts storage or fail\nconst taco_kind: taco_supply =\n  match (Map.find_opt(taco_kind_index, taco_data)) {\n    when(Some(kind)): kind;\n    when(None()): failwith("Unknown kind of taco");\n  };\n'))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"After the code you just added, add this code to get the current price of a taco:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},"// Get the current price of this type of taco\nconst current_purchase_price = get_taco_price_internal(taco_kind_index, taco_data);\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Add this code to verify that the caller sent the correct amount of tez with the transaction, which you can get with the ",(0,o.kt)("inlineCode",{parentName:"p"},"Tezos.get_amount()")," function:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},'// Verify that the caller sent the correct amount of tez\nif ((Tezos.get_amount()) != current_purchase_price) {\n  return failwith("Sorry, the taco you are trying to purchase has a different price");\n}\n'))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Add this code to verify that there is at least one taco in stock:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},'// Verify that there is at least one of this type of taco\nif (taco_kind.current_stock == 0n) {\n  return failwith("Sorry, we are out of this type of taco");\n}\n'))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Add this code to calculate the updated taco data map and put it in the ",(0,o.kt)("inlineCode",{parentName:"p"},"updated_taco_data")," constant:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},"// Update the storage with the new quantity of tacos\nconst updated_taco_data: taco_data = Map.update(\n  taco_kind_index,\n  (Some (({...taco_kind, current_stock: abs(taco_kind.current_stock - 1n) }))),\n  taco_data);\n")),(0,o.kt)("p",{parentName:"li"},"This code uses the ",(0,o.kt)("inlineCode",{parentName:"p"},"Map.update")," function to create a new version of the map with an updated record.\nIn this case, the new map updates the stock of the specified type of taco to be one less.\nIt uses the ",(0,o.kt)("inlineCode",{parentName:"p"},"abs")," function to ensure that the new stock of tacos is a nat, because subtraction yields an integer.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Create the new value of the contract storage, including the admin address and the updated taco data:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},"const updated_storage: storage = {\n  admin_address: admin_address,\n  taco_data: updated_taco_data,\n};\n")),(0,o.kt)("p",{parentName:"li"},"The next line is the line ",(0,o.kt)("inlineCode",{parentName:"p"},"return [[], updated_taco_data];"),", which you added when you stubbed in the entrypoint code earlier."),(0,o.kt)("p",{parentName:"li"},"Now the ",(0,o.kt)("inlineCode",{parentName:"p"},"buy_taco")," entrypoint updates the stock in storage to indicate that it has one less of that type of taco.\nThe contract automatically accepts the tez that is included with the transaction.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Stub in the code for the entrypoint that allows Pedro to retrieve the tez in the contract, which you will add in a later section:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},"const payout = (_u: unit, storage: storage): [\n    list<operation>,\n    storage\n  ] => {\n\n  // Entrypoint logic goes here\n\n  return [[], storage];\n}\n")),(0,o.kt)("p",{parentName:"li"},"Currently this entrypoint does nothing, but you will add code for it later.")))),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Entrypoints are functions marked with the ",(0,o.kt)("inlineCode",{parentName:"li"},"@entry")," attribute"),(0,o.kt)("li",{parentName:"ul"},"Entrypoints receive a parameter from the caller and the current state of the contract storage"),(0,o.kt)("li",{parentName:"ul"},"Entrypoints return a tuple consisting of a list of operations to run (such as calls to other smart contracts or transfers of tez) and the new state of the contract storage")),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"In the smart contract file, within the ",(0,o.kt)("inlineCode",{parentName:"p"},"TacoShop")," module, add this stub of an entrypoint:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},"(* Buy a taco *)\n[@entry]\nlet buy_taco (taco_kind_index : nat) (storage: storage) : operation list * storage =\n\n    (* Entrypoint logic goes here *)\n\n  [], updated_storage\n")),(0,o.kt)("p",{parentName:"li"},"Your IDE may show an error that the ",(0,o.kt)("inlineCode",{parentName:"p"},"updated_storage")," value is not defined, but you can ignore this error for now because you will define it in the next few steps."),(0,o.kt)("p",{parentName:"li"},"To call this entrypoint, the caller passes a nat to indicate the type of taco.\nThe function automatically receives the current state of the storage as the last parameter.\nThe line ",(0,o.kt)("inlineCode",{parentName:"p"},"[], updated_storage")," returns an empty list of operations to run and the new state of the storage.\nIn the next few steps, you add logic to verify that the caller sent the correct price and to deduct the taco from the current stock.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Within the entrypoint, add code to get the admin address and the taco data by destructuring the storage parameter:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},"let { admin_address; taco_data } = storage in\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"After this code, add code to get the type of taco that the caller requested based on the ",(0,o.kt)("inlineCode",{parentName:"p"},"taco_kind_index")," parameter:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},'(* Retrieve the kind of taco from the contracts storage or fail *)\nlet taco_kind : taco_supply =\n  match Map.find_opt taco_kind_index taco_data with\n  | Some kind -> kind\n  | None -> failwith "Unknown kind of taco" in\n'))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"After the code you just added, add this code to get the current price of a taco:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},"(* Get the current price of this type of taco *)\nlet current_purchase_price = get_taco_price_internal taco_kind_index taco_data in\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Add this code to verify that the caller sent the correct amount of tez with the transaction, which you can get with the ",(0,o.kt)("inlineCode",{parentName:"p"},"Tezos.get_amount()")," function:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},'(* Verify that the caller sent the correct amount of tez *)\nlet _ = if (Tezos.get_amount () <> current_purchase_price) then\n  failwith "Sorry, the taco you are trying to purchase has a different price" in\n'))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Add this code to verify that there is at least one taco in stock:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},'(* Verify that there is at least one of this type of taco *)\nlet _ = if (taco_kind.current_stock = 0n) then\n  failwith "Sorry, we are out of this type of taco" in\n'))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Add this code to calculate the updated taco data map and put it in the ",(0,o.kt)("inlineCode",{parentName:"p"},"updated_taco_data")," variable:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},"(* Update the storage with the new quantity of tacos *)\nlet updated_taco_data : taco_data = Map.update\n  taco_kind_index\n  (Some { taco_kind with current_stock = abs (taco_kind.current_stock - 1n) })\n  taco_data in\n")),(0,o.kt)("p",{parentName:"li"},"This code uses the ",(0,o.kt)("inlineCode",{parentName:"p"},"Map.update")," function to create a new version of the map with an updated record.\nIn this case, the new map updates the stock of the specified type of taco to be one less.\nIt uses the ",(0,o.kt)("inlineCode",{parentName:"p"},"abs")," function to ensure that the new stock of tacos is a nat, because subtraction yields an integer.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Create the new value of the contract storage, including the admin address and the updated taco data:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},"let updated_storage : storage = {\n  admin_address = admin_address;\n  taco_data = updated_taco_data;\n} in\n")),(0,o.kt)("p",{parentName:"li"},"The next line is the line ",(0,o.kt)("inlineCode",{parentName:"p"},"[], updated_taco_data"),", which you added when you stubbed in the entrypoint code earlier."),(0,o.kt)("p",{parentName:"li"},"Now the ",(0,o.kt)("inlineCode",{parentName:"p"},"buy_taco")," entrypoint updates the stock in storage to indicate that it has one less of that type of taco.\nThe contract automatically accepts the tez that is included with the transaction.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Stub in the code for the entrypoint that allows Pedro to retrieve the tez in the contract, which you will add in a later section:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},"[@entry]\nlet payout (_u : unit) (storage : storage) : operation list * storage =\n\n  (* Entrypoint logic goes here *)\n\n  [], storage\n")),(0,o.kt)("p",{parentName:"li"},"Currently this entrypoint does nothing, but you will add code for it later.")))),(0,o.kt)("h2",{id:"providing-information-to-clients"},"Providing information to clients"),(0,o.kt)("p",null,"Earlier, you added an internal function that calculated the price of a taco.\nExternal clients can't call this function because it is not an entrypoint."),(0,o.kt)("p",null,"The contract should give Pedro's customers a way to get the current price of a taco.\nHowever, because entrypoints don't return a value directly to the caller, an entrypoint isn't the best way to provide information to clients."),(0,o.kt)("p",null,"If you need to provide information to clients, one way is to use a ",(0,o.kt)("em",{parentName:"p"},"view"),", which is a static function that returns a value to clients but does not change the storage or generate any operations.\nLike entrypoints, views are functions that receive one or more parameters from the caller and the current value of the storage.\nUnlike entrypoints, they return a single value to the caller instead of a list of operations and the new value of the storage."),(0,o.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("p",null,"Add this view to the contract, after the ",(0,o.kt)("inlineCode",{parentName:"p"},"get_taco_price_internal")," function and somewhere within the namespace:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},"@view\nconst get_taco_price = (taco_kind_index: nat, storage: storage): tez =>\n  get_taco_price_internal(taco_kind_index, storage.taco_data);\n")),(0,o.kt)("p",null,"This view is merely a wrapper around the ",(0,o.kt)("inlineCode",{parentName:"p"},"get_taco_price_internal")," function, but the ",(0,o.kt)("inlineCode",{parentName:"p"},"@view")," decorator makes external clients able to call it."),(0,o.kt)("p",null,"For more information about views, see ",(0,o.kt)("a",{parentName:"p",href:"../../syntax/contracts/views"},"Views"),"."),(0,o.kt)("p",null,"The complete contract file looks like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},'namespace TacoShop {\n  export type taco_supply = { current_stock: nat, max_price: tez };\n  export type taco_data = map<nat, taco_supply>;\n  export type admin_address = address;\n  export type storage = {\n    admin_address: admin_address,\n    taco_data: taco_data,\n  };\n\n  export const default_taco_data: taco_data = Map.literal ([\n    [1n, { current_stock: 50n, max_price: 50tez }],\n    [2n, { current_stock: 20n, max_price: 75tez }]\n  ]);\n\n  // Internal function to get the price of a taco\n  const get_taco_price_internal = (taco_kind_index: nat, taco_data: taco_data): tez => {\n    const taco_kind: taco_supply =\n      match (Map.find_opt(taco_kind_index, taco_data)) {\n        when(Some(kind)): kind;\n        when(None()): failwith("Unknown kind of taco")\n      };\n    return taco_kind.max_price / taco_kind.current_stock;\n  }\n\n  @view\n  const get_taco_price = (taco_kind_index: nat, storage: storage): tez =>\n    get_taco_price_internal(taco_kind_index, storage.taco_data);\n\n  // Buy a taco\n  @entry\n  const buy_taco = (taco_kind_index: nat, storage: storage): [\n      list<operation>,\n      storage\n    ] => {\n\n    const { admin_address, taco_data } = storage;\n\n    // Retrieve the kind of taco from the contracts storage or fail\n    const taco_kind: taco_supply =\n      match (Map.find_opt(taco_kind_index, taco_data)) {\n        when(Some(kind)): kind;\n        when(None()): failwith("Unknown kind of taco");\n      };\n\n    // Get the current price of this type of taco\n    const current_purchase_price = get_taco_price_internal(taco_kind_index, taco_data);\n\n    // Verify that the caller sent the correct amount of tez\n    if ((Tezos.get_amount()) != current_purchase_price) {\n      return failwith("Sorry, the taco you are trying to purchase has a different price");\n    }\n\n    // Verify that there is at least one of this type of taco\n    if (taco_kind.current_stock == 0n) {\n      return failwith("Sorry, we are out of this type of taco");\n    }\n\n    // Update the storage with the new quantity of tacos\n    const updated_taco_data: taco_data = Map.update(\n      taco_kind_index,\n      (Some (({...taco_kind, current_stock: abs (taco_kind.current_stock - 1n) }))),\n      taco_data);\n\n    const updated_storage: storage = {\n      admin_address: admin_address,\n      taco_data: updated_taco_data,\n    };\n\n    return [[], updated_storage];\n  }\n\n  @entry\n  const payout = (_u: unit, storage: storage): [\n      list<operation>,\n      storage\n    ] => {\n\n    // Entrypoint logic goes here\n\n    return [[], storage];\n  }\n};\n'))),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("p",null,"Add this view to the contract, after the ",(0,o.kt)("inlineCode",{parentName:"p"},"get_taco_price_internal")," function and somewhere within the module:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},"[@view]\nlet get_taco_price (taco_kind_index : nat) (storage : storage) : tez =\n  get_taco_price_internal taco_kind_index storage.taco_data\n")),(0,o.kt)("p",null,"This view is merely a wrapper around the ",(0,o.kt)("inlineCode",{parentName:"p"},"get_taco_price_internal")," function, but the ",(0,o.kt)("inlineCode",{parentName:"p"},"@view")," attribute makes external clients able to call it."),(0,o.kt)("p",null,"For more information about views, see ",(0,o.kt)("a",{parentName:"p",href:"../../syntax/contracts/views"},"Views"),"."),(0,o.kt)("p",null,"The complete contract file looks like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},'module TacoShop = struct\n\n  type taco_supply = { current_stock: nat; max_price: tez }\n  type taco_data = (nat, taco_supply) map\n  type admin_address = address\n  type storage = {\n    admin_address: admin_address;\n    taco_data: taco_data;\n  }\n\n  let default_taco_data: taco_data = Map.literal [\n    (1n, { current_stock = 50n; max_price = 50tez });\n    (2n, { current_stock = 20n; max_price = 75tez });\n  ]\n\n  (* Internal function to get the price of a taco *)\n  let get_taco_price_internal (taco_kind_index : nat) (taco_data : taco_data) : tez =\n    let taco_kind : taco_supply =\n      match Map.find_opt taco_kind_index taco_data with\n      | Some kind -> kind\n      | None -> failwith "Unknown kind of taco"\n      in\n      taco_kind.max_price / taco_kind.current_stock\n\n  [@view]\n  let get_taco_price (taco_kind_index : nat) (storage : storage) : tez =\n    get_taco_price_internal taco_kind_index storage.taco_data\n\n  (* Buy a taco *)\n  [@entry]\n  let buy_taco (taco_kind_index : nat) (storage : storage) : operation list * storage =\n\n    let { admin_address; taco_data } = storage in\n\n    (* Retrieve the kind of taco from the contracts storage or fail *)\n    let taco_kind : taco_supply =\n      match Map.find_opt taco_kind_index taco_data with\n      | Some kind -> kind\n      | None -> failwith "Unknown kind of taco" in\n\n    (* Get the current price of this type of taco *)\n    let current_purchase_price = get_taco_price_internal taco_kind_index taco_data in\n\n    (* Verify that the caller sent the correct amount of tez *)\n    let _ = if (Tezos.get_amount () <> current_purchase_price) then\n      failwith "Sorry, the taco you are trying to purchase has a different price" in\n\n    (* Verify that there is at least one of this type of taco *)\n    let _ = if (taco_kind.current_stock = 0n) then\n      failwith "Sorry, we are out of this type of taco" in\n\n\n    (* Update the storage with the new quantity of tacos *)\n    let updated_taco_data : taco_data = Map.update\n      taco_kind_index\n      (Some { taco_kind with current_stock = abs (taco_kind.current_stock - 1n) })\n      taco_data in\n\n\n    let updated_storage : storage = {\n      admin_address = admin_address;\n      taco_data = updated_taco_data;\n    } in\n\n    [], updated_storage\n\n    [@entry]\n    let payout (_u : unit) (storage : storage) : operation list * storage =\n\n      (* Entrypoint logic goes here *)\n\n      [], storage\n\n  end\n'))),(0,o.kt)("h2",{id:"compiling-the-contract"},"Compiling the contract"),(0,o.kt)("p",null,"Before you can deploy the contract to Tezos, you must compile it to Michelson,the low-level language of contracts on Tezos."),(0,o.kt)("p",null,"Run this command to compile the contract:"),(0,o.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"ligo compile contract -m TacoShop -o taco_shop.tz taco_shop.jsligo\n"))),(0,o.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"ligo compile contract -m TacoShop -o taco_shop.tz taco_shop.mligo\n"))),(0,o.kt)("p",null,"If compilation is successful, LIGO prints nothing to the console and writes the compiled contract to the file ",(0,o.kt)("inlineCode",{parentName:"p"},"taco_shop.tz"),".\nYou don't need to interact with this file directly."),(0,o.kt)("p",null,"If you see errors, make sure your code matches the code in the previous section."),(0,o.kt)("p",null,"You now have a basic contract that can accept requests to sell tacos.\nHowever, before you deploy it, you should test the contract to make sure it works.\nContinue to ",(0,o.kt)("a",{parentName:"p",href:"./testing-contract"},"Part 2: Testing the contract"),"."))}m.isMDXComponent=!0}}]);