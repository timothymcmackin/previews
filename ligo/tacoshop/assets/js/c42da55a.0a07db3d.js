"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[48478],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>u});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},y={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),m=p(n),u=r,b=m["".concat(l,".").concat(u)]||m[u]||y[u]||s;return n?a.createElement(b,o(o({ref:t},c),{},{components:n})):a.createElement(b,o({ref:t},c))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,o=new Array(s);o[0]=m;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:r,o[1]=i;for(var p=2;p<s;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},48720:(e,t,n)=>{n.d(t,{D:()=>r.Z,Z:()=>s});var a=n(67294),r=n(75402);const s=function(e){return a.createElement(r.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},18220:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var a=n(87462),r=(n(67294),n(3905)),s=n(48720);const o={id:"bytes",title:"Sequences of bytes"},i=void 0,l={unversionedId:"tezos/bytes/bytes",id:"version-1.5.0/tezos/bytes/bytes",title:"Sequences of bytes",description:"Bytes are used for serializing data, for example to compute signature",source:"@site/versioned_docs/version-1.5.0/tezos/bytes/bytes.md",sourceDirName:"tezos/bytes",slug:"/tezos/bytes/",permalink:"/previews/ligo/tacoshop/docs/1.5.0/tezos/bytes/",draft:!1,tags:[],version:"1.5.0",frontMatter:{id:"bytes",title:"Sequences of bytes"},sidebar:"docs",previous:{title:"Tezos",permalink:"/previews/ligo/tacoshop/docs/1.5.0/tezos/"},next:{title:"Concatenating",permalink:"/previews/ligo/tacoshop/docs/1.5.0/tezos/bytes/concatenating"}},p={},c=[{value:"Literals",id:"literals",level:3},{value:"From numbers to bytes and back",id:"from-numbers-to-bytes-and-back",level:3},{value:"From strings",id:"from-strings",level:3}],y={toc:c};function m(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},y,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Bytes are used for serializing data, for example to compute signature\nhashes. Conversely, they can be used to deserialise external data, in\nwhich case the expected LIGO type needs to be specified."),(0,r.kt)("h3",{id:"literals"},"Literals"),(0,r.kt)("p",null,"Byte literals are sequences of bytes (eight-bit values, also known as\n",(0,r.kt)("em",{parentName:"p"},"octets"),"), defined using the prefix ",(0,r.kt)("inlineCode",{parentName:"p"},"0x")," followed by hexadecimal\ndigits, or none if the denoted literal is zero:"),(0,r.kt)(s.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=bytes",group:"bytes"},"let a : bytes = 0x70FF\nlet zero : bytes = 0x\nlet zero_too = 0x00\n"))),(0,r.kt)(s.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=bytes",group:"bytes"},"const a : bytes = 0x70FF;\nconst zero : bytes = 0x;\nconst zero_too = 0x00;\n"))),(0,r.kt)("p",null,"Clearly, this means that literal bytes are always comprised of an even\nnumber of hexadecimal digits (because one hexadecimal digit requires\nup to four bits in binary, and eight are needed to make up a byte)."),(0,r.kt)("h3",{id:"from-numbers-to-bytes-and-back"},"From numbers to bytes and back"),(0,r.kt)("p",null,"Some other numerals can be converted to bytes by means of calling the\npredefined function ",(0,r.kt)("inlineCode",{parentName:"p"},"bytes"),", which is overloaded. The reverse\nconversion is done by the predefined functions ",(0,r.kt)("inlineCode",{parentName:"p"},"int")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"nat"),". For\ninstance, here how to create bytes from natural numbers and integers:"),(0,r.kt)(s.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=bytes",group:"bytes"},"let b : bytes = bytes 123n   // 7B in hexadecimal\nlet c : bytes = bytes 123\nlet d : bytes = bytes (-123) // Two's complement\n\nlet n : nat = nat 0x7B // n = 123n\nlet i : int = int 0x7B // i = 123\n"))),(0,r.kt)(s.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=bytes",group:"bytes"},"const b: bytes = bytes(123n); // 7B in hexadecimal\nconst c: bytes = bytes(123);\nconst d: bytes = bytes(-123); // Two's complement\n\nconst n: nat = nat(0x7B); // n == 123n\nconst i: int = int(0x7B); // i == 123\n"))),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note: See\n",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Two's_complement"},"Two's complement"),".")),(0,r.kt)("h3",{id:"from-strings"},"From strings"),(0,r.kt)("p",null,"A string literal can be converted to bytes in two ways:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"by interpreting the ",(0,r.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/ASCII"},"ASCII"),"\ncode of each character (which spans over two hexadecimal digits) as\none byte;"),(0,r.kt)("li",{parentName:"ol"},"by interpreting directly each character as one hexadecimal digit.")),(0,r.kt)("p",null,"In the former case, the syntax is somewhat odd -- as opposed to simply\ncalling the function ",(0,r.kt)("inlineCode",{parentName:"p"},"bytes"),":"),(0,r.kt)(s.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=bytes",group:"bytes"},'let from_ascii : bytes = [%bytes "foo"]\n'))),(0,r.kt)(s.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=bytes",group:"bytes"},"const from_ascii: bytes = bytes`foo`; // Not a call\n"))),(0,r.kt)("p",null,"The latter case is implemented as a type cast:"),(0,r.kt)(s.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=bytes",group:"bytes"},'// raw = from_ascii\nlet raw : bytes = ("666f6f" : bytes)\n')),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note that both the ",(0,r.kt)("inlineCode",{parentName:"p"},"[%bytes ...]")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"(... : bytes)")," syntaxes apply\nonly to ",(0,r.kt)("em",{parentName:"p"},"string literals"),", not general expressions of type\n",(0,r.kt)("inlineCode",{parentName:"p"},"string"),". In other words, the contents of the strings must be\navailable in-place at compile-time. (This actually reveals that\n",(0,r.kt)("inlineCode",{parentName:"p"},'("666f6f" : bytes)')," is not really a cast, as casts are\nnon-operations.)"))),(0,r.kt)(s.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=bytes",group:"bytes"},'// raw == from_ascii\nconst raw: bytes = ("666f6f" as bytes);\n')),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note that both syntaxes apply respectively only to ",(0,r.kt)("em",{parentName:"p"},"verbatim")," string\nliterals and general strings, not general expressions of type\n",(0,r.kt)("inlineCode",{parentName:"p"},"string"),". In other words, the contents of the strings must be\navailable at compile-time. (This actually reveals that ",(0,r.kt)("inlineCode",{parentName:"p"},'("666f6f" as\nbytes)')," is not really a cast, as casts are non-operations.)"))))}m.isMDXComponent=!0}}]);