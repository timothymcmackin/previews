"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[55098],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var r=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var p=r.createContext({}),s=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},c=function(e){var t=s(e.components);return r.createElement(p.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,p=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=s(n),h=i,m=u["".concat(p,".").concat(h)]||u[h]||d[h]||o;return n?r.createElement(m,a(a({ref:t},c),{},{components:n})):r.createElement(m,a({ref:t},c))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,a=new Array(o);a[0]=u;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l.mdxType="string"==typeof e?e:i,a[1]=l;for(var s=2;s<o;s++)a[s]=n[s];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},48720:(e,t,n)=>{n.d(t,{D:()=>i.Z,Z:()=>o});var r=n(67294),i=n(75402);const o=function(e){return r.createElement(i.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:r.createElement(r.Fragment,null)}))}},19137:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>s});var r=n(87462),i=(n(67294),n(3905));n(48720);const o={id:"include",title:"#include"},a=void 0,l={unversionedId:"preprocessor/include",id:"version-1.6.0/preprocessor/include",title:"#include",description:"The solution provided by the conditional directives with symbol",source:"@site/versioned_docs/version-1.6.0/preprocessor/include.md",sourceDirName:"preprocessor",slug:"/preprocessor/include",permalink:"/previews/ligo/tacoshop/docs/1.6.0/preprocessor/include",draft:!1,tags:[],version:"1.6.0",frontMatter:{id:"include",title:"#include"},sidebar:"docs",previous:{title:"#define",permalink:"/previews/ligo/tacoshop/docs/1.6.0/preprocessor/define"},next:{title:"#import",permalink:"/previews/ligo/tacoshop/docs/1.6.0/preprocessor/import"}},p={},s=[],c={toc:s};function d(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The solution provided by the conditional directives with symbol\ndefinition to manage several standards is improved upon by physically\nseparating the input into different files. This is where the\n",(0,i.kt)("inlineCode",{parentName:"p"},"#include")," directive comes handy. Basically, it takes an argument made\nof a string containing a path to the file to be textually included,\nlike so:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'#include "path/to/standard_1.ligo"\n')),(0,i.kt)("p",null,"and the preprocessor replaces the directive with the contents of the\nfile ",(0,i.kt)("inlineCode",{parentName:"p"},"path/to/standard_1.ligo"),", whose contents is then preprocessed as\nwell. This can in theory create a loop, for example, if two files try\nto include each other."),(0,i.kt)("p",null,"In fact, the preprocessor does more than simply include the given\nfile. To enable the consumer of the output to keep track of\ninclusions, in particular, to maintain the line numbers of the input\nthat has been copied, the preprocessor inserts two special directives\nin the output, called\n",(0,i.kt)("a",{parentName:"p",href:"https://gcc.gnu.org/onlinedocs/cpp/Preprocessor-Output.html"},"linemarkers"),",\none in the stead of the ",(0,i.kt)("inlineCode",{parentName:"p"},"#include")," directive and one after the\ninclusion. Let us consider the following example where ",(0,i.kt)("inlineCode",{parentName:"p"},"a.txt"),"\nincludes ",(0,i.kt)("inlineCode",{parentName:"p"},"b.txt"),", which, in turn, includes ",(0,i.kt)("inlineCode",{parentName:"p"},"c.txt"),". Here is the\ncontents of ",(0,i.kt)("inlineCode",{parentName:"p"},"a.txt"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Start of "a.txt"\n#include "b.txt"\nEnd of "a.txt"\n')),(0,i.kt)("p",null,"Then ",(0,i.kt)("inlineCode",{parentName:"p"},"b.txt"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Start of "b.txt"\n#include "c.txt"\nEnd of "b.txt"\n')),(0,i.kt)("p",null,"and, finally, ",(0,i.kt)("inlineCode",{parentName:"p"},"c.txt"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Start of "c.txt"\nEnd of "c.txt"\n')),(0,i.kt)("p",null,"If we gather the files in a ",(0,i.kt)("inlineCode",{parentName:"p"},"Tests")," directory and run the preprocessor\nonly, like so"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"$ ligo print preprocessed Tests/a.txt")),(0,i.kt)("p",null,"we obtain on ",(0,i.kt)("inlineCode",{parentName:"p"},"stdout"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'# 1 "Tests/a.txt"\nStart of "a.txt"\n\n# 1 "Tests/b.txt" 1\nStart of "b.txt"\n\n# 1 "Tests/c.txt" 1\nStart of "c.txt"\nEnd of "c.txt"\n# 3 "Tests/b.txt" 2\nEnd of "b.txt"\n# 3 "Tests/a.txt" 2\nEnd of "a.txt"\n')),(0,i.kt)("p",null,"There are three forms of linemarkers:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},'# <line number> "path/to/file"')),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},'# <line number> "path/to/file" 1')),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},'# <line number> "path/to/file" 2'))),(0,i.kt)("p",null,"The first kind is used only at the start of the output file and states\nthat the line after the linemarker has number ",(0,i.kt)("inlineCode",{parentName:"p"},"<line number>")," and\nbelongs to the file ",(0,i.kt)("inlineCode",{parentName:"p"},"path/to/file"),". Therefore ",(0,i.kt)("inlineCode",{parentName:"p"},'Start of "a.txt"')," has\nline number ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," in file ",(0,i.kt)("inlineCode",{parentName:"p"},"Tests/a.txt"),"."),(0,i.kt)("p",null,"The second kind is used when including a file. The ",(0,i.kt)("inlineCode",{parentName:"p"},"#include"),"\ndirective is discarded in the output, except the newline character,\nwhich explains the empty line after ",(0,i.kt)("inlineCode",{parentName:"p"},'Start of "a.txt"'),". Then a\nlinemarker ending in ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," is printed, which means that we went to the\nfile ",(0,i.kt)("inlineCode",{parentName:"p"},"path/to/file")," when processing the input."),(0,i.kt)("p",null,"The third kind is inserted in the output upon returning from an\nincluded file. For example, ",(0,i.kt)("inlineCode",{parentName:"p"},'# 3 "Tests/b.txt" 2')," means that the next\nline has number ",(0,i.kt)("inlineCode",{parentName:"p"},"3")," and we return to file ",(0,i.kt)("inlineCode",{parentName:"p"},"Tests/b.txt"),"."),(0,i.kt)("p",null,"Linemarkers need to be handled by the consumer of the output. In the\ncontext of the LIGO compiler, the lexer reads the output of the\npreprocessor, therefore scans for linemarkers."),(0,i.kt)("p",null,"When using the preprocessor with the LIGO compiler, the ",(0,i.kt)("inlineCode",{parentName:"p"},"#include"),"\ndirective can only occur at the top level according to the grammar,\nthat is, either at the beginning of the smart contract, in between\nfile-level declarations or at the end. (This property is checked by\nthe parser.) The rationale for this restriction is to avoid fragments\nof smart contracts that are syntactically incorrect, and yet assembled\ninto a correct one."))}d.isMDXComponent=!0}}]);