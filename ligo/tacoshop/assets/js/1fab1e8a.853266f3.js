"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[64167],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>g});var a=n(67294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,s=e.mdxType,r=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=c(n),g=s,m=d["".concat(l,".").concat(g)]||d[g]||u[g]||r;return n?a.createElement(m,o(o({ref:t},p),{},{components:n})):a.createElement(m,o({ref:t},p))}));function g(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var r=n.length,o=new Array(r);o[0]=d;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:s,o[1]=i;for(var c=2;c<r;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},48720:(e,t,n)=>{n.d(t,{D:()=>s.Z,Z:()=>r});var a=n(67294),s=n(75402);const r=function(e){return a.createElement(s.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},42585:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=n(87462),s=(n(67294),n(3905)),r=n(48720);const o={id:"testing",title:"Testing"},i=void 0,l={unversionedId:"testing/testing",id:"testing/testing",title:"Testing",description:"The LIGO command-line interpreter provides commands to test your LIGO code.",source:"@site/../docs/testing/testing.md",sourceDirName:"testing",slug:"/testing/",permalink:"/previews/ligo/tacoshop/docs/next/testing/",draft:!1,tags:[],version:"current",frontMatter:{id:"testing",title:"Testing"},sidebar:"docs",previous:{title:"Parameteric types",permalink:"/previews/ligo/tacoshop/docs/next/data-types/parametric_types"},next:{title:"Testing tickets",permalink:"/previews/ligo/tacoshop/docs/next/testing/testing-tickets"}},c={},p=[{value:"Testing with <code>ligo run test</code>",id:"testing-with-ligo-run-test",level:2},{value:"Creating transactions",id:"creating-transactions",level:3},{value:"Generating test accounts",id:"generating-test-accounts",level:3},{value:"Testing views",id:"testing-views",level:3},{value:"Testing events",id:"testing-events",level:3},{value:"Unit testing functions",id:"unit-testing-functions",level:3},{value:"Testing with <code>ligo run interpret</code>",id:"testing-with-ligo-run-interpret",level:2},{value:"Testing with <code>ligo run dry-run</code>",id:"testing-with-ligo-run-dry-run",level:2}],u={toc:p};function d(e){let{components:t,...n}=e;return(0,s.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The LIGO command-line interpreter provides commands to test your LIGO code.\nIt provides three main ways to test code:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("inlineCode",{parentName:"p"},"ligo run test"),": Runs automated tests in LIGO code")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("inlineCode",{parentName:"p"},"ligo run interpret"),": Interprets a LIGO expression in the context of a LIGO file")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("inlineCode",{parentName:"p"},"ligo run dry-run"),": Simulates running a contract based on a given parameter and storage value"))),(0,s.kt)("admonition",{type:"warning"},(0,s.kt)("p",{parentName:"admonition"},"LIGO testing tools are in beta and may change.\nNo production test procedure should rely on these tools alone.")),(0,s.kt)("h2",{id:"testing-with-ligo-run-test"},"Testing with ",(0,s.kt)("inlineCode",{parentName:"h2"},"ligo run test")),(0,s.kt)("p",null,"The command ",(0,s.kt)("inlineCode",{parentName:"p"},"ligo run test")," runs automated tests on a contract."),(0,s.kt)("p",null,"When running the ",(0,s.kt)("inlineCode",{parentName:"p"},"ligo run test")," command, LIGO code has access to an additional ",(0,s.kt)("inlineCode",{parentName:"p"},"Test")," module.\nThis module provides ways of originating contracts and executing transactions in a simulated environment, as well as additional helper functions that allow you to control different parameters of the Tezos testing library."),(0,s.kt)("admonition",{type:"note"},(0,s.kt)("p",{parentName:"admonition"},"The LIGO interpreter uses the ",(0,s.kt)("a",{parentName:"p",href:"https://gitlab.com/tezos/tezos/-/tree/master/src/proto_alpha/lib_protocol/test/helpers"},"same library that Tezos internally uses for testing"),".")),(0,s.kt)("p",null,"To originate a contract in the test simulation, use the ",(0,s.kt)("inlineCode",{parentName:"p"},"Test.Next.originate")," function, which accepts these parameters:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"The contract itself"),(0,s.kt)("li",{parentName:"ul"},"The initial storage value"),(0,s.kt)("li",{parentName:"ul"},"The starting balance of the contract in tez")),(0,s.kt)("p",null,"The function returns an object that has these values:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"taddr"),": The address of the deployed contract in the simulation"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"size"),": The size of the deployed contract in bytes, as an integer"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"code"),": The Michelson code of the contract")),(0,s.kt)("p",null,"You can get the storage of a deployed contract by passing the address of the contract to the ",(0,s.kt)("inlineCode",{parentName:"p"},"Test.Next.Typed_address.get_storage")," function."),(0,s.kt)("p",null,"For example, this LIGO file includes a simple counter contract:"),(0,s.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"test-ligo group=mycontract","test-ligo":!0,group:"mycontract"},"// This is mycontract.mligo\nmodule MyContract = struct\n  type storage = int\n  type result = operation list * storage\n\n  [@entry] let increment (delta : int) (storage : storage) : result = [],storage + delta\n  [@entry] let decrement (delta : int) (storage : storage) : result = [],storage - delta\n  [@entry] let reset () (_storage : storage) : result = [], 0\nend\n"))),(0,s.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"test-ligo group=mycontract","test-ligo":!0,group:"mycontract"},"// This is mycontract.jsligo\nexport namespace MyContract {\n  export type storage = int;\n  export type result = [list<operation>, storage];\n\n  @entry const increment = (delta : int, storage : storage) : result => [[], storage + delta];\n  @entry const decrement = (delta : int, storage : storage) : result => [[], storage - delta];\n  @entry const reset = (_u : unit, _storage : storage) : result => [[], 0];\n}\n"))),(0,s.kt)("p",null,"To test the contract, create a function to originate the contract in the test simulation, call it, and verify the result.\nYou can put the test functions in the same file or a separate file."),(0,s.kt)("p",null,"This example shows a test in a separate file.\nIt follows these basic steps:"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"It imports the contract file with the ",(0,s.kt)("inlineCode",{parentName:"li"},"import")," directive."),(0,s.kt)("li",{parentName:"ol"},"It creates a function named ",(0,s.kt)("inlineCode",{parentName:"li"},"run_test1")," for the test."),(0,s.kt)("li",{parentName:"ol"},"In the function, it creates a value for the initial storage of the contract."),(0,s.kt)("li",{parentName:"ol"},"It originates the contract to the test simulation with the initial storage."),(0,s.kt)("li",{parentName:"ol"},"It verifies that the deployed contract has the storage value."),(0,s.kt)("li",{parentName:"ol"},"It calls the ",(0,s.kt)("inlineCode",{parentName:"li"},"increment")," entrypoint with the ",(0,s.kt)("inlineCode",{parentName:"li"},"Test.Next.Contract.transfer_exn")," function, passing the entrypoint, the parameter, and 0 tez."),(0,s.kt)("li",{parentName:"ol"},"It verifies the updated storage value.")),(0,s.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"test-ligo group=mycontract-test","test-ligo":!0,group:"mycontract-test"},'(* This is mycontract-test.mligo *)\n\nmodule Test = Test.Next\n\n#import "gitlab-pages/docs/testing/src/testing/mycontract.mligo" "MyContract"\n\nlet run_test1 =\n  let initial_storage = 10 in\n  let orig = Test.Originate.contract (contract_of MyContract.MyContract) initial_storage 0tez in\n  let () = Assert.assert (Test.Typed_address.get_storage(orig.taddr) = initial_storage) in\n  let _: nat = Test.Contract.transfer_exn (Test.Typed_address.get_entrypoint "increment" orig.taddr) 32 0tez in\n  Assert.assert (Test.Typed_address.get_storage(orig.taddr) = initial_storage + 32)\n'))),(0,s.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"test-ligo group=mycontract-test","test-ligo":!0,group:"mycontract-test"},'// This is mycontract-test.jligo\n\nimport Test = Test.Next;\n\n#import "gitlab-pages/docs/testing/src/testing/mycontract.jsligo" "MyModule"\n\nconst run_test1 = () => {\n    let initial_storage = 10;\n    let orig = Test.Originate.contract(contract_of(MyModule.MyContract), initial_storage, 0tez);\n    Test.Contract.transfer_exn(Test.Typed_address.get_entrypoint("increment", orig.taddr), 5, 0tez);\n    return Assert.assert(Test.Typed_address.get_storage(orig.taddr) == initial_storage + 5);\n};\n\nconst test1 = run_test1();\n'))),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"run test")," command evaluates all top-level definitions and prints any\nentries that begin with the prefix ",(0,s.kt)("inlineCode",{parentName:"p"},"test")," as well as the value that these\ndefinitions evaluate to. If any of the definitions fail, it prints a message\nwith the line number where the problem occurred.\nYou can also log messages to the console with the ",(0,s.kt)("inlineCode",{parentName:"p"},"Test.Next.IO.log")," function."),(0,s.kt)("p",null,"To run the tests, pass the file with the tests to the ",(0,s.kt)("inlineCode",{parentName:"p"},"run test")," command.\nIf the file imports other files, pass the folders that contain these files in the ",(0,s.kt)("inlineCode",{parentName:"p"},"--library")," argument, as in this example:"),(0,s.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},"ligo run test --library gitlab-pages/docs/testing/src/testing/ gitlab-pages/docs/testing/src/testing/mycontract-test.mligo\n"))),(0,s.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},"ligo run test --library gitlab-pages/docs/testing/src/testing/ gitlab-pages/docs/testing/src/testing/mycontract-test.jsligo\n"))),(0,s.kt)("p",null,"The response shows that the functions at the top level of the file ran successfully:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"Everything at the top-level was executed.\n- test1 exited with value ().\n")),(0,s.kt)("h3",{id:"creating-transactions"},"Creating transactions"),(0,s.kt)("p",null,"The function ",(0,s.kt)("inlineCode",{parentName:"p"},"Test.Next.Contract.transfer_exn")," creates a transaction in the test simulation, as in the example in the previous section.\nIt takes these parameters:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"The target entrypoint or account to call"),(0,s.kt)("li",{parentName:"ul"},"The parameter to pass"),(0,s.kt)("li",{parentName:"ul"},"The amount of tez to include")),(0,s.kt)("p",null,"If the transaction succeeds, it returns the gas consumption.\nIf it fails, it fails the test."),(0,s.kt)("p",null,"For greater control, such as to test error conditions and error messages, you can use the function ",(0,s.kt)("inlineCode",{parentName:"p"},"Test.Next.Contract.transfer"),".\nThe function takes the same parameters but returns an option of the type ",(0,s.kt)("inlineCode",{parentName:"p"},"test_exec_result"),", which is ",(0,s.kt)("inlineCode",{parentName:"p"},"Fail")," if the transaction failed and ",(0,s.kt)("inlineCode",{parentName:"p"},"Success")," if it succeeded.\nIn case of success the value is the gas consumed and in case of failure the value is an object of the type ",(0,s.kt)("inlineCode",{parentName:"p"},"test_exec_error")," that describes the error."),(0,s.kt)("admonition",{type:"warning"},(0,s.kt)("p",{parentName:"admonition"},"If you create a transaction with ",(0,s.kt)("inlineCode",{parentName:"p"},"Test.Next.Contract.transfer")," and the transaction fails, the test does not automatically fail.\nYou must check the result of the transaction to see if it succeeded or failed.")),(0,s.kt)("p",null,"For example, this contract is similar to the contract in an earlier example, but it only allows the number in storage to change by 5 or less with each transaction:"),(0,s.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=mycontract-failures",group:"mycontract-failures"},'module MyContract = struct\n  type storage = int\n  type result = operation list * storage\n\n  [@entry] let increment (delta : int) (storage : storage) : result =\n    if abs delta <= 5n then [], storage + delta else failwith "Pass 5 or less"\n  [@entry] let decrement (delta : int) (storage : storage) : result =\n    if abs delta <= 5n then [], storage - delta else failwith "Pass 5 or less"\n  [@entry] let reset () (_storage : storage) : result = [], 0\nend\n')),(0,s.kt)("p",null,"This test verifies that the error works by passing a number larger than 5 and handling the error:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=mycontract-failures",group:"mycontract-failures"},'module Test = Test.Next\n\nlet test_failure =\n  let initial_storage = 10 in\n  let orig = Test.Originate.contract (contract_of MyContract) initial_storage 0tez in\n  let result: test_exec_result = Test.Contract.transfer (Test.Typed_address.get_entrypoint "increment" orig.taddr) 50 0tez in\n  match result with\n    Fail _x -> Test.IO.log "Failed as expected"\n  | Success _s -> failwith "This should not succeed"\n'))),(0,s.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=mycontract-failures",group:"mycontract-failures"},'namespace MyContract {\n  export type storage = int;\n  export type result = [list<operation>, storage];\n\n  @entry const increment = (delta : int, storage : storage) : result =>\n    abs(delta) <= 5n ? [[], storage + delta] : failwith("Pass 5 or less");\n  @entry const decrement = (delta : int, storage : storage) : result =>\n    abs(delta) <= 5n ? [[], storage - delta] : failwith("Pass 5 or less");\n  @entry const reset = (_u : unit, _storage : storage) : result => [[], 0];\n}\n')),(0,s.kt)("p",null,"This test verifies that the error works by passing a number larger than 5 and handling the error:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=mycontract-failures",group:"mycontract-failures"},'import Test = Test.Next;\n\nconst test_failure = () => {\n  const initial_storage = 10 as int;\n  const orig = Test.Originate.contract(contract_of(MyContract), initial_storage, 0tez);\n  const result = Test.Contract.transfer(Test.Typed_address.get_entrypoint("increment", orig.taddr), 50 as int, 0tez);\n\n  match(result) {\n    when(Fail(_x)): Test.IO.log("Failed as expected");\n    when(Success(_s)): failwith("This should not succeed")\n  };\n}\n\nconst test1 = test_failure();\n'))),(0,s.kt)("h3",{id:"generating-test-accounts"},"Generating test accounts"),(0,s.kt)("p",null,"You can use test accounts to simulate real accounts in tests.\nFor example, assume that you want to allow only an administrator account to call the ",(0,s.kt)("inlineCode",{parentName:"p"},"reset")," entrypoint in the contract from the previous example.\nThis version adds an administrator address to the contract storage.\nIt checks the sender of the transaction in the ",(0,s.kt)("inlineCode",{parentName:"p"},"reset")," entrypoint and fails if the addresses don't match:"),(0,s.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=test-accounts",group:"test-accounts"},'module Counter = struct\n  type storage = int * address\n  type return_type = operation list * storage\n\n  [@entry] let increment (n : int) (storage : storage) : return_type =\n    let (number, admin_account) = storage in\n    [], (number + n, admin_account)\n\n  [@entry] let sub (n : int) (storage : storage) : return_type =\n    let (number, admin_account) = storage in\n    [], (number - n, admin_account)\n\n  [@entry] let reset (_ : unit) (storage : storage) : return_type =\n    let (_number, admin_account) = storage in\n    if Tezos.get_sender() = admin_account then\n      [], (0, admin_account)\n    else\n      failwith "Only the owner can call this entrypoint"\nend\n'))),(0,s.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=test-accounts",group:"test-accounts"},'namespace Counter {\n  type storage = [int, address];\n  type return_type = [list<operation>, storage];\n\n  @entry\n  const increment = (n: int, storage: storage): return_type => {\n    const [number, admin_account] = storage;\n    return [[], [number + n, admin_account]];\n  }\n\n  @entry\n  const decrement = (n: int, storage: storage): return_type => {\n    const [number, admin_account] = storage;\n    return [[], [number - n, admin_account]];\n  }\n\n  @entry\n  const reset = (_: unit, storage: storage): return_type => {\n    const [_number, admin_account] = storage;\n\n    if (Tezos.get_sender() != admin_account) {\n      return failwith("Only the owner can call this entrypoint");\n    }\n\n    return [[], [0, admin_account]];\n  }\n};\n'))),(0,s.kt)("p",null,"To generate test accounts, pass a nat to the ",(0,s.kt)("inlineCode",{parentName:"p"},"Test.Next.Account.address")," function, which returns an address.\nThen use the ",(0,s.kt)("inlineCode",{parentName:"p"},"Test.Next.State.set_source")," function to set the source account for transactions."),(0,s.kt)("p",null,"This example creates an admin account and user account.\nIt attempts to call the ",(0,s.kt)("inlineCode",{parentName:"p"},"reset")," entrypoint as the user account and expects it to fail.\nThen it calls the ",(0,s.kt)("inlineCode",{parentName:"p"},"reset")," entrypoint as the admin account and verifies that the entrypoint runs correctly:"),(0,s.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=test-accounts",group:"test-accounts"},'module Test = Test.Next\n\nlet test_admin =\n  let (admin_account, user_account) = (Test.Account.address(0n), Test.Account.address(1n)) in\n\n  // Originate the contract with the admin account in storage\n  let initial_storage = (10, admin_account) in\n  let orig = Test.Originate.contract (contract_of Counter) initial_storage 0tez in\n\n  // Try to call the reset entrypoint as the user and expect it to fail\n  let () = Test.State.set_source user_account in\n  let result = Test.Contract.transfer (Test.Typed_address.get_entrypoint "reset" orig.taddr ) unit 0tez in\n  let () = match result with\n    Fail _err -> Test.IO.log "Test succeeded"\n  | Success _s -> failwith "User should not be able to call reset" in\n\n  // Call the reset entrypoint as the admin and expect it to succeed\n  let () = Test.State.set_source admin_account in\n  let _: nat = Test.Contract.transfer_exn (Test.Typed_address.get_entrypoint "reset" orig.taddr) unit 0tez in\n\n  let (newNumber, _admin_account) = Test.Typed_address.get_storage orig.taddr in\n  Assert.assert (newNumber = 0)\n'))),(0,s.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=test-accounts",group:"test-accounts"},'import Test = Test.Next;\n\nconst test_admin = (() => {\n  const admin_account = Test.Account.address(0n);\n  const user_account = Test.Account.address(1n);\n\n  // Originate the contract with the admin account in storage\n  const initial_storage = [10 as int, admin_account];\n  const orig = Test.Originate.contract(contract_of(Counter), initial_storage, 0tez);\n\n  // Try to call the reset entrypoint as the user and expect it to fail\n  Test.State.set_source(user_account);\n  const result = Test.Contract.transfer(Test.Typed_address.get_entrypoint("reset", orig.taddr), unit, 0tez);\n  match(result) {\n    when(Fail(_err)): Test.IO.log("Test succeeded");\n    when (Success(_s)): failwith("User should not be able to call reset");\n  };\n\n  // Call the reset entrypoint as the admin and expect it to succeed\n  Test.State.set_source(admin_account);\n  Test.Contract.transfer_exn(Test.Typed_address.get_entrypoint("reset", orig.taddr), unit, 0tez);\n\n  const [newNumber, _admin_account] = Test.Typed_address.get_storage(orig.taddr);\n  Assert.assert(newNumber == 0);\n}) ()\n'))),(0,s.kt)("p",null,"By default, the test simulation has two test accounts.\nTo create more, pass the number of accounts and a list of their balances or an empty list to use the default balance to the ",(0,s.kt)("inlineCode",{parentName:"p"},"Test.Next.State.Reset")," function, as in the following example.\nThe default balance is 4000000 tez minus %5 that is frozen so the account can act as a validator."),(0,s.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"test-ligo group=reset","test-ligo":!0,group:"reset"},"module Test = Test.Next\n\nlet test_accounts =\n  let initial_balances : tez list = [] in\n  let () = Test.State.reset 3n initial_balances in\n  let admin_account = Test.Account.address(0n) in\n  let user_account1 = Test.Account.address(1n) in\n  let user_account2 = Test.Account.address(2n) in\n\n  let () = Test.IO.log (Test.Address.get_balance admin_account) in\n  // 3800000000000mutez\n  let () = Test.IO.log (Test.Address.get_balance user_account1) in\n  // 3800000000000mutez\n  Test.IO.log (Test.Address.get_balance user_account2)\n  // 3800000000000mutez\n"))),(0,s.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"test-ligo group=reset","test-ligo":!0,group:"reset"},"import Test = Test.Next;\n\nconst test_accounts = () => {\n  Test.State.reset(3n, [] as list <tez>);\n  const admin_account = Test.Account.address(0n);\n  const user_account1 = Test.Account.address(1n);\n  const user_account2 = Test.Account.address(2n);\n\n  Test.IO.log(Test.Address.get_balance(admin_account));\n  // 3800000000000mutez\n  Test.IO.log(Test.Address.get_balance(user_account1));\n  // 3800000000000mutez\n  Test.IO.log(Test.Address.get_balance(user_account2));\n  // 3800000000000mutez\n}\n"))),(0,s.kt)("h3",{id:"testing-views"},"Testing views"),(0,s.kt)("p",null,"You can call views in tests and verify the results.\nHowever, the process for calling a view in a test is different from calling an entrypoint."),(0,s.kt)("p",null,"For example, this contract stores a string.\nIt has entrypoints that change the string and a view that returns the string:"),(0,s.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=test_views",group:"test_views"},'module Testviews = struct\n\n  type storage = string\n\n  type return_type = operation list * storage\n\n  [@entry]\n  let set (inputStr : storage) (_storage: storage) : return_type =\n   [], inputStr\n\n  [@entry]\n  let reset (_u : unit) (_storage : storage) : return_type =\n    [], ""\n\n  [@view]\n  let getString (_u : unit) (storage : storage) : string =\n    storage\nend\n')),(0,s.kt)("p",null,"This test casts the contract's typed address to an ordinary address type and uses that address to call the view with the function ",(0,s.kt)("inlineCode",{parentName:"p"},"Tezos.Next.View.call")," and pass the parameter ",(0,s.kt)("inlineCode",{parentName:"p"},"unit"),".\nThis function returns an option, so the test matches the option to verify the response from the view:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=test_views",group:"test_views"},'module Test = Test.Next\nmodule Tezos = Tezos.Next\n\nlet test_view =\n  let contract = Test.Originate.contract (contract_of Testviews) "" 0tez in\n  let _ : nat = Test.Contract.transfer_exn (Test.Typed_address.get_entrypoint "set" contract.taddr) "hello" 0tez in\n  let address = Test.Typed_address.to_address contract.taddr in\n  let viewResultOption : string option = Tezos.View.call "getString" unit address in\n  let viewResult = match viewResultOption with\n    | Some str -> str\n    | None -> ""\n  in\n  Assert.assert (Test.Compare.eq viewResult "hello")\n'))),(0,s.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=test_views",group:"test_views"},'namespace Testviews {\n\n  type storage = string;\n\n  type return_type = [list<operation>, storage];\n\n  @entry\n  const set = (inputStr: storage, _storage: storage): return_type =>\n    [list([]), inputStr];\n\n  @entry\n  const reset = (_u: unit, _storage: storage): return_type =>\n    [list([]), ""];\n\n  @view\n  const getString = (_u: unit, storage: storage): string =>\n    storage;\n}\n')),(0,s.kt)("p",null,"This test casts the contract's typed address to an ordinary address type and uses that address to call the view with the function ",(0,s.kt)("inlineCode",{parentName:"p"},"Tezos.Next.View.call"),".\nThis function returns an option, so the test matches the option to verify the response from the view:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=test_views",group:"test_views"},'import Test = Test.Next;\nimport Tezos = Tezos.Next;\n\nconst test_view = () => {\n  const contract = Test.Originate.contract(contract_of(Testviews), "", 0tez);\n  Test.Contract.transfer_exn(Test.Typed_address.get_entrypoint("set", contract.taddr), "hello", 0tez);\n  const address = Test.Typed_address.to_address(contract.taddr);\n  const viewResultOption: option<string> = Tezos.View.call("getString", unit, address);\n  const viewResult = match(viewResultOption) {\n    when(Some(str)): str;\n    when(None()): "";\n  };\n  Assert.assert(Test.Compare.eq(viewResult, "hello"));\n};\nconst test1 = test_view();\n'))),(0,s.kt)("h3",{id:"testing-events"},"Testing events"),(0,s.kt)("p",null,"To test events, emit them as usual with the ",(0,s.kt)("inlineCode",{parentName:"p"},"Tezos.emit")," function and use the ",(0,s.kt)("inlineCode",{parentName:"p"},"Test.Next.State.last_events")," function to capture the most recent events, as in this example:"),(0,s.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"test-ligo group=test_ex","test-ligo":!0,group:"test_ex"},'module C = struct\n  [@entry] let main (p : int*int) () =\n    [Tezos.emit "%foo" p ; Tezos.emit "%foo" p.0],()\nend\n\nmodule Test = Test.Next\n\nlet test_foo =\n  let orig = Test.Originate.contract (contract_of C) () 0tez in\n  let _: nat = Test.Typed_address.transfer_exn orig.taddr (Main (1,2)) 0tez in\n  (Test.State.last_events orig.taddr "foo" : (int*int) list),(Test.State.last_events orig.taddr "foo" : int list)\n'))),(0,s.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"test-ligo group=test_ex","test-ligo":!0,group:"test_ex"},'namespace C {\n  @entry\n  const main = (p: [int, int], _: unit) => {\n    const op1 = Tezos.emit("%foo", p);\n    const op2 = Tezos.emit("%foo", p[0]);\n    return [([op1, op2] as list<operation>), unit];\n  };\n}\n\nimport Test = Test.Next;\n\nconst test = () => {\n  const orig = Test.Originate.contract(contract_of(C), unit, 0tez);\n  Test.Typed_address.transfer_exn(orig.taddr, Main ([1,2]), 0tez);\n  return [Test.State.last_events(orig.taddr, "foo") as list<[int, int]>, Test.State.last_events(orig.taddr, "foo") as list<int>];\n};\n\nconst run_test = test();\n'))),(0,s.kt)("h3",{id:"unit-testing-functions"},"Unit testing functions"),(0,s.kt)("p",null,"You can use the ",(0,s.kt)("inlineCode",{parentName:"p"},"run test")," command to run unit tests of functions."),(0,s.kt)("p",null,"A common way of unit testing functions is to create a map of input values and expected output values and iterate over them.\nFor example, consider a map binding addresses to amounts and a function removing all entries in that map that have an amount less than a given threshold:"),(0,s.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=remove-balance",group:"remove-balance"},"(* This is remove-balance.mligo *)\n\ntype balances = (address, tez) map\n\nlet remove_balances_under (b : balances) (threshold : tez) : balances =\n  Map.fold\n    (fun ((acc, (k, v)) : balances * (address * tez)) ->\n       if v < threshold then Map.remove k acc else acc)\n    b b\n"))),(0,s.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=remove-balance",group:"remove-balance"},"// This is remove-balance.jsligo\n\ntype balances = map <address, tez>;\n\nconst remove_balances_under = (b: balances, threshold: tez): balances => {\n  let f = ([acc, kv]: [balances, [address, tez]] ): balances => {\n    let [k, v] = kv;\n    if (v < threshold) { return Map.remove (k, acc) } else {return acc}\n  };\n  return Map.fold (f, b, b);\n}\n"))),(0,s.kt)("p",null,"You can test this function against a range of thresholds with the LIGO test framework."),(0,s.kt)("p",null,"First, include the file under test and reset the state with 5 bootstrap accounts:"),(0,s.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"test-ligo group=unit-remove-balance-mixed","test-ligo":!0,group:"unit-remove-balance-mixed"},'#include "./gitlab-pages/docs/testing/src/testing/remove-balance.mligo"\n\nmodule Test = Test.Next\n\nlet test_remove_balance =\n  let () = Test.State.reset 5n ([]: tez list) in\n'))),(0,s.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"test-ligo group=unit-remove-balance-mixed","test-ligo":!0,group:"unit-remove-balance-mixed"},'#include "./gitlab-pages/docs/testing/src/testing/remove-balance.jsligo"\n\nimport Test = Test.Next;\n\nconst test_remove_balance = (() => {\n  Test.State.reset(5n, [] as list <tez>);\n'))),(0,s.kt)("p",null,"Now build the ",(0,s.kt)("inlineCode",{parentName:"p"},"balances")," map that serves as the test input:"),(0,s.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"test-ligo group=unit-remove-balance-mixed","test-ligo":!0,group:"unit-remove-balance-mixed"},"let balances: balances =\n  let a1, a2, a3 = Test.Account.address 1n, Test.Account.address 2n, Test.Account.address 3n\n  in Map.literal [(a1, 10tz); (a2, 100tz); (a3, 1000tz)] in\n"))),(0,s.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"test-ligo group=unit-remove-balance-mixed","test-ligo":!0,group:"unit-remove-balance-mixed"},"const balances: balances =\n  Map.literal([[Test.Account.address(1n), 10tez],\n              [Test.Account.address(2n), 100tez],\n              [Test.Account.address(3n), 1000tez]]);\n"))),(0,s.kt)("p",null,"The test loop will call the function with the compiled map\ndefined above, get the size of the resulting map, and compare it to an\nexpected value with ",(0,s.kt)("inlineCode",{parentName:"p"},"Test.Next.Compare.eq"),"."),(0,s.kt)("p",null,"The call to ",(0,s.kt)("inlineCode",{parentName:"p"},"remove_balances_under")," and the computation of the size of the resulting map is achieved through the primitive ",(0,s.kt)("inlineCode",{parentName:"p"},"Test.Next.Michelson.run"),".\nThis primitive runs a function on an input, translating both (function and input)\nto Michelson before running on the Michelson interpreter.\nMore concretely ",(0,s.kt)("inlineCode",{parentName:"p"},"Test.Next.Michelson.run f v")," performs the following:"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"Compiles the function argument ",(0,s.kt)("inlineCode",{parentName:"li"},"f")," to Michelson ",(0,s.kt)("inlineCode",{parentName:"li"},"f_mich")),(0,s.kt)("li",{parentName:"ol"},"Compiles the value argument ",(0,s.kt)("inlineCode",{parentName:"li"},"v")," (which was already evaluated) to Michelson ",(0,s.kt)("inlineCode",{parentName:"li"},"v_mich")),(0,s.kt)("li",{parentName:"ol"},"Runs the Michelson interpreter on the code ",(0,s.kt)("inlineCode",{parentName:"li"},"f_mich")," with the initial stack ",(0,s.kt)("inlineCode",{parentName:"li"},"[ v_mich ]"))),(0,s.kt)("p",null,"The function that is being compiled is called ",(0,s.kt)("inlineCode",{parentName:"p"},"tester"),"."),(0,s.kt)("p",null,"We also print the actual and expected sizes for good measure."),(0,s.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"test-ligo group=unit-remove-balance-mixed","test-ligo":!0,group:"unit-remove-balance-mixed"},'List.iter\n  (fun ((threshold , expected_size): tez * nat) ->\n    let tester (balances, threshold: balances * tez) = Map.size (remove_balances_under balances threshold) in\n    let size = Test.Michelson.run tester (balances, threshold) in\n    let expected_size = Test.Michelson.eval expected_size in\n    let () = Test.IO.log ("expected", expected_size) in\n    let () = Test.IO.log ("actual", size) in\n    Assert.assert (Test.Compare.eq size expected_size)\n  )\n  [(15tez,2n); (130tez,1n); (1200tez,0n)]\n'))),(0,s.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"test-ligo group=unit-remove-balance-mixed","test-ligo":!0,group:"unit-remove-balance-mixed"},'return List.iter(([threshold, expected_size]: [tez, nat]): unit => {\n    const tester = ([balances, threshold]: [balances, tez]): nat =>\n      Map.size (remove_balances_under (balances, threshold));\n    const size = Test.Michelson.run(tester, [balances, threshold]);\n    const expected_size_ = Test.Michelson.eval(expected_size);\n    Test.IO.log(["expected", expected_size]);\n    Test.IO.log(["actual", size]);\n    return (Assert.assert (Test.Compare.eq(size, expected_size_)))\n  },\n  list ([ [15tez, 2n], [130tez, 1n], [1200tez, 0n]]) );\n}) ()\n'))),(0,s.kt)("p",null,"Here is the complete test file:"),(0,s.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"test-ligo group=unit-remove-balance-complete","test-ligo":!0,group:"unit-remove-balance-complete"},'#include "./gitlab-pages/docs/testing/src/testing/remove-balance.mligo"\n\nmodule Test = Test.Next\n\nlet test_remove_balance =\n  let () = Test.State.reset 5n ([]: tez list) in\nlet balances: balances =\n  let a1, a2, a3 = Test.Account.address 1n, Test.Account.address 2n, Test.Account.address 3n\n    in Map.literal [(a1, 10tz); (a2, 100tz); (a3, 1000tz)] in\n  List.iter\n    (fun ((threshold , expected_size): tez * nat) ->\n      let tester (balances, threshold: balances * tez) = Map.size (remove_balances_under balances threshold) in\n      let size = Test.Michelson.run tester (balances, threshold) in\n      let expected_size = Test.Michelson.eval expected_size in\n      let () = Test.IO.log ("expected", expected_size) in\n      let () = Test.IO.log ("actual", size) in\n      Assert.assert (Test.Compare.eq size expected_size)\n    )\n    [(15tez,2n); (130tez,1n); (1200tez,0n)]\n'))),(0,s.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"test-ligo group=unit-remove-balance-complete","test-ligo":!0,group:"unit-remove-balance-complete"},'#include "./gitlab-pages/docs/testing/src/testing/remove-balance.jsligo"\n\nimport Test = Test.Next;\n\nconst test_remove_balance = (() => {\n  Test.State.reset(5n, [] as list <tez>);\n  const balances: balances =\n    Map.literal([[Test.Account.address(1n), 10tez],\n                 [Test.Account.address(2n), 100tez],\n                 [Test.Account.address(3n), 1000tez]]);\n  return List.iter(([threshold, expected_size]: [tez, nat]): unit => {\n      const tester = ([balances, threshold]: [balances, tez]): nat =>\n        Map.size (remove_balances_under (balances, threshold));\n      const size = Test.Michelson.run(tester, [balances, threshold]);\n      const expected_size_ = Test.Michelson.eval(expected_size);\n      Test.IO.log(["expected", expected_size]);\n      Test.IO.log(["actual", size]);\n      return (Assert.assert (Test.Compare.eq(size, expected_size_)))\n    },\n    list ([ [15tez, 2n], [130tez, 1n], [1200tez, 0n]]) );\n}) ()\n'))),(0,s.kt)("p",null,"You can now execute the test by running this command:"),(0,s.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},"ligo run test --library . gitlab-pages/docs/testing/src/testing/unit-remove-balance-mixed.mligo\n"))),(0,s.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},"ligo run test --library . gitlab-pages/docs/testing/src/testing/unit-remove-balance-mixed.jsligo\n"))),(0,s.kt)("p",null,"The response shows the expected and actual results of each test run:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},'# Outputs:\n# ("expected" , 2)\n# ("actual" , 2)\n# ("expected" , 1)\n# ("actual" , 1)\n# ("expected" , 0)\n# ("actual" , 0)\n# Everything at the top-level was executed.\n# - test exited with value ().\n')),(0,s.kt)("h2",{id:"testing-with-ligo-run-interpret"},"Testing with ",(0,s.kt)("inlineCode",{parentName:"h2"},"ligo run interpret")),(0,s.kt)("p",null,"The command ",(0,s.kt)("inlineCode",{parentName:"p"},"ligo run interpret")," interprets a LIGO expression in a\ncontext initialised by a source file. The interpretation is done using\nMichelson's interpreter."),(0,s.kt)("p",null,"For example, suppose you have a function that encodes input values into a specific format.\nThis function takes two input values and uses them as the key and value for an entry in a map:"),(0,s.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=interpret",group:"interpret"},"// This is interpret.mligo\ntype myDataType = (int, string) map\n\nlet encodeEntry (a : int) (b : string): myDataType =\n  Map.literal [(a, b)]\n"))),(0,s.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=interpret",group:"interpret"},"// This is interpret.jsligo\ntype myDataType = map<int, string>;\n\nconst encodeEntry = (a: int, b: string): myDataType => {\n  return Map.literal([[a, b]]);\n}\n"))),(0,s.kt)("p",null,"To encode values with this function, pass the LIGO expression to call the function to the ",(0,s.kt)("inlineCode",{parentName:"p"},"run interpret")," command and include the LIGO file in the ",(0,s.kt)("inlineCode",{parentName:"p"},"--init-file")," argument:"),(0,s.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},"ligo run interpret 'encodeEntry 5 \"hello\"' --init-file gitlab-pages/docs/testing/src/testing/interpret.mligo\n"))),(0,s.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},"ligo run interpret 'encodeEntry(5, \"hello\")' --init-file gitlab-pages/docs/testing/src/testing/interpret.jsligo\n"))),(0,s.kt)("p",null,"The response is the Michelson-encoded value of the output of the function:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-michelson"},'MAP_ADD(5 , "hello" , MAP_EMPTY())\n')),(0,s.kt)("p",null,"You can use the ",(0,s.kt)("inlineCode",{parentName:"p"},"run interpret")," command to interpret complex LIGO code and get the output in Michelson, such as formatting parameters for calls to entrypoints."),(0,s.kt)("p",null,"You can pass these arguments to set parameters for the interpretation:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"--amount"),": The amount of tez to send with the transaction; the default is 0"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"--balance"),": The amount of tez in the contract; the default is 0"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"--now"),": The current timestamp, such as ",(0,s.kt)("inlineCode",{parentName:"li"},"2000-01-01T10:10:10Z")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"--sender"),": The address for the sender of the transaction"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"--source"),": The address for the source of the transaction")),(0,s.kt)("h2",{id:"testing-with-ligo-run-dry-run"},"Testing with ",(0,s.kt)("inlineCode",{parentName:"h2"},"ligo run dry-run")),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"ligo run dry-run")," command runs the contract in a simulated\nenvironment. You can use it to test contracts with given parameters\nand storage values. You pass these arguments to the command:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"The contract file to run"),(0,s.kt)("li",{parentName:"ul"},"The parameter to pass to the contract, as a LIGO expression"),(0,s.kt)("li",{parentName:"ul"},"The value of the contract storage, as a LIGO expression")),(0,s.kt)("p",null,"For example, this contract stores a number and allows callers to\nincrement it by one:"),(0,s.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=dry-run-simple",group:"dry-run-simple"},"module Counter = struct\n  type storage_type = int\n  type return_type = operation list * storage_type\n\n  [@entry]\n  let main (_action: unit) (storage: storage_type): return_type =\n    [], storage + 1\nend\n")),(0,s.kt)("p",null,"This command tests the contract with the ",(0,s.kt)("inlineCode",{parentName:"p"},"run dry-run")," command:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"ligo run dry-run -m Counter gitlab-pages/docs/testing/src/testing/counter_simple.mligo 'unit' '4'\n")),(0,s.kt)("p",null,"The result shows the new value of the storage:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"( LIST_EMPTY() , 5 )\n"))),(0,s.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=dry-run-simple",group:"dry-run-simple"},"namespace Counter {\n  type storage_type = int;\n  type return_type = [list<operation>, storage_type];\n\n  @entry\n  const main = (_action: unit, storage: storage_type): return_type =>\n    [[], storage + 1]\n}\n")),(0,s.kt)("p",null,"This command tests the contract with the ",(0,s.kt)("inlineCode",{parentName:"p"},"run dry-run")," command:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"ligo run dry-run -m Counter gitlab-pages/docs/testing/src/testing/counter_simple.jsligo 'unit' '4'\n")),(0,s.kt)("p",null,"The result shows the new value of the storage:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"( LIST_EMPTY() , 5 )\n"))),(0,s.kt)("p",null,"For a more complicated example, this contract stores a map and\nprovides an entrypoint that updates elements in it:"),(0,s.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=dry-run-complex",group:"dry-run-complex"},"module MyContract = struct\n  type storage_type = (nat, string) map\n  type return_type = operation list * storage_type\n\n  [@entry]\n  let update (param: nat * string) (storage: storage_type): return_type =\n    let (index, value) = param in\n    let updated_map = Map.add index value storage in\n    [], updated_map\n\nend\n")),(0,s.kt)("p",null,"You can test the entrypoint and view the resulting operations and\nstorage by running this command, which uses an empty map of the same\ntype as the contract storage as the initial value of the storage:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"ligo run dry-run -m MyContract gitlab-pages/docs/testing/src/testing/dry-run-complex.mligo \\\n  'Update(1n, \"hi\")' \\\n  '(Map.empty : (nat, string) map)'\n"))),(0,s.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=dry-run-complex",group:"dry-run-complex"},"namespace MyContract {\n  type storage_type = map<nat, string>;\n  type return_type = [list<operation>, storage_type];\n\n  @entry\n  const update = (param: [nat, string], storage: storage_type): return_type => {\n    const [index, value] = param;\n    const updated_map = Map.add(index, value, storage);\n    return [[], updated_map];\n  }\n}\n")),(0,s.kt)("p",null,"You can test the entrypoint and view the resulting operations and\nstorage by running this command, which uses an empty map of the same\ntype as the contract storage as the initial value of the storage:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"ligo run dry-run -m MyContract gitlab-pages/docs/testing/src/testing/dry-run-complex.jsligo \\\n  'Update(1n, \"new value\")' \\\n  'Map.empty as map<nat, string>'\n"))),(0,s.kt)("p",null,"Note that the values of the parameter and the initial storage state\nare both LIGO expressions."),(0,s.kt)("p",null,"The result shows the empty list of operations and the new value of the\nstorage, expressed by adding elements to an empty map:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},'( LIST_EMPTY() , MAP_ADD(+1 , "new value" , MAP_EMPTY()) )\n')),(0,s.kt)("p",null,"You can pass these arguments to set parameters for the transaction:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"--amount"),": The amount of tez to send with the transaction; the default is 0"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"--balance"),": The amount of tez in the contract; the default is 0"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"--now"),": The current timestamp, such as ",(0,s.kt)("inlineCode",{parentName:"li"},"2000-01-01T10:10:10Z")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"--sender"),": The address for the sender of the transaction"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"--source"),": The address for the source of the transaction")))}d.isMDXComponent=!0}}]);