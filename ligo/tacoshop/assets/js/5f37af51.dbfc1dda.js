"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7307],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(n),m=a,g=u["".concat(l,".").concat(m)]||u[m]||d[m]||o;return n?r.createElement(g,i(i({ref:t},p),{},{components:n})):r.createElement(g,i({ref:t},p))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},48720:(e,t,n)=>{n.d(t,{D:()=>a.Z,Z:()=>o});var r=n(67294),a=n(75402);const o=function(e){return r.createElement(a.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:r.createElement(r.Fragment,null)}))}},64411:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var r=n(87462),a=(n(67294),n(3905)),o=n(48720);const i={id:"assigning",title:"Assigning"},s=void 0,l={unversionedId:"records/assigning",id:"version-1.6.0/records/assigning",title:"Assigning",description:"Given a record, it is a common design pattern to update only a small",source:"@site/versioned_docs/version-1.6.0/records/assigning.md",sourceDirName:"records",slug:"/records/assigning",permalink:"/previews/ligo/tacoshop/docs/1.6.0/records/assigning",draft:!1,tags:[],version:"1.6.0",frontMatter:{id:"assigning",title:"Assigning"},sidebar:"docs",previous:{title:"Accessing",permalink:"/previews/ligo/tacoshop/docs/1.6.0/records/accessing"},next:{title:"Declaring",permalink:"/previews/ligo/tacoshop/docs/1.6.0/sets/declaring"}},c={},p=[{value:"Nested updates",id:"nested-updates",level:2},{value:"Comparison",id:"comparison",level:2}],d={toc:p};function u(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Given a record, it is a common design pattern to update only a small\nnumber of its fields. Instead of forcing the programmer to copy the\nremaining, unchanged fields, CameLIGO offers a way to only update the\nfields that are modified."),(0,a.kt)("p",null,"One way to understand the update of records is the ",(0,a.kt)("em",{parentName:"p"},"functional\nupdate"),". The idea is to have an ",(0,a.kt)("em",{parentName:"p"},"expression")," whose value is the\nupdated record."),(0,a.kt)("p",null,"Let us consider defining a function that translates three-dimensional\npoints on a plane."),(0,a.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,a.kt)("p",null,"The syntax for the functional updates of record in CameLIGO follows\nthat of OCaml:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=record_update",group:"record_update"},"type point = {x : int; y : int; z : int}\ntype vector = {dx : int; dy : int}\n\nlet origin : point = {x = 0; y = 0; z = 0}\n\nlet xy_translate (p, vec : point * vector) : point =\n  {p with x = p.x + vec.dx; y = p.y + vec.dy}\n")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"It is important to understand that ",(0,a.kt)("inlineCode",{parentName:"p"},"p")," has not been changed by the\nfunctional update: a nameless new version of it has been created and\nreturned."))),(0,a.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,a.kt)("p",null,"The syntax for the functional updates is:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=record_update",group:"record_update"},"type point = {x: int, y: int, z: int}\ntype vector = {dx: int, dy: int}\n\nconst origin = {x: 0, y: 0, z: 0};\n\nconst xy_translate = (p: point, vec: vector) =>\n  ({...p, x: p.x + vec.dx, y: p.y + vec.dy});\n")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"It is important to understand that ",(0,a.kt)("inlineCode",{parentName:"p"},"p")," has not been changed by the\nfunctional update: a nameless new version of it has been created and\nreturned."))),(0,a.kt)("h2",{id:"nested-updates"},"Nested updates"),(0,a.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,a.kt)("p",null,"A unique feature of CameLIGO is the ability to perform nested updates\non records. For example, given the following record declarations:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=record_nested_update",group:"record_nested_update"},"type user = {\n  login : string;\n  name  : string\n}\n\ntype account = {\n  user     : user;\n  id       : int;\n  is_admin : bool\n}\n")),(0,a.kt)("p",null,"You can update the record ",(0,a.kt)("inlineCode",{parentName:"p"},"user")," nested inside ",(0,a.kt)("inlineCode",{parentName:"p"},"account")," with the\nfollowing code:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=record_nested_update",group:"record_nested_update"},"let change_login (login : string) (account : account) : account =\n  {account with user.login = login}\n")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Note: This is not possible in OCaml."))),(0,a.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,a.kt)("p",null,"JsLIGO does not support functional updates of nested records. For\nexample, if you have the following record declarations:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=record_nested_update",group:"record_nested_update"},"type user = {\n  login : string,\n  name  : string\n};\n\ntype account = {\n  user     : user,\n  id       : int,\n  is_admin : bool\n};\n")),(0,a.kt)("p",null,"You can update the record ",(0,a.kt)("inlineCode",{parentName:"p"},"user")," nested inside ",(0,a.kt)("inlineCode",{parentName:"p"},"account")," the long way:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=record_nested_update",group:"record_nested_update"},"const change_login = (login: string, account: account) : account =>\n  ({...account, user: {...account.user, login}});\n"))),(0,a.kt)("h2",{id:"comparison"},"Comparison"),(0,a.kt)("p",null,"Record types are comparable types, which means that their values can\nbe implicitly compared for equality, and records can be used as keys\nin ",(0,a.kt)("a",{parentName:"p",href:"/previews/ligo/tacoshop/docs/1.6.0/sets/declaring"},"sets")," or ",(0,a.kt)("a",{parentName:"p",href:"/previews/ligo/tacoshop/docs/1.6.0/maps/declaring"},"maps"),". By\ndefault, the implicit, total order over records is ",(0,a.kt)("strong",{parentName:"p"},"undefined and\nimplementation-dependent")," --- ultimately, the order is determined by\nthe translated Michelson type."),(0,a.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,a.kt)("p",null,"When using the ",(0,a.kt)("inlineCode",{parentName:"p"},'[@layout "comb"]')," (or ",(0,a.kt)("inlineCode",{parentName:"p"},"[@layout:comb]"),") attribute,\nfields are translated in Michelsom with their order as written in the\nsource code, and records are then ordered lexicographically (that is,\nwhen two fields of the same name have the same values, another field\nis compared, much rather like ordering two English words according to\nthe alphabet).")),(0,a.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,a.kt)("p",null,"When using the ",(0,a.kt)("inlineCode",{parentName:"p"},'@layout("comb")')," decorator, fields are translated in\nMichelsom with their order as written in the source code, and records\nare then ordered lexicographically (that is, when two fields of the\nsame name have the same values, another field is compared, much rather\nlike ordering two English words according to the alphabet).")))}u.isMDXComponent=!0}}]);