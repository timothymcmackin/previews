"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[92016],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>u});var r=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var p=r.createContext({}),s=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=s(e.components);return r.createElement(p.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,p=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=s(n),u=i,h=m["".concat(p,".").concat(u)]||m[u]||d[u]||a;return n?r.createElement(h,o(o({ref:t},c),{},{components:n})):r.createElement(h,o({ref:t},c))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,o=new Array(a);o[0]=m;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var s=2;s<a;s++)o[s]=n[s];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},48720:(e,t,n)=>{n.d(t,{D:()=>i.Z,Z:()=>a});var r=n(67294),i=n(75402);const a=function(e){return r.createElement(i.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:r.createElement(r.Fragment,null)}))}},23:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>m,frontMatter:()=>o,metadata:()=>p,toc:()=>c});var r=n(87462),i=(n(67294),n(3905)),a=n(48720);const o={id:"preprocessor",title:"Preprocessor"},l=void 0,p={unversionedId:"compiling/preprocessor",id:"compiling/preprocessor",title:"Preprocessor",description:"The preprocessor edits files before they go to the LIGO compiler.",source:"@site/../docs/compiling/preprocessor.md",sourceDirName:"compiling",slug:"/compiling/preprocessor",permalink:"/previews/ligo/tacoshop/docs/next/compiling/preprocessor",draft:!1,tags:[],version:"current",frontMatter:{id:"preprocessor",title:"Preprocessor"},sidebar:"docs",previous:{title:"Testing Michelson code",permalink:"/previews/ligo/tacoshop/docs/next/testing/michelson_testing"},next:{title:"Compiling contracts",permalink:"/previews/ligo/tacoshop/docs/next/compiling/"}},s={},c=[{value:"Viewing the preprocessor output",id:"viewing-the-preprocessor-output",level:2},{value:"Comments",id:"comments",level:2},{value:"String processing",id:"string-processing",level:2},{value:"Blank lines",id:"blank-lines",level:2},{value:"Linemarkers",id:"linemarkers",level:2},{value:"Directives",id:"directives",level:2},{value:"<code>#define</code> and <code>#undef</code>",id:"define-and-undef",level:3},{value:"<code>#error</code>",id:"error",level:3},{value:"<code>#if</code>, <code>#else</code>, <code>#elif</code>, and <code>#endif</code>",id:"if-else-elif-and-endif",level:3},{value:"<code>#import</code>",id:"import",level:3},{value:"<code>#include</code>",id:"include",level:3}],d={toc:c};function m(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The preprocessor edits files before they go to the LIGO compiler.\nYou can include commands called ",(0,i.kt)("em",{parentName:"p"},"preprocessor directives")," to instruct the preprocessor to make changes to a file before the compiler receives it, such as including or excluding code and importing code from other files."),(0,i.kt)("p",null,"Preprocessor directives can allow you to make changes to files before the compiler processes them.\nFor example, the following contract has three entrypoints, but one is between ",(0,i.kt)("inlineCode",{parentName:"p"},"#if")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"#endif")," directives.\nThe line ",(0,i.kt)("inlineCode",{parentName:"p"},"#if INCLUDE_RESET")," instructs the preprocessor to include the text between the directives (in this case, the third entrypoint) only if the ",(0,i.kt)("inlineCode",{parentName:"p"},"INCLUDE_RESET")," Boolean variable is set:"),(0,i.kt)(a.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=includereset",group:"includereset"},"module MyContract = struct\n  type storage = int\n  type result = operation list * storage\n\n  [@entry] let increment (delta : int) (storage : storage) : result = [],storage + delta\n\n  [@entry] let decrement (delta : int) (storage : storage) : result = [],storage - delta\n\n  #if INCLUDE_RESET\n  [@entry] let reset () (_storage : storage) : result = [], 0\n  #endif\nend\n"))),(0,i.kt)(a.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=includereset",group:"includereset"},"export namespace MyContract {\n  export type storage = int;\n  export type result = [list<operation>, storage];\n\n  @entry const increment = (delta : int, storage : storage) : result => [[], storage + delta];\n\n  @entry const decrement = (delta : int, storage : storage) : result => [[], storage - delta];\n\n  #if INCLUDE_RESET\n  @entry const reset = (_u : unit, _storage : storage) : result => [[], 0];\n  #endif\n}\n"))),(0,i.kt)(a.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"You can set these Boolean preprocessor variables with the ",(0,i.kt)("a",{parentName:"p",href:"#define-and-undef"},(0,i.kt)("inlineCode",{parentName:"a"},"#define"))," directive or by passing them to the ",(0,i.kt)("inlineCode",{parentName:"p"},"-D")," argument of the ",(0,i.kt)("inlineCode",{parentName:"p"},"ligo compile contract")," command.\nFor example, if the contract in the previous example is in a file named ",(0,i.kt)("inlineCode",{parentName:"p"},"mycontract.mligo"),", this command causes the preprocessor and compiler to output a contract with only two entrypoints:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"ligo compile contract mycontract.mligo\n")),(0,i.kt)("p",null,"This command passes the ",(0,i.kt)("inlineCode",{parentName:"p"},"INCLUDE_RESET")," Boolean variable to the preprocessor and causes the compiler to output a contract with three entrypoints:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"ligo compile contract -D INCLUDE_RESET mycontract.mligo\n"))),(0,i.kt)(a.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"You can set these Boolean preprocessor variables with the ",(0,i.kt)("a",{parentName:"p",href:"#define-and-undef"},(0,i.kt)("inlineCode",{parentName:"a"},"#define"))," directive or by passing them to the ",(0,i.kt)("inlineCode",{parentName:"p"},"-D")," argument of the ",(0,i.kt)("inlineCode",{parentName:"p"},"ligo compile contract")," command.\nFor example, if the contract in the previous example is in a file named ",(0,i.kt)("inlineCode",{parentName:"p"},"mycontract.jsligo"),", this command causes the preprocessor and compiler to output a contract with only two entrypoints:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"ligo compile contract mycontract.jsligo\n")),(0,i.kt)("p",null,"This command passes the ",(0,i.kt)("inlineCode",{parentName:"p"},"INCLUDE_RESET")," Boolean variable to the preprocessor and causes the compiler to output a contract with three entrypoints:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"ligo compile contract -D INCLUDE_RESET mycontract.jsligo\n"))),(0,i.kt)("h2",{id:"viewing-the-preprocessor-output"},"Viewing the preprocessor output"),(0,i.kt)("p",null,"It's rarely necessary to view the output of the preprocessor, but if you need to see the output to debug directives, you can view the output with the ",(0,i.kt)("inlineCode",{parentName:"p"},"ligo print preprocessed")," command, as in this example:"),(0,i.kt)(a.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"ligo print preprocessed myContract.mligo\n"))),(0,i.kt)(a.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"ligo print preprocessed myContract.jsligo\n"))),(0,i.kt)("h2",{id:"comments"},"Comments"),(0,i.kt)("p",null,"The preprocessor ignores directives that are in ",(0,i.kt)("a",{parentName:"p",href:"../syntax/comments"},"comments"),", which prevents problems where comments in your code contain text that looks like a directive.\nFor example, this code is valid because the preprocessor ignores the text ",(0,i.kt)("inlineCode",{parentName:"p"},"#endif")," in the comment:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"#if true\n // #endif\n#endif\n")),(0,i.kt)("p",null,"The preprocessor includes and excludes comments just like any other line of code."),(0,i.kt)("h2",{id:"string-processing"},"String processing"),(0,i.kt)("p",null,"The preprocessor ignores directives that are in strings, which prevents problems where strings in your code contain text that looks like a directive."),(0,i.kt)("p",null,"For example, this code includes a string with the text ",(0,i.kt)("inlineCode",{parentName:"p"},"#endif"),", but the preprocessor does not interpret this text as the ",(0,i.kt)("inlineCode",{parentName:"p"},"#endif")," directive:"),(0,i.kt)(a.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},'#if true\nlet textValue = "This string includes the text #endif"\n#endif\n'))),(0,i.kt)(a.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},'#if true\nconst textValue = "This string includes the text #endif";\n#endif\n'))),(0,i.kt)("h2",{id:"blank-lines"},"Blank lines"),(0,i.kt)("p",null,"When the preprocessor hides text, it includes a blank line consisting only of a newline character in place of the omitted line to keep line numbers in compiler errors consistent with the source file.\nSimilarly, it includes a blank line in place of each preprocessor directive.\nThese blank lines do not affect compilation."),(0,i.kt)("p",null,"For example, take this source file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"#if false\nThis is NOT copied to the output, except the newline character\n#endif\n")),(0,i.kt)("p",null,"The output that goes to the compiler from this source file is three blank lines plus the linemarker that indicates the start of the file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'# 1 "mySourceFile.txt"\n\n\n\n')),(0,i.kt)("h2",{id:"linemarkers"},"Linemarkers"),(0,i.kt)("p",null,"As in C-based languages, the LIGO preprocessor includes ",(0,i.kt)("a",{parentName:"p",href:"https://gcc.gnu.org/onlinedocs/cpp/Preprocessor-Output.html"},"linemarkers")," in files that it processes.\nFor example, if you include files with the ",(0,i.kt)("inlineCode",{parentName:"p"},"#include")," directive, the preprocessor inserts a line in the processed file to indicate where the included file starts and a line to indicate where the included file ends and the original file resumes."),(0,i.kt)("p",null,"The output begins with a linemarker that indicates the start of the original file that was sent to the preprocessor, in the format ",(0,i.kt)("inlineCode",{parentName:"p"},'# <line number> "<path to file>"'),".\nOther linemarkers follow the same format, adding the number ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," to indicate the start of an imported file and the number ",(0,i.kt)("inlineCode",{parentName:"p"},"2")," to indicate the end of the imported file and the resumption of the previous file."),(0,i.kt)("p",null,"The following example uses three files: ",(0,i.kt)("inlineCode",{parentName:"p"},"a.txt"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"b.txt"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"c.txt"),".\nFile A includes file B and file B includes file C."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Start of "a.txt"\n#include "b.txt"\nEnd of "a.txt"\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Start of "b.txt"\n#include "c.txt"\nEnd of "b.txt"\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Start of "c.txt"\nEnd of "c.txt"\n')),(0,i.kt)("p",null,"If you create these files and run the command ",(0,i.kt)("inlineCode",{parentName:"p"},"ligo print preprocessed --syntax cameligo a.txt"),", the output includes linemarkers that indicate where the files begin and end and the line number in the file that the preprocessor is on at the time:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'# 1 "a.txt"\nStart of "a.txt"\n\n# 1 "b.txt" 1\nStart of "b.txt"\n\n# 1 "c.txt" 1\nStart of "c.txt"\nEnd of "c.txt"\n# 3 "b.txt" 2\nEnd of "b.txt"\n# 3 "a.txt" 2\nEnd of "a.txt"\n')),(0,i.kt)("p",null,"The LIGO compiler ignores these linemarkers when it compiles the code."),(0,i.kt)("h2",{id:"directives"},"Directives"),(0,i.kt)("p",null,"These are the preprocessor directives that the LIGO preprocessor supports:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#define-and-undef"},(0,i.kt)("inlineCode",{parentName:"a"},"#define")," and ",(0,i.kt)("inlineCode",{parentName:"a"},"#undef"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#error"},(0,i.kt)("inlineCode",{parentName:"a"},"#error"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#if-else-elif-and-endif"},(0,i.kt)("inlineCode",{parentName:"a"},"#if"),", ",(0,i.kt)("inlineCode",{parentName:"a"},"#else"),", ",(0,i.kt)("inlineCode",{parentName:"a"},"#elif"),", and ",(0,i.kt)("inlineCode",{parentName:"a"},"#endif"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#import"},(0,i.kt)("inlineCode",{parentName:"a"},"#import"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#include"},(0,i.kt)("inlineCode",{parentName:"a"},"#include")))),(0,i.kt)("h3",{id:"define-and-undef"},(0,i.kt)("inlineCode",{parentName:"h3"},"#define")," and ",(0,i.kt)("inlineCode",{parentName:"h3"},"#undef")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"#define")," directive sets a Boolean variable (also known as a ",(0,i.kt)("em",{parentName:"p"},"symbol"),") to true, and the ",(0,i.kt)("inlineCode",{parentName:"p"},"#undef")," directive unsets it, which is equivalent to setting it to false."),(0,i.kt)("p",null,"You can use these variables with the ",(0,i.kt)("inlineCode",{parentName:"p"},"#if")," directive to show or hide text from the compiler, as in this example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"#define SYM\n\n#if SYM\nThis IS copied to the output because SYM is set.\n#else\nThis is NOT copied to the output, except the newline character.\n#endif\n")),(0,i.kt)("h3",{id:"error"},(0,i.kt)("inlineCode",{parentName:"h3"},"#error")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"#error")," directive forces the preprocessor to stop and emit an error.\nThis directive can help you catch problems in complex files.\nYou can include an error message, as in this example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"#error Not implemented/tested yet\n")),(0,i.kt)("h3",{id:"if-else-elif-and-endif"},(0,i.kt)("inlineCode",{parentName:"h3"},"#if"),", ",(0,i.kt)("inlineCode",{parentName:"h3"},"#else"),", ",(0,i.kt)("inlineCode",{parentName:"h3"},"#elif"),", and ",(0,i.kt)("inlineCode",{parentName:"h3"},"#endif")),(0,i.kt)("p",null,"These conditional directives allow you to include or exclude text conditionally.\nThey use a syntax similar to conditions in many other languages, starting with ",(0,i.kt)("inlineCode",{parentName:"p"},"#if")," and ending with ",(0,i.kt)("inlineCode",{parentName:"p"},"#endif"),".\nLogic between these two directives can also include:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"One ",(0,i.kt)("inlineCode",{parentName:"p"},"#else")," directive before ",(0,i.kt)("inlineCode",{parentName:"p"},"#endif"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"One or more ",(0,i.kt)("inlineCode",{parentName:"p"},"#elif")," directives as a shorthand for a\n",(0,i.kt)("inlineCode",{parentName:"p"},"#else")," immediately followed by an ",(0,i.kt)("inlineCode",{parentName:"p"},"#if")))),(0,i.kt)("p",null,"For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"#if CONDITION_A\nCONDITION_A is true\n#elif CONDITION_B\nCONDITION_B is true\n#else\nNeither A nor B are true\n#endif\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"#if")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"#elif")," directives support basic Boolean logic, including:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"||"),' for the disjunction ("or")'),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"&&"),' for the conjunction ("and")'),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"==")," for equality"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"!=")," for inequality"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"!")," for negation"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"(")," and ",(0,i.kt)("inlineCode",{parentName:"li"},")")," around expressions to specify order of operations")),(0,i.kt)("p",null,"For real-world examples of this logic, see ",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.com/dexter2tz/dexter2tz/-/blob/febd360cf6df6e090dedbf21b27538681246f980/dexter.mligo#L52"},"Dexter"),".\nIn one section, it uses different record types depending on the version of the FA standard in use (see ",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.com/dexter2tz/dexter2tz/-/blob/febd360cf6df6e090dedbf21b27538681246f980/dexter.mligo#L84"},(0,i.kt)("inlineCode",{parentName:"a"},"dexter.mligo")," line 84"),"):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo"},"type storage =\n  [@layout:comb]\n  { tokenPool : nat ;\n    xtzPool : tez ;\n    lqtTotal : nat ;\n    selfIsUpdatingTokenPool : bool ;\n    freezeBaker : bool ;\n    manager : address ;\n    tokenAddress : address ;\n#if FA2\n    tokenId : nat ;\n#endif\n    lqtAddress : address ;\n  }\n")),(0,i.kt)("h3",{id:"import"},(0,i.kt)("inlineCode",{parentName:"h3"},"#import")),(0,i.kt)(a.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"#import")," directive prompts the preprocessor to include another file as a ",(0,i.kt)("a",{parentName:"p",href:"../syntax/modules"},"module")," in the current file."),(0,i.kt)("p",null,"For example, you can create a file with related type definitions, as in this example file named ",(0,i.kt)("inlineCode",{parentName:"p"},"euro.mligo"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=euro",group:"euro"},"type t = nat\n\nlet add (a, b : t * t) : t = a + b\n\nlet one : t = 1n\nlet two : t = 2n\n")),(0,i.kt)("p",null,"In another file, you can import this file, assign it the module ",(0,i.kt)("inlineCode",{parentName:"p"},"Euro"),", and use its definitions:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=main_importer",group:"main_importer"},'#import "gitlab-pages/docs/compiling/src/preprocessor/euro.mligo" "Euro"\n\ntype storage = Euro.t\n\nlet tip (s : storage) : storage = Euro.add (s, Euro.one)\n')),(0,i.kt)("p",null,"For more information, see ",(0,i.kt)("a",{parentName:"p",href:"../syntax/modules"},"Modules"),".")),(0,i.kt)(a.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"#import")," directive prompts the preprocessor to include another file as a ",(0,i.kt)("a",{parentName:"p",href:"../syntax/modules"},"namespace")," in the current file."),(0,i.kt)("p",null,"For example, you can create a file with related type definitions, as in this example file named ",(0,i.kt)("inlineCode",{parentName:"p"},"euro.jsligo"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=euro",group:"euro"},"export type t = nat;\n\nexport const add = (a: t, b: t): t => a + b;\n\nexport const one: t = 1n;\nexport const two: t = 2n;\n")),(0,i.kt)("p",null,"In another file, you can import this file, assign it the namespace ",(0,i.kt)("inlineCode",{parentName:"p"},"Euro"),", and use its definitions:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=main_importer",group:"main_importer"},'#import "gitlab-pages/docs/compiling/src/preprocessor/euro.jsligo" "Euro"\n\ntype storage = Euro.t;\n\nconst tip = (s : storage) : storage =>\n  Euro.add (s, Euro.one);\n')),(0,i.kt)("p",null,"When you import a file with the ",(0,i.kt)("inlineCode",{parentName:"p"},"#import")," directive, LIGO packages the file as a namespace.\nTherefore, any namespaces in the file are sub-namespaces of that namespace."),(0,i.kt)("p",null,"However, the namespace does not export those sub-namespaces automatically.\nAs a result, if you import a file that contains namespaces, those namespaces are not accessible."),(0,i.kt)("p",null,"To work around this limitation, add the ",(0,i.kt)("inlineCode",{parentName:"p"},"@public")," decorator to the namespaces in the file.\nFor example, this file defines the Euro type as a namespace with the ",(0,i.kt)("inlineCode",{parentName:"p"},"@public")," decorator:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=euro_namespace_public",group:"euro_namespace_public"},"// This file is gitlab-pages/docs/preprocessor/src/import/euro_namespace_public.jsligo\n\n@public\nnamespace Euro {\n  export type t = nat;\n  export const add = (a: t, b: t) : t => a + b;\n  export const one: t = 1n;\n  export const two: t = 2n;\n};\n")),(0,i.kt)("p",null,"Because the namespace is public, you can access it as a sub-namespace when you import the file into another file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=import_euro_public",group:"import_euro_public"},'#import "gitlab-pages/docs/compiling/src/preprocessor/euro_namespace_public.jsligo" "Euro_import"\n\ntype euro_balance = Euro_import.Euro.t;\n\nconst add_tip = (s: euro_balance): euro_balance =>\n  Euro_import.Euro.add(s, Euro_import.Euro.one);\n')),(0,i.kt)("p",null,"For more information, see ",(0,i.kt)("a",{parentName:"p",href:"../syntax/modules"},"Namespaces"),".")),(0,i.kt)("h3",{id:"include"},(0,i.kt)("inlineCode",{parentName:"h3"},"#include")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"#include")," directive includes the entire text contents of the specified file, as in this example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'#include "path/to/standard_1.ligo"\n')),(0,i.kt)(a.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"Unlike the ",(0,i.kt)("inlineCode",{parentName:"p"},"#import")," directive, the ",(0,i.kt)("inlineCode",{parentName:"p"},"#include")," directive does not package the included file as a module.")),(0,i.kt)(a.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"Unlike the ",(0,i.kt)("inlineCode",{parentName:"p"},"#import")," directive, the ",(0,i.kt)("inlineCode",{parentName:"p"},"#include")," directive does not package the included file as a namespace.")))}m.isMDXComponent=!0}}]);