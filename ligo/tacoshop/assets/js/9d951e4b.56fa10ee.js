"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[34396],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>m});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),c=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},d=function(e){var n=c(e.components);return a.createElement(l.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=c(t),m=r,g=u["".concat(l,".").concat(m)]||u[m]||p[m]||o;return t?a.createElement(g,i(i({ref:n},d),{},{components:t})):a.createElement(g,i({ref:n},d))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=u;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=t[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},48720:(e,n,t)=>{t.d(n,{D:()=>r.Z,Z:()=>o});var a=t(67294),r=t(75402);const o=function(e){return a.createElement(r.Z.Consumer,null,(n=>{let{syntax:t}=n;return t===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},86530:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>d});var a=t(87462),r=(t(67294),t(3905)),o=t(48720);const i={title:"Records"},s=void 0,l={unversionedId:"data-types/records",id:"version-1.9.2/data-types/records",title:"Records",description:"So far, we have seen relatively simple data types. LIGO also offers",source:"@site/versioned_docs/version-1.9.2/data-types/records.md",sourceDirName:"data-types",slug:"/data-types/records",permalink:"/previews/ligo/tacoshop/docs/data-types/records",draft:!1,tags:[],version:"1.9.2",frontMatter:{title:"Records"},sidebar:"docs",previous:{title:"Lists",permalink:"/previews/ligo/tacoshop/docs/data-types/lists"},next:{title:"Sets",permalink:"/previews/ligo/tacoshop/docs/data-types/sets"}},c={},d=[{value:"Accessing",id:"accessing",level:2},{value:"Assigning",id:"assigning",level:2},{value:"Nested updates",id:"nested-updates",level:3},{value:"Comparing",id:"comparing",level:2}],p={toc:d};function u(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"So far, we have seen relatively simple data types. LIGO also offers\nmore complex built-in constructs, such as ",(0,r.kt)("em",{parentName:"p"},"records"),"."),(0,r.kt)("p",null,"Records are one-way data of different types can be packed into a\nsingle type. A record is made of a set of ",(0,r.kt)("em",{parentName:"p"},"fields"),", which are made of\na ",(0,r.kt)("em",{parentName:"p"},"field name")," and a ",(0,r.kt)("em",{parentName:"p"},"field type"),'. Given a record, the value bound to\na field is accessed by giving its name to the selection operator\n"',(0,r.kt)("inlineCode",{parentName:"p"},"."),'".'),(0,r.kt)("p",null,"Let us first consider an example of record type declaration."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=records1",group:"records1"},"type user = {\n  id       : nat;\n  is_admin : bool;\n  name     : string\n}\n"))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=records1",group:"records1"},"type user = {\n  id       : nat,\n  is_admin : bool,\n  name     : string\n};\n"))),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("p",null,"And here is how a record value is defined:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=records1",group:"records1"},'let alice : user = {\n  id       = 1n;\n  is_admin = true;\n  name     = "Alice"\n}\n'))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("p",null,"And here is how a record value is defined:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=records1",group:"records1"},'const alice : user = {\n  id       : 1n,\n  is_admin : true,\n  name     : "Alice"\n};\n')),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note: A semicolon ",(0,r.kt)("inlineCode",{parentName:"p"},";")," can also separate fields instead of a\ncomma."))),(0,r.kt)("h2",{id:"accessing"},"Accessing"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("p",null,'If we want the contents of a given field, we use the selection operator\n"',(0,r.kt)("inlineCode",{parentName:"p"},"."),'", like so:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=record_access",group:"record_access"},'type user = {\n  login : string;\n  name  : string\n}\n\ntype account = {\n  user     : user;\n  id       : int;\n  is_admin : bool\n}\n\nlet user : user = {login = "al"; name = "Alice"}\nlet alice : account = {user; id=5; is_admin = true}\nlet is_alice_admin : bool = alice.is_admin // = true\n'))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("p",null,'If we want to access a field, we use the selection operator "',(0,r.kt)("inlineCode",{parentName:"p"},"."),'"\nfollowed by the field name, like so:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=record_access",group:"record_access"},'type user = {\n  login : string,\n  name  : string\n};\n\ntype account = {\n  user     : user,\n  id       : int,\n  is_admin : bool\n};\n\nconst user : user = {login: "al", name: "Alice"};\nconst alice : account = {user, id: 5, is_admin: true};\nconst is_alice_admin = alice.is_admin; // == true\n')),(0,r.kt)("p",null,"Instead of the field name, we can provide between square brackets a\nstring that contains the field name, or an integer that is the index\nof the field in the record declaration:")),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("p",null,"We can also access fields of a record using a destructuring syntax,\nknown as ",(0,r.kt)("em",{parentName:"p"},"pattern matching"),", which enables accessing multiple fields of\na record in parallel, like so:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=record_access",group:"record_access"},"let user_to_triple (a : account) =\n  let {user; id; is_admin} = a\n  in user, id, is_admin\n"))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("p",null,"We can also access fields of a record using the destructuring\nsyntax, known as ",(0,r.kt)("em",{parentName:"p"},"pattern matching"),", which allows accessing multiple\nfields of a record in parallel, like so:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=record_access",group:"record_access"},"function userToTuple (a : account) {\n  const {user, id, is_admin} = a;\n  return [user, id, is_admin];\n}\n"))),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("p",null,"If we do not use some of the fields we matched, we assign them the\nspecial variable ",(0,r.kt)("inlineCode",{parentName:"p"},"_"),", to avoid triggering a warning about an unused\nvariable, like so:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=record_access",group:"record_access"},"let get_id (a : account) =\n  let {user=_; id; is_admin=_} = a // To avoid a warning\n  in id\n"))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("p",null,"We can ignore some fields by calling the predefined function\n",(0,r.kt)("inlineCode",{parentName:"p"},"ignore")," on them, like so:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=record_access",group:"record_access"},"function getId (a : account) {\n  let {user, id, is_admin} = a;\n  ignore([user, is_admin]); // To avoid a warning\n  return id;\n}\n"))),(0,r.kt)("h2",{id:"assigning"},"Assigning"),(0,r.kt)("p",null,"Given a record, it is a common design pattern to update only a small\nnumber of its fields. Instead of forcing the programmer to copy the\nremaining, unchanged fields, CameLIGO offers a way to only update the\nfields that are modified."),(0,r.kt)("p",null,"One way to understand the update of records is the ",(0,r.kt)("em",{parentName:"p"},"functional\nupdate"),". The idea is to have an ",(0,r.kt)("em",{parentName:"p"},"expression")," whose value is the\nupdated record."),(0,r.kt)("p",null,"Let us consider defining a function that translates three-dimensional\npoints on a plane."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("p",null,"The syntax for the functional updates of record in CameLIGO follows\nthat of OCaml:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=record_update",group:"record_update"},"type point = {x : int; y : int; z : int}\ntype vector = {dx : int; dy : int}\n\nlet origin : point = {x = 0; y = 0; z = 0}\n\nlet xy_translate (p, vec : point * vector) : point =\n  {p with x = p.x + vec.dx; y = p.y + vec.dy}\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"It is important to understand that ",(0,r.kt)("inlineCode",{parentName:"p"},"p")," has not been changed by the\nfunctional update: a nameless new version of it has been created and\nreturned."))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("p",null,"The syntax for the functional updates is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=record_update",group:"record_update"},"type point = {x: int, y: int, z: int}\ntype vector = {dx: int, dy: int}\n\nconst origin = {x: 0, y: 0, z: 0};\n\nconst xy_translate = (p: point, vec: vector) =>\n  ({...p, x: p.x + vec.dx, y: p.y + vec.dy});\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"It is important to understand that ",(0,r.kt)("inlineCode",{parentName:"p"},"p")," has not been changed by the\nfunctional update: a nameless new version of it has been created and\nreturned."))),(0,r.kt)("h3",{id:"nested-updates"},"Nested updates"),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("p",null,"A unique feature of CameLIGO is the ability to perform nested updates\non records. For example, given the following record declarations:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=record_nested_update",group:"record_nested_update"},"type user = {\n  login : string;\n  name  : string\n}\n\ntype account = {\n  user     : user;\n  id       : int;\n  is_admin : bool\n}\n")),(0,r.kt)("p",null,"You can update the record ",(0,r.kt)("inlineCode",{parentName:"p"},"user")," nested inside ",(0,r.kt)("inlineCode",{parentName:"p"},"account")," with the\nfollowing code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=record_nested_update",group:"record_nested_update"},"let change_login (login : string) (account : account) : account =\n  {account with user.login = login}\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note: This is not possible in OCaml."))),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("p",null,"JsLIGO does not support functional updates of nested records. For\nexample, if you have the following record declarations:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=record_nested_update",group:"record_nested_update"},"type user = {\n  login : string,\n  name  : string\n};\n\ntype account = {\n  user     : user,\n  id       : int,\n  is_admin : bool\n};\n")),(0,r.kt)("p",null,"You can update the record ",(0,r.kt)("inlineCode",{parentName:"p"},"user")," nested inside ",(0,r.kt)("inlineCode",{parentName:"p"},"account")," the long way:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=record_nested_update",group:"record_nested_update"},"const change_login = (login: string, account: account) : account =>\n  ({...account, user: {...account.user, login}});\n"))),(0,r.kt)("h2",{id:"comparing"},"Comparing"),(0,r.kt)("p",null,"Record types are comparable types, which means that their values can\nbe implicitly compared for equality, and records can be used as keys\nin ",(0,r.kt)("a",{parentName:"p",href:"/previews/ligo/tacoshop/docs/data-types/sets"},"sets")," or ",(0,r.kt)("a",{parentName:"p",href:"/previews/ligo/tacoshop/docs/data-types/maps"},"maps"),". By\ndefault, the implicit, total order over records is ",(0,r.kt)("strong",{parentName:"p"},"undefined and\nimplementation-dependent")," --- ultimately, the order is determined by\nthe translated Michelson type."),(0,r.kt)(o.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,r.kt)("p",null,"When using the ",(0,r.kt)("inlineCode",{parentName:"p"},'[@layout "comb"]')," (or ",(0,r.kt)("inlineCode",{parentName:"p"},"[@layout:comb]"),") attribute,\nfields are translated in Michelsom with their order as written in the\nsource code, and records are then ordered lexicographically (that is,\nwhen two fields of the same name have the same values, another field\nis compared, much rather like ordering two English words according to\nthe alphabet).")),(0,r.kt)(o.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,r.kt)("p",null,"When using the ",(0,r.kt)("inlineCode",{parentName:"p"},'@layout("comb")')," decorator, fields are translated in\nMichelsom with their order as written in the source code, and records\nare then ordered lexicographically (that is, when two fields of the\nsame name have the same values, another field is compared, much rather\nlike ordering two English words according to the alphabet).")))}u.isMDXComponent=!0}}]);