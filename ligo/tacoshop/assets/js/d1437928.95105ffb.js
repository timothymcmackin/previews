"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[94018],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=p(n),m=i,h=c["".concat(l,".").concat(m)]||c[m]||d[m]||r;return n?a.createElement(h,o(o({ref:t},u),{},{components:n})):a.createElement(h,o({ref:t},u))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},48720:(e,t,n)=>{n.d(t,{D:()=>i.Z,Z:()=>r});var a=n(67294),i=n(75402);const r=function(e){return a.createElement(i.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},61430:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>s,default:()=>c,frontMatter:()=>o,metadata:()=>l,toc:()=>u});var a=n(87462),i=(n(67294),n(3905)),r=n(48720);const o={id:"signatures",title:"Signatures",jsligoTitle:"Interfaces"},s=void 0,l={unversionedId:"syntax/signatures",id:"syntax/signatures",title:"Signatures",description:"A signature is a list of types and values that you can apply to a module.",source:"@site/../docs/syntax/signatures.md",sourceDirName:"syntax",slug:"/syntax/signatures",permalink:"/previews/ligo/tacoshop/docs/next/syntax/signatures",draft:!1,tags:[],version:"current",frontMatter:{id:"signatures",title:"Signatures",jsligoTitle:"Interfaces"},sidebar:"docs",previous:{title:"Attributes",permalink:"/previews/ligo/tacoshop/docs/next/syntax/decorators"},next:{title:"Keywords",permalink:"/previews/ligo/tacoshop/docs/next/syntax/keywords"}},p={},u=[{value:"Extending signatures",id:"extending-signatures",level:2},{value:"Extending interfaces",id:"extending-interfaces",level:2}],d={toc:u};function c(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("p",null,"A signature is a list of types and values that you can apply to a module.\nWhen you apply a signature to a module, that module must have all of the types and values in the signature and no types or values that are not in the signature.\nThe LIGO compiler warns you of any mismatches between the signature and the module."),(0,i.kt)("p",null,"As in OCaml, to create a signature, use the keywords ",(0,i.kt)("inlineCode",{parentName:"p"},"module type")," and list the types and values between the keywords ",(0,i.kt)("inlineCode",{parentName:"p"},"sig")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"end"),".\nFor example, the following signature specifies that a module must have these contents:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A type named ",(0,i.kt)("inlineCode",{parentName:"li"},"t"),", although the data type of that type is not specified, which makes it an ",(0,i.kt)("em",{parentName:"li"},"abstract type")),(0,i.kt)("li",{parentName:"ul"},"A function named ",(0,i.kt)("inlineCode",{parentName:"li"},"add"),", which accepts two values of type ",(0,i.kt)("inlineCode",{parentName:"li"},"t")," and returns a value of type ",(0,i.kt)("inlineCode",{parentName:"li"},"t")),(0,i.kt)("li",{parentName:"ul"},"Values ",(0,i.kt)("inlineCode",{parentName:"li"},"one")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"two"),", which are of the type ",(0,i.kt)("inlineCode",{parentName:"li"},"t"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=sig_declaring",group:"sig_declaring"},"module type Euro_SIG =\n  sig\n    type t\n    val add : t * t -> t\n    val one : t\n    val two : t\n  end\n")),(0,i.kt)("p",null,"To apply a signature to a module, put the name of the signature after a colon and the module name, as in the following example.\nThis module defines the type ",(0,i.kt)("inlineCode",{parentName:"p"},"t")," as a nat and defines the ",(0,i.kt)("inlineCode",{parentName:"p"},"add")," function and the ",(0,i.kt)("inlineCode",{parentName:"p"},"one")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"two")," values:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=sig_declaring",group:"sig_declaring"},"module Euro : Euro_SIG =\n  struct\n    type t = nat\n    let add (a, b : t * t) = a + b\n    let one : t = 1n\n    let two : t = 2n\n  end\n")),(0,i.kt)("p",null,"The module must instantiate any abstract type in the signature, as this module defines the abstract type ",(0,i.kt)("inlineCode",{parentName:"p"},"t")," as a nat.")),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("p",null,"An interface is a list of types and values that you can apply to a namespace.\nWhen you apply an interface to a namespace, that namespace must have all of the types and values in the interface.\nThe namespace can also have additional definitions that are not in the interface.\nThe LIGO compiler warns you of any mismatches between the interface and the namespace."),(0,i.kt)("p",null,"For example, the following interface specifies that a namespace must have these contents:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A type named ",(0,i.kt)("inlineCode",{parentName:"li"},"t"),", although the data type of that type is not specified, which makes it an ",(0,i.kt)("em",{parentName:"li"},"abstract type")),(0,i.kt)("li",{parentName:"ul"},"A function named ",(0,i.kt)("inlineCode",{parentName:"li"},"add"),", which accepts two values of type ",(0,i.kt)("inlineCode",{parentName:"li"},"t")," and returns a value of type ",(0,i.kt)("inlineCode",{parentName:"li"},"t")),(0,i.kt)("li",{parentName:"ul"},"Values ",(0,i.kt)("inlineCode",{parentName:"li"},"one")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"two"),", which are of the type ",(0,i.kt)("inlineCode",{parentName:"li"},"t"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=intf_declaring",group:"intf_declaring"},"interface Euro_INTF {\n  type t;\n  const add: (a: t, b: t) => t;\n  const one: t;\n  const two: t;\n};\n")),(0,i.kt)("p",null,"To apply an interface to a namespace, put the name of the interface after the keyword ",(0,i.kt)("inlineCode",{parentName:"p"},"implements")," and the namespace name, as in the following example.\nIt's said that the namespace ",(0,i.kt)("em",{parentName:"p"},"implements")," the interface.\nThis namespace defines the type ",(0,i.kt)("inlineCode",{parentName:"p"},"t")," as a nat and defines the ",(0,i.kt)("inlineCode",{parentName:"p"},"add")," function and the ",(0,i.kt)("inlineCode",{parentName:"p"},"one")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"two")," values.\nIt also adds a function named ",(0,i.kt)("inlineCode",{parentName:"p"},"multiply")," that is not specified in the interface:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=intf_declaring",group:"intf_declaring"},"namespace Euro implements Euro_INTF {\n  export type t = nat; // No more abstract\n  export const add = (a: t, b: t): t => a + b;\n  export const one: t = 1n;\n  export const two: t = 2n;\n  export const multiply = (a: t, b: t): t=> a * b;\n};\n")),(0,i.kt)("p",null,"The namespace must instantiate any abstract type in the interface, as this namespace defines the abstract type ",(0,i.kt)("inlineCode",{parentName:"p"},"t")," as a nat.")),(0,i.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,i.kt)("h2",{id:"extending-signatures"},"Extending signatures"),(0,i.kt)("p",null,"Like modules, you can extend signatures by including other signatures in them, as in this example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=sig_including",group:"sig_including"},"module type Euro_SIG =\n  sig\n    type t\n    val add : t * t -> t\n    val one : t\n    val two : t\n  end\n\nmodule type NewEuro_SIG =\n  sig\n    include Euro_SIG\n    val ten : t\n  end\n")),(0,i.kt)("p",null,"Note that the type ",(0,i.kt)("inlineCode",{parentName:"p"},"t")," remains abstract in both signatures.\nModules that use either signature must instantiate the type.")),(0,i.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,i.kt)("h2",{id:"extending-interfaces"},"Extending interfaces"),(0,i.kt)("p",null,"Interfaces can be extended by inheritance with the ",(0,i.kt)("inlineCode",{parentName:"p"},"extends")," keyword, as in this example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=intf_extending",group:"intf_extending"},"interface Euro_INTF {\n  type t;\n  const add: (a: t, b: t) => t;\n  const one: t;\n  const two: t;\n};\n\ninterface WithTenEuro_INTF extends Euro_INTF {\n  const ten: t;\n};\n\ninterface WithFiftyEuro_INTF extends Euro_INTF {\n  const fifty: t;\n};\n")),(0,i.kt)("p",null,"Note that the type ",(0,i.kt)("inlineCode",{parentName:"p"},"t")," remains abstract in all of the interfaces.\nNamespaces that use any of these interfaces must instantiate the type."),(0,i.kt)("p",null,"Interfaces can extend more than one interface, which can lead to an interface that extends a base interface more than once, known as ",(0,i.kt)("em",{parentName:"p"},"diamond inheritance"),".\nFor example, the following interface extends two interfaces from the previous example.\nBecause both of these interfaces extend the same base interface, it is as if the interface extends the base interface twice.\nDiamond inheritance doesn't cause any problems for the interface."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=intf_extending",group:"intf_extending"},"interface NewEuro_INTF\n  extends WithTenEuro_INTF, WithFiftyEuro_INTF {\n  const hundred: t;\n  const five_hundred?: t;\n};\n")),(0,i.kt)("p",null,"Interfaces can have optional types and values indicated with a question mark ",(0,i.kt)("inlineCode",{parentName:"p"},"?"),".\nIn the previous example, the interface ",(0,i.kt)("inlineCode",{parentName:"p"},"NewEuro_INTF")," has an optional value ",(0,i.kt)("inlineCode",{parentName:"p"},"five_hundred"),".\nThis namespace defines this optional value and adds a value named ",(0,i.kt)("inlineCode",{parentName:"p"},"twenty")," that is not defined in the ",(0,i.kt)("inlineCode",{parentName:"p"},"NewEuro_INTF")," interface:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=intf_extending",group:"intf_extending"},"namespace NewEuro implements NewEuro_INTF {\n  export type t = int;\n\n  export const add = (a: t, b: t) => a + b;\n\n  export const one: t = 1;\n  export const two: t = 2;\n  export const ten: t = 10;\n  export const fifty: t = 50;\n  export const hundred: t = 100;\n  export const five_hundred: t = 500; // Could be omitted\n  const twenty: t = 20; // Extra new constant\n}\n"))))}c.isMDXComponent=!0}}]);