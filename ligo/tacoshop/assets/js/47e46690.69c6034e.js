"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[73718],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var a=n(67294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},y={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},g=a.forwardRef((function(e,t){var n=e.components,s=e.mdxType,r=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),g=p(n),m=s,u=g["".concat(l,".").concat(m)]||g[m]||y[m]||r;return n?a.createElement(u,i(i({ref:t},c),{},{components:n})):a.createElement(u,i({ref:t},c))}));function m(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var r=n.length,i=new Array(r);i[0]=g;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:s,i[1]=o;for(var p=2;p<r;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}g.displayName="MDXCreateElement"},48720:(e,t,n)=>{n.d(t,{D:()=>s.Z,Z:()=>r});var a=n(67294),s=n(75402);const r=function(e){return a.createElement(s.Z.Consumer,null,(t=>{let{syntax:n}=t;return n===e.syntax?e.children:a.createElement(a.Fragment,null)}))}},53676:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>g,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var a=n(87462),s=(n(67294),n(3905)),r=n(48720);const i={id:"bytes",title:"Bytes"},o=void 0,l={unversionedId:"data-types/bytes",id:"data-types/bytes",title:"Bytes",description:"Bytes are used for serializing data, for example to compute signature",source:"@site/../docs/data-types/bytes.md",sourceDirName:"data-types",slug:"/data-types/bytes",permalink:"/previews/ligo/tacoshop/docs/next/data-types/bytes",draft:!1,tags:[],version:"current",frontMatter:{id:"bytes",title:"Bytes"},sidebar:"docs",previous:{title:"Timestamps",permalink:"/previews/ligo/tacoshop/docs/next/data-types/timestamp"},next:{title:"Tuples",permalink:"/previews/ligo/tacoshop/docs/next/data-types/tuples"}},p={},c=[{value:"Literals",id:"literals",level:2},{value:"From numbers to bytes and back",id:"from-numbers-to-bytes-and-back",level:2},{value:"From strings",id:"from-strings",level:2},{value:"Concatenating",id:"concatenating",level:2},{value:"Sizing",id:"sizing",level:2},{value:"Slicing",id:"slicing",level:2},{value:"Bitwise operations",id:"bitwise-operations",level:2},{value:"Packing and unpacking",id:"packing-and-unpacking",level:2},{value:"Cryptography",id:"cryptography",level:2}],y={toc:c};function g(e){let{components:t,...n}=e;return(0,s.kt)("wrapper",(0,a.Z)({},y,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Bytes are used for serializing data, for example to compute signature\nhashes. Conversely, they can be used to deserialise external data, in\nwhich case the expected LIGO type needs to be specified."),(0,s.kt)("h2",{id:"literals"},"Literals"),(0,s.kt)("p",null,"Byte literals are sequences of bytes (eight-bit values, also known as\n",(0,s.kt)("em",{parentName:"p"},"octets"),"), defined using the prefix ",(0,s.kt)("inlineCode",{parentName:"p"},"0x")," followed by hexadecimal\ndigits, or none if the denoted literal is zero:"),(0,s.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=bytes",group:"bytes"},"let a : bytes = 0x70FF\nlet zero : bytes = 0x\nlet zero_too = 0x00\n"))),(0,s.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=bytes",group:"bytes"},"const a : bytes = 0x70FF;\nconst zero : bytes = 0x;\nconst zero_too = 0x00;\n"))),(0,s.kt)("p",null,"Clearly, this means that literal bytes are always comprised of an even\nnumber of hexadecimal digits (because one hexadecimal digit requires\nup to four bits in binary, and eight are needed to make up a byte)."),(0,s.kt)("h2",{id:"from-numbers-to-bytes-and-back"},"From numbers to bytes and back"),(0,s.kt)("p",null,"Some other numerals can be converted to bytes by means of calling the\npredefined function ",(0,s.kt)("inlineCode",{parentName:"p"},"bytes"),", which is overloaded. The reverse\nconversion is done by the predefined functions ",(0,s.kt)("inlineCode",{parentName:"p"},"int")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"nat"),". For\ninstance, here how to create bytes from natural numbers and integers:"),(0,s.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=bytes",group:"bytes"},"let b : bytes = bytes 123n   // 7B in hexadecimal\nlet c : bytes = bytes 123\nlet d : bytes = bytes (-123) // Two's complement\n\nlet n : nat = nat 0x7B // n = 123n\nlet i : int = int 0x7B // i = 123\n"))),(0,s.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=bytes",group:"bytes"},"const b: bytes = bytes(123n); // 7B in hexadecimal\nconst c: bytes = bytes(123);\nconst d: bytes = bytes(-123); // Two's complement\n\nconst n: nat = nat(0x7B); // n == 123n\nconst i: int = int(0x7B); // i == 123\n"))),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"Note: See\n",(0,s.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Two's_complement"},"Two's complement"),".")),(0,s.kt)("h2",{id:"from-strings"},"From strings"),(0,s.kt)("p",null,"A string literal can be converted to bytes in two ways:"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"by interpreting the ",(0,s.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/ASCII"},"ASCII"),"\ncode of each character (which spans over two hexadecimal digits) as\none byte;"),(0,s.kt)("li",{parentName:"ol"},"by interpreting directly each character as one hexadecimal digit.")),(0,s.kt)("p",null,"In the former case, the syntax is somewhat odd -- as opposed to simply\ncalling the function ",(0,s.kt)("inlineCode",{parentName:"p"},"bytes"),":"),(0,s.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=bytes",group:"bytes"},'let from_ascii : bytes = [%bytes "foo"]\n'))),(0,s.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=bytes",group:"bytes"},"const from_ascii: bytes = bytes`foo`; // Not a call\n"))),(0,s.kt)("p",null,"The latter case is implemented as a type cast:"),(0,s.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=bytes",group:"bytes"},'// raw = from_ascii\nlet raw : bytes = ("666f6f" : bytes)\n')),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"Note that both the ",(0,s.kt)("inlineCode",{parentName:"p"},"[%bytes ...]")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"(... : bytes)")," syntaxes apply\nonly to ",(0,s.kt)("em",{parentName:"p"},"string literals"),", not general expressions of type\n",(0,s.kt)("inlineCode",{parentName:"p"},"string"),". In other words, the contents of the strings must be\navailable in-place at compile-time. (This actually reveals that\n",(0,s.kt)("inlineCode",{parentName:"p"},'("666f6f" : bytes)')," is not really a cast, as casts are\nnon-operations.)"))),(0,s.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=bytes",group:"bytes"},'// raw == from_ascii\nconst raw: bytes = ("666f6f" as bytes);\n')),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"Note that both syntaxes apply respectively only to ",(0,s.kt)("em",{parentName:"p"},"verbatim")," string\nliterals and general strings, not general expressions of type\n",(0,s.kt)("inlineCode",{parentName:"p"},"string"),". In other words, the contents of the strings must be\navailable at compile-time. (This actually reveals that ",(0,s.kt)("inlineCode",{parentName:"p"},'("666f6f" as\nbytes)')," is not really a cast, as casts are non-operations.)"))),(0,s.kt)("h2",{id:"concatenating"},"Concatenating"),(0,s.kt)("p",null,"Two or more bytes can be concatenated."),(0,s.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=concatenating",group:"concatenating"},"let two : bytes = Bytes.concat 0x70 0xAA\nlet three : bytes = Bytes.concats [0x70; 0xAA; 0xFF]\n"))),(0,s.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=concatenating",group:"concatenating"},"const two: bytes = Bytes.concat(0x70, 0xAA);\nconst three: bytes = Bytes.concats([0x70, 0xAA, 0xFF]);\n"))),(0,s.kt)("h2",{id:"sizing"},"Sizing"),(0,s.kt)("p",null,"In order to obtain the length of a sequence of bytes, use the\npredefined function ",(0,s.kt)("inlineCode",{parentName:"p"},"Bytes.length")," like so:"),(0,s.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=sizing",group:"sizing"},"let len : nat = Bytes.length 0x0AFF // len = 2n\n"))),(0,s.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=sizing",group:"sizing"},"const len: nat = Bytes.length(0x0AFF); // len == 2n\n"))),(0,s.kt)("h2",{id:"slicing"},"Slicing"),(0,s.kt)("p",null,"Bytes can be extracted using the predefined function ",(0,s.kt)("inlineCode",{parentName:"p"},"Bytes.sub"),". The\nfirst parameter is the start index and the second is the number of\nbytes of the slice we want. Keep in mind that the first byte in a\nsequence has index ",(0,s.kt)("inlineCode",{parentName:"p"},"0n"),"."),(0,s.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=slicing",group:"slicing"},"let large = 0x12345678\nlet slice = Bytes.sub 1n 2n large // sub = 0x3456\n"))),(0,s.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=slicing",group:"slicing"},"const large = 0x12345678;\nconst slice = Bytes.sub(1n, 2n, large); // sub == 0x3456\n"))),(0,s.kt)("h2",{id:"bitwise-operations"},"Bitwise operations"),(0,s.kt)("p",null,"The bitwise operations on sequences of bytes are as follows:"),(0,s.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=bitwise",group:"bitwise"},'// Bitwise "and"\nlet and : bytes = 0x0005 land 0x0106 // 0x0004\n\n// Bitwise "or"\nlet @or : bytes = 0x0005 lor 0x0106 // 0x0107\n\n// Bitwise "xor"\nlet xor : bytes = 0x0005 lxor 0x0106 // 0x0103\n\n// Bitwise "shift left"\nlet shift_left : bytes = 0x06 lsl 8n // 0x0600\n\n// Bitwise "shift right"\nlet shift_right : bytes = 0x0006 lsr 1n // 0x0003\n'))),(0,s.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=bitwise",group:"bitwise"},'// Bitwise "and"\nconst and: bytes = 0x0005 & 0x0106; // 0x0004\n\n// Bitwise "or"\nconst or: bytes = 0x0005 | 0x0106; // 0x0107\n\n// Bitwise "xor"\nconst xor: bytes = 0x0005 ^ 0x0106; // 0x0103\n\n// Bitwise "shift left"\nconst shift_left: bytes = 0x06 << 8n; // 0x0600\n\n// Bitwise "shift right"\nconst shift_right: bytes = 0x0006 >> 1n; // 0x0003\n'))),(0,s.kt)("h2",{id:"packing-and-unpacking"},"Packing and unpacking"),(0,s.kt)("p",null,"As Michelson provides the instructions ",(0,s.kt)("inlineCode",{parentName:"p"},"PACK")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"UNPACK")," for data\nserialisation, so does LIGO with ",(0,s.kt)("inlineCode",{parentName:"p"},"Bytes.pack")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"Bytes.unpack"),".  The\nformer serialises Michelson data structures into a binary format, and\nthe latter reverses that transformation. Unpacking may fail, so the\nreturn type of ",(0,s.kt)("inlineCode",{parentName:"p"},"Byte.unpack")," is an option that needs to be annotated."),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"Note: ",(0,s.kt)("inlineCode",{parentName:"p"},"PACK")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"UNPACK")," are Michelson instructions that are\nintended to be used by people that really know what they are\ndoing. There are several risks and failure cases, such as unpacking\na lambda from an untrusted source or casting the result to the wrong\ntype. Be careful.")),(0,s.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"group=packing",group:"packing"},"let id_string (p : string) : string option =\n  let packed: bytes = Bytes.pack p\n  in Bytes.unpack packed\n"))),(0,s.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"group=packing",group:"packing"},"const id_string = (p: string) : option<string> => {\n  let packed = Bytes.pack(p);\n  return Bytes.unpack(packed);\n};\n"))),(0,s.kt)("h2",{id:"cryptography"},"Cryptography"),(0,s.kt)("p",null,"One common use of bytes, beyond packing and unpacking, is\ncryptography. The predefined module ",(0,s.kt)("inlineCode",{parentName:"p"},"Crypto")," provides the following\nhashing functions, which are efficient because they are natively\nsupported by the Michelson virtual machine:"),(0,s.kt)(r.Z,{syntax:"cameligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cameligo",metastring:"skip",skip:!0},"val blake2b : bytes -> bytes\nval sha256 : bytes -> bytes\nval sha512 : bytes -> bytes\nval sha3 : bytes -> bytes\nval keccak : bytes -> bytes\n"))),(0,s.kt)(r.Z,{syntax:"jsligo",mdxType:"Syntax"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsligo",metastring:"skip",skip:!0},"const blake2b: bytes => bytes;\nconst sha256: bytes => bytes;\nconst sha512: bytes => bytes;\nconst sha3: bytes => bytes;\nconst keccak: bytes => bytes;\n"))))}g.isMDXComponent=!0}}]);