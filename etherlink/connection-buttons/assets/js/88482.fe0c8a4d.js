"use strict";(self.webpackChunketherlink_docs=self.webpackChunketherlink_docs||[]).push([[88482],{88482:(a,e,t)=>{t.d(e,{relayOpenZeppelinTransaction:()=>c});var n=t(57621),r=t(52749),s=t(75100),i=t(26182);const o=[{name:"from",type:"address"},{name:"to",type:"address"},{name:"value",type:"uint256"},{name:"gas",type:"uint256"},{name:"nonce",type:"uint256"},{name:"data",type:"bytes"}],d=[{name:"from",type:"address"},{name:"to",type:"address"},{name:"value",type:"uint256"},{name:"gas",type:"uint256"},{name:"nonce",type:"uint256"},{name:"data",type:"bytes"},{name:"chainid",type:"uint256"}];async function c(a){const{message:e,messageType:t,signature:c}=await async function({account:a,serializableTransaction:e,transaction:t,gasless:r}){const s=(0,n.u)({address:r.relayerForwarderAddress,chain:t.chain,client:t.client}),c=await(0,i.readContract)({contract:s,method:"function getNonce(address) view returns (uint256)",params:[a.address]}),[p,u]=await(async()=>{if(!e.to)throw new Error("OpenZeppelin transactions must have a 'to' address");if(!e.gas)throw new Error("OpenZeppelin transactions must have a 'gas' value");if(!e.data)throw new Error("OpenZeppelin transactions must have a 'data' value");if(r.experimentalChainlessSupport){const n={from:a.address,to:e.to,value:0n,gas:e.gas,nonce:c,data:e.data,chainid:BigInt(t.chain.id)};return[await a.signTypedData({domain:{name:"GSNv2 Forwarder",version:"0.0.1",verifyingContract:s.address},message:n,primaryType:"ForwardRequest",types:{ForwardRequest:d}}),n]}const n={from:a.address,to:e.to,value:0n,gas:e.gas,nonce:c,data:e.data};return[await a.signTypedData({domain:{name:r.domainName??"GSNv2 Forwarder",version:r.domainVersion??"0.0.1",chainId:t.chain.id,verifyingContract:s.address},message:n,primaryType:"ForwardRequest",types:{ForwardRequest:o}}),n]})();return{message:u,signature:p,messageType:"forward"}}(a),p=await fetch(a.gasless.relayerUrl,{method:"POST",body:(0,s.P)({request:e,type:t,signature:c,forwarderAddress:a.gasless.relayerForwarderAddress})});if(!p.ok)throw p.body?.cancel(),new Error(`Failed to send transaction: ${await p.text()}`);const u=await p.json();if(!u.result)throw new Error(`Relay transaction failed: ${u.message}`);const m=JSON.parse(u.result).txHash;if((0,r.v)(m))return{transactionHash:m,chain:a.transaction.chain,client:a.transaction.client};throw new Error(`Failed to send transaction: ${(0,s.P)(u)}`)}}}]);