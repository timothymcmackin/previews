import{D as p}from"./chunks/DocFunction.e9a30d9e.js";import{D as o}from"./chunks/DocInPlace.04c2ab1e.js";import{o as i,c as r,Q as n,C as t,y as l,v as s,a}from"./chunks/framework.741828c6.js";import"./chunks/DocFunction.vue_vue_type_style_index_0_scoped_21214205_lang.4ed993c7.js";import"./chunks/DocInPlace.vue_vue_type_style_index_0_scoped_8490fbaf_lang.4ed993c7.js";const f=JSON.parse('{"title":"Casting","description":"","frontmatter":{},"headers":[],"relativePath":"manual/data-types/casting.md","filePath":"manual/data-types/casting.md"}'),c={name:"manual/data-types/casting.md"},_=Object.assign(c,{setup(y){return(d,e)=>(i(),r("div",null,[e[2]||(e[2]=n(`<h1 id="casting" tabindex="-1">Casting <a class="header-anchor" href="#casting" aria-label="Permalink to &quot;Casting&quot;">​</a></h1><p>The SmartPy compiler must know the type of all variables in order to compile to Michelson, which is a strongly-typed language. SmartPy has powerful <em>type inference</em>, which can determine the types of most variables based on how they are used.</p><p>However, sometimes it is necessary to cast a variable to specify its type. SmartPy provides two tools for that: type hints (currently only supported on entrypoints and lambdas / views signature) and <span class="inline shiki material-theme-palenight"><code><span class="line"><span style="color:#BABED8;">sp</span><span style="color:#89DDFF;">.</span><span style="color:#F07178;">cast</span></span></code></span>. For example, the errors <span class="inline shiki material-theme-palenight"><code><span class="line"><span style="color:#BABED8;">Error </span><span style="color:#89DDFF;">in</span><span style="color:#BABED8;"> generated Michelson contract</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> Missing </span><span style="color:#FFCB6B;">type</span> <span style="color:#89DDFF;">in</span><span style="color:#BABED8;"> storage</span></span></code></span> or <span class="inline shiki material-theme-palenight"><code><span class="line"><span style="color:#BABED8;">Missing </span><span style="color:#FFCB6B;">type</span> <span style="color:#89DDFF;">in</span><span style="color:#BABED8;"> parameters</span></span></code></span> often mean that SmartPy can&#39;t determine the type of a variable in the contract storage or in an entrypoint parameter.</p><p>Other errors might lead you to think that you need to cast a variable when you don&#39;t. Errors that start with <span class="inline shiki material-theme-palenight"><code><span class="line"><span style="color:#BABED8;">entrypoint expects parameter of type </span><span style="color:#89DDFF;">[</span><span style="color:#FFCB6B;">type</span><span style="color:#BABED8;"> a</span><span style="color:#89DDFF;">],</span><span style="color:#BABED8;"> but got </span><span style="color:#89DDFF;">[</span><span style="color:#FFCB6B;">type</span><span style="color:#BABED8;"> b</span><span style="color:#89DDFF;">]</span></span></code></span> usually mean that you are passing the wrong type of variable to an entrypoint.</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>In SmartPy, casting does not change the type of a variable, like casting does in some other languages. Instead, casting identifies the type of a variable that the compiler can&#39;t infer from context.</p><p>The <a href="/previews/smartpy/tutorials/manual/stdlib/library">STDLIB</a> modules provide some traditional casting functions, such as converting between different numerical types.</p></div><h2 id="adding-type-hints" tabindex="-1">Adding type hints <a class="header-anchor" href="#adding-type-hints" aria-label="Permalink to &quot;Adding type hints&quot;">​</a></h2><p>You can add Python-style type hints to set the types of entrypoint parameters and resolve type ambiguities:</p><div class="language-smartpy"><button title="Copy Code" class="copy"></button><span class="lang">smartpy</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">@sp.entrypoint</span></span>
<span class="line"><span style="color:#babed8;">def ep(self, x: sp.int, y: sp.nat):</span></span>
<span class="line"><span style="color:#babed8;">    ...</span></span></code></pre></div><p>Type hints can also specify the return type of views and lambdas, as in this example:</p><div class="language-smartpy"><button title="Copy Code" class="copy"></button><span class="lang">smartpy</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">@sp.onchain_view()</span></span>
<span class="line"><span style="color:#babed8;">def total_supply(self) -&gt; sp.nat:</span></span>
<span class="line"><span style="color:#babed8;">    return self.data.supply</span></span></code></pre></div><h2 id="casting-variables" tabindex="-1">Casting variables <a class="header-anchor" href="#casting-variables" aria-label="Permalink to &quot;Casting variables&quot;">​</a></h2><p>When type hints are not possible, you can use <span class="inline shiki material-theme-palenight"><code><span class="line"><span style="color:#BABED8;">sp</span><span style="color:#89DDFF;">.</span><span style="color:#F07178;">cast</span></span></code></span> to set the type of a variable:</p>`,12)),t(p,{name:"sp.cast",arg:"x, T",rType:"T"},{default:l(()=>e[0]||(e[0]=[s("p",null,[a("Assign value "),s("span",{class:"inline shiki material-theme-palenight"},[s("code",null,[s("span",{class:"line"},[s("span",{style:{color:"#BABED8"}},"x")])])]),a(" to type "),s("span",{class:"inline shiki material-theme-palenight"},[s("code",null,[s("span",{class:"line"},[s("span",{style:{color:"#BABED8"}},"T")])])]),a(".")],-1),s("div",{class:"language-smartpy"},[s("button",{title:"Copy Code",class:"copy"}),s("span",{class:"lang"},"smartpy"),s("pre",{class:"shiki material-theme-palenight"},[s("code",null,[s("span",{class:"line"},[s("span",{style:{color:"#babed8"}},"# Cast as an expression")]),a(`
`),s("span",{class:"line"},[s("span",{style:{color:"#babed8"}},"b = sp.cast(a, sp.int) + 1")]),a(`
`),s("span",{class:"line"},[s("span",{style:{color:"#babed8"}})]),a(`
`),s("span",{class:"line"},[s("span",{style:{color:"#babed8"}},"# Cast as a statement")]),a(`
`),s("span",{class:"line"},[s("span",{style:{color:"#babed8"}},"c = 5")]),a(`
`),s("span",{class:"line"},[s("span",{style:{color:"#babed8"}},"sp.cast(c, sp.nat)")])])])],-1)])),_:1}),e[3]||(e[3]=n(`<h2 id="when-is-casting-not-necessary" tabindex="-1">When is casting not necessary? <a class="header-anchor" href="#when-is-casting-not-necessary" aria-label="Permalink to &quot;When is casting not necessary?&quot;">​</a></h2><p>Casting is not necessary when SmartPy can infer a variable type from the context. For example, casting is not necessary if you assign a value to a variable, because SmartPy can use the type of that value as the type of the variable, as in this example:</p><div class="language-smartpy"><button title="Copy Code" class="copy"></button><span class="lang">smartpy</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;"># No casting required</span></span>
<span class="line"><span style="color:#babed8;">my_string = &quot;hello&quot;  # Inferred to be sp.string</span></span>
<span class="line"><span style="color:#babed8;">my_list = [my_string]  # Inferred to be sp.list[string]</span></span></code></pre></div><p>Casting is also not necessary when SmartPy can infer a type based on an operation. For example, this entrypoint accepts a parameter that is not casted, but SmartPy can infer that it is a nat because the entrypoint adds it to another nat:</p><div class="language-smartpy"><button title="Copy Code" class="copy"></button><span class="lang">smartpy</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">@sp.entrypoint</span></span>
<span class="line"><span style="color:#babed8;">def acceptANat(self, a):</span></span>
<span class="line"><span style="color:#babed8;">    b = sp.nat(5)</span></span>
<span class="line"><span style="color:#babed8;">    c = a + b  # All variables assumed to be sp.nat</span></span></code></pre></div><p>SmartPy can infer types in this way across entrypoints. For example, the following contract&#39;s <span class="inline shiki material-theme-palenight"><code><span class="line"><span style="color:#82AAFF;">__init__</span><span style="color:#89DDFF;">()</span></span></code></span> method creates an empty big map and its <span class="inline shiki material-theme-palenight"><code><span class="line"><span style="color:#BABED8;">update</span></span></code></span> entrypoint adds an element to that big map. SmartPy can infer the type of the big map by the element that the entrypoint adds:</p><div class="language-smartpy"><button title="Copy Code" class="copy"></button><span class="lang">smartpy</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">class MyContract(sp.Contract):</span></span>
<span class="line"><span style="color:#babed8;">    def __init__(self):</span></span>
<span class="line"><span style="color:#babed8;">        # Inferred to be sp.big_map[sp.string, sp.int] based on usage</span></span>
<span class="line"><span style="color:#babed8;">        self.data.my_big_map = sp.big_map()</span></span>
<span class="line"><span style="color:#babed8;"></span></span>
<span class="line"><span style="color:#babed8;">    @sp.entrypoint</span></span>
<span class="line"><span style="color:#babed8;">    def update(self):</span></span>
<span class="line"><span style="color:#babed8;">        self.data.my_big_map[&quot;a&quot;] = 5</span></span></code></pre></div><div class="info custom-block"><p class="custom-block-title">INFO</p><p>SmartPy does not use information from the test scenario to infer types. All type information comes from the contract code itself.</p></div><h2 id="when-does-smartpy-assume-types" tabindex="-1">When does SmartPy assume types? <a class="header-anchor" href="#when-does-smartpy-assume-types" aria-label="Permalink to &quot;When does SmartPy assume types?&quot;">​</a></h2><p>The SmartPy compiler sometimes assumes a variable&#39;s type when it does not have complete information.</p><p>When SmartPy knows that a variable is a number but not whether that number is an integer or a nat, it assumes that it is an integer. For example, this <span class="inline shiki material-theme-palenight"><code><span class="line"><span style="color:#82AAFF;">__init__</span><span style="color:#89DDFF;">()</span></span></code></span> function creates a storage field and puts a number in it. In the absence of other information, SmartPy assumes that it is an integer:</p><div class="language-smartpy"><button title="Copy Code" class="copy"></button><span class="lang">smartpy</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">def __init__(self):</span></span>
<span class="line"><span style="color:#babed8;">    self.data.my_value = 5  # Assumed to be sp.int</span></span></code></pre></div><p>Similarly, SmartPy assumes that key-value series in braces are maps, not big maps, as in this example:</p><div class="language-smartpy"><button title="Copy Code" class="copy"></button><span class="lang">smartpy</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">def __init__(self):</span></span>
<span class="line"><span style="color:#babed8;">    # Assumed to be sp.map[sp.string, sp.int]</span></span>
<span class="line"><span style="color:#babed8;">    self.data.my_map = {&quot;a&quot;: 1, &quot;b&quot;: 2}</span></span></code></pre></div><h2 id="when-is-casting-necessary" tabindex="-1">When is casting necessary? <a class="header-anchor" href="#when-is-casting-necessary" aria-label="Permalink to &quot;When is casting necessary?&quot;">​</a></h2><p>Because SmartPy can use many different ways of inferring types, casting is rarely necessary. Here are some cases that may require casting:</p><h3 id="setting-the-type-of-unused-variables" tabindex="-1">Setting the type of unused variables <a class="header-anchor" href="#setting-the-type-of-unused-variables" aria-label="Permalink to &quot;Setting the type of unused variables&quot;">​</a></h3><p>Casting may be required during the development process when you create a variable but do not use it yet.</p><p>For example, this contract&#39;s <span class="inline shiki material-theme-palenight"><code><span class="line"><span style="color:#82AAFF;">__init__</span><span style="color:#89DDFF;">()</span></span></code></span> method creates an empty big map. If no entrypoints manipulate this big map directly, you may need to cast it temporarily to specify its type:</p><div class="language-smartpy"><button title="Copy Code" class="copy"></button><span class="lang">smartpy</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">class MyContract(sp.Contract):</span></span>
<span class="line"><span style="color:#babed8;">    def __init__(self):</span></span>
<span class="line"><span style="color:#babed8;">        self.data.my_big_map = sp.big_map()</span></span>
<span class="line"><span style="color:#babed8;">        sp.cast(self.data.my_big_map, sp.big_map[sp.string, sp.nat])</span></span></code></pre></div><p>Of course, completed contracts don&#39;t usually have unused variables in them. Therefore, casting is usually necessary only during the development process, before your code is complete.</p><h3 id="setting-the-layout-for-parameters" tabindex="-1">Setting the layout for parameters <a class="header-anchor" href="#setting-the-layout-for-parameters" aria-label="Permalink to &quot;Setting the layout for parameters&quot;">​</a></h3><p>Casting also allows you to set the layout of records in storage or parameters. For example, the <a href="https://gitlab.com/tezos/tzip/-/blob/master/proposals/tzip-12/tzip-12.md" target="_blank" rel="noreferrer">FA2 standard</a> specifies a layout and annotations for entrypoint parameters. The <span class="inline shiki material-theme-palenight"><code><span class="line"><span style="color:#BABED8;">transfer</span></span></code></span> entrypoint parameter receives this Micheline value:</p><div class="language-michelson"><button title="Copy Code" class="copy"></button><span class="lang">michelson</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">(list %transfer</span></span>
<span class="line"><span style="color:#babed8;">  (pair</span></span>
<span class="line"><span style="color:#babed8;">    (address %from_)</span></span>
<span class="line"><span style="color:#babed8;">    (list %txs</span></span>
<span class="line"><span style="color:#babed8;">      (pair</span></span>
<span class="line"><span style="color:#babed8;">        (address %to_)</span></span>
<span class="line"><span style="color:#babed8;">        (pair</span></span>
<span class="line"><span style="color:#babed8;">          (nat %token_id)</span></span>
<span class="line"><span style="color:#babed8;">          (nat %amount)</span></span>
<span class="line"><span style="color:#babed8;">        )</span></span>
<span class="line"><span style="color:#babed8;">      )</span></span>
<span class="line"><span style="color:#babed8;">    )</span></span>
<span class="line"><span style="color:#babed8;">  )</span></span>
<span class="line"><span style="color:#babed8;">)</span></span></code></pre></div><p>To implement this layout in SmartPy and include the annotations, you can cast the fields in the parameter. The SmartPy FA2 library provides types for this purpose. In this case, the <span class="inline shiki material-theme-palenight"><code><span class="line"><span style="color:#BABED8;">t</span><span style="color:#89DDFF;">.</span><span style="color:#F07178;">transfer_batch</span></span></code></span> type sets the fields and annotations for the <span class="inline shiki material-theme-palenight"><code><span class="line"><span style="color:#BABED8;">transfer</span></span></code></span> entrypoint. These are the types:</p><div class="language-smartpy"><button title="Copy Code" class="copy"></button><span class="lang">smartpy</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">tx: type = sp.record(</span></span>
<span class="line"><span style="color:#babed8;">    to_=sp.address,</span></span>
<span class="line"><span style="color:#babed8;">    token_id=sp.nat,</span></span>
<span class="line"><span style="color:#babed8;">    amount=sp.nat,</span></span>
<span class="line"><span style="color:#babed8;">).layout((&quot;to_&quot;, (&quot;token_id&quot;, &quot;amount&quot;)))</span></span>
<span class="line"><span style="color:#babed8;"></span></span>
<span class="line"><span style="color:#babed8;">transfer_batch: type = sp.record(</span></span>
<span class="line"><span style="color:#babed8;">    from_=sp.address,</span></span>
<span class="line"><span style="color:#babed8;">    txs=list[tx],</span></span>
<span class="line"><span style="color:#babed8;">).layout((&quot;from_&quot;, &quot;txs&quot;))</span></span>
<span class="line"><span style="color:#babed8;"></span></span>
<span class="line"><span style="color:#babed8;">transfer_params: type = list[transfer_batch]</span></span></code></pre></div><p>Then, the <span class="inline shiki material-theme-palenight"><code><span class="line"><span style="color:#BABED8;">transfer</span></span></code></span> entrypoint casts its parameter to the <span class="inline shiki material-theme-palenight"><code><span class="line"><span style="color:#BABED8;">t</span><span style="color:#89DDFF;">.</span><span style="color:#F07178;">transfer_batch</span></span></code></span> type:</p><div class="language-smartpy"><button title="Copy Code" class="copy"></button><span class="lang">smartpy</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">@sp.entrypoint</span></span>
<span class="line"><span style="color:#babed8;">def transfer(self, batch):</span></span>
<span class="line"><span style="color:#babed8;">    &quot;&quot;&quot;Accept a list of transfer operations between a source and multiple</span></span>
<span class="line"><span style="color:#babed8;">    destinations.</span></span>
<span class="line"><span style="color:#babed8;"></span></span>
<span class="line"><span style="color:#babed8;">    \`transfer_tx_\` and \`is_defined_\` must be defined in the child class.</span></span>
<span class="line"><span style="color:#babed8;">    &quot;&quot;&quot;</span></span>
<span class="line"><span style="color:#babed8;">    sp.cast(batch, t.transfer_params)</span></span>
<span class="line"><span style="color:#babed8;">    # ...</span></span></code></pre></div><p>You may need to set layouts in this way to accept calls from contracts that provide parameters in a specific layout.</p><h2 id="when-is-casting-helpful" tabindex="-1">When is casting helpful? <a class="header-anchor" href="#when-is-casting-helpful" aria-label="Permalink to &quot;When is casting helpful?&quot;">​</a></h2><p>Casting can be helpful (but is not required) to set the type of storage or of a parameter. If you set a type in this way by casting, the SmartPy compiler warns you if the code deviates from this type. For example, this code creates a type for the storage with comments that describe what each field is for. Then the <span class="inline shiki material-theme-palenight"><code><span class="line"><span style="color:#82AAFF;">__init__</span><span style="color:#89DDFF;">()</span></span></code></span> method casts the storage to this type to ensure that the contract uses this type:</p><div class="language-smartpy"><button title="Copy Code" class="copy"></button><span class="lang">smartpy</span><pre class="shiki material-theme-palenight has-diff"><code><span class="line"><span style="color:#babed8;">contract_storage_type: type = sp.record(</span></span>
<span class="line"><span style="color:#babed8;">    my_integer=sp.int,  # An integer value</span></span>
<span class="line"><span style="color:#babed8;">    my_string=sp.string,  # A string value</span></span>
<span class="line"><span style="color:#babed8;">    my_record=sp.record(</span></span>
<span class="line"><span style="color:#babed8;">        my_address=sp.address,  # An address</span></span>
<span class="line"><span style="color:#babed8;">        my_nat=sp.nat,  # A nat</span></span>
<span class="line"><span style="color:#babed8;">        my_bool=sp.bool,  # A Boolean</span></span>
<span class="line"><span style="color:#babed8;">        my_list_nat=sp.list[sp.nat],  # A list of nat</span></span>
<span class="line"><span style="color:#babed8;">    ),</span></span>
<span class="line"><span style="color:#babed8;">)</span></span>
<span class="line"><span style="color:#babed8;"></span></span>
<span class="line"><span style="color:#babed8;"></span></span>
<span class="line"><span style="color:#babed8;">class MyContract(sp.Contract):</span></span>
<span class="line"><span style="color:#babed8;">    def __init__(self):</span></span>
<span class="line"><span style="color:#babed8;">        # Cast storage to alert on differences</span></span>
<span class="line"><span style="color:#babed8;">        sp.cast(self.data, contract_storage_type)</span></span></code></pre></div><h2 id="type-aliases" tabindex="-1">Type aliases <a class="header-anchor" href="#type-aliases" aria-label="Permalink to &quot;Type aliases&quot;">​</a></h2><p>To help with casting, you can create type aliases to identify types. These types can be simple or complex.</p>`,34)),t(o,{name:"type alias",left:"x",symbol:": type =",right:"t"},{default:l(()=>e[1]||(e[1]=[s("p",null,"Alias a type.",-1),s("div",{class:"language-smartpy"},[s("button",{title:"Copy Code",class:"copy"}),s("span",{class:"lang"},"smartpy"),s("pre",{class:"shiki material-theme-palenight"},[s("code",null,[s("span",{class:"line"},[s("span",{style:{color:"#babed8"}},"@sp.module")]),a(`
`),s("span",{class:"line"},[s("span",{style:{color:"#babed8"}},"def main():")]),a(`
`),s("span",{class:"line"},[s("span",{style:{color:"#babed8"}},"    # my_integer_type is now equivalent to sp.int")]),a(`
`),s("span",{class:"line"},[s("span",{style:{color:"#babed8"}},"    my_integer_type: type = sp.int")]),a(`
`),s("span",{class:"line"},[s("span",{style:{color:"#babed8"}})]),a(`
`),s("span",{class:"line"},[s("span",{style:{color:"#babed8"}},"    # A more complex type for the contract storage")]),a(`
`),s("span",{class:"line"},[s("span",{style:{color:"#babed8"}},"    contract_storage_type: type = sp.record(")]),a(`
`),s("span",{class:"line"},[s("span",{style:{color:"#babed8"}},"        ledger=sp.big_map[sp.pair[sp.address, sp.nat], sp.nat],")]),a(`
`),s("span",{class:"line"},[s("span",{style:{color:"#babed8"}},"        supply=sp.big_map[sp.nat, sp.nat],")]),a(`
`),s("span",{class:"line"},[s("span",{style:{color:"#babed8"}},"        metadata=sp.big_map[sp.string, sp.bytes],")]),a(`
`),s("span",{class:"line"},[s("span",{style:{color:"#babed8"}},"        token_metadata=sp.big_map[")]),a(`
`),s("span",{class:"line"},[s("span",{style:{color:"#babed8"}},"            sp.nat,")]),a(`
`),s("span",{class:"line"},[s("span",{style:{color:"#babed8"}},"            sp.record(token_id=sp.nat, token_info=sp.map[sp.string, sp.bytes]).layout(")]),a(`
`),s("span",{class:"line"},[s("span",{style:{color:"#babed8"}},'                ("token_id", "token_info")')]),a(`
`),s("span",{class:"line"},[s("span",{style:{color:"#babed8"}},"            ),")]),a(`
`),s("span",{class:"line"},[s("span",{style:{color:"#babed8"}},"        ],")]),a(`
`),s("span",{class:"line"},[s("span",{style:{color:"#babed8"}},"    )")]),a(`
`),s("span",{class:"line"},[s("span",{style:{color:"#babed8"}})]),a(`
`),s("span",{class:"line"},[s("span",{style:{color:"#babed8"}},"    class MyContract(sp.Contract):")]),a(`
`),s("span",{class:"line"},[s("span",{style:{color:"#babed8"}},"        def __init__(self):")]),a(`
`),s("span",{class:"line"},[s("span",{style:{color:"#babed8"}},"            self.data.ledger = sp.big_map()")]),a(`
`),s("span",{class:"line"},[s("span",{style:{color:"#babed8"}},"            self.data.supply = sp.big_map()")]),a(`
`),s("span",{class:"line"},[s("span",{style:{color:"#babed8"}},"            self.data.metadata = sp.big_map()")]),a(`
`),s("span",{class:"line"},[s("span",{style:{color:"#babed8"}},"            self.data.token_metadata = sp.big_map()")]),a(`
`),s("span",{class:"line"},[s("span",{style:{color:"#babed8"}})]),a(`
`),s("span",{class:"line"},[s("span",{style:{color:"#babed8"}},"            # Cast the storage to a type alias")]),a(`
`),s("span",{class:"line"},[s("span",{style:{color:"#babed8"}},"            sp.cast(self.data, contract_storage_type)")]),a(`
`),s("span",{class:"line"},[s("span",{style:{color:"#babed8"}})]),a(`
`),s("span",{class:"line"},[s("span",{style:{color:"#babed8"}},"        @sp.entrypoint")]),a(`
`),s("span",{class:"line"},[s("span",{style:{color:"#babed8"}},"        def ep(x):")]),a(`
`),s("span",{class:"line"},[s("span",{style:{color:"#babed8"}},"            # my_integer_type can be used anywhere you would use a type")]),a(`
`),s("span",{class:"line"},[s("span",{style:{color:"#babed8"}},"            sp.cast(x, my_integer_type)")])])])],-1)])),_:1})]))}});export{f as __pageData,_ as default};
