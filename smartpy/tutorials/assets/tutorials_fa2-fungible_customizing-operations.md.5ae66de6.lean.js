import{_ as a,o as t,c as s,Q as n}from"./chunks/framework.741828c6.js";const u=JSON.parse('{"title":"Part 4: Customizing operations","description":"","frontmatter":{},"headers":[],"relativePath":"tutorials/fa2-fungible/customizing-operations.md","filePath":"tutorials/fa2-fungible/customizing-operations.md"}'),o={name:"tutorials/fa2-fungible/customizing-operations.md"};function l(p,e,r,i,c,d){return t(),s("div",null,e[0]||(e[0]=[n(`<h1 id="part-4-customizing-operations" tabindex="-1">Part 4: Customizing operations <a class="header-anchor" href="#part-4-customizing-operations" aria-label="Permalink to &quot;Part 4: Customizing operations&quot;">​</a></h1><p>As shown in previous parts, the SmartPy FA2 library provides the entrypoints that the standard requires. You can override these entrypoints, but you must be sure to follow the standard. You can also customize their behavior by setting security policies.</p><p>You can also customize the contract by adding your own entrypoints. In this part, you add an entrypoint that allows users to exchange one token for another. To convert one token into another, the entrypoint follows these general steps:</p><ol><li>Verify that the source and target tokens are defined.</li><li>Burn the source tokens by decreasing the amount in the ledger for the account or fail if the account doesn&#39;t have enough.</li><li>Mint the target tokens by increasing the amount in the ledger for the account.</li></ol><p>The burn and mint steps are straightforward as long as you understand how FA2 contracts store information in their ledger. As described in <a href="/previews/smartpy/tutorials/tutorials/fa2-fungible/basic-fa2-token">Part 1</a>, the contract stores information about who owns tokens in a key-value store:</p><ul><li>The key is a pair that contains the address of the owner and the ID of the token</li><li>The value is the quantity of tokens</li></ul><p>In table format, the ledger might look like this after some mint and burn transactions:</p><table><thead><tr><th>key</th><th>value</th></tr></thead><tbody><tr><td>Alice, token ID 0</td><td>10</td></tr><tr><td>Alice, token ID 1</td><td>2</td></tr><tr><td>Alice, token ID 2</td><td>1</td></tr><tr><td>Alice, token ID 4</td><td>5</td></tr><tr><td>Bob, token ID 1</td><td>2</td></tr><tr><td>Bob, token ID 2</td><td>8</td></tr><tr><td>Bob, token ID 3</td><td>14</td></tr></tbody></table><p>That means that to get the amount of the source token that an account has, you must put the address and token ID together as a pair.</p><h2 id="tutorial-contract" tabindex="-1">Tutorial contract <a class="header-anchor" href="#tutorial-contract" aria-label="Permalink to &quot;Tutorial contract&quot;">​</a></h2><p>The completed contract that you create in this part is at <a href="https://github.com/trilitech/tutorial-applications/blob/main/smartpy_fa2_fungible/part_4_complete.py" target="_blank" rel="noreferrer">part_4_complete.py</a>.</p><h2 id="exchanging-one-token-for-another" tabindex="-1">Exchanging one token for another <a class="header-anchor" href="#exchanging-one-token-for-another" aria-label="Permalink to &quot;Exchanging one token for another&quot;">​</a></h2><p>Follow these steps to create the <span class="inline shiki material-theme-palenight"><code><span class="line"><span style="color:#BABED8;">convert</span></span></code></span> entrypoint that exchanges one token for another:</p><ol><li><p>At the beginning of the module, after the <span class="inline shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">def</span> <span style="color:#82AAFF;">my_module</span><span style="color:#89DDFF;">():</span></span></code></span> statement but before the <span class="inline shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">class</span></span></code></span> statement, add a type that represents the information for a token transfer:</p><div class="language-smartpy"><button title="Copy Code" class="copy"></button><span class="lang">smartpy</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">conversion_type: type = sp.record(</span></span>
<span class="line"><span style="color:#babed8;">    source_token_id = sp.nat,  # The ID of the source token</span></span>
<span class="line"><span style="color:#babed8;">    target_token_id = sp.nat,  # The ID of the target token</span></span>
<span class="line"><span style="color:#babed8;">    amount = sp.nat,  # The number of source tokens to convert</span></span>
<span class="line"><span style="color:#babed8;">)</span></span></code></pre></div><p>The type includes the ID of the source token, the ID of the token to convert it into, and the amount of tokens to convert.</p></li><li><p>After this type, create a type that is a list of conversions:</p><div class="language-smartpy"><button title="Copy Code" class="copy"></button><span class="lang">smartpy</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">conversion_batch: type = sp.list[conversion_type]</span></span></code></pre></div><p>This type is the parameter for the <span class="inline shiki material-theme-palenight"><code><span class="line"><span style="color:#BABED8;">convert</span></span></code></span> entrypoint. The FA2 standard says that custom entrypoints should accept batches for parameters to allow users to do multiple things in a single transaction.</p></li><li><p>After the <span class="inline shiki material-theme-palenight"><code><span class="line"><span style="color:#82AAFF;">__init__</span><span style="color:#89DDFF;">()</span></span></code></span> function, add an entrypoint with the <span class="inline shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">@</span><span style="color:#82AAFF;">sp</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">entrypoint</span></span></code></span> annotation and accept a parameter of the <span class="inline shiki material-theme-palenight"><code><span class="line"><span style="color:#BABED8;">conversion_match</span></span></code></span> type:</p><div class="language-smartpy"><button title="Copy Code" class="copy"></button><span class="lang">smartpy</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;"># Convert one token into another</span></span>
<span class="line"><span style="color:#babed8;">@sp.entrypoint</span></span>
<span class="line"><span style="color:#babed8;">def convert(self, batch):</span></span>
<span class="line"><span style="color:#babed8;">    sp.cast(batch, conversion_batch)</span></span></code></pre></div></li><li><p>Loop over the conversions in the batch:</p><div class="language-smartpy"><button title="Copy Code" class="copy"></button><span class="lang">smartpy</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">for conversion in batch:</span></span></code></pre></div></li><li><p>Within the loop, destructure the conversion into individual variables:</p><div class="language-smartpy"><button title="Copy Code" class="copy"></button><span class="lang">smartpy</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">record(source_token_id, target_token_id, amount).match = conversion</span></span></code></pre></div></li><li><p>Add this code to verify that the contract&#39;s security policy allows transfers (which it does by default) and that the source and target token exist:</p><div class="language-smartpy"><button title="Copy Code" class="copy"></button><span class="lang">smartpy</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;"># Verify that transfers are allowed</span></span>
<span class="line"><span style="color:#babed8;">assert self.private.policy.supports_transfer, &quot;FA2_TX_DENIED&quot;</span></span>
<span class="line"><span style="color:#babed8;"># Verify that the source and target tokens exist</span></span>
<span class="line"><span style="color:#babed8;">assert self.is_defined_(source_token_id), &quot;FA2_TOKEN_UNDEFINED&quot;</span></span>
<span class="line"><span style="color:#babed8;">assert self.is_defined_(target_token_id), &quot;FA2_TOKEN_UNDEFINED&quot;</span></span></code></pre></div></li><li><p>Create a pair that represents the key for the source token type:</p><div class="language-smartpy"><button title="Copy Code" class="copy"></button><span class="lang">smartpy</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;"># Get a pair to represent the key for the ledger for the source tokens</span></span>
<span class="line"><span style="color:#babed8;">from_source = (sp.sender, source_token_id)</span></span></code></pre></div><p>Note that this code uses <span class="inline shiki material-theme-palenight"><code><span class="line"><span style="color:#BABED8;">sp</span><span style="color:#89DDFF;">.</span><span style="color:#F07178;">sender</span></span></code></span> instead of <span class="inline shiki material-theme-palenight"><code><span class="line"><span style="color:#BABED8;">sp</span><span style="color:#89DDFF;">.</span><span style="color:#F07178;">source</span></span></code></span> to identify the account that sent the transaction. The source is the account that initiated the original transaction that led to this entrypoint call, while the sender is the account that made the call that led directly to this entrypoint call. Using sender here is important to prevent other contracts from accepting a transaction from an account and then sending other transactions that impersonate that account. For more information, see <a href="https://opentezos.com/smart-contracts/avoiding-flaws" target="_blank" rel="noreferrer">Avoiding flaws</a> on opentezos.com.</p></li><li><p>Add this code to burn the source tokens:</p><div class="language-smartpy"><button title="Copy Code" class="copy"></button><span class="lang">smartpy</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;"># Burn the source tokens</span></span>
<span class="line"><span style="color:#babed8;">self.data.ledger[from_source] = sp.as_nat(</span></span>
<span class="line"><span style="color:#babed8;">    self.data.ledger.get(from_source, default=0) - amount,</span></span>
<span class="line"><span style="color:#babed8;">    error=&quot;FA2_INSUFFICIENT_BALANCE&quot;,</span></span>
<span class="line"><span style="color:#babed8;">)</span></span>
<span class="line"><span style="color:#babed8;">is_supply = sp.is_nat(</span></span>
<span class="line"><span style="color:#babed8;">    self.data.supply.get(source_token_id, default=0) - amount</span></span>
<span class="line"><span style="color:#babed8;">)</span></span>
<span class="line"><span style="color:#babed8;">with sp.match(is_supply):</span></span>
<span class="line"><span style="color:#babed8;">    with sp.case.Some as supply:</span></span>
<span class="line"><span style="color:#babed8;">        self.data.supply[source_token_id] = supply</span></span>
<span class="line"><span style="color:#babed8;">    with None:</span></span>
<span class="line"><span style="color:#babed8;">        self.data.supply[source_token_id] = 0</span></span></code></pre></div><p>This code uses the key from the previous step to subtract the tokens from the ledger entry. Then it updates the contract storage with the total number of that type of token remaining.</p></li><li><p>Add this code to create a pair that represents the key for the target token type:</p><div class="language-smartpy"><button title="Copy Code" class="copy"></button><span class="lang">smartpy</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;"># Get a pair to represent the key for the ledger for the target tokens</span></span>
<span class="line"><span style="color:#babed8;">from_target = (sp.sender, target_token_id)</span></span></code></pre></div></li><li><p>Add this code to mint the target tokens:</p><div class="language-smartpy"><button title="Copy Code" class="copy"></button><span class="lang">smartpy</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;"># Mint the target tokens</span></span>
<span class="line"><span style="color:#babed8;">target_amount = self.data.ledger.get(from_target, default=0)</span></span>
<span class="line"><span style="color:#babed8;">self.data.ledger[from_target] = amount + target_amount</span></span>
<span class="line"><span style="color:#babed8;">self.data.supply[target_token_id] += amount</span></span></code></pre></div><p>This code attempts to retrieve the record by the pair in the previous step. If it exists, the code adds the number of tokens to the existing amount. If not, it creates a new record in the ledger. Finally, it increases the supply of that token.</p></li><li><p>At the end of the file, add this test to verify that a user can convert their own tokens:</p><div class="language-smartpy"><button title="Copy Code" class="copy"></button><span class="lang">smartpy</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">scenario.h2(&quot;Convert tokens&quot;)</span></span>
<span class="line"><span style="color:#babed8;"></span></span>
<span class="line"><span style="color:#babed8;"># Verify that you can convert your own tokens</span></span>
<span class="line"><span style="color:#babed8;">conversions = [</span></span>
<span class="line"><span style="color:#babed8;">    sp.record(source_token_id = 0, target_token_id = 1, amount = 2),</span></span>
<span class="line"><span style="color:#babed8;">]</span></span>
<span class="line"><span style="color:#babed8;">contract.convert(</span></span>
<span class="line"><span style="color:#babed8;">    conversions,</span></span>
<span class="line"><span style="color:#babed8;">    _sender=alice</span></span>
<span class="line"><span style="color:#babed8;">)</span></span>
<span class="line"><span style="color:#babed8;">scenario.verify(</span></span>
<span class="line"><span style="color:#babed8;">    _get_balance(contract, sp.record(owner=alice.address, token_id=0)) == 8</span></span>
<span class="line"><span style="color:#babed8;">)</span></span>
<span class="line"><span style="color:#babed8;">scenario.verify(</span></span>
<span class="line"><span style="color:#babed8;">    _get_balance(contract, sp.record(owner=alice.address, token_id=1)) == 5</span></span>
<span class="line"><span style="color:#babed8;">)</span></span>
<span class="line"><span style="color:#babed8;">scenario.verify(_total_supply(contract, sp.record(token_id=0)) == 12)</span></span>
<span class="line"><span style="color:#babed8;">scenario.verify(_total_supply(contract, sp.record(token_id=1)) == 16)</span></span></code></pre></div></li></ol><p>That&#39;s all that&#39;s necessary to convert one fungible token into another. If you wanted to extend this feature, you could implement an exchange rate, take a fee for converting tokens, or allow only certain accounts to convert tokens. You could also test the entrypoint more thoroughly, such as testing that a user can&#39;t convert more tokens than they have.</p><p>If you want to, you can deploy this new contract to the mockup mode with the same commands as in <a href="/previews/smartpy/tutorials/tutorials/fa2-fungible/basic-fa2-token">Part 1: Setting up a simple FA2 token</a> and try it out locally. In the next section, you deploy it to a test network. Continue to <a href="/previews/smartpy/tutorials/tutorials/fa2-fungible/deploying-contract">Part 5: Deploying the contract</a>.</p>`,16)]))}const y=a(o,[["render",l]]);export{u as __pageData,y as default};
