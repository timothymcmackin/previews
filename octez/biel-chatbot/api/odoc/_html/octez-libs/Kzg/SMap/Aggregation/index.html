<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Aggregation (octez-libs.Kzg.SMap.Aggregation)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../../index.html">octez-libs</a> &#x00BB; <a href="../../index.html">Kzg</a> &#x00BB; <a href="../index.html">SMap</a> &#x00BB; Aggregation</nav><header class="odoc-preamble"><h1>Module <code><span>SMap.Aggregation</span></code></h1><p>This module is used to handle proof aggregation in Plonk The format of keys for aggregation is &lt;circuit~proof~key&gt;</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec value anchored" id="val-sep"><a href="#val-sep" class="anchor"></a><code><span><span class="keyword">val</span> sep : string</span></code></div><div class="spec-doc"><p>The separator that distinguish the different parts of the key, currently <code>'~'</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-update_key_name"><a href="#val-update_key_name" class="anchor"></a><code><span><span class="keyword">val</span> update_key_name : <span><span>(<span>string <span class="arrow">&#45;&gt;</span></span> string)</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>applies the input function on the last part of the input string (parts are delimited by sep). <code>update_key_name f (&quot;hello&quot; ^ sep ^ &quot;world&quot; ^ sep ^ &quot;!!&quot;)</code> returns <code>&quot;hello&quot; ^ sep ^ &quot;world&quot; ^ sep ^ (f &quot;!!&quot;)</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_prefix"><a href="#val-add_prefix" class="anchor"></a><code><span><span class="keyword">val</span> add_prefix : 
  <span><span class="optlabel">?no_sep</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?n</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?i</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?shift</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  string</span></code></div><div class="spec-doc"><p><code>add_prefix ~n ~i ~shift prefix str</code> return idx^prefix^sep^str idx = <code>i</code> + <code>shift</code> as a string, eventually padded with '0' before to allow a numbering until <code>n</code> with the same number of caracters for instance, <code>prefix ~n:11 ~i:5 ~shift:1 &quot;hello&quot; &quot;world&quot;</code> will return &quot;06~hello~world&quot; <code>n</code> is zero by default, this means if no <code>n</code> is specified, no idx will be added <code>no_sep</code> is false by default ; if set to true, the separator before the string to prefix will be ommitted : <code>prefix ~no_sep:true ~n:11 ~i:5 ~shift:1 &quot;hello&quot; &quot;world&quot;</code> will return &quot;06~helloworld&quot;</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-build_all_names"><a href="#val-build_all_names" class="anchor"></a><code><span><span class="keyword">val</span> build_all_names : <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>string list</span></span></code></div><div class="spec-doc"><p><code>build_all_names prefix n k</code> build the list of all prefixed <code>k</code> with n proofs : <code>build_all_names &quot;hello&quot; 11 &quot;world&quot;</code> will return <code>&quot;hello~00~world&quot; ; &quot;hello~01~world&quot; ; … ; &quot;hello~10~world&quot;</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-prefix_map"><a href="#val-prefix_map" class="anchor"></a><code><span><span class="keyword">val</span> prefix_map : <span><span class="optlabel">?n</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?i</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?shift</span>:int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../index.html#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../index.html#type-t">t</a></span></span></code></div><div class="spec-doc"><p>adds prefix to each key of str_map ; <code>i</code> will be added as a string before the prefix For instance <code>prefix_map ~n:3000 ~i:5 ~shift:1 &quot;hello&quot; map</code> will prefix all the keys of <code>map</code> with &quot;0006~hello~&quot;</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span><span class="keyword">val</span> of_list : <span><span class="optlabel">?n</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?shift</span>:int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../index.html#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>Aggregation.of_list ~n ~shift s name l</code> is the same as <code>of_list @@ List.mapi (fun i x -&gt; Aggregation.add_prefix ~n ~i ~shift s name, x) l</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-smap_of_smap_smap"><a href="#val-smap_of_smap_smap" class="anchor"></a><code><span><span class="keyword">val</span> smap_of_smap_smap : <span><span><span><span class="type-var">'a</span> <a href="../index.html#type-t">t</a></span> <a href="../index.html#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../index.html#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>&quot;c1&quot; -&gt; {&quot;a&quot; ; &quot;b&quot;} ; &quot;c2&quot; -&gt; {&quot;a&quot; ; &quot;c&quot;}</code> becomes <code>{&quot;c1~a&quot; ; &quot;c1~b&quot; ; &quot;c2~a&quot; ; &quot;c2~c&quot;}</code> with the same values</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-gather_maps"><a href="#val-gather_maps" class="anchor"></a><code><span><span class="keyword">val</span> gather_maps : <span><span class="optlabel">?shifts_map</span>:<span><span>(int * int)</span> <a href="../index.html#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span><span><span class="type-var">'a</span> <a href="../index.html#type-t">t</a></span> list</span> <a href="../index.html#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../index.html#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Converts a map of list of map in a map, by merging each list of map in one map, prefixing all keys with their proof index, and then merging all the new maps into one prefixing the keys with the outside map’s keys. shifts_maps map outside key to pairs of integers. 'key1' -&gt; (7, 20) means that 20 proofs will be produced for key1 in total and we should start from the 8th one, assuming 7 of them were done independently. (Note that we may not even finish the whole 20, this depends on the map_list length). For example, on input:</p><pre class="language-ocaml"><code>'circuit_foo' -&gt; [ {'a' -&gt; fa0; 'b' -&gt; fb0; 'c' -&gt; fc0};
                  {'a' -&gt; fa1; 'b' -&gt; fb1; 'c' -&gt; fc1} ];
'circuit_bar' -&gt; [ {'a' -&gt; ga0; 'b' -&gt; gb0; 'c' -&gt; gc0} ]; </code></pre><p>outputs</p><pre class="language-ocaml"><code>'circuit_foo~0~a' -&gt; fa0
'circuit_foo~0~b' -&gt; fb0
'circuit_foo~0~c' -&gt; fc0
'circuit_foo~1~a' -&gt; fa1
'circuit_foo~1~b' -&gt; fb1
'circuit_foo~1~c' -&gt; fc1
'circuit_bar~0~a' -&gt; ga0
'circuit_bar~0~b' -&gt; gb0
'circuit_bar~0~c' -&gt; gc0</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filter_by_circuit_name"><a href="#val-filter_by_circuit_name" class="anchor"></a><code><span><span class="keyword">val</span> filter_by_circuit_name : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../index.html#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../index.html#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Filter a map keeping the elements whose key corresponds to the given circuit name</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-select_answers_by_circuit"><a href="#val-select_answers_by_circuit" class="anchor"></a><code><span><span class="keyword">val</span> select_answers_by_circuit : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><span><span class="type-var">'a</span> <a href="../index.html#type-t">t</a></span> <a href="../index.html#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../index.html#type-t">t</a></span> <a href="../index.html#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>select_answers_by_circuit circuit_name s_map_map</code> takes a <code>circuit_name</code> and a map with the structure:</p><pre class="language-ocaml"><code>'x' -&gt; { 'circuit_foo~0~a' -&gt; [scalar] ;
         'circuit_foo~0~b' -&gt; [scalar] ;
         ...
      }</code></pre><p>and filters the keys of the inner map, keeping the elements whose key corresponds to the given circuit name.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_map_list_map"><a href="#val-add_map_list_map" class="anchor"></a><code><span><span class="keyword">val</span> add_map_list_map : <span><span><span><span><span class="type-var">'a</span> <a href="../index.html#type-t">t</a></span> list</span> <a href="../index.html#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span><span><span class="type-var">'a</span> <a href="../index.html#type-t">t</a></span> list</span> <a href="../index.html#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span><span class="type-var">'a</span> <a href="../index.html#type-t">t</a></span> list</span> <a href="../index.html#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>add_map_list_map m1 m2</code> will merge <code>m1</code> &amp; <code>m2</code> ; the resulting map will contain the same keys as <code>m1</code> ; <code>m1</code> &amp; <code>m2</code> can be disjoint, if a key is not found in <code>m2</code>, the resulting map contains the same binding as <code>m1</code> for this key</p></div></div></div></body></html>
