<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Cryptobox (octez-libs.Tezos_crypto_dal.Cryptobox)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../index.html">octez-libs</a> &#x00BB; <a href="../index.html">Tezos_crypto_dal</a> &#x00BB; Cryptobox</nav><header class="odoc-preamble"><h1>Module <code><span>Tezos_crypto_dal.Cryptobox</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#cryptography-for-the-data-availability-layer">Cryptography for the Data Availability Layer</a></li></ul></nav><div class="odoc-content"><h2 id="cryptography-for-the-data-availability-layer"><a href="#cryptography-for-the-data-availability-layer" class="anchor"></a>Cryptography for the Data Availability Layer</h2><p>The Data Availability Layer (DAL) reduces the storage strain on the blockchain by only storing on-chain constant-size cryptographic <a href="#type-commitment"><code>commitment</code></a>s to arbitrary data blobs called <a href="#type-slot"><code>slot</code></a>s. The slots themselves are stored off-chain and are made available by the DAL.</p><p>A slot is encoded with some redundancy using a so-called MDS (Maximum Distance Separable) code. The resulting encoded slot is partitioned into <a href="#type-shard"><code>shard</code></a>s, allowing retrieval of the slot with any subset of <code>{!field:parameters.number_of_shards}/{!field:parameters.redundancy_factor}</code> out of <code>{!field:parameters.number_of_shards}</code> shards. By doing so, we can guarantee high data availability provided a certain fraction of the DAL nodes is storing and supplying the data. This fraction can be made as small as desired at the expense of a higher data redundancy <a href="#type-parameters.redundancy_factor"><code>parameters.redundancy_factor</code></a>. MDS codes have no unnecessary redundancy.</p><p>One can verify in constant time that the correct shard was retrieved using a constant-sized <a href="https://www.iacr.org/archive/asiacrypt2010/6477178/6477178.pdf">KZG proof</a> <a href="#type-shard_proof"><code>shard_proof</code></a> (see function <code>verifyEval</code> in section 3.3) and the slot commitment.</p><p>A <a href="#type-slot"><code>slot</code></a> is partioned into <code>{!field:parameters.slot_size}/{!field:parameters.page_size}</code> segments called <a href="Verifier/index.html#type-page"><code>Verifier.page</code></a>s of size <a href="#type-parameters.page_size"><code>parameters.page_size</code></a>. One can also verify in constant time that the correct page was retrieved using a KZG proof <a href="#type-page_proof"><code>page_proof</code></a> and the slot commitment.</p><p>A challenge is to keep the proving time for the <a href="#type-shard_proof"><code>shard_proof</code></a>s almost proportional to the length <code>n</code> of the slot encoded with the MDS code: we've chosen and implemented a technique to produce the proofs in time <code>O(n log n)</code> (see <a href="https://eprint.iacr.org/2023/033.pdf">Fast amortized KZG proofs</a>).</p><p>More diverse details about the formalization are provided here : https://hackmd.io/36XUZUo7QqK5Ub6GvZmgOg</p><div class="odoc-spec"><div class="spec type anchored" id="type-parameters"><a href="#type-parameters" class="anchor"></a><code><span><span class="keyword">type</span> parameters</span><span> = <a href="../../Tezos_crypto_dal_octez_dal_config/Dal_config/index.html#type-parameters">Tezos_crypto_dal_octez_dal_config.Dal_config.parameters</a></span><span> = </span><span>{</span></code><ol><li id="type-parameters.redundancy_factor" class="def record field anchored"><a href="#type-parameters.redundancy_factor" class="anchor"></a><code><span>redundancy_factor : int;</span></code></li><li id="type-parameters.page_size" class="def record field anchored"><a href="#type-parameters.page_size" class="anchor"></a><code><span>page_size : int;</span></code></li><li id="type-parameters.slot_size" class="def record field anchored"><a href="#type-parameters.slot_size" class="anchor"></a><code><span>slot_size : int;</span></code></li><li id="type-parameters.number_of_shards" class="def record field anchored"><a href="#type-parameters.number_of_shards" class="anchor"></a><code><span>number_of_shards : int;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Initial values for the parameters of the DAL cryptographic primitives. It used to build a value of type <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>Encapsulates parameters required to use the cryptographic primitives exported by this module. A value of type <code>t</code> contains both initial <code>parameters</code> and computed values depending on it.</p></div></div><p>Because of the shell/protocol separation, cryptographic primitives need to be splitted. An interface, called the <a href="Verifier/index.html"><code>Verifier</code></a> aims to be provided for the economic protocol. The other interface, called the <code>Builder</code> is for the shell.</p><p>A <code>Verifier</code>, as hinted by the name, mainly needs to check proofs:</p><p>1. A proof that a commitment is valid</p><p>2. A proof that a page is valid</p><p>A technicality is that the economic protocol is able to configure those cryptographic primitives via several constants. Also, an SRS (aka trusted setup) is required.</p><p>It is the responsibility of the shell and the protocol to ensure that both the <code>Verifier</code> and the <code>Builder</code> are instantiated with the same parameters and use the same trusted setup.</p><div class="odoc-spec"><div class="spec type anchored" id="type-commitment"><a href="#type-commitment" class="anchor"></a><code><span><span class="keyword">type</span> commitment</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-commitment_proof"><a href="#type-commitment_proof" class="anchor"></a><code><span><span class="keyword">type</span> commitment_proof</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-page_proof"><a href="#type-page_proof" class="anchor"></a><code><span><span class="keyword">type</span> page_proof</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-error_container"><a href="#type-error_container" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'b) error_container</span></span><span> = </span><span>{</span></code><ol><li id="type-error_container.given" class="def record field anchored"><a href="#type-error_container.given" class="anchor"></a><code><span>given : <span class="type-var">'a</span>;</span></code></li><li id="type-error_container.expected" class="def record field anchored"><a href="#type-error_container.expected" class="anchor"></a><code><span>expected : <span class="type-var">'b</span>;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type extension anchored" id="extension-decl-Failed_to_load_trusted_setup"><a href="#extension-decl-Failed_to_load_trusted_setup" class="anchor"></a><code><span><span class="keyword">type</span> <a href="../../Tezos_error_monad/Error_monad/index.html#type-error">Tezos_error_monad.Error_monad.error</a> += </span></code><ol><li id="extension-Failed_to_load_trusted_setup" class="def variant extension anchored"><a href="#extension-Failed_to_load_trusted_setup" class="anchor"></a><code><span>| </span><span><span class="extension">Failed_to_load_trusted_setup</span> <span class="keyword">of</span> string</span></code></li></ol></div><div class="spec-doc"><p><code>Failed_to_load_trusted_setup</code>, thrown by <code>Config.init_dal</code>.</p></div></div><div class="odoc-spec"><div class="spec type extension anchored" id="extension-decl-Invalid_precomputation_hash"><a href="#extension-decl-Invalid_precomputation_hash" class="anchor"></a><code><span><span class="keyword">type</span> <a href="../../Tezos_error_monad/Error_monad/index.html#type-error">Tezos_error_monad.Error_monad.error</a> += </span></code><ol><li id="extension-Invalid_precomputation_hash" class="def variant extension anchored"><a href="#extension-Invalid_precomputation_hash" class="anchor"></a><code><span>| </span><span><span class="extension">Invalid_precomputation_hash</span> <span class="keyword">of</span> <span><span>(string, string)</span> <a href="#type-error_container">error_container</a></span></span></code></li></ol></div><div class="spec-doc"><p><code>Invalid_precomputation_hash</code>, thrown by <a href="#val-load_precompute_shards_proofs"><code>load_precompute_shards_proofs</code></a>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-initialisation_parameters"><a href="#type-initialisation_parameters" class="anchor"></a><code><span><span class="keyword">type</span> initialisation_parameters</span></code></div><div class="spec-doc"><p>The primitives exposed in this modules require some preprocessing. This preprocessing generates data from an unknown secret. For the security of those primitives, it is important that the secret is unknown.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-slot"><a href="#type-slot" class="anchor"></a><code><span><span class="keyword">type</span> slot</span><span> = bytes</span></code></div><div class="spec-doc"><p>A slot is a byte sequence corresponding to some data.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-scalar"><a href="#type-scalar" class="anchor"></a><code><span><span class="keyword">type</span> scalar</span></code></div><div class="spec-doc"><p>The finited field used by the polynomial.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-polynomial"><a href="#type-polynomial" class="anchor"></a><code><span><span class="keyword">type</span> polynomial</span></code></div><div class="spec-doc"><p>A polynomial is another representation for a slot. One advantage of this representation is that a commitment can be computed from a polynomial. A commitment has nice properties:</p><p>1. A commitment ensures that the size of the <code>slot</code> has a bounded size (typically <code>slot_size</code>).</p><p>2. A commitment can be used to verify that a page of fixed size (typically <code>page_size</code>) is part of the original slot.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-polynomial_degree"><a href="#val-polynomial_degree" class="anchor"></a><code><span><span class="keyword">val</span> polynomial_degree : <span><a href="#type-polynomial">polynomial</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>polynomial_degree polynomial</code> returns the degree of the polynomial.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-polynomial_evaluate"><a href="#val-polynomial_evaluate" class="anchor"></a><code><span><span class="keyword">val</span> polynomial_evaluate : <span><a href="#type-polynomial">polynomial</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-scalar">scalar</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-scalar">scalar</a></span></code></div><div class="spec-doc"><p><code>polynomial_evaluate polynomial x</code> evaluates <code>polynomial(x)</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-polynomial_from_slot"><a href="#val-polynomial_from_slot" class="anchor"></a><code><span><span class="keyword">val</span> polynomial_from_slot : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-slot">slot</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="#type-polynomial">polynomial</a>, <span>[&gt; <span>`Slot_wrong_size of string</span> ]</span>)</span> <span class="xref-unresolved">Stdlib</span>.Result.t</span></span></code></div><div class="spec-doc"><p><code>polynomial_from_slot t slot</code> returns a polynomial from the a slot <code>slot</code>.</p><p>Requires:</p><ul><li><code>Bytes.length slot</code> is the slot size declared in <code>t</code>.</li></ul><p>Ensures:</p><ul><li>For any <code>slot</code> satisfying <code>Bytes.length slot</code> is equal to the declared slot size of <code>t</code>, <code>polynomial_to_slot (polynomial_from_slot slot) = slot</code>.</li></ul><p>Fails with <code>`Slot_wrong_size</code> when the slot size is not equal to the value slot size declared in <code>t</code>.</p><p>Note:</p><ul><li><code>polynomial_from_slot</code> is injective.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-polynomial_to_slot"><a href="#val-polynomial_to_slot" class="anchor"></a><code><span><span class="keyword">val</span> polynomial_to_slot : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-polynomial">polynomial</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-slot">slot</a></span></code></div><div class="spec-doc"><p><code>polynomial_to_slot t polynomial</code> returns a slot from a <code>polynomial</code>.</p><p>Ensures:</p><ul><li>For any <code>slot</code> satisfying <code>Bytes.length slot = parameters.slot_size</code>, <code>polynomial_to_slot (polynomial_from_slot slot) = slot</code>.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-commit"><a href="#val-commit" class="anchor"></a><code><span><span class="keyword">val</span> commit : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-polynomial">polynomial</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="#type-commitment">commitment</a>,
    <span>[&gt; <span>`Invalid_degree_strictly_less_than_expected of
         <span><span>(int, int)</span> <a href="#type-error_container">error_container</a></span></span>
    <span>| `Prover_SRS_not_loaded</span> ]</span>)</span>
    <span class="xref-unresolved">Stdlib</span>.Result.t</span></span></code></div><div class="spec-doc"><p><code>commit t polynomial</code> returns the commitment associated to a polynomial <code>p</code>.</p><p>Fails with <code>`Invalid_degree_strictly_less_than_expected _</code> if the degree of <code>p</code> exceeds the SRS size.</p><p>Fails with <code>`Prover_SRS_not_loaded</code> if the prover’s SRS is not loaded (ie: <code>init_dal_verifier</code> has been used to load the SRS).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_commit_error"><a href="#val-pp_commit_error" class="anchor"></a><code><span><span class="keyword">val</span> pp_commit_error : 
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span>[&lt; <span>`Invalid_degree_strictly_less_than_expected of <span><span>(int, int)</span> <a href="#type-error_container">error_container</a></span></span>
  <span>| `Prover_SRS_not_loaded</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>pp_commit_error fmt error</code> pretty-prints the error returned by <a href="#val-commit"><code>commit</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-string_of_commit_error"><a href="#val-string_of_commit_error" class="anchor"></a><code><span><span class="keyword">val</span> string_of_commit_error : 
  <span><span>[&lt; <span>`Invalid_degree_strictly_less_than_expected of <span><span>(int, int)</span> <a href="#type-error_container">error_container</a></span></span>
  <span>| `Prover_SRS_not_loaded</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  string</span></code></div><div class="spec-doc"><p><code>string_of_commit_error error</code> returns an error string message for <code>error</code>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-share"><a href="#type-share" class="anchor"></a><code><span><span class="keyword">type</span> share</span></code></div><div class="spec-doc"><p>A portion of the data represented by a polynomial.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-shard"><a href="#type-shard" class="anchor"></a><code><span><span class="keyword">type</span> shard</span><span> = </span><span>{</span></code><ol><li id="type-shard.index" class="def record field anchored"><a href="#type-shard.index" class="anchor"></a><code><span>index : int;</span></code></li><li id="type-shard.share" class="def record field anchored"><a href="#type-shard.share" class="anchor"></a><code><span>share : <a href="#type-share">share</a>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>A shard is share with its index (see <a href="#val-shards_from_polynomial"><code>shards_from_polynomial</code></a>).</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-shard_proof"><a href="#type-shard_proof" class="anchor"></a><code><span><span class="keyword">type</span> shard_proof</span></code></div><div class="spec-doc"><p>A proof that a shard belongs to some commitment.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Verifier"><a href="#module-Verifier" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Verifier/index.html">Verifier</a></span><span> : 
  <a href="../Cryptobox_intf/module-type-VERIFIER/index.html">Cryptobox_intf.VERIFIER</a>
    <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../Cryptobox_intf/module-type-VERIFIER/index.html#type-t">t</a> = <a href="#type-t">t</a></span>
     <span class="keyword">and</span> <span><span class="keyword">type</span> <a href="../Cryptobox_intf/module-type-VERIFIER/index.html#type-commitment">commitment</a> = <a href="#type-commitment">commitment</a></span>
     <span class="keyword">and</span> <span><span class="keyword">type</span> <a href="../Cryptobox_intf/module-type-VERIFIER/index.html#type-commitment_proof">commitment_proof</a> = <a href="#type-commitment_proof">commitment_proof</a></span>
     <span class="keyword">and</span> <span><span class="keyword">type</span> <a href="../Cryptobox_intf/module-type-VERIFIER/index.html#type-page_proof">page_proof</a> = <a href="#type-page_proof">page_proof</a></span>
     <span class="keyword">and</span> <span><span class="keyword">type</span> <span>('a, 'b) <a href="../Cryptobox_intf/module-type-VERIFIER/index.html#type-error_container">error_container</a></span> = <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-error_container">error_container</a></span></span>
     <span class="keyword">and</span> <span><span class="keyword">type</span> <a href="../Cryptobox_intf/module-type-VERIFIER/index.html#type-share">share</a> = <a href="#type-share">share</a></span>
     <span class="keyword">and</span> <span><span class="keyword">type</span> <a href="../Cryptobox_intf/module-type-VERIFIER/index.html#type-shard">shard</a> = <a href="#type-shard">shard</a></span>
     <span class="keyword">and</span> <span><span class="keyword">type</span> <a href="../Cryptobox_intf/module-type-VERIFIER/index.html#type-shard_proof">shard_proof</a> = <a href="#type-shard_proof">shard_proof</a></span></span></code></div></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../Cryptobox_intf/module-type-VERIFIER/index.html">Cryptobox_intf.VERIFIER</a>
  <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../Cryptobox_intf/module-type-VERIFIER/index.html#type-t">t</a> := <a href="#type-t">t</a></span>
   <span class="keyword">and</span> <span><span class="keyword">type</span> <a href="../Cryptobox_intf/module-type-VERIFIER/index.html#type-parameters">parameters</a> :=
         <a href="../../Tezos_crypto_dal_octez_dal_config/Dal_config/index.html#type-parameters">Tezos_crypto_dal_octez_dal_config.Dal_config.parameters</a></span>
   <span class="keyword">and</span> <span><span class="keyword">type</span> <a href="../Cryptobox_intf/module-type-VERIFIER/index.html#type-commitment">commitment</a> := <a href="#type-commitment">commitment</a></span>
   <span class="keyword">and</span> <span><span class="keyword">type</span> <a href="../Cryptobox_intf/module-type-VERIFIER/index.html#type-commitment_proof">commitment_proof</a> := <a href="#type-commitment_proof">commitment_proof</a></span>
   <span class="keyword">and</span> <span><span class="keyword">type</span> <a href="../Cryptobox_intf/module-type-VERIFIER/index.html#type-page_proof">page_proof</a> := <a href="#type-page_proof">page_proof</a></span>
   <span class="keyword">and</span> <span><span class="keyword">type</span> <span>('a, 'b) <a href="../Cryptobox_intf/module-type-VERIFIER/index.html#type-error_container">error_container</a></span> := <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-error_container">error_container</a></span></span>
   <span class="keyword">and</span> <span><span class="keyword">type</span> <a href="../Cryptobox_intf/module-type-VERIFIER/index.html#type-share">share</a> := <a href="#type-share">share</a></span>
   <span class="keyword">and</span> <span><span class="keyword">type</span> <a href="../Cryptobox_intf/module-type-VERIFIER/index.html#type-shard">shard</a> := <a href="#type-shard">shard</a></span>
   <span class="keyword">and</span> <span><span class="keyword">type</span> <a href="../Cryptobox_intf/module-type-VERIFIER/index.html#type-shard_proof">shard_proof</a> := <a href="#type-shard_proof">shard_proof</a></span></span></code></summary><div class="odoc-spec"><div class="spec value anchored" id="val-parameters_encoding"><a href="#val-parameters_encoding" class="anchor"></a><code><span><span class="keyword">val</span> parameters_encoding : 
  <span><a href="../../Tezos_crypto_dal_octez_dal_config/Dal_config/index.html#type-parameters">Tezos_crypto_dal_octez_dal_config.Dal_config.parameters</a> <a href="../../Data_encoding/index.html#type-t">Data_encoding.t</a></span></span></code></div><div class="spec-doc"><p>An encoding for values of type <a href="#type-parameters"><code>parameters</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-make"><a href="#val-make" class="anchor"></a><code><span><span class="keyword">val</span> make : 
  <span><a href="../../Tezos_crypto_dal_octez_dal_config/Dal_config/index.html#type-parameters">Tezos_crypto_dal_octez_dal_config.Dal_config.parameters</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="#type-t">t</a>, <span>[&gt; <span>`Fail of string</span> ]</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>make</code> precomputes the set of values needed by the cryptographic primitives defined in this module and stores them in a value of type <code>t</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-parameters"><a href="#val-parameters" class="anchor"></a><code><span><span class="keyword">val</span> parameters : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../Tezos_crypto_dal_octez_dal_config/Dal_config/index.html#type-parameters">Tezos_crypto_dal_octez_dal_config.Dal_config.parameters</a></span></code></div><div class="spec-doc"><p><code>parameters t</code> returns the parameters given when <code>t</code> was initialised with the function <a href="#val-make"><code>make</code></a></p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Commitment_proof"><a href="#module-Commitment_proof" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Commitment_proof/index.html">Commitment_proof</a></span><span> : 
  <a href="../../Kzg/Interfaces/module-type-Degree_check_proof/index.html">Kzg.Interfaces.Degree_check_proof</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../../Kzg/Interfaces/module-type-Degree_check_proof/index.html#type-t">t</a> := <a href="#type-commitment_proof">commitment_proof</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-verify_commitment"><a href="#val-verify_commitment" class="anchor"></a><code><span><span class="keyword">val</span> verify_commitment : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-commitment">commitment</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-commitment_proof">commitment_proof</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>verify_commitment t commitment proof</code> returns <code>true</code> if and only if the size of the data committed via <code>commitment</code> does not exceed the <code>slot_size</code> declared in <code>t</code>.</p><p>The verification time is constant.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-page"><a href="#type-page" class="anchor"></a><code><span><span class="keyword">type</span> page</span><span> = bytes</span></code></div><div class="spec-doc"><p>The original slot can be split into a list of pages of fixed size. This size is given by the parameter <code>page_size</code> given to the function <a href="#val-make"><code>make</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-page_proof_encoding"><a href="#val-page_proof_encoding" class="anchor"></a><code><span><span class="keyword">val</span> page_proof_encoding : <span><a href="#type-page_proof">page_proof</a> <a href="../../Data_encoding/index.html#type-t">Data_encoding.t</a></span></span></code></div><div class="spec-doc"><p>An encoding for the proof of a page.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pages_per_slot"><a href="#val-pages_per_slot" class="anchor"></a><code><span><span class="keyword">val</span> pages_per_slot : 
  <span><a href="../../Tezos_crypto_dal_octez_dal_config/Dal_config/index.html#type-parameters">Tezos_crypto_dal_octez_dal_config.Dal_config.parameters</a> <span class="arrow">&#45;&gt;</span></span>
  int</span></code></div><div class="spec-doc"><p><code>pages_per_slot t</code> returns the number of expected pages per slot.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-verify_page"><a href="#val-verify_page" class="anchor"></a><code><span><span class="keyword">val</span> verify_page : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-commitment">commitment</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">page_index</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-page">page</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-page_proof">page_proof</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(unit,
    <span>[&gt; <span>`Invalid_degree_strictly_less_than_expected of
         <span><span>(int, int)</span> <a href="#type-error_container">error_container</a></span></span>
    <span>| `Invalid_page</span>
    <span>| `Page_length_mismatch</span>
    <span>| `Page_index_out_of_range</span> ]</span>)</span>
    <span class="xref-unresolved">Stdlib</span>.Result.t</span></span></code></div><div class="spec-doc"><p><code>verify_page t commitment ~page_index page proof</code> returns <code>Ok ()</code> if the <code>proof</code> certifies that the <code>page</code> is the <code>page_index</code>-th page of the slot with the given <code>commitment</code>.</p><p>Fails with:</p><ul><li><code>Error `Invalid_page</code> if the verification Fails</li><li><code>Error `Invalid_degree_strictly_less_than_expected _</code> if the SRS contained in <code>t</code> is too small to proceed with the verification</li><li><code>Error `Page_length_mismatch</code> if the page is not of the expected length <code>page_size</code> given for the initialisation of <code>t</code></li><li><code>Error `Page_index_out_of_range</code> if <code>page_index</code> is out of the range <code>0, slot_size/page_size - 1</code> where <code>slot_size</code> and <code>page_size</code> are given for the initialisation of <code>t</code></li></ul><p>Ensures:</p><ul><li><code>verify_page t commitment ~page_index page proof = Ok ()</code> if and only if <code>page = Bytes.sub slot (page_index * t.page_size) t.page_size</code>), <code>proof = prove_page t polynomial page_index</code>, <code>p = polynomial_from_slot t slot</code>, and <code>commitment = commit t p</code>.</li></ul></div></div></details></div><div class="odoc-spec"><div class="spec module anchored" id="module-Commitment"><a href="#module-Commitment" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Commitment/index.html">Commitment</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-share_encoding"><a href="#val-share_encoding" class="anchor"></a><code><span><span class="keyword">val</span> share_encoding : <span><a href="#type-share">share</a> <a href="../../Data_encoding/index.html#type-t">Data_encoding.t</a></span></span></code></div><div class="spec-doc"><p>Encoding of a share.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-shard_encoding"><a href="#val-shard_encoding" class="anchor"></a><code><span><span class="keyword">val</span> shard_encoding : <span><a href="#type-shard">shard</a> <a href="../../Data_encoding/index.html#type-t">Data_encoding.t</a></span></span></code></div><div class="spec-doc"><p>An encoding of a share.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-encoded_share_size"><a href="#val-encoded_share_size" class="anchor"></a><code><span><span class="keyword">val</span> encoded_share_size : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>encoded_share_size t</code> returns the size of a share in byte depending on <code>t</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-polynomial_from_shards"><a href="#val-polynomial_from_shards" class="anchor"></a><code><span><span class="keyword">val</span> polynomial_from_shards : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-shard">shard</a> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="#type-polynomial">polynomial</a>,
    <span>[&gt; <span>`Not_enough_shards of string</span>
    <span><span>| `Shard_index_out_of_range</span> of string</span>
    <span><span>| `Invalid_shard_length</span> of string</span> ]</span>)</span>
    <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>polynomial_from_shards t shards</code> computes the original polynomial from <code>shards</code>. The proportion of shards needed is <code>1</code> over <code>redundancy_factor</code> the total number of shards declared in <code>t</code>.</p><p>Requires:</p><ul><li><code>Seq.length shards &gt;= number_of_shards / redundancy_factor</code> (where <code>number_of_shards</code> and <code>redundancy_factor</code> are found in <code>t</code>) .</li></ul><p>Ensures:</p><ul><li>For any <code>p</code>, let <code>shards = shards_from_polynomial p</code>, for any subset S of shards of <code>polynomial_length / shard_length</code> elements, <code>polynomial_from_shards S = p</code>. Here, <code>polynomial_length</code> and <code>shard_length</code> are parameters declared in <code>t</code>.</li></ul><p>Fails with:</p><ul><li><code>Error (`Not_enough_shards msg)</code> if there aren't at least <code>number_of_shards / redundancy_factor</code> shards (where these two parameters are found in <code>t</code>)</li><li><code>Error (`Shard_index_out_of_range msg)</code> if one shard index is not within the range <code>0, number_of_shards - 1</code> (where <code>number_of_shards</code> is declared in <code>t</code>).</li><li><code>Error (`Invalid_shard_length msg)</code> if one shard is not of the expected length.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-shards_from_polynomial"><a href="#val-shards_from_polynomial" class="anchor"></a><code><span><span class="keyword">val</span> shards_from_polynomial : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-polynomial">polynomial</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-shard">shard</a> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p><code>shards_from_polynomial t polynomial</code> computes all the shards encoding the original <code>polynomial</code>.</p><p>Ensures:</p><ul><li>For any <code>p</code>, let <code>shards = shards_from_polynomial p</code>, for any subset S of shards of <code>polynomial_length / shard_length</code> elements, <code>polynomial_from_shards S = p</code>. Here, <code>polynomial_length</code> and <code>shard_length</code> are parameters declared in <code>t</code>. The shards in the returned sequence have increasing indexes.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-shard_proof_encoding"><a href="#val-shard_proof_encoding" class="anchor"></a><code><span><span class="keyword">val</span> shard_proof_encoding : <span><a href="#type-shard_proof">shard_proof</a> <a href="../../Data_encoding/index.html#type-t">Data_encoding.t</a></span></span></code></div><div class="spec-doc"><p>An encoding of a shard proof.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-verify_shard"><a href="#val-verify_shard" class="anchor"></a><code><span><span class="keyword">val</span> verify_shard : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-commitment">commitment</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-shard">shard</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-shard_proof">shard_proof</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(unit,
    <span>[&gt; <span>`Invalid_degree_strictly_less_than_expected of
         <span><span>(int, int)</span> <a href="#type-error_container">error_container</a></span></span>
    <span>| `Invalid_shard</span>
    <span>| `Shard_length_mismatch</span>
    <span><span>| `Shard_index_out_of_range</span> of string</span> ]</span>)</span>
    <span class="xref-unresolved">Stdlib</span>.Result.t</span></span></code></div><div class="spec-doc"><p><code>verify_shard t commitment shard proof</code> returns <code>Ok ()</code> if <code>shard</code> is an element of <code>shards_from_polynomial p</code> where <code>commitment = commit t p</code> for some polynomial <code>p</code>.</p><p>The verification time is constant.</p><p>Requires:</p><ul><li>The SRS (structured reference string) contained in <code>t</code> should be the same as the one used to produce the <code>commitment</code> and <code>proof</code>.</li></ul><p>Fails with:</p><ul><li><code>Error `Invalid_shard</code> if the verification fails</li><li><code>Error `Invalid_degree_strictly_less_than_expected _</code> if the SRS contained in <code>t</code> is too small to proceed with the verification</li><li><code>Error `Shard_length_mismatch</code> if the shard is not of the expected length <code>shard_length</code> given for the initialisation of <code>t</code></li><li><code>Error (`Shard_index_out_of_range msg)</code> if the shard index is not within the range <code>0, number_of_shards - 1</code> (where <code>number_of_shards</code> is found in <code>t</code>).</li></ul><p>Ensures:</p><ul><li><code>verify_shard t commitment shard proof = Ok ()</code> if and only if <code>Array.mem shard (shards_from_polynomial t polynomial</code>), <code>precomputation = precompute_shards_proofs t</code>, <code>proof = (prove_shards t ~precomputation ~polynomial).(shard.index)</code>, and <code>commitment = commit t p</code>.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-verify_shard_multi"><a href="#val-verify_shard_multi" class="anchor"></a><code><span><span class="keyword">val</span> verify_shard_multi : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-commitment">commitment</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-shard">shard</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-shard_proof">shard_proof</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(unit,
    <span>[&gt; <span>`Invalid_degree_strictly_less_than_expected of
         <span><span>(int, int)</span> <a href="#type-error_container">error_container</a></span></span>
    <span>| `Invalid_shard</span>
    <span>| `Shard_length_mismatch</span>
    <span><span>| `Shard_index_out_of_range</span> of string</span> ]</span>)</span>
    <span class="xref-unresolved">Stdlib</span>.Result.t</span></span></code></div><div class="spec-doc"><p>Batched version of verify_shard, for better verifier performance. <code>verify_shard_multi t commitment shard_list proof_list</code> returns <code>Ok ()</code> if for all i List.nth i <code>shard</code> is an element of <code>shards_from_polynomial p</code> where <code>commitment = commit t p</code> for some polynomial <code>p</code>, and the proofs are correctly generated.</p><p>The verification time smaller than calling List.lenght shard_list times the verify_shard function.</p><p>Requires:</p><ul><li>The SRS (structured reference string) contained in <code>t</code> should be the same as the one used to produce the <code>commitment</code> and <code>proof</code>.</li></ul><p>Fails with:</p><ul><li><code>Error `Invalid_shard</code> if the verification fails</li><li><code>Error `Invalid_degree_strictly_less_than_expected _</code> if the SRS contained in <code>t</code> is too small to proceed with the verification</li><li><code>Error `Shard_length_mismatch</code> if one of the shard is not of the expected length <code>shard_length</code> given for the initialisation of <code>t</code></li><li><code>Error (`Shard_index_out_of_range msg)</code> if one of the shard index is not within the range <code>0, number_of_shards - 1</code> (where <code>number_of_shards</code> is found in <code>t</code>).</li></ul><p>Ensures:</p><ul><li><code>verify_shard_multi t commitment shard_list proof_list = Ok ()</code> if and only if <code>Array.mem (List.nth i shard_list) (shards_from_polynomial t polynomial</code>), <code>precomputation = precompute_shards_proofs t</code>, <code>List.nth i proof_list = (prove_shards t ~precomputation ~polynomial).
    (List. nth i (shard_list.index))</code>, for all i and <code>commitment = commit t p</code>.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-prove_commitment"><a href="#val-prove_commitment" class="anchor"></a><code><span><span class="keyword">val</span> prove_commitment : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-polynomial">polynomial</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="#type-commitment_proof">commitment_proof</a>,
    <span>[&gt; <span>`Invalid_degree_strictly_less_than_expected of
         <span><span>(int, int)</span> <a href="#type-error_container">error_container</a></span></span>
    <span>| `Prover_SRS_not_loaded</span> ]</span>)</span>
    <span class="xref-unresolved">Stdlib</span>.Result.t</span></span></code></div><div class="spec-doc"><p><code>prove_commitment t polynomial</code> produces a proof that the slot represented by <code>polynomial</code> has its size bounded by <code>slot_size</code> declared in <code>t</code>.</p><p>Fails with:</p><ul><li><code>Error `Invalid_degree_strictly_less_than_expected _</code> if the SRS contained in <code>t</code> is too small to produce the proof</li><li><code>Error `Prover_SRS_not_loaded</code> if the prover’s SRS is not loaded (ie: <code>init_dal_verifier</code> has been used to load the SRS).</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-prove_page"><a href="#val-prove_page" class="anchor"></a><code><span><span class="keyword">val</span> prove_page : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-polynomial">polynomial</a> <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="#type-page_proof">page_proof</a>,
    <span>[&gt; <span>`Invalid_degree_strictly_less_than_expected of
         <span><span>(int, int)</span> <a href="#type-error_container">error_container</a></span></span>
    <span>| `Page_index_out_of_range</span>
    <span>| `Prover_SRS_not_loaded</span> ]</span>)</span>
    <span class="xref-unresolved">Stdlib</span>.Result.t</span></span></code></div><div class="spec-doc"><p><code>prove_page t polynomial n</code> produces a proof for the <code>n</code>-th page of the <code>slot</code> such that <code>polynomial = polynomial_from_slot t slot</code>. This proof can be used to verify given a commitment to a slot that a byte sequence is indeed the <code>n</code>-th page of the slot (see Ensures section below).</p><p>Fails with:</p><ul><li><code>Error `Invalid_degree_strictly_less_than_expected _</code> if the SRS contained in <code>t</code> is too small to produce the proof</li><li><code>Error (`Page_index_out_of_range msg)</code> if the page index is not within the range <code>0, slot_size/page_size - 1</code> (where <code>slot_size</code> and <code>page_size</code> are found in <code>t</code>).</li><li><code>Error `Prover_SRS_not_loaded</code> if the SRS has been loaded with <code>init_dal_verifier</code>.</li></ul><p>Ensures:</p><ul><li><code>verify_page t commitment ~page_index page page_proof = Ok ()</code> if and only if <code>page = Bytes.sub slot (page_index * t.page_size) t.page_size</code>), <code>page_proof = prove_page t polynomial page_index</code>, <code>p = polynomial_from_slot t slot</code>, and <code>commitment = commit t p</code>.</li></ul></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-shards_proofs_precomputation"><a href="#type-shards_proofs_precomputation" class="anchor"></a><code><span><span class="keyword">type</span> shards_proofs_precomputation</span></code></div><div class="spec-doc"><p>The precomputation used to produce shard proofs.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-shards_proofs_precomputation_encoding"><a href="#val-shards_proofs_precomputation_encoding" class="anchor"></a><code><span><span class="keyword">val</span> shards_proofs_precomputation_encoding : 
  <span><a href="#type-shards_proofs_precomputation">shards_proofs_precomputation</a> <a href="../../Data_encoding/index.html#type-t">Data_encoding.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-precompute_shards_proofs"><a href="#val-precompute_shards_proofs" class="anchor"></a><code><span><span class="keyword">val</span> precompute_shards_proofs : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="#type-shards_proofs_precomputation">shards_proofs_precomputation</a>,
    <span>[&gt; <span>`Invalid_degree_strictly_less_than_expected of
         <span><span>(int, int)</span> <a href="#type-error_container">error_container</a></span></span> ]</span>)</span>
    <span class="xref-unresolved">Stdlib</span>.Result.t</span></span></code></div><div class="spec-doc"><p><code>precomputation_shard_proofs t</code> returns the precomputation used to produce shard proofs.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-save_precompute_shards_proofs"><a href="#val-save_precompute_shards_proofs" class="anchor"></a><code><span><span class="keyword">val</span> save_precompute_shards_proofs : 
  <span><a href="#type-shards_proofs_precomputation">shards_proofs_precomputation</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">filename</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span>unit <a href="../../Tezos_error_monad/Error_monad/index.html#type-tzresult">Tezos_error_monad.Error_monad.tzresult</a></span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>save_precompute_shards_proofs precomputation ~filename</code> saves the given <code>precomputation</code> to disk with the given <code>filename</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-load_precompute_shards_proofs"><a href="#val-load_precompute_shards_proofs" class="anchor"></a><code><span><span class="keyword">val</span> load_precompute_shards_proofs : 
  <span><span class="label">hash</span>:<span><a href="../../Tezos_crypto/Blake2B/index.html#type-t">Tezos_crypto.Blake2B.t</a> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">filename</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span>unit <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-shards_proofs_precomputation">shards_proofs_precomputation</a> <a href="../../Tezos_error_monad/Error_monad/index.html#type-tzresult">Tezos_error_monad.Error_monad.tzresult</a></span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>load_precompute_shards_proofs ~hash ~filename ()</code> loads the precomputation from disk from the given <code>filename</code>. If <code>hash</code> is not <code>None</code>, an integrity check of the retrieved precomputation is performed.</p><p>Returns the error <code>Invalid_precomputation_hash</code> if the integrity check fails.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-hash_precomputation"><a href="#val-hash_precomputation" class="anchor"></a><code><span><span class="keyword">val</span> hash_precomputation : 
  <span><a href="#type-shards_proofs_precomputation">shards_proofs_precomputation</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../Tezos_crypto/Blake2B/index.html#type-t">Tezos_crypto.Blake2B.t</a></span></code></div><div class="spec-doc"><p><code>hash_precomputation precomputation</code> returns the <a href="../../Tezos_crypto/Blake2B/index.html#type-t"><code>Tezos_crypto.Blake2B.t</code></a> hash of the <a href="../../Data_encoding/index.html#type-t"><code>Data_encoding.t</code></a> value of <code>precomputation</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>a</code> <p><a href="../../Data_encoding/V1/Binary/index.html#exception-Write_error"><code>Data_encoding.Binary.Write_error</code></a> if <code>precomputation</code> can't be serialized to a value <a href="#val-shards_proofs_precomputation_encoding"><code>shards_proofs_precomputation_encoding</code></a>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-prove_shards"><a href="#val-prove_shards" class="anchor"></a><code><span><span class="keyword">val</span> prove_shards : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">precomputation</span>:<a href="#type-shards_proofs_precomputation">shards_proofs_precomputation</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">polynomial</span>:<a href="#type-polynomial">polynomial</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-shard_proof">shard_proof</a> array</span></span></code></div><div class="spec-doc"><p><code>prove_shards t ~precomputation ~polynomial</code> produces <code>number_of_shards</code> proofs <code>(π_0, ..., π_{number_of_shards - 1})</code> for the elements of <code>polynomial_from_shards polynomial</code> (where <code>number_of_shards</code> is declared in <code>t</code>) using the <code>precomputation</code>.</p><p>Requires:</p><ul><li><code>polynomial = polynomial_from_slot t s</code> for some slot <code>s</code> and the same value <code>t</code> used in <code>prove_shards</code>. Since the caller of <code>prove_shards</code> knows <code>polynomial</code>, it is its responsibility to enforce this requirement.</li><li><code>precomputation = precompute_shards_proofs t</code> with the same value <code>t</code> used in <code>prove_shards</code>. There is no way for this function to check that the <code>precomputation</code> is correct since it doesn't compute it.</li></ul><p>Ensures:</p><ul><li><code>verify_shard t commitment shard proof = Ok ()</code> if and only if <code>Array.mem shard (shards_from_polynomial t polynomial</code>) <code>proof = (prove_shards t polynomial).(shard.index)</code>, and <code>commitment = commit t polynomial</code>.</li></ul></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Internal_for_tests"><a href="#module-Internal_for_tests" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Internal_for_tests/index.html">Internal_for_tests</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-init_prover_dal"><a href="#val-init_prover_dal" class="anchor"></a><code><span><span class="keyword">val</span> init_prover_dal : 
  <span><span class="label">find_srs_files</span>:
    <span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span><span>(string * string)</span> <a href="../../Tezos_error_monad/Error_monad/index.html#type-tzresult">Tezos_error_monad.Error_monad.tzresult</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?srs_size_log2</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span>unit <span class="arrow">&#45;&gt;</span></span>
  <span><span>unit <a href="../../Tezos_error_monad/Error_monad/index.html#type-tzresult">Tezos_error_monad.Error_monad.tzresult</a></span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>init_prover_dal ~find_srs_files ?(srs_size_log2=21) ()</code> initializes the DAL in &quot;prover&quot; mode, given the function <code>find_srs_files</code> to find the SRS files, and the optional log2 of the SRS size <code>srs_size_log2</code>. Note that the both proving &amp; verifying functions can be used with this setup. If this function is not called only verifying functions are available.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Config"><a href="#module-Config" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Config/index.html">Config</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>node parameters for the DAL.</p></div></div></div></body></html>
