<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>MakeUnivariate (octez-libs.Polynomial.MakeUnivariate)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">octez-libs</a> &#x00BB; <a href="../index.html">Polynomial</a> &#x00BB; MakeUnivariate</nav><header class="odoc-preamble"><h1>Module <code><span>Polynomial.MakeUnivariate</span></code></h1><p><code>Make(Fp)</code> builds a module of type <code>T</code> where the coefficients are in the prime field Fp</p></header><nav class="odoc-toc"><ul><li><a href="#parameters">Parameters</a></li><li><a href="#signature">Signature</a></li></ul></nav><div class="odoc-content"><h2 id="parameters"><a href="#parameters" class="anchor"></a>Parameters</h2><div class="odoc-spec"><div class="spec parameter anchored" id="argument-1-R"><a href="#argument-1-R" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="argument-1-R/index.html">R</a></span><span> : <a href="../../../bls12-381/Bls12_381/Ff_sig/module-type-PRIME/index.html">Bls12_381.Ff_sig.PRIME</a></span></code></div></div><h2 id="signature"><a href="#signature" class="anchor"></a>Signature</h2><div class="odoc-spec"><div class="spec type anchored" id="type-scalar"><a href="#type-scalar" class="anchor"></a><code><span><span class="keyword">type</span> scalar</span><span> = <a href="argument-1-R/index.html#type-t">R.t</a></span></code></div><div class="spec-doc"><p>The type of the polynomial coefficients. Can be a field or more generally a ring. For the moment, it is restricted to prime fields.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>Represents a polynomial</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-zero"><a href="#val-zero" class="anchor"></a><code><span><span class="keyword">val</span> zero : <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Returns the polynomial <code>P(X) = 0</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-one"><a href="#val-one" class="anchor"></a><code><span><span class="keyword">val</span> one : <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Returns the polynomial <code>P(X) = 1</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-degree"><a href="#val-degree" class="anchor"></a><code><span><span class="keyword">val</span> degree : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../index.html#type-natural_with_infinity">natural_with_infinity</a></span></code></div><div class="spec-doc"><p>Returns the degree of the polynomial</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-degree_int"><a href="#val-degree_int" class="anchor"></a><code><span><span class="keyword">val</span> degree_int : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-have_same_degree"><a href="#val-have_same_degree" class="anchor"></a><code><span><span class="keyword">val</span> have_same_degree : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>have_same_degree P Q</code> returns <code>true</code> if <code>P</code> and <code>Q</code> have the same degree</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_dense_polynomial_coefficients"><a href="#val-get_dense_polynomial_coefficients" class="anchor"></a><code><span><span class="keyword">val</span> get_dense_polynomial_coefficients : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-scalar">scalar</a> list</span></span></code></div><div class="spec-doc"><p><code>get_dense_polynomial_coefficients P</code> returns the list of the coefficients of P, including the null coefficients, in decreasing order i.e. if <code>P(X) = a_{0} + a_{1} X + ... + a_{n - 1} X^{n - 1}</code>, the function will return <code>a_{n - 1}, ..., a_{0}</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_dense_polynomial_coefficients_with_degree"><a href="#val-get_dense_polynomial_coefficients_with_degree" class="anchor"></a><code><span><span class="keyword">val</span> get_dense_polynomial_coefficients_with_degree : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-scalar">scalar</a> * int)</span> list</span></span></code></div><div class="spec-doc"><p><code>get_dense_polynomial_coefficients_with_degree P</code> returns the list of the coefficients of P with the degree as a tuple, including the null coefficients, in decreasing order i.e. if <code>P(X) = a_{0} + a_{1} X + ... + a_{n - 1} X^{n - 1}</code>, the function will return <code>(a_{n - 1}, n -1), ..., (a_{0}, 0)</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_list_coefficients"><a href="#val-get_list_coefficients" class="anchor"></a><code><span><span class="keyword">val</span> get_list_coefficients : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-scalar">scalar</a> * int)</span> list</span></span></code></div><div class="spec-doc"><p><code>get_list_coefficients P</code> returns <code>(a_4,4), (a_2,2), (a_0,0)</code> if P = a_4 X^4 + a_2 X^2 + a_0</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-evaluation"><a href="#val-evaluation" class="anchor"></a><code><span><span class="keyword">val</span> evaluation : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-scalar">scalar</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-scalar">scalar</a></span></code></div><div class="spec-doc"><p><code>evaluation P s</code> computes <code>P(s)</code>. Use Horner's method in O(n).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-constants"><a href="#val-constants" class="anchor"></a><code><span><span class="keyword">val</span> constants : <span><a href="#type-scalar">scalar</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>constants s</code> returns the constant polynomial <code>P(X) = s</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add"><a href="#val-add" class="anchor"></a><code><span><span class="keyword">val</span> add : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>add P Q</code> returns <code>P(X) + Q(X)</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sub"><a href="#val-sub" class="anchor"></a><code><span><span class="keyword">val</span> sub : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>sub P Q</code> returns <code>P(X) - Q(X)</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mult_by_scalar"><a href="#val-mult_by_scalar" class="anchor"></a><code><span><span class="keyword">val</span> mult_by_scalar : <span><a href="#type-scalar">scalar</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>mult_by_scalar s P</code> returns <code>s*P(X)</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_null"><a href="#val-is_null" class="anchor"></a><code><span><span class="keyword">val</span> is_null : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_null P</code> returns <code>true</code> iff <code>P(X) = 0</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_constant"><a href="#val-is_constant" class="anchor"></a><code><span><span class="keyword">val</span> is_constant : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_constant P</code> returns <code>true</code> iff <code>P(X) = s</code> for s scalar</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-opposite"><a href="#val-opposite" class="anchor"></a><code><span><span class="keyword">val</span> opposite : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>opposite P</code> returns <code>-P(X)</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>equal P Q</code> returns <code>true</code> iff <code>P(X) = Q(X)</code> on S</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_coefficients"><a href="#val-of_coefficients" class="anchor"></a><code><span><span class="keyword">val</span> of_coefficients : <span><span><span>(<a href="#type-scalar">scalar</a> * int)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_coefficients [(x_0, y_0) ; (x_1, y_1); ... ; (x_n ; y_n)]</code> builds the polynomial Î£(a_i * X^i) as a type <code>t</code>.</p><p>By default, the null coefficients will be removed as the internal representation of polynomials is sparsed. However, a version with null coefficients can be generated if required. It is not recommended to use this possibility as it breaks an invariant of the type <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lagrange_interpolation"><a href="#val-lagrange_interpolation" class="anchor"></a><code><span><span class="keyword">val</span> lagrange_interpolation : <span><span><span>(<a href="#type-scalar">scalar</a> * <a href="#type-scalar">scalar</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>lagrange_interpolation [(x_0, y_0) ; (x_1, y_1); ... ; (x_n ; y_n)]</code> builds the unique polynomial P of degre n such that P(x_i) = y_i for i = 0...n using the intermediate lagrange polynomials. <code>lagrange_interpolation_fft</code> can be used in case of a FFT friendly scalar structure. It is supposed all x_i are different.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-even_polynomial"><a href="#val-even_polynomial" class="anchor"></a><code><span><span class="keyword">val</span> even_polynomial : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>even_polynomial P</code> returns the polynomial P_even containing only the even coefficients of P</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-odd_polynomial"><a href="#val-odd_polynomial" class="anchor"></a><code><span><span class="keyword">val</span> odd_polynomial : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>odd_polynomial P</code> returns the polynomial P_odd containing only the odd coefficients of P</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-evaluation_fft"><a href="#val-evaluation_fft" class="anchor"></a><code><span><span class="keyword">val</span> evaluation_fft : <span><span class="label">domain</span>:<span><a href="#type-scalar">scalar</a> array</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-scalar">scalar</a> list</span></span></code></div><div class="spec-doc"><p><code>evaluate_fft_imperative ~domain P</code> evaluates P on the points given in the <code>domain</code>. The domain should be of the form <code>g^{i}</code> where <code>g</code> is a principal root of unity. If the domain is of size <code>n</code>, <code>g</code> must be a <code>n</code>-th principal root of unity. The degree of <code>P</code> can be smaller than the domain size. Larger polynomials can also be used but the implementation is not the most memory efficient yet and must be improved. The complexity is in <code>O(n log(m))</code> where <code>n</code> is the domain size and <code>m</code> the degree of the polynomial. When <code>m</code> is smaller than <code>n</code>, the polynomial is padded with zeroes to reach <code>n</code> coefficients. The resulting list contains the evaluation points <code>P(1), P(w), ..., P(w^{n - 1})</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-generate_random_polynomial"><a href="#val-generate_random_polynomial" class="anchor"></a><code><span><span class="keyword">val</span> generate_random_polynomial : <span><a href="../index.html#type-natural_with_infinity">natural_with_infinity</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>generate_random_polynomial n</code> returns a random polynomial of degree <code>n</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_highest_coefficient"><a href="#val-get_highest_coefficient" class="anchor"></a><code><span><span class="keyword">val</span> get_highest_coefficient : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-scalar">scalar</a></span></code></div><div class="spec-doc"><p><code>get_highest_coefficient P</code> where <code>P(X) = a_n X^n + ... a_0</code> returns <code>a_n</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-interpolation_fft"><a href="#val-interpolation_fft" class="anchor"></a><code><span><span class="keyword">val</span> interpolation_fft : <span><span class="label">domain</span>:<span><a href="#type-scalar">scalar</a> array</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-scalar">scalar</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>interpolation_fft ~domain [y_{0} ; y_{1} ;
      ... y_{n}]</code> computes the interpolation at the points <code>y_{0}, ..., y_{n}</code> using FFT Cookey Tukey. The domain should be of the form <code>g^{i}</code> where <code>g</code> is a principal root of unity. If the domain is of size <code>n</code>, <code>g</code> must be a <code>n</code>-th principal root of unity. The domain size must be exactly the same than the number of points. The complexity is <code>O(n log(n))</code> where <code>n</code> is the domain size.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-polynomial_multiplication"><a href="#val-polynomial_multiplication" class="anchor"></a><code><span><span class="keyword">val</span> polynomial_multiplication : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>polynomial_multiplication P Q</code> computes the product P(X).Q(X)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-polynomial_multiplication_fft"><a href="#val-polynomial_multiplication_fft" class="anchor"></a><code><span><span class="keyword">val</span> polynomial_multiplication_fft : <span><span class="label">domain</span>:<span><a href="#type-scalar">scalar</a> array</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>polynomial_multiplication_fft ~domain P Q</code> computes the product <code>P(X).Q(X)</code> using FFT. The domain should be of the form <code>g^{i}</code> where <code>g</code> is a principal root of unity. If the domain is of size <code>n</code>, <code>g</code> must be a <code>n</code>-th principal root of unity. The degrees of <code>P</code> and <code>Q</code> can be different. The only condition is <code>degree P + degree Q</code> should be smaller or equal to <code>n - 2</code> (i.e. the domain should be big enough to compute <code>n - 1</code> points of <code>P * Q</code>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-euclidian_division_opt"><a href="#val-euclidian_division_opt" class="anchor"></a><code><span><span class="keyword">val</span> euclidian_division_opt : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-t">t</a> * <a href="#type-t">t</a>)</span> option</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-extended_euclide"><a href="#val-extended_euclide" class="anchor"></a><code><span><span class="keyword">val</span> extended_euclide : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a> * <a href="#type-t">t</a> * <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>extended_euclide P S</code> returns (GCD, U, V) the greatest common divisor of <code>P</code> and <code>S</code> and the Bezout's coefficient: <code>U P + V S = GCD</code> and <code>GCD</code> greatest coefficient is one</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(=)"><a href="#val-(=)" class="anchor"></a><code><span><span class="keyword">val</span> (=) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Infix operator for <code>equal</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(+)"><a href="#val-(+)" class="anchor"></a><code><span><span class="keyword">val</span> (+) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Infix operator for <code>add</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(*)"><a href="#val-(*)" class="anchor"></a><code><span><span class="keyword">val</span> (*) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Infix operator for <code>polynomial_multiplication</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(-)"><a href="#val-(-)" class="anchor"></a><code><span><span class="keyword">val</span> (-) : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Infix operator for <code>sub</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span><span class="keyword">val</span> to_string : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div></div></div></body></html>
