<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Micheline (octez-libs.Tezos_micheline.Micheline)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">octez-libs</a> &#x00BB; <a href="../index.html">Tezos_micheline</a> &#x00BB; Micheline</nav><header class="odoc-preamble"><h1>Module <code><span>Tezos_micheline.Micheline</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-annot"><a href="#type-annot" class="anchor"></a><code><span><span class="keyword">type</span> annot</span><span> = <span>string list</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-node"><a href="#type-node" class="anchor"></a><code><span><span class="keyword">type</span> <span>('l, 'p) node</span></span><span> = </span></code><ol><li id="type-node.Int" class="def variant constructor anchored"><a href="#type-node.Int" class="anchor"></a><code><span>| </span><span><span class="constructor">Int</span> <span class="keyword">of</span> <span class="type-var">'l</span> * <span class="xref-unresolved">Z</span>.t</span></code></li><li id="type-node.String" class="def variant constructor anchored"><a href="#type-node.String" class="anchor"></a><code><span>| </span><span><span class="constructor">String</span> <span class="keyword">of</span> <span class="type-var">'l</span> * string</span></code></li><li id="type-node.Bytes" class="def variant constructor anchored"><a href="#type-node.Bytes" class="anchor"></a><code><span>| </span><span><span class="constructor">Bytes</span> <span class="keyword">of</span> <span class="type-var">'l</span> * <span class="xref-unresolved">Stdlib</span>.Bytes.t</span></code></li><li id="type-node.Prim" class="def variant constructor anchored"><a href="#type-node.Prim" class="anchor"></a><code><span>| </span><span><span class="constructor">Prim</span> <span class="keyword">of</span> <span class="type-var">'l</span> * <span class="type-var">'p</span> * <span><span><span>(<span class="type-var">'l</span>, <span class="type-var">'p</span>)</span> <a href="#type-node">node</a></span> list</span> * <a href="#type-annot">annot</a></span></code></li><li id="type-node.Seq" class="def variant constructor anchored"><a href="#type-node.Seq" class="anchor"></a><code><span>| </span><span><span class="constructor">Seq</span> <span class="keyword">of</span> <span class="type-var">'l</span> * <span><span><span>(<span class="type-var">'l</span>, <span class="type-var">'p</span>)</span> <a href="#type-node">node</a></span> list</span></span></code></li></ol></div><div class="spec-doc"><p>The abstract syntax tree of Micheline expressions. The first parameter is used to contain locations, but can also embed custom data. The second parameter is the type of primitive names.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-location"><a href="#val-location" class="anchor"></a><code><span><span class="keyword">val</span> location : <span><span><span>(<span class="type-var">'l</span>, <span class="type-var">'p</span>)</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'l</span></span></code></div><div class="spec-doc"><p>Extract the location of the node.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-annotations"><a href="#val-annotations" class="anchor"></a><code><span><span class="keyword">val</span> annotations : <span><span><span>(<span class="type-var">'l</span>, <span class="type-var">'p</span>)</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span>string list</span></span></code></div><div class="spec-doc"><p>Extract the annotations of the node.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-canonical"><a href="#type-canonical" class="anchor"></a><code><span><span class="keyword">type</span> <span>'p canonical</span></span></code></div><div class="spec-doc"><p>Expression form using canonical integer numbering as locations. The root has number zero, and each node adds one in the order of infix traversal. To be used when locations are not important, or when one wants to attach properties to nodes in an expression without rewriting it (using an indirection table with canonical locations as keys).</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-canonical_location"><a href="#type-canonical_location" class="anchor"></a><code><span><span class="keyword">type</span> canonical_location</span><span> = int</span></code></div><div class="spec-doc"><p>Canonical integer locations that appear inside <a href="#type-canonical"><code>canonical</code></a> expressions.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-dummy_location"><a href="#val-dummy_location" class="anchor"></a><code><span><span class="keyword">val</span> dummy_location : <a href="#type-canonical_location">canonical_location</a></span></code></div><div class="spec-doc"><p>A location that won't exist in any well-formed canonical value</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-strip_locations"><a href="#val-strip_locations" class="anchor"></a><code><span><span class="keyword">val</span> strip_locations : <span><span><span>(<span class="type-var">_</span>, <span class="type-var">'p</span>)</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'p</span> <a href="#type-canonical">canonical</a></span></span></code></div><div class="spec-doc"><p>Compute the canonical form of an expression. Drops the concrete locations completely.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-root"><a href="#val-root" class="anchor"></a><code><span><span class="keyword">val</span> root : <span><span><span class="type-var">'p</span> <a href="#type-canonical">canonical</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-canonical_location">canonical_location</a>, <span class="type-var">'p</span>)</span> <a href="#type-node">node</a></span></span></code></div><div class="spec-doc"><p>Give the root node of an expression in canonical form.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-extract_locations"><a href="#val-extract_locations" class="anchor"></a><code><span><span class="keyword">val</span> extract_locations : 
  <span><span><span>(<span class="type-var">'l</span>, <span class="type-var">'p</span>)</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'p</span> <a href="#type-canonical">canonical</a></span> * <span><span>(<a href="#type-canonical_location">canonical_location</a> * <span class="type-var">'l</span>)</span> list</span></span></code></div><div class="spec-doc"><p>Compute the canonical form of an expression. Saves the concrete locations in an association list.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-inject_locations"><a href="#val-inject_locations" class="anchor"></a><code><span><span class="keyword">val</span> inject_locations : 
  <span><span>(<span><a href="#type-canonical_location">canonical_location</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'l</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'p</span> <a href="#type-canonical">canonical</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'l</span>, <span class="type-var">'p</span>)</span> <a href="#type-node">node</a></span></span></code></div><div class="spec-doc"><p>Transforms an expression in canonical form into a polymorphic one. Takes a mapping function to inject the concrete locations.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-canonical">canonical</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-canonical">canonical</a></span></span></code></div><div class="spec-doc"><p>Copies the tree, updating its primitives.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map_node"><a href="#val-map_node" class="anchor"></a><code><span><span class="keyword">val</span> map_node : 
  <span><span>(<span><span class="type-var">'la</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'lb</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'pa</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'pb</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'la</span>, <span class="type-var">'pa</span>)</span> <a href="#type-node">node</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'lb</span>, <span class="type-var">'pb</span>)</span> <a href="#type-node">node</a></span></span></code></div><div class="spec-doc"><p>Copies the tree, updating its primitives and locations.</p></div></div></div></body></html>
