<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>S (octez-libs.Tezos_error_monad.Monad_maker.S)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">octez-libs</a> &#x00BB; <a href="../../index.html">Tezos_error_monad</a> &#x00BB; <a href="../index.html">Monad_maker</a> &#x00BB; S</nav><header class="odoc-preamble"><h1>Module type <code><span>Monad_maker.S</span></code></h1><p><code>S</code> is the Tezos-specific extension to the generic monad provided by Lwtreslib. It sets some defaults (e.g., it defaults traced failures), it brings some qualified identifiers into the main unqualified part (e.g., <code>return_unit</code>), it provides some tracing helpers and some in-monad assertion checks.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-error"><a href="#type-error" class="anchor"></a><code><span><span class="keyword">type</span> error</span></code></div><div class="spec-doc"><p>for substitution</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-trace"><a href="#type-trace" class="anchor"></a><code><span><span class="keyword">type</span> <span>'error trace</span></span></code></div><div class="spec-doc"><p>for substitution</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-tztrace"><a href="#type-tztrace" class="anchor"></a><code><span><span class="keyword">type</span> tztrace</span><span> = <span><a href="#type-error">error</a> <a href="#type-trace">trace</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-tzresult"><a href="#type-tzresult" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a tzresult</span></span><span> = <span><span>(<span class="type-var">'a</span>, <a href="#type-tztrace">tztrace</a>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Lwt_syntax"><a href="#module-Lwt_syntax" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Lwt_syntax/index.html">Lwt_syntax</a></span><span> : <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <a href="../../TzLwtreslib/Monad/Lwt_syntax/index.html">TzLwtreslib.Monad.Lwt_syntax</a></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Result_syntax"><a href="#module-Result_syntax" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Result_syntax/index.html">Result_syntax</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Lwt_result_syntax"><a href="#module-Lwt_result_syntax" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Lwt_result_syntax/index.html">Lwt_result_syntax</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-classify_trace"><a href="#val-classify_trace" class="anchor"></a><code><span><span class="keyword">val</span> classify_trace : <span><a href="#type-tztrace">tztrace</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../Error_classification/index.html#type-t">Error_classification.t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_print_trace"><a href="#val-pp_print_trace" class="anchor"></a><code><span><span class="keyword">val</span> pp_print_trace : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-tztrace">tztrace</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_print_top_error_of_trace"><a href="#val-pp_print_top_error_of_trace" class="anchor"></a><code><span><span class="keyword">val</span> pp_print_top_error_of_trace : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-tztrace">tztrace</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Pretty-prints the top error of a trace</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-trace_encoding"><a href="#val-trace_encoding" class="anchor"></a><code><span><span class="keyword">val</span> trace_encoding : <span><a href="#type-tztrace">tztrace</a> <a href="../../../Data_encoding/index.html#type-t">Data_encoding.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-result_encoding"><a href="#val-result_encoding" class="anchor"></a><code><span><span class="keyword">val</span> result_encoding : <span><span><span class="type-var">'a</span> <a href="../../../Data_encoding/index.html#type-t">Data_encoding.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-tzresult">tzresult</a></span> <a href="../../../Data_encoding/index.html#type-t">Data_encoding.t</a></span></span></code></div><div class="spec-doc"><p>A serializer for result of a given type</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-record_trace"><a href="#val-record_trace" class="anchor"></a><code><span><span class="keyword">val</span> record_trace : 
  <span><span class="type-var">'err</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span><span class="type-var">'err</span> <a href="#type-trace">trace</a></span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span>, <span><span class="type-var">'err</span> <a href="#type-trace">trace</a></span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>record_trace err res</code> is either <code>res</code> if <code>res</code> is <code>Ok _</code>, or it is <code>Error (Trace.cons err tr)</code> if <code>res</code> is <code>Error tr</code>.</p><p>In other words, <code>record_trace err res</code> enriches the trace that is carried by <code>res</code> (if it is carrying a trace) with the error <code>err</code>. It leaves <code>res</code> untouched if <code>res</code> is not carrying a trace.</p><p>You can use this to add high-level information to potential low-level errors. E.g.,</p><pre class="language-ocaml"><code>record_trace
   Failure_to_load_config
   (load_data_from_file config_encoding config_file_name)</code></pre><p>Note that <code>record_trace</code> takes a <em>fully evaluated</em> error <code>err</code> as argument. It means that, whatever the value of the result <code>res</code>, the error <code>err</code> is evaluated. This is not an issue if the error is a simple expression (a literal or a constructor with simple parameters). However, for any expression that is more complex (e.g., one that calls a function) you should prefer <code>record_trace_eval</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-trace"><a href="#val-trace" class="anchor"></a><code><span><span class="keyword">val</span> trace : 
  <span><span class="type-var">'err</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span><span>(<span class="type-var">'b</span>, <span><span class="type-var">'err</span> <a href="#type-trace">trace</a></span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'b</span>, <span><span class="type-var">'err</span> <a href="#type-trace">trace</a></span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>trace</code> is identical to <code>record_trace</code> but applies to a promise. More formally, <code>trace err p</code> is a promise that resolves to <code>Ok v</code> if <code>p</code> resolves to <code>Ok v</code>, or it resolves to <code>Error (Trace.cons err tr)</code> if <code>res</code> resolves to <code>Error tr</code>.</p><p>In other words, <code>trace err p</code> enriches the trace that <code>p</code> resolves to (if it does resolve to a trace) with the error <code>err</code>. It leaves the value that <code>p</code> resolves to untouched if it is not a trace.</p><p>You can use this to add high-level information to potential low-level errors.</p><p>Note that, like <a href="#val-record_trace"><code>record_trace</code></a>, <code>trace</code> takes a fully evaluated error as argument. For a similar reason as explained there, you should only use <code>trace</code> with simple expressions (literal or constructor with simple parameters) and prefer <code>trace_eval</code> for any other expression (such as ones that include functions calls).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-record_trace_eval"><a href="#val-record_trace_eval" class="anchor"></a><code><span><span class="keyword">val</span> record_trace_eval : 
  <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'err</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span><span class="type-var">'err</span> <a href="#type-trace">trace</a></span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span>, <span><span class="type-var">'err</span> <a href="#type-trace">trace</a></span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>record_trace_eval</code> is identical to <code>record_trace</code> except that the error that enriches the trace is wrapped in a function that is evaluated only if it is needed. More formally <code>record_trace_eval mkerr res</code> is <code>res</code> if <code>res</code> is <code>Ok _</code>, or it is <code>Error (Trace.cons (mkerr ()) tr)</code> if <code>res</code> is <code>Error tr</code>.</p><p>You can achieve the same effect by hand with</p><pre class="language-ocaml"><code>match res with
| Ok _ -&gt; res
| Error tr -&gt; Error (Trace.cons (mkerr ()) tr)</code></pre><p>Prefer <code>record_trace_eval</code> over <code>record_trace</code> when the enriching error is expensive to compute or heavy to allocate.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-trace_eval"><a href="#val-trace_eval" class="anchor"></a><code><span><span class="keyword">val</span> trace_eval : 
  <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'err</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span><span>(<span class="type-var">'b</span>, <span><span class="type-var">'err</span> <a href="#type-trace">trace</a></span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'b</span>, <span><span class="type-var">'err</span> <a href="#type-trace">trace</a></span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>trace_eval</code> is identical to <code>trace</code> except that the error that enriches the trace is wrapped in a function that is evaluated only if <em>and when</em> it is needed. More formally <code>trace_eval mkerr p</code> is a promise that resolves to <code>Ok v</code> if <code>p</code> resolves to <code>Ok v</code>, or it resolves to <code>Error (Trace.cons err tr)</code> if <code>p</code> resolves to <code>Error tr</code> and then <code>mkerr
      ()</code> resolves to <code>err</code>.</p><p>You can achieve the same effect by hand with</p><pre class="language-ocaml"><code>p &gt;&gt;= function
| Ok _ -&gt; p
| Error tr -&gt;
   mkerr () &gt;&gt;= fun err -&gt;
   Lwt.return (Error (Trace.cons err tr))</code></pre><p>Note that the evaluation of the error can be arbitrarily delayed. Avoid using references and other mutable values in the function <code>mkerr</code>.</p><p>Prefer <code>trace_eval</code> over <code>trace</code> when the enriching error is expensive to compute or heavy to allocate or when evaluating it requires the use of Lwt.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-error_unless"><a href="#val-error_unless" class="anchor"></a><code><span><span class="keyword">val</span> error_unless : <span>bool <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'err</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(unit, <span><span class="type-var">'err</span> <a href="#type-trace">trace</a></span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>error_unless flag err</code> is <code>Ok ()</code> if <code>b</code> is <code>true</code>, it is <code>Error (Trace.make err)</code> otherwise.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-error_when"><a href="#val-error_when" class="anchor"></a><code><span><span class="keyword">val</span> error_when : <span>bool <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'err</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(unit, <span><span class="type-var">'err</span> <a href="#type-trace">trace</a></span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>error_when flag err</code> is <code>Error (Trace.make err)</code> if <code>b</code> is <code>true</code>, it is <code>Ok ()</code> otherwise.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fail_unless"><a href="#val-fail_unless" class="anchor"></a><code><span><span class="keyword">val</span> fail_unless : <span>bool <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'err</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(unit, <span><span class="type-var">'err</span> <a href="#type-trace">trace</a></span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>fail_unless flag err</code> is <code>Lwt.return @@ Ok ()</code> if <code>b</code> is <code>true</code>, it is <code>Lwt.return @@ Error (Trace.make err)</code> otherwise.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fail_when"><a href="#val-fail_when" class="anchor"></a><code><span><span class="keyword">val</span> fail_when : <span>bool <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'err</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(unit, <span><span class="type-var">'err</span> <a href="#type-trace">trace</a></span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>fail_when flag err</code> is <code>Lwt.return @@ Error (Trace.make err)</code> if <code>b</code> is <code>true</code>, it is <code>Lwt.return @@ Ok ()</code> otherwise.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unless"><a href="#val-unless" class="anchor"></a><code><span><span class="keyword">val</span> unless : 
  <span>bool <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span><span><span>(unit, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(unit, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>unless b f</code> is <code>f ()</code> if <code>b</code> is <code>false</code> and it is a promise already resolved to <code>Ok ()</code> otherwise.</p><p>You can use <code>unless</code> to avoid having to write an <code>if</code> statement that you then need to populate entirely to satisfy the type-checker. E.g, you can write <code>unless b f</code> instead of <code>if not b then f () else return_unit</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-when_"><a href="#val-when_" class="anchor"></a><code><span><span class="keyword">val</span> when_ : 
  <span>bool <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span><span><span>(unit, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(unit, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>when_ b f</code> is <code>f ()</code> if <code>b</code> is <code>true</code> and it is a promise already resolved to <code>Ok ()</code> otherwise.</p><p>You can use <code>when_</code> to avoid having to write an <code>if</code> statement that you then need to populate entirely to satisfy the type-checker. E.g, you can write <code>when_ b f</code> instead of <code>if b then f () else return_unit</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-dont_wait"><a href="#val-dont_wait" class="anchor"></a><code><span><span class="keyword">val</span> dont_wait : 
  <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span><span><span>(unit, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'trace</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>exn <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Wrapper around <code>Lwt_utils.dont_wait</code></p></div></div></div></body></html>
