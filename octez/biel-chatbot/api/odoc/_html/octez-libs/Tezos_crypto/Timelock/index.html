<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Timelock (octez-libs.Tezos_crypto.Timelock)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">octez-libs</a> &#x00BB; <a href="../index.html">Tezos_crypto</a> &#x00BB; Timelock</nav><header class="odoc-preamble"><h1>Module <code><span>Tezos_crypto.Timelock</span></code></h1><p><code>Timelock</code> is a set of functions to handle time-locking a value and opening time-locked values.</p><p>A time-locked value can be opened slowly by anyone doing a fixed number of sequential operations.</p><p>In the interface of this module, this fixed number is consistently named <code>time</code> and is represented by an integer.</p><p>Once opened via the slow method a proof of opening can be produced to avoid having to do so again. This proof is verifiable in logarithmic time.</p><p>In order to time-lock an arbitrary sequence of bytes, we 1. encrypt the bytes with a symmetric key, and then 2. we time-lock the symmetric key itself.</p><p>This module implements a scheme inspired by: Time-lock puzzles and timed release - Rivest, Shamir, Wagner https://people.csail.mit.edu/rivest/pubs/RSW96.pdf</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-symmetric_key"><a href="#type-symmetric_key" class="anchor"></a><code><span><span class="keyword">type</span> symmetric_key</span></code></div><div class="spec-doc"><p>We will time-lock symmetric keys to then handle arbitrary bytes</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-locked_value"><a href="#type-locked_value" class="anchor"></a><code><span><span class="keyword">type</span> locked_value</span></code></div><div class="spec-doc"><p>Locked value that can be accessed with a number of sequential operations. It is concretely a member of the RSA group.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_locked_value_opt"><a href="#val-to_locked_value_opt" class="anchor"></a><code><span><span class="keyword">val</span> to_locked_value_opt : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-locked_value">locked_value</a> option</span></span></code></div><div class="spec-doc"><p>Function taking as input a string and returning Some locked_value if the element is in the RSA group with RSA2048 as modulus, None otherwise.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_locked_value_unsafe"><a href="#val-to_locked_value_unsafe" class="anchor"></a><code><span><span class="keyword">val</span> to_locked_value_unsafe : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-locked_value">locked_value</a></span></code></div><div class="spec-doc"><p>Function taking as input a string and returning a locked_value with no check.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-unlocked_value"><a href="#type-unlocked_value" class="anchor"></a><code><span><span class="keyword">type</span> unlocked_value</span></code></div><div class="spec-doc"><p>Member of the RSA group that we will lock. In our case it represents a symmetric key.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-vdf_proof"><a href="#type-vdf_proof" class="anchor"></a><code><span><span class="keyword">type</span> vdf_proof</span></code></div><div class="spec-doc"><p>VDF proof (Wesolowski).</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-ciphertext"><a href="#type-ciphertext" class="anchor"></a><code><span><span class="keyword">type</span> ciphertext</span></code></div><div class="spec-doc"><p>A symmetric ciphertext and message authentication code, containing the bytes we want to protect</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-vdf_tuple"><a href="#type-vdf_tuple" class="anchor"></a><code><span><span class="keyword">type</span> vdf_tuple</span><span> = </span><span>{</span></code><ol><li id="type-vdf_tuple.locked_value" class="def record field anchored"><a href="#type-vdf_tuple.locked_value" class="anchor"></a><code><span>locked_value : <a href="#type-locked_value">locked_value</a>;</span></code></li><li id="type-vdf_tuple.unlocked_value" class="def record field anchored"><a href="#type-vdf_tuple.unlocked_value" class="anchor"></a><code><span>unlocked_value : <a href="#type-unlocked_value">unlocked_value</a>;</span></code></li><li id="type-vdf_tuple.vdf_proof" class="def record field anchored"><a href="#type-vdf_tuple.vdf_proof" class="anchor"></a><code><span>vdf_proof : <a href="#type-vdf_proof">vdf_proof</a>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Tuple of the RSA group comprising the locked and unlocked values as well as a (Wesolowski) proof that the unlocked value indeed corresponds to the locked one.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-timelock_proof"><a href="#type-timelock_proof" class="anchor"></a><code><span><span class="keyword">type</span> timelock_proof</span><span> = </span><span>{</span></code><ol><li id="type-timelock_proof.vdf_tuple" class="def record field anchored"><a href="#type-timelock_proof.vdf_tuple" class="anchor"></a><code><span>vdf_tuple : <a href="#type-vdf_tuple">vdf_tuple</a>;</span></code></li><li id="type-timelock_proof.nonce" class="def record field anchored"><a href="#type-timelock_proof.nonce" class="anchor"></a><code><span>nonce : <span class="xref-unresolved">Z</span>.t;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Proof that the opening of a value is the claimed value. It is concretely a vdf_tuple and a member of the RSA group.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-gen_locked_value_unsafe"><a href="#val-gen_locked_value_unsafe" class="anchor"></a><code><span><span class="keyword">val</span> gen_locked_value_unsafe : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-locked_value">locked_value</a></span></code></div><div class="spec-doc"><p>Generates almost uniformly an integer mod n. It is in the RSA group with overwhelming probability. We use this since we want to lock symmetric keys, not pre-determined messages.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Failure</code> <p>if there is not enough entropy available.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-gen_locked_value_opt"><a href="#val-gen_locked_value_opt" class="anchor"></a><code><span><span class="keyword">val</span> gen_locked_value_opt : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-locked_value">locked_value</a> option</span></span></code></div><div class="spec-doc"><p>Returns None if <code>rsa_public</code> is not RSA2048, otherwise returns Some <code>gen_locked_value_unsafe</code> <code>rsa_public</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-timelock_proof_to_symmetric_key"><a href="#val-timelock_proof_to_symmetric_key" class="anchor"></a><code><span><span class="keyword">val</span> timelock_proof_to_symmetric_key : <span><a href="#type-timelock_proof">timelock_proof</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-symmetric_key">symmetric_key</a></span></code></div><div class="spec-doc"><p>Hashes a number mod n to a symmetric key for authenticated encryption, where the number is unlocked_value**nonce mod rsa2048.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unlock_and_prove"><a href="#val-unlock_and_prove" class="anchor"></a><code><span><span class="keyword">val</span> unlock_and_prove : <span><span class="label">time</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-locked_value">locked_value</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-timelock_proof">timelock_proof</a></span></code></div><div class="spec-doc"><p>Unlock a timelock value and produces a proof certifying that the result is indeed what had been locked.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-prove"><a href="#val-prove" class="anchor"></a><code><span><span class="keyword">val</span> prove : <span><span class="label">time</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-locked_value">locked_value</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-unlocked_value">unlocked_value</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-timelock_proof">timelock_proof</a></span></code></div><div class="spec-doc"><p>Produces a proof certifying that the result is indeed what had been locked.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-verify"><a href="#val-verify" class="anchor"></a><code><span><span class="keyword">val</span> verify : <span><span class="label">time</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-locked_value">locked_value</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-timelock_proof">timelock_proof</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Verifies that <code>locked_value</code> indeed contains <code>unlocked_value</code> with parameters <code>time:int</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-precompute_timelock"><a href="#val-precompute_timelock" class="anchor"></a><code><span><span class="keyword">val</span> precompute_timelock : 
  <span><span class="optlabel">?locked_value</span>:<span><a href="#type-locked_value">locked_value</a> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?precompute_path</span>:<span>string option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">time</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span>unit <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-vdf_tuple">vdf_tuple</a></span></code></div><div class="spec-doc"><p>Precomputes a <code>vdf_tuple</code> given a <code>time:int</code> and optionally <code>locked_value</code>. If <code>precompute_path</code> is given, it will instead read <code>vdf_tuple</code> locally and if not found, will write the newly computed <code>vdf_tuple</code> there.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-proof_of_vdf_tuple"><a href="#val-proof_of_vdf_tuple" class="anchor"></a><code><span><span class="keyword">val</span> proof_of_vdf_tuple : <span><span class="label">time</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-vdf_tuple">vdf_tuple</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-locked_value">locked_value</a> * <a href="#type-timelock_proof">timelock_proof</a></span></code></div><div class="spec-doc"><p>Randomizes a <code>vdf_tuple</code> given a <code>time:int</code> (to verify the <code>vdf_tuple</code> is correct).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-encrypt"><a href="#val-encrypt" class="anchor"></a><code><span><span class="keyword">val</span> encrypt : <span><a href="#type-symmetric_key">symmetric_key</a> <span class="arrow">&#45;&gt;</span></span> <span>bytes <span class="arrow">&#45;&gt;</span></span> <a href="#type-ciphertext">ciphertext</a></span></code></div><div class="spec-doc"><p>encrypt using authenticated encryption, i.e. ciphertext contains a ciphertext and a message authentication code.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-decrypt"><a href="#val-decrypt" class="anchor"></a><code><span><span class="keyword">val</span> decrypt : <span><a href="#type-symmetric_key">symmetric_key</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-ciphertext">ciphertext</a> <span class="arrow">&#45;&gt;</span></span> <span>bytes option</span></span></code></div><div class="spec-doc"><p>Checks the message authentication code. If correct decrypt the ciphertext, otherwise returns None.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ciphertext_encoding"><a href="#val-ciphertext_encoding" class="anchor"></a><code><span><span class="keyword">val</span> ciphertext_encoding : <span><a href="#type-ciphertext">ciphertext</a> <a href="../../Data_encoding/index.html#type-t">Data_encoding.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-vdf_tuple_encoding"><a href="#val-vdf_tuple_encoding" class="anchor"></a><code><span><span class="keyword">val</span> vdf_tuple_encoding : <span><a href="#type-vdf_tuple">vdf_tuple</a> <a href="../../Data_encoding/index.html#type-t">Data_encoding.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-proof_encoding"><a href="#val-proof_encoding" class="anchor"></a><code><span><span class="keyword">val</span> proof_encoding : <span><a href="#type-timelock_proof">timelock_proof</a> <a href="../../Data_encoding/index.html#type-t">Data_encoding.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-chest"><a href="#type-chest" class="anchor"></a><code><span><span class="keyword">type</span> chest</span><span> = </span><span>{</span></code><ol><li id="type-chest.locked_value" class="def record field anchored"><a href="#type-chest.locked_value" class="anchor"></a><code><span>locked_value : <a href="#type-locked_value">locked_value</a>;</span></code></li><li id="type-chest.ciphertext" class="def record field anchored"><a href="#type-chest.ciphertext" class="anchor"></a><code><span>ciphertext : <a href="#type-ciphertext">ciphertext</a>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Contains a value (the decryption of the ciphertext) that can be provably recovered in <code>time</code> sequential operation.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-chest_encoding"><a href="#val-chest_encoding" class="anchor"></a><code><span><span class="keyword">val</span> chest_encoding : <span><a href="#type-chest">chest</a> <a href="../../Data_encoding/index.html#type-t">Data_encoding.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-chest_key"><a href="#type-chest_key" class="anchor"></a><code><span><span class="keyword">type</span> chest_key</span><span> = <a href="#type-timelock_proof">timelock_proof</a></span></code></div><div class="spec-doc"><p>Provably opens a chest in a short time.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-chest_key_encoding"><a href="#val-chest_key_encoding" class="anchor"></a><code><span><span class="keyword">val</span> chest_key_encoding : <span><a href="#type-chest_key">chest_key</a> <a href="../../Data_encoding/index.html#type-t">Data_encoding.t</a></span></span></code></div></div><p>Result of the opening of a chest. The opening can fail in two ways which we distinguish to blame the right party. One can provide a false unlocked_value or unlocked_proof, in which case we return <code>Bogus_opening</code> and the provider of the chest key is at fault. Otherwise we return <code>Correct payload</code> where <code>payload</code> is the content that had originally been put in the chest.</p><div class="odoc-spec"><div class="spec type anchored" id="type-opening_result"><a href="#type-opening_result" class="anchor"></a><code><span><span class="keyword">type</span> opening_result</span><span> = </span></code><ol><li id="type-opening_result.Correct" class="def variant constructor anchored"><a href="#type-opening_result.Correct" class="anchor"></a><code><span>| </span><span><span class="constructor">Correct</span> <span class="keyword">of</span> <span class="xref-unresolved">Stdlib</span>.Bytes.t</span></code></li><li id="type-opening_result.Bogus_opening" class="def variant constructor anchored"><a href="#type-opening_result.Bogus_opening" class="anchor"></a><code><span>| </span><span><span class="constructor">Bogus_opening</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-open_chest"><a href="#val-open_chest" class="anchor"></a><code><span><span class="keyword">val</span> open_chest : <span><a href="#type-chest">chest</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-chest_key">chest_key</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">time</span>:int <span class="arrow">&#45;&gt;</span></span> <a href="#type-opening_result">opening_result</a></span></code></div><div class="spec-doc"><p>Takes a chest, chest key and time and tries to recover the underlying plaintext. See the documentation of opening_result.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_plaintext_size"><a href="#val-get_plaintext_size" class="anchor"></a><code><span><span class="keyword">val</span> get_plaintext_size : <span><a href="#type-chest">chest</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Gives the size of the underlying plaintext in a chest in bytes. Used for gas accounting</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Internal_for_tests"><a href="#module-Internal_for_tests" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Internal_for_tests/index.html">Internal_for_tests</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-create_chest_and_chest_key"><a href="#val-create_chest_and_chest_key" class="anchor"></a><code><span><span class="keyword">val</span> create_chest_and_chest_key : 
  <span><span class="optlabel">?precompute_path</span>:<span>string option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">payload</span>:<span class="xref-unresolved">Stdlib</span>.Bytes.t <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">time</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span>unit <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-chest">chest</a> * <a href="#type-chest_key">chest_key</a></span></code></div><div class="spec-doc"><p>High level function which given a <code>payload</code>, <code>time</code> and optionally a <code>precomputed_path</code>, generates a <code>chest</code> and <code>chest_key</code>. The <code>payload</code> corresponds to the message to timelock while the <code>time</code> corresponds to the difficulty in opening the chest. Beware, it does not correspond to a duration per se but to the number of iteration needed. The optional <code>precomputation_path</code> is a local path where to read or write some auxiliary information to generate the chest quickly.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-create_chest_key"><a href="#val-create_chest_key" class="anchor"></a><code><span><span class="keyword">val</span> create_chest_key : <span><a href="#type-chest">chest</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">time</span>:int <span class="arrow">&#45;&gt;</span></span> <a href="#type-chest_key">chest_key</a></span></code></div><div class="spec-doc"><p>High level function to unlock the value and create a proof.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-chest_sampler"><a href="#val-chest_sampler" class="anchor"></a><code><span><span class="keyword">val</span> chest_sampler : 
  <span><span class="label">rng_state</span>:<span class="xref-unresolved">Stdlib</span>.Random.State.t <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">plaintext_size</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">time</span>:int <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-chest">chest</a> * <a href="#type-chest_key">chest_key</a></span></code></div><div class="spec-doc"><p>----- !!!!! Do not use for wallets: the RNG is not safe !!!!---- Sampler for the gasbenchmarks. Takes an Ocaml RNG state as arg for reproducibility.</p></div></div></div></body></html>
