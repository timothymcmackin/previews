<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Make (octez-libs.Tezos_scoru_wasm.Host_funcs.Aux.Make)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../../index.html">octez-libs</a> &#x00BB; <a href="../../../index.html">Tezos_scoru_wasm</a> &#x00BB; <a href="../../index.html">Host_funcs</a> &#x00BB; <a href="../index.html">Aux</a> &#x00BB; Make</nav><header class="odoc-preamble"><h1>Module <code><span>Aux.Make</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#parameters">Parameters</a></li><li><a href="#signature">Signature</a></li></ul></nav><div class="odoc-content"><h2 id="parameters"><a href="#parameters" class="anchor"></a>Parameters</h2><div class="odoc-spec"><div class="spec parameter anchored" id="argument-1-Memory_access"><a href="#argument-1-Memory_access" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="argument-1-Memory_access/index.html">Memory_access</a></span><span> : <a href="../../module-type-Memory_access/index.html">Memory_access</a></span></code></div></div><h2 id="signature"><a href="#signature" class="anchor"></a>Signature</h2><div class="odoc-spec"><div class="spec type anchored" id="type-memory"><a href="#type-memory" class="anchor"></a><code><span><span class="keyword">type</span> memory</span><span> = <a href="argument-1-Memory_access/index.html#type-t">Memory_access.t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-input_output_max_size"><a href="#val-input_output_max_size" class="anchor"></a><code><span><span class="keyword">val</span> input_output_max_size : int</span></code></div><div class="spec-doc"><p>max size of intputs and outputs.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-load_bytes"><a href="#val-load_bytes" class="anchor"></a><code><span><span class="keyword">val</span> load_bytes : 
  <span><span class="label">memory</span>:<a href="#type-memory">memory</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">addr</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">size</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(string, int32)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>load_bytes ~memory ~addr ~size</code> extracts the bytes from the given adress.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-write_output"><a href="#val-write_output" class="anchor"></a><code><span><span class="keyword">val</span> write_output : 
  <span><span class="label">output_buffer</span>:<a href="../../../../Tezos_webassembly_interpreter/Output_buffer/index.html#type-t">Tezos_webassembly_interpreter.Output_buffer.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">memory</span>:<a href="#type-memory">memory</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">src</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">num_bytes</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span>int32 <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>aux_write_output ~input_buffer ~output_buffer ~module_inst ~src
     ~num_bytes</code> reads num_bytes from the memory of module_inst starting at src and writes this to the output_buffer. It also checks that the input payload is no larger than `max_output`. It returns 0 for Ok and 1 for `output too large`.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-read_input"><a href="#val-read_input" class="anchor"></a><code><span><span class="keyword">val</span> read_input : 
  <span><span class="label">input_buffer</span>:<a href="../../../../Tezos_webassembly_interpreter/Input_buffer/index.html#type-t">Tezos_webassembly_interpreter.Input_buffer.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">memory</span>:<a href="#type-memory">memory</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">info_addr</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">dst</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">max_bytes</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span>int32 <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>aux_write_memory ~input_buffer ~module_inst ~level_offset
     ~id_offset ~dst ~max_bytes</code> reads `input_buffer` and writes its components to the memory of `module_inst` based on the memory addreses offsets described. It also checks that the input payload is no larger than `max_input` and crashes with `input too large` otherwise. It returns the size of the payload. Note also that, if the level increases this function also updates the level of the output buffer and resets its id to zero.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-store_exists"><a href="#val-store_exists" class="anchor"></a><code><span><span class="keyword">val</span> store_exists : 
  <span><span class="label">durable</span>:<a href="../../../Durable/index.html#type-t">Durable.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">memory</span>:<a href="#type-memory">memory</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">key_offset</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">key_length</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span>int32 <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.0.0~r2</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-store_has"><a href="#val-store_has" class="anchor"></a><code><span><span class="keyword">val</span> store_has : 
  <span><span class="label">durable</span>:<a href="../../../Durable/index.html#type-t">Durable.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">memory</span>:<a href="#type-memory">memory</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">key_offset</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">key_length</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span>int32 <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-generic_store_delete"><a href="#val-generic_store_delete" class="anchor"></a><code><span><span class="keyword">val</span> generic_store_delete : 
  <span><span class="label">kind</span>:<a href="../../../Durable/index.html#type-kind">Durable.kind</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">durable</span>:<a href="../../../Durable/index.html#type-t">Durable.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">memory</span>:<a href="#type-memory">memory</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">key_offset</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">key_length</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../../../Durable/index.html#type-t">Durable.t</a> * int32)</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>generic_store_delete ~kind ~durable ~memory ~key_offset ~key_length</code> either removes the value if <code>kind = Value</code> or the complete directory if <code>kind = Directory</code> at the given key.</p><p><code>store_delete</code> from version 2.0.0 is actually <code>generic_store_delete
        ~kind:Durable.Directory</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.0.0~r1</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-store_copy"><a href="#val-store_copy" class="anchor"></a><code><span><span class="keyword">val</span> store_copy : 
  <span><span class="label">durable</span>:<a href="../../../Durable/index.html#type-t">Durable.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">memory</span>:<a href="#type-memory">memory</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">from_key_offset</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">from_key_length</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">to_key_offset</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">to_key_length</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../../../Durable/index.html#type-t">Durable.t</a> * int32)</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-store_move"><a href="#val-store_move" class="anchor"></a><code><span><span class="keyword">val</span> store_move : 
  <span><span class="label">durable</span>:<a href="../../../Durable/index.html#type-t">Durable.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">memory</span>:<a href="#type-memory">memory</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">from_key_offset</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">from_key_length</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">to_key_offset</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">to_key_length</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../../../Durable/index.html#type-t">Durable.t</a> * int32)</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-store_create"><a href="#val-store_create" class="anchor"></a><code><span><span class="keyword">val</span> store_create : 
  <span><span class="label">durable</span>:<a href="../../../Durable/index.html#type-t">Durable.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">memory</span>:<a href="#type-memory">memory</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">key_offset</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">key_length</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">size</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../../../Durable/index.html#type-t">Durable.t</a> * int32)</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>store_create ~durable ~memory ~key_offset ~key_length ~size</code> allocates a new value under the given <code>key</code> if it doesn't exist. Returns <code>0</code> if the new value has been allocated, and <code>Error.code
        Store_value_already_exists</code> (`-13`) if there was already a value. The function is tick safe: allocating won't write the data itself, hence the <code>size</code> is not limited by the maximum size of an IO. It is limited to the maximum size of values, which is 2GB (`Int32.max_int`).</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.0.0~r1</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-store_value_size"><a href="#val-store_value_size" class="anchor"></a><code><span><span class="keyword">val</span> store_value_size : 
  <span><span class="label">durable</span>:<a href="../../../Durable/index.html#type-t">Durable.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">memory</span>:<a href="#type-memory">memory</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">key_offset</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">key_length</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span>int32 <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-store_read"><a href="#val-store_read" class="anchor"></a><code><span><span class="keyword">val</span> store_read : 
  <span><span class="label">durable</span>:<a href="../../../Durable/index.html#type-t">Durable.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">memory</span>:<a href="#type-memory">memory</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">key_offset</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">key_length</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">value_offset</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">dest</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">max_bytes</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span>int32 <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-store_write"><a href="#val-store_write" class="anchor"></a><code><span><span class="keyword">val</span> store_write : 
  <span><span class="label">durable</span>:<a href="../../../Durable/index.html#type-t">Durable.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">memory</span>:<a href="#type-memory">memory</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">key_offset</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">key_length</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">value_offset</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">src</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">num_bytes</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../../../Durable/index.html#type-t">Durable.t</a> * int32)</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-store_list_size"><a href="#val-store_list_size" class="anchor"></a><code><span><span class="keyword">val</span> store_list_size : 
  <span><span class="label">durable</span>:<a href="../../../Durable/index.html#type-t">Durable.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">memory</span>:<a href="#type-memory">memory</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">key_offset</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">key_length</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../../../Durable/index.html#type-t">Durable.t</a> * int64)</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-store_get_nth_key"><a href="#val-store_get_nth_key" class="anchor"></a><code><span><span class="keyword">val</span> store_get_nth_key : 
  <span><span class="label">durable</span>:<a href="../../../Durable/index.html#type-t">Durable.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">memory</span>:<a href="#type-memory">memory</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">key_offset</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">key_length</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">index</span>:int64 <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">dst</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">max_size</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span>int32 <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p>The current implementation of <code>store_get_nth_key</code> is not deterministic, and should not be used in kernel development. It cannot be removed from the PVM for backward compatibility reason, but it should not be used in any new kernel development.</p><p>See issue https://gitlab.com/tezos/tezos/-/issues/5301</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-store_get_hash"><a href="#val-store_get_hash" class="anchor"></a><code><span><span class="keyword">val</span> store_get_hash : 
  <span><span class="label">durable</span>:<a href="../../../Durable/index.html#type-t">Durable.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">memory</span>:<a href="#type-memory">memory</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">key_offset</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">key_length</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">dst</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">max_size</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span>int32 <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-reveal"><a href="#val-reveal" class="anchor"></a><code><span><span class="keyword">val</span> reveal : 
  <span><span class="label">memory</span>:<a href="#type-memory">memory</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">dst</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">max_bytes</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">payload</span>:bytes <span class="arrow">&#45;&gt;</span></span>
  <span>int32 <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>reveal mem base size payload</code> is intended to be the function used by the PVM to load at most <code>size</code> bytes of the result <code>payload</code> of a reveal step in <code>mem</code>, at address <code>base</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-read_mem_for_debug"><a href="#val-read_mem_for_debug" class="anchor"></a><code><span><span class="keyword">val</span> read_mem_for_debug : 
  <span><span class="label">memory</span>:<a href="#type-memory">memory</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">src</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">num_bytes</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-write_debug"><a href="#val-write_debug" class="anchor"></a><code><span><span class="keyword">val</span> write_debug : 
  <span><span class="label">implem</span>:<a href="../../../Builtins/index.html#type-write_debug">Builtins.write_debug</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">memory</span>:<a href="#type-memory">memory</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">src</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">num_bytes</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span>unit <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ec_pairing_check_bls12_381"><a href="#val-ec_pairing_check_bls12_381" class="anchor"></a><code><span><span class="keyword">val</span> ec_pairing_check_bls12_381 : 
  <span><span class="label">memory</span>:<a href="#type-memory">memory</a> <span class="arrow">&#45;&gt;</span></span>
  <span>int32 <span class="arrow">&#45;&gt;</span></span>
  <span>int32 <span class="arrow">&#45;&gt;</span></span>
  <span>int32 <span class="arrow">&#45;&gt;</span></span>
  <span>int32 <span class="arrow">&#45;&gt;</span></span>
  <span>int32 <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>ec_pairing_check_bls12_381 point1 point2 point3 point4</code> returns 0 if any points is incorrectly encoded, otherwise returns <code>pairing (point1, point2) * pairing (point3, point4) == 1</code>.</p></div></div></div></body></html>
