<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Json_encoding (octez-libs.Json_encoding)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../index.html">octez-libs</a> &#x00BB; Json_encoding</nav><header class="odoc-preamble"><h1>Module <code><span>Json_encoding</span></code></h1><p>JSON structure description using dependently typed combinators.</p></header><nav class="odoc-toc"><ul><li><a href="#dependent-types-describing-json-document-structures">Dependent types describing JSON document structures</a></li><li><a href="#constructors-and-destructors-for-json_repr.ezjsonm">Constructors and destructors for Json_repr.ezjsonm</a></li><li><a href="#json-type-combinators-for-simple-immediates">JSON type combinators for simple immediates</a></li><li><a href="#json-type-combinators-for-objects">JSON type combinators for objects</a></li><li><a href="#json-type-combinators-for-arrays">JSON type combinators for arrays</a></li><li><a href="#json-type-combinators-for-unions">JSON type combinators for unions</a></li><li><a href="#json-generic-type-combinators">JSON generic type combinators</a></li><li><a href="#exporting-encodings-as-json-schemas">Exporting <code>encoding</code>s as JSON schemas</a></li><li><a href="#errors">Errors</a></li><li><a href="#advanced-interface-for-using-a-custom-json-representation">Advanced interface for using a custom JSON representation</a></li></ul></nav><div class="odoc-content"><h3 id="dependent-types-describing-json-document-structures"><a href="#dependent-types-describing-json-document-structures" class="anchor"></a>Dependent types describing JSON document structures</h3><div class="odoc-spec"><div class="spec type anchored" id="type-encoding"><a href="#type-encoding" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a encoding</span></span></code></div><div class="spec-doc"><p>An encoding between an OCaml data type (the parameter) and a JSON representation. To be built using the predefined combinators provided by this module.</p><p>For instance, here is an encoding, of type <code>(int * string)
    encoding</code>, mapping values of type <code>int * string</code> to JSON objects with a field <code>code</code> of whose value is a number and a field <code>message</code> whose value is a string.</p><p><code>let enc = obj2 (req &quot;code&quot; int) (req &quot;message&quot; string)</code></p><p>This encoding serves three purposes:</p><p>1. Output an OCaml value of type <code>'a</code> to an intermediate JSON representation using <a href="#val-construct"><code>construct</code></a>. To be printed to actual JSON using an external library. 2. Input a JSON intermediate structure (already parsed with an external library) to produce an OCaml value of type <code>'a</code>. 3. Describe this encoding in JSON-schema format for inter-operability: you describe the encoding of your internal types, and obtain machine-readable descriptions of the formats as a byproduct. Specific documentation combinators are provided for that purpose.</p><p>By default, this library provides functions that work on the <a href="../Json_repr/index.html#type-ezjsonm"><code>Json_repr.ezjsonm</code></a> data type, compatible with <code>Ezjsonm.value</code>. However, encodings are not tied with this representation. See functor <a href="Make/index.html"><code>Make</code></a> and module <a href="../Json_repr/index.html"><code>Json_repr</code></a> for using another format.</p></div></div><h3 id="constructors-and-destructors-for-json_repr.ezjsonm"><a href="#constructors-and-destructors-for-json_repr.ezjsonm" class="anchor"></a>Constructors and destructors for Json_repr.ezjsonm</h3><p>see <a href="../Json_repr/index.html#type-ezjsonm"><code>Json_repr.ezjsonm</code></a></p><div class="odoc-spec"><div class="spec value anchored" id="val-construct"><a href="#val-construct" class="anchor"></a><code><span><span class="keyword">val</span> construct : 
  <span><span class="optlabel">?include_default_fields</span>:<span>[ `Always <span>| `Auto</span> <span>| `Never</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'t</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'t</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="../Json_repr/index.html#type-ezjsonm">Json_repr.ezjsonm</a></span></code></div><div class="spec-doc"><p>Builds a json value from an OCaml value and an encoding.</p><p>The optional argument <code>?include_default_fields</code> allows to systematically manage the behaviour of <code>?construct</code> argument of <code>dft</code> fields.</p><p>This function works with JSON data represented in the <a href="../Json_repr/index.html#type-ezjsonm"><code>Json_repr.ezjsonm</code></a> format. See functor <a href="Make/index.html"><code>Make</code></a> for using another representation.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-jsonm_lexeme"><a href="#type-jsonm_lexeme" class="anchor"></a><code><span><span class="keyword">type</span> jsonm_lexeme</span><span> = </span><span>[ </span></code><ol><li id="type-jsonm_lexeme.Null" class="def variant constructor anchored"><a href="#type-jsonm_lexeme.Null" class="anchor"></a><code><span>| </span><span>`Null</span></code></li><li id="type-jsonm_lexeme.Bool" class="def variant constructor anchored"><a href="#type-jsonm_lexeme.Bool" class="anchor"></a><code><span>| </span><span>`Bool <span class="keyword">of</span> bool</span></code></li><li id="type-jsonm_lexeme.String" class="def variant constructor anchored"><a href="#type-jsonm_lexeme.String" class="anchor"></a><code><span>| </span><span>`String <span class="keyword">of</span> string</span></code></li><li id="type-jsonm_lexeme.Float" class="def variant constructor anchored"><a href="#type-jsonm_lexeme.Float" class="anchor"></a><code><span>| </span><span>`Float <span class="keyword">of</span> float</span></code></li><li id="type-jsonm_lexeme.Name" class="def variant constructor anchored"><a href="#type-jsonm_lexeme.Name" class="anchor"></a><code><span>| </span><span>`Name <span class="keyword">of</span> string</span></code></li><li id="type-jsonm_lexeme.As" class="def variant constructor anchored"><a href="#type-jsonm_lexeme.As" class="anchor"></a><code><span>| </span><span>`As</span></code></li><li id="type-jsonm_lexeme.Ae" class="def variant constructor anchored"><a href="#type-jsonm_lexeme.Ae" class="anchor"></a><code><span>| </span><span>`Ae</span></code></li><li id="type-jsonm_lexeme.Os" class="def variant constructor anchored"><a href="#type-jsonm_lexeme.Os" class="anchor"></a><code><span>| </span><span>`Os</span></code></li><li id="type-jsonm_lexeme.Oe" class="def variant constructor anchored"><a href="#type-jsonm_lexeme.Oe" class="anchor"></a><code><span>| </span><span>`Oe</span></code></li></ol><code><span> ]</span></code></div><div class="spec-doc"><p>The type of json lexeme. This type is compatible with <code>Jsonm.lexeme</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-construct_seq"><a href="#val-construct_seq" class="anchor"></a><code><span><span class="keyword">val</span> construct_seq : 
  <span><span class="optlabel">?include_default_fields</span>:<span>[ `Always <span>| `Auto</span> <span>| `Never</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'t</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-jsonm_lexeme">jsonm_lexeme</a> <span class="xref-unresolved">Json_data_encoding_stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p>Builds a lazy Seq representation of the OCaml value.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-jsonm_lexeme_seq_of_ezjson"><a href="#val-jsonm_lexeme_seq_of_ezjson" class="anchor"></a><code><span><span class="keyword">val</span> jsonm_lexeme_seq_of_ezjson : 
  <span><a href="../Json_repr/index.html#type-ezjsonm">Json_repr.ezjsonm</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-jsonm_lexeme">jsonm_lexeme</a> <span class="xref-unresolved">Json_data_encoding_stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p>Converts json AST (<code>ezjsonm</code>) into a sequence representation</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-destruct"><a href="#val-destruct" class="anchor"></a><code><span><span class="keyword">val</span> destruct : 
  <span><span class="optlabel">?ignore_extra_fields</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?bson_relaxation</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'t</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Json_repr/index.html#type-ezjsonm">Json_repr.ezjsonm</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'t</span></span></code></div><div class="spec-doc"><p>Reads an OCaml value from a JSON value and an encoding. May raise <code>Cannot_destruct</code>.</p><p>This function works with JSON data represented in the <a href="../Json_repr/index.html#type-ezjsonm"><code>Json_repr.ezjsonm</code></a> format. See functor <a href="Make/index.html"><code>Make</code></a> for using another representation.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">[ignore_extra_fields]</span> <p>(default to <code>false</code>), when true, the extra fields of an object will be ignored during parsing. If set to false, will raise <code>Cannot_destruct (path, Unexpected_field field)</code> instead.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">[bson_relaxation]</span> <p>(default to <code>false</code>) works around a limitation of the BSON format. Specifically, in BSON, arrays are represented as number-indexed objects. When nested deep inside a value, arrays and objects are tagged to distinguish them, but at the top-level. However, at the top-level this is not the case. As a result, it is impossible to disintguish a naked array from a naked object.</p></li></ul></div></div><h3 id="json-type-combinators-for-simple-immediates"><a href="#json-type-combinators-for-simple-immediates" class="anchor"></a>JSON type combinators for simple immediates</h3><div class="odoc-spec"><div class="spec value anchored" id="val-unit"><a href="#val-unit" class="anchor"></a><code><span><span class="keyword">val</span> unit : <span>unit <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml unit by any (ignored) JSON.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-null"><a href="#val-null" class="anchor"></a><code><span><span class="keyword">val</span> null : <span>unit <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml unit by a JSON null.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : <span>unit <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml unit by an empty JSON object.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-int"><a href="#val-int" class="anchor"></a><code><span><span class="keyword">val</span> int : <span>int <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml int by a JSON number.</p><p>When destructing, the JSON number cannot have a fractional part, and must be between <code>-2^30</code> and <code>2^30-1</code> (these bounds are chosen to be compatible with both 32-bit and 64bit native OCaml compilers as well as JavaScript). When constructing, the value coming from the OCaml world is assumed to be valid, otherwise an <code>Invalid_argument</code> will be raised (can only happen on 64-bit systems).</p><p>Use <a href="#val-int32"><code>int32</code></a> or <a href="#val-int53"><code>int53</code></a> for a greater range. Use <a href="#val-ranged_int"><code>ranged_int</code></a> to restrict to an interval.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-int32"><a href="#val-int32" class="anchor"></a><code><span><span class="keyword">val</span> int32 : <span>int32 <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml int32 by a JSON number.</p><p>Must be a floating point without fractional part and between <code>-2^31</code> and <code>2^31-1</code> when destructing. Never fails when constructing, as all 32-bit integers are included in JSON numbers.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-int53"><a href="#val-int53" class="anchor"></a><code><span><span class="keyword">val</span> int53 : <span>int64 <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of a JSON-representable OCaml int64 by a JSON number.</p><p>Restricted to the <code>-2^53</code> to <code>2^53</code> range, as this is the limit of representable integers in JSON numbers. Must be a floating point without fractional part and in this range when destructing. When constructing, the value coming from the OCaml world is assumed to be in this range, otherwise an <code>Invalid_argument</code> will be raised.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ranged_int"><a href="#val-ranged_int" class="anchor"></a><code><span><span class="keyword">val</span> ranged_int : <span><span class="label">minimum</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="label">maximum</span>:int <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml int by a JSON number restricted to a specific range.</p><p>The bounds must be between <code>-2^30</code> and <code>2^30-1</code>.</p><p>The inclusive bounds are checked when destructing. When constructing, the value coming from the OCaml world is assumed to be within the bounds, otherwise an <code>Invalid_argument</code> will be raised. The string parameter is a name used to tweak the error messages.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ranged_int32"><a href="#val-ranged_int32" class="anchor"></a><code><span><span class="keyword">val</span> ranged_int32 : <span><span class="label">minimum</span>:int32 <span class="arrow">&#45;&gt;</span></span> <span><span class="label">maximum</span>:int32 <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>int32 <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml int32 by a JSON number restricted to a specific range.</p><p>The bounds must be between <code>-2^31</code> and <code>2^31-1</code>.</p><p>The inclusive bounds are checked when destructing. When constructing, the value coming from the OCaml world is assumed to be within the bounds, otherwise an <code>Invalid_argument</code> will be raised. The string parameter is a name used to tweak the error messages.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ranged_int53"><a href="#val-ranged_int53" class="anchor"></a><code><span><span class="keyword">val</span> ranged_int53 : <span><span class="label">minimum</span>:int64 <span class="arrow">&#45;&gt;</span></span> <span><span class="label">maximum</span>:int64 <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>int64 <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml int64 by a JSON number restricted to a specific range.</p><p>The bounds must be between <code>-2^53</code> and <code>2^53</code>.</p><p>The inclusive bounds are checked when destructing. When constructing, the value coming from the OCaml world is assumed to be within the bounds, otherwise an <code>Invalid_argument</code> will be raised. The string parameter is a name used to tweak the error messages.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-bool"><a href="#val-bool" class="anchor"></a><code><span><span class="keyword">val</span> bool : <span>bool <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml boolean by a JSON one.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-string"><a href="#val-string" class="anchor"></a><code><span><span class="keyword">val</span> string : <span>string <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml string by a JSON one.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-string_enum"><a href="#val-string_enum" class="anchor"></a><code><span><span class="keyword">val</span> string_enum : <span><span><span>(string * <span class="type-var">'a</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of a closed set of OCaml values by JSON strings.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-constant"><a href="#val-constant" class="anchor"></a><code><span><span class="keyword">val</span> constant : <span>string <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of a constant string.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-bytes"><a href="#val-bytes" class="anchor"></a><code><span><span class="keyword">val</span> bytes : <span>bytes <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml mutable string by a JSON string.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-float"><a href="#val-float" class="anchor"></a><code><span><span class="keyword">val</span> float : <span>float <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml float by a JSON number.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ranged_float"><a href="#val-ranged_float" class="anchor"></a><code><span><span class="keyword">val</span> ranged_float : <span><span class="label">minimum</span>:float <span class="arrow">&#45;&gt;</span></span> <span><span class="label">maximum</span>:float <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>float <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml float by a JSON number with range constraints</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-option"><a href="#val-option" class="anchor"></a><code><span><span class="keyword">val</span> option : <span><span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> option</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml option by a nullable JSON value. Raises <code>Invalid_argument</code> when nesting options – i.e., when building <code>'a option
    option encoding</code>. Also raises <code>Invalid_argument</code> when used on the encoding of <code>null</code>.</p></div></div><h3 id="json-type-combinators-for-objects"><a href="#json-type-combinators-for-objects" class="anchor"></a>JSON type combinators for objects</h3><div class="odoc-spec"><div class="spec type anchored" id="type-field"><a href="#type-field" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a field</span></span></code></div><div class="spec-doc"><p>A first class handle to a JSON field.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-req"><a href="#val-req" class="anchor"></a><code><span><span class="keyword">val</span> req : 
  <span><span class="optlabel">?title</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?description</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'t</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'t</span> <a href="#type-field">field</a></span></span></code></div><div class="spec-doc"><p>A required field of a given its type.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-opt"><a href="#val-opt" class="anchor"></a><code><span><span class="keyword">val</span> opt : 
  <span><span class="optlabel">?title</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?description</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'t</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'t</span> option</span> <a href="#type-field">field</a></span></span></code></div><div class="spec-doc"><p>An optional field of a given type, using an OCaml <code>option</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-dft"><a href="#val-dft" class="anchor"></a><code><span><span class="keyword">val</span> dft : 
  <span><span class="optlabel">?title</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?description</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?equal</span>:<span>(<span><span class="type-var">'t</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'t</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?construct</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'t</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'t</span> <a href="#type-field">field</a></span></span></code></div><div class="spec-doc"><p>An optional field of a given type. The field is omitted when equal to the default value except when <code>construct</code> is <code>true</code>.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">[equal]</span> <p>defaults to the polymorphic, structural equality (<code>( = )</code>). You must set this function if the type of data carried by the field is not comparable (e.g., a <code>Seq.t</code>).</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-obj1"><a href="#val-obj1" class="anchor"></a><code><span><span class="keyword">val</span> obj1 : <span><span><span class="type-var">'f1</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'f1</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml value by a singleton object.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-obj2"><a href="#val-obj2" class="anchor"></a><code><span><span class="keyword">val</span> obj2 : <span><span><span class="type-var">'f1</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'f2</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml pair by a JSON object with two fields.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-obj3"><a href="#val-obj3" class="anchor"></a><code><span><span class="keyword">val</span> obj3 : <span><span><span class="type-var">'f1</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'f2</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'f3</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml triple by a JSON object with three fields.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-obj4"><a href="#val-obj4" class="anchor"></a><code><span><span class="keyword">val</span> obj4 : 
  <span><span><span class="type-var">'f1</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f2</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f3</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f4</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span> * <span class="type-var">'f4</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml quadruple by a JSON object with four fields.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-obj5"><a href="#val-obj5" class="anchor"></a><code><span><span class="keyword">val</span> obj5 : 
  <span><span><span class="type-var">'f1</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f2</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f3</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f4</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f5</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span> * <span class="type-var">'f4</span> * <span class="type-var">'f5</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml quintuple by a JSON object with five fields.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-obj6"><a href="#val-obj6" class="anchor"></a><code><span><span class="keyword">val</span> obj6 : 
  <span><span><span class="type-var">'f1</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f2</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f3</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f4</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f5</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f6</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span> * <span class="type-var">'f4</span> * <span class="type-var">'f5</span> * <span class="type-var">'f6</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml sextuple by a JSON object with six fields.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-obj7"><a href="#val-obj7" class="anchor"></a><code><span><span class="keyword">val</span> obj7 : 
  <span><span><span class="type-var">'f1</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f2</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f3</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f4</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f5</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f6</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f7</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span> * <span class="type-var">'f4</span> * <span class="type-var">'f5</span> * <span class="type-var">'f6</span> * <span class="type-var">'f7</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml septuple by a JSON object with seven fields.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-obj8"><a href="#val-obj8" class="anchor"></a><code><span><span class="keyword">val</span> obj8 : 
  <span><span><span class="type-var">'f1</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f2</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f3</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f4</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f5</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f6</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f7</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f8</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span> * <span class="type-var">'f4</span> * <span class="type-var">'f5</span> * <span class="type-var">'f6</span> * <span class="type-var">'f7</span> * <span class="type-var">'f8</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml octuple by a JSON object with eight fields.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-obj9"><a href="#val-obj9" class="anchor"></a><code><span><span class="keyword">val</span> obj9 : 
  <span><span><span class="type-var">'f1</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f2</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f3</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f4</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f5</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f6</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f7</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f8</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f9</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span> * <span class="type-var">'f4</span> * <span class="type-var">'f5</span> * <span class="type-var">'f6</span> * <span class="type-var">'f7</span> * <span class="type-var">'f8</span> * <span class="type-var">'f9</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml nonuple by a JSON object with nine fields.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-obj10"><a href="#val-obj10" class="anchor"></a><code><span><span class="keyword">val</span> obj10 : 
  <span><span><span class="type-var">'f1</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f2</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f3</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f4</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f5</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f6</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f7</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f8</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f9</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f10</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span> * <span class="type-var">'f4</span> * <span class="type-var">'f5</span> * <span class="type-var">'f6</span> * <span class="type-var">'f7</span> * <span class="type-var">'f8</span> * <span class="type-var">'f9</span> * <span class="type-var">'f10</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml decuple by a JSON object with ten fields.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-merge_objs"><a href="#val-merge_objs" class="anchor"></a><code><span><span class="keyword">val</span> merge_objs : <span><span><span class="type-var">'o1</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'o2</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'o1</span> * <span class="type-var">'o2</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>Merge two object <code>encoding</code>s. For describing heavyweight objects with a lot of fields. The ocaml type is a pair of tuples, but the JSON object is flat. Both arguments must be object encodings, otherwise a future <a href="#val-construct"><code>construct</code></a>, <a href="#val-destruct"><code>destruct</code></a> or <a href="#val-schema"><code>schema</code></a> will fail with <code>Invalid_argument</code>.</p></div></div><h3 id="json-type-combinators-for-arrays"><a href="#json-type-combinators-for-arrays" class="anchor"></a>JSON type combinators for arrays</h3><div class="odoc-spec"><div class="spec value anchored" id="val-array"><a href="#val-array" class="anchor"></a><code><span><span class="keyword">val</span> array : <span><span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> array</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml array by a JSON one.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-list"><a href="#val-list" class="anchor"></a><code><span><span class="keyword">val</span> list : <span><span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml list by a JSON array.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-seq"><a href="#val-seq" class="anchor"></a><code><span><span class="keyword">val</span> seq : <span><span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <span class="xref-unresolved">Json_data_encoding_stdlib</span>.Seq.t</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml <code>Seq.t</code> by a JSON array.</p><p>The JSON form is indistinguishable from that of a list. In other words, <code>construct (list e) (List.of_seq s)</code> is the same JSON value as <code>construct (seq e) s</code>.</p><p>In case you use <a href="#val-construct_seq"><code>construct_seq</code></a>, the elements sequence is traversed lazily as needed.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-assoc"><a href="#val-assoc" class="anchor"></a><code><span><span class="keyword">val</span> assoc : 
  <span><span class="optlabel">?definitions_path</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(string * <span class="type-var">'a</span>)</span> list</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml associative list by a JSON object.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tup1"><a href="#val-tup1" class="anchor"></a><code><span><span class="keyword">val</span> tup1 : <span><span><span class="type-var">'f1</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'f1</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml value by a singleton array.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tup2"><a href="#val-tup2" class="anchor"></a><code><span><span class="keyword">val</span> tup2 : <span><span><span class="type-var">'f1</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'f2</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml pair by a JSON array with two cells.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tup3"><a href="#val-tup3" class="anchor"></a><code><span><span class="keyword">val</span> tup3 : 
  <span><span><span class="type-var">'f1</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f2</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f3</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml triple by a JSON array with three cells.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tup4"><a href="#val-tup4" class="anchor"></a><code><span><span class="keyword">val</span> tup4 : 
  <span><span><span class="type-var">'f1</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f2</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f3</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f4</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span> * <span class="type-var">'f4</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml quadruple by a JSON array with four cells.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tup5"><a href="#val-tup5" class="anchor"></a><code><span><span class="keyword">val</span> tup5 : 
  <span><span><span class="type-var">'f1</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f2</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f3</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f4</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f5</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span> * <span class="type-var">'f4</span> * <span class="type-var">'f5</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml quintuple by a JSON array with five cells.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tup6"><a href="#val-tup6" class="anchor"></a><code><span><span class="keyword">val</span> tup6 : 
  <span><span><span class="type-var">'f1</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f2</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f3</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f4</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f5</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f6</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span> * <span class="type-var">'f4</span> * <span class="type-var">'f5</span> * <span class="type-var">'f6</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml sextuple by a JSON array with six cells.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tup7"><a href="#val-tup7" class="anchor"></a><code><span><span class="keyword">val</span> tup7 : 
  <span><span><span class="type-var">'f1</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f2</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f3</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f4</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f5</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f6</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f7</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span> * <span class="type-var">'f4</span> * <span class="type-var">'f5</span> * <span class="type-var">'f6</span> * <span class="type-var">'f7</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml septuple by a JSON array with seven cells.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tup8"><a href="#val-tup8" class="anchor"></a><code><span><span class="keyword">val</span> tup8 : 
  <span><span><span class="type-var">'f1</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f2</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f3</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f4</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f5</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f6</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f7</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f8</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span> * <span class="type-var">'f4</span> * <span class="type-var">'f5</span> * <span class="type-var">'f6</span> * <span class="type-var">'f7</span> * <span class="type-var">'f8</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml octuple by a JSON array with eight cells.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tup9"><a href="#val-tup9" class="anchor"></a><code><span><span class="keyword">val</span> tup9 : 
  <span><span><span class="type-var">'f1</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f2</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f3</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f4</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f5</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f6</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f7</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f8</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f9</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span> * <span class="type-var">'f4</span> * <span class="type-var">'f5</span> * <span class="type-var">'f6</span> * <span class="type-var">'f7</span> * <span class="type-var">'f8</span> * <span class="type-var">'f9</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml nonuple by a JSON array with nine cells.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tup10"><a href="#val-tup10" class="anchor"></a><code><span><span class="keyword">val</span> tup10 : 
  <span><span><span class="type-var">'f1</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f2</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f3</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f4</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f5</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f6</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f7</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f8</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f9</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f10</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span> * <span class="type-var">'f4</span> * <span class="type-var">'f5</span> * <span class="type-var">'f6</span> * <span class="type-var">'f7</span> * <span class="type-var">'f8</span> * <span class="type-var">'f9</span> * <span class="type-var">'f10</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding of an OCaml decuple by a JSON array with ten cells.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-merge_tups"><a href="#val-merge_tups" class="anchor"></a><code><span><span class="keyword">val</span> merge_tups : <span><span><span class="type-var">'a1</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a2</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a1</span> * <span class="type-var">'a2</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>Merge two tuple <code>encoding</code>s. For describing heavyweight arrays with a lot of cells. The ocaml type is a pair of tuples, but the JSON array is flat, with the elements of the first tuple before the ones of the second. Both arguments must be tuple encodings, otherwise a future <a href="#val-construct"><code>construct</code></a>, <a href="#val-destruct"><code>destruct</code></a> or <a href="#val-schema"><code>schema</code></a> will fail with <code>Invalid_argument</code>.</p></div></div><h3 id="json-type-combinators-for-unions"><a href="#json-type-combinators-for-unions" class="anchor"></a>JSON type combinators for unions</h3><div class="odoc-spec"><div class="spec type anchored" id="type-case"><a href="#type-case" class="anchor"></a><code><span><span class="keyword">type</span> <span>'t case</span></span></code></div><div class="spec-doc"><p>A case for describing union types using <a href="#val-union"><code>union</code></a> and <a href="#val-case"><code>case</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-case"><a href="#val-case" class="anchor"></a><code><span><span class="keyword">val</span> case : 
  <span><span class="optlabel">?title</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?description</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'b</span> <a href="#type-case">case</a></span></span></code></div><div class="spec-doc"><p>To be used inside a <a href="#val-union"><code>union</code></a>. Takes a <code>encoding</code> for a specific case, and a converter to and from a type common to all cases (<code>'t</code>). Usually, it consists in boxing / deboxing the specific data in an OCaml sum type constructor.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-union"><a href="#val-union" class="anchor"></a><code><span><span class="keyword">val</span> union : <span><span><span><span class="type-var">'t</span> <a href="#type-case">case</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'t</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>A utility to build destructors for custom encoded sum types.</p></div></div><h3 id="json-generic-type-combinators"><a href="#json-generic-type-combinators" class="anchor"></a>JSON generic type combinators</h3><div class="odoc-spec"><div class="spec value anchored" id="val-custom"><a href="#val-custom" class="anchor"></a><code><span><span class="keyword">val</span> custom : 
  <span><span class="optlabel">?is_object</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'t</span> <span class="arrow">&#45;&gt;</span></span> <a href="../Json_repr/index.html#type-ezjsonm">Json_repr.ezjsonm</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="../Json_repr/index.html#type-ezjsonm">Json_repr.ezjsonm</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">schema</span>:<a href="../Json_schema/index.html#type-schema">Json_schema.schema</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'t</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>A simple custom encoding using the <a href="../Json_repr/index.html#type-ezjsonm"><code>Json_repr.ezjsonm</code></a> intermediate representation for the conversion functions. The resulting encoding is usable with any other instanciation of functor <a href="Make/index.html"><code>Make</code></a>, internal conversions may be performed needed. The second transformer function can <code>raise (Cannot_destruct ([ (* location *)], exn))</code> to indicate an error, which will be relocated correctly.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-conv"><a href="#val-conv" class="anchor"></a><code><span><span class="keyword">val</span> conv : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?schema</span>:<a href="../Json_schema/index.html#type-schema">Json_schema.schema</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>An encoding adapter, with an optional handwritten schema. The second transformer function can <code>raise (Cannot_destruct ([], exn))</code> to indicate an error, which will be relocated correctly.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mu"><a href="#val-mu" class="anchor"></a><code><span><span class="keyword">val</span> mu : 
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?title</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?description</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>A fixpoint combinator. Links a recursive OCaml type to an internal JSON schema reference, by allowing to use the encoding inside its own definition. The first parameter is a path, that must be unique and respect the format of <a href="../Json_schema/index.html#val-add_definition"><code>Json_schema.add_definition</code></a>. It is used to encode the recursivity as a named reference in the JSON schema.</p><p>Here is an example to turn a standard OCaml list into either <code>&quot;nil&quot;</code> for <code>[]</code> or <code>{&quot;hd&quot;:hd,&quot;tl&quot;:tl}</code> for <code>hd::tl</code>.</p><pre class="language-ocaml"><code>let reclist item_encoding =
   mu &quot;list&quot; @@ fun self -&gt;
   union [
      case (string_enum [ &quot;nil&quot;, () ])
         (function [] -&gt; Some () | _ :: _ -&gt; None)
         (fun () -&gt; []) ;
      case (obj2 (req &quot;hd&quot; itemencoding) (req &quot;tl&quot; self))
         (function hd :: tl -&gt; Some (hd, tl) | [] -&gt; None)
         (fun (hd, tl) -&gt; hd :: tl)
   ]</code></pre><p>Notice that the function passed to <code>mu</code> must be pure. Otherwise, the behavior is unspecified.</p><p>A stateful recursive encoding can still be put under a <code>delayed</code> combinator to make sure that a new encoding is generated each time it is used. Caching the encoding generation when the state has not changed is then the responsability of the client.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-any_ezjson_value"><a href="#val-any_ezjson_value" class="anchor"></a><code><span><span class="keyword">val</span> any_ezjson_value : <span><a href="../Json_repr/index.html#type-ezjsonm">Json_repr.ezjsonm</a> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>A raw JSON value in ezjsonm representation.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-any_document"><a href="#val-any_document" class="anchor"></a><code><span><span class="keyword">val</span> any_document : <span><a href="../Json_repr/index.html#type-any">Json_repr.any</a> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>A valid JSON document (i.e. an array or object value).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-any_object"><a href="#val-any_object" class="anchor"></a><code><span><span class="keyword">val</span> any_object : <span><a href="../Json_repr/index.html#type-any">Json_repr.any</a> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>A valid JSON object. May raise <a href="#exception-Unexpected"><code>Unexpected</code></a>. Specifically, the <code>construct</code> or <code>destruct</code> (or similar) function using this encoding will raise <a href="#exception-Unexpected"><code>Unexpected</code></a> if given anything other than an object to handle.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-any_ezjson_object"><a href="#val-any_ezjson_object" class="anchor"></a><code><span><span class="keyword">val</span> any_ezjson_object : <span><a href="../Json_repr/index.html#type-ezjsonm">Json_repr.ezjsonm</a> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>A valid JSON object in ezjsonm representation. May raise <a href="#exception-Unexpected"><code>Unexpected</code></a>. Specifically, the <code>construct</code> or <code>destruct</code> (or similar) function using this encoding will raise <a href="#exception-Unexpected"><code>Unexpected</code></a> if given anything other than an object to handle.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-any_schema"><a href="#val-any_schema" class="anchor"></a><code><span><span class="keyword">val</span> any_schema : <span><a href="../Json_schema/index.html#type-schema">Json_schema.schema</a> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>The encoding of a JSON schema, linked to its OCaml definiton.</p></div></div><h3 id="exporting-encodings-as-json-schemas"><a href="#exporting-encodings-as-json-schemas" class="anchor"></a>Exporting <code>encoding</code>s as JSON schemas</h3><div class="odoc-spec"><div class="spec value anchored" id="val-schema"><a href="#val-schema" class="anchor"></a><code><span><span class="keyword">val</span> schema : <span><span class="optlabel">?definitions_path</span>:string <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'t</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="../Json_schema/index.html#type-schema">Json_schema.schema</a></span></code></div><div class="spec-doc"><p>Describe an encoding in JSON schema format. May raise <a href="#exception-Bad_schema"><code>Bad_schema</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-def"><a href="#val-def" class="anchor"></a><code><span><span class="keyword">val</span> def : 
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?title</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?description</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'t</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'t</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>Name a definition so its occurences can be shared in the JSON schema. The first parameter is a path, that must be unique and respect the format of <a href="../Json_schema/index.html#val-add_definition"><code>Json_schema.add_definition</code></a>.</p></div></div><h3 id="errors"><a href="#errors" class="anchor"></a>Errors</h3><div class="odoc-spec"><div class="spec exception anchored" id="exception-Cannot_destruct"><a href="#exception-Cannot_destruct" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Cannot_destruct</span> <span class="keyword">of</span> <a href="../Json_query/index.html#type-path">Json_query.path</a> * exn</span></code></div><div class="spec-doc"><p>Exception raised by destructors, with the location in the original JSON structure and the specific error.</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Unexpected"><a href="#exception-Unexpected" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Unexpected</span> <span class="keyword">of</span> string * string</span></code></div><div class="spec-doc"><p>Unexpected kind of data encountered (w/ the expectation).</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-No_case_matched"><a href="#exception-No_case_matched" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">No_case_matched</span> <span class="keyword">of</span> <span>exn list</span></span></code></div><div class="spec-doc"><p>Some <a href="#val-union"><code>union</code></a> couldn't be destructed, w/ the reasons for each <a href="#val-case"><code>case</code></a>.</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Bad_array_size"><a href="#exception-Bad_array_size" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Bad_array_size</span> <span class="keyword">of</span> int * int</span></code></div><div class="spec-doc"><p>Array of unexpected size encountered (w/ the expectation).</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Missing_field"><a href="#exception-Missing_field" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Missing_field</span> <span class="keyword">of</span> string</span></code></div><div class="spec-doc"><p>Missing field in an object.</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Unexpected_field"><a href="#exception-Unexpected_field" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Unexpected_field</span> <span class="keyword">of</span> string</span></code></div><div class="spec-doc"><p>Supernumerary field in an object.</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Bad_schema"><a href="#exception-Bad_schema" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Bad_schema</span> <span class="keyword">of</span> exn</span></code></div><div class="spec-doc"><p>Bad custom schema encountered.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print_error"><a href="#val-print_error" class="anchor"></a><code><span><span class="keyword">val</span> print_error : 
  <span><span class="optlabel">?print_unknown</span>:<span>(<span><span class="xref-unresolved">Json_data_encoding_stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span>exn <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Json_data_encoding_stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span>exn <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Produces a human readable version of an error.</p></div></div><h3 id="advanced-interface-for-using-a-custom-json-representation"><a href="#advanced-interface-for-using-a-custom-json-representation" class="anchor"></a>Advanced interface for using a custom JSON representation</h3><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-S"><a href="#module-type-S" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-S/index.html">S</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Make"><a href="#module-Make" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Make/index.html">Make</a></span><span> (<a href="Make/argument-1-Repr/index.html">Repr</a> : <a href="../Json_repr/module-type-Repr/index.html">Json_repr.Repr</a>) : <a href="module-type-S/index.html">S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="module-type-S/index.html#type-repr_value">repr_value</a> = <a href="Make/argument-1-Repr/index.html#type-value">Repr.value</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-repr_agnostic_custom"><a href="#type-repr_agnostic_custom" class="anchor"></a><code><span><span class="keyword">type</span> <span>'t repr_agnostic_custom</span></span><span> = </span><span>{</span></code><ol><li id="type-repr_agnostic_custom.write" class="def record field anchored"><a href="#type-repr_agnostic_custom.write" class="anchor"></a><code><span>write : 'rt. <span><span>(<span class="keyword">module</span> <a href="../Json_repr/module-type-Repr/index.html">Json_repr.Repr</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../Json_repr/module-type-Repr/index.html#type-value">value</a> = <span class="type-var">'rt</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'t</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'rt</span>;</span></code></li><li id="type-repr_agnostic_custom.read" class="def record field anchored"><a href="#type-repr_agnostic_custom.read" class="anchor"></a><code><span>read : 'rf. <span><span>(<span class="keyword">module</span> <a href="../Json_repr/module-type-Repr/index.html">Json_repr.Repr</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../Json_repr/module-type-Repr/index.html#type-value">value</a> = <span class="type-var">'rf</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'rf</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'t</span>;</span></code></li><li id="type-repr_agnostic_custom.is_object" class="def record field anchored"><a href="#type-repr_agnostic_custom.is_object" class="anchor"></a><code><span>is_object : bool;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Custom encoders for an OCaml type, given both custom conversion functions. The actual representation is not known in advance, so the conversion functions have to examine / construct the JSON value through the first class modules they are passed. The <code>read</code> transformer function can <code>raise (Cannot_destruct ([], &quot;message&quot;))</code> to indicate an error, which will be relocated correctly.</p><p>Here is an example of how to build such a value for a type <code>'t</code>.</p><pre class="language-ocaml"><code>let read
  : type tf. (module Json_repr.Repr with type value = tf) -&gt; tf -&gt; 't
  = fun (module Repr_f) repr -&gt;
    match Repr_f.view repr with
    | `Null (* destruct the JSON using [Repr_f.view] *) -&gt;
      (* create a value of type 't *)
    | _ -&gt;
      (* or fail with this wrapping exception *)
      raise (Cannot_destruct ([ (* location *) ], (* exn *))) in
let write
  : type tf. (module Json_repr.Repr with type value = tf) -&gt; 't -&gt; tf
  = fun (module Repr_f) v -&gt;
    (* examine the value and produce a JSON using [Repr_f.repr] *)
    Repr_f.repr `Null in
{ read ; write } </code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-repr_agnostic_custom"><a href="#val-repr_agnostic_custom" class="anchor"></a><code><span><span class="keyword">val</span> repr_agnostic_custom : 
  <span><span><span class="type-var">'t</span> <a href="#type-repr_agnostic_custom">repr_agnostic_custom</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">schema</span>:<a href="../Json_schema/index.html#type-schema">Json_schema.schema</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'t</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>A custom encoding, using custom encoders and a schema.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-any_value"><a href="#val-any_value" class="anchor"></a><code><span><span class="keyword">val</span> any_value : <span><a href="../Json_repr/index.html#type-any">Json_repr.any</a> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>A raw JSON value in its original representation.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_nullable"><a href="#val-is_nullable" class="anchor"></a><code><span><span class="keyword">val</span> is_nullable : <span><span><span class="type-var">'t</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Returns <code>true</code> is the encoding might construct <code>null</code>.</p></div></div></div></body></html>
