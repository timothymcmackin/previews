<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Json (octez-libs.Data_encoding.V1.Json)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">octez-libs</a> &#x00BB; <a href="../../index.html">Data_encoding</a> &#x00BB; <a href="../index.html">V1</a> &#x00BB; Json</nav><header class="odoc-preamble"><h1>Module <code><span>V1.Json</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-json"><a href="#type-json" class="anchor"></a><code><span><span class="keyword">type</span> json</span><span> = </span><span>[ </span></code><ol><li id="type-json.O" class="def variant constructor anchored"><a href="#type-json.O" class="anchor"></a><code><span>| </span><span>`O <span class="keyword">of</span> <span><span>(string * <a href="#type-json">json</a>)</span> list</span></span></code></li><li id="type-json.Bool" class="def variant constructor anchored"><a href="#type-json.Bool" class="anchor"></a><code><span>| </span><span>`Bool <span class="keyword">of</span> bool</span></code></li><li id="type-json.Float" class="def variant constructor anchored"><a href="#type-json.Float" class="anchor"></a><code><span>| </span><span>`Float <span class="keyword">of</span> float</span></code></li><li id="type-json.A" class="def variant constructor anchored"><a href="#type-json.A" class="anchor"></a><code><span>| </span><span>`A <span class="keyword">of</span> <span><a href="#type-json">json</a> list</span></span></code></li><li id="type-json.Null" class="def variant constructor anchored"><a href="#type-json.Null" class="anchor"></a><code><span>| </span><span>`Null</span></code></li><li id="type-json.String" class="def variant constructor anchored"><a href="#type-json.String" class="anchor"></a><code><span>| </span><span>`String <span class="keyword">of</span> string</span></code></li></ol><code><span> ]</span></code></div><div class="spec-doc"><p>In memory JSON data, compatible with <code>Ezjsonm</code>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = <a href="#type-json">json</a></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-schema"><a href="#type-schema" class="anchor"></a><code><span><span class="keyword">type</span> schema</span><span> = <a href="../../../Json_schema/index.html#type-schema">Json_schema.schema</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-encoding"><a href="#val-encoding" class="anchor"></a><code><span><span class="keyword">val</span> encoding : <span><a href="#type-json">json</a> <a href="../Encoding/index.html#type-t">Encoding.t</a></span></span></code></div><div class="spec-doc"><p>Encodes raw JSON data (BSON is used for binary).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-schema_encoding"><a href="#val-schema_encoding" class="anchor"></a><code><span><span class="keyword">val</span> schema_encoding : <span><a href="#type-schema">schema</a> <a href="../Encoding/index.html#type-t">Encoding.t</a></span></span></code></div><div class="spec-doc"><p>Encodes a JSON schema (BSON encoded for binary).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-convert"><a href="#val-convert" class="anchor"></a><code><span><span class="keyword">val</span> convert : <span><span><span class="type-var">'a</span> <a href="../Encoding/index.html#type-t">Encoding.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../../../Json_encoding/index.html#type-encoding">Json_encoding.encoding</a></span></span></code></div><div class="spec-doc"><p>Create a <a href="../../../Json_encoding/index.html#type-encoding"><code>Json_encoding.encoding</code></a> from an <a href="../index.html#type-encoding"><code>encoding</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-schema"><a href="#val-schema" class="anchor"></a><code><span><span class="keyword">val</span> schema : <span><span class="optlabel">?definitions_path</span>:string <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../Encoding/index.html#type-t">Encoding.t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-schema">schema</a></span></code></div><div class="spec-doc"><p>Generate a schema from an <a href="../index.html#type-encoding"><code>encoding</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-construct"><a href="#val-construct" class="anchor"></a><code><span><span class="keyword">val</span> construct : 
  <span><span class="optlabel">?include_default_fields</span>:<span>[ `Always <span>| `Auto</span> <span>| `Never</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'t</span> <a href="../Encoding/index.html#type-t">Encoding.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'t</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-json">json</a></span></code></div><div class="spec-doc"><p>Construct a JSON object from an encoding.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-jsonm_lexeme"><a href="#type-jsonm_lexeme" class="anchor"></a><code><span><span class="keyword">type</span> jsonm_lexeme</span><span> = </span><span>[ </span></code><ol><li id="type-jsonm_lexeme.Null" class="def variant constructor anchored"><a href="#type-jsonm_lexeme.Null" class="anchor"></a><code><span>| </span><span>`Null</span></code></li><li id="type-jsonm_lexeme.Bool" class="def variant constructor anchored"><a href="#type-jsonm_lexeme.Bool" class="anchor"></a><code><span>| </span><span>`Bool <span class="keyword">of</span> bool</span></code></li><li id="type-jsonm_lexeme.String" class="def variant constructor anchored"><a href="#type-jsonm_lexeme.String" class="anchor"></a><code><span>| </span><span>`String <span class="keyword">of</span> string</span></code></li><li id="type-jsonm_lexeme.Float" class="def variant constructor anchored"><a href="#type-jsonm_lexeme.Float" class="anchor"></a><code><span>| </span><span>`Float <span class="keyword">of</span> float</span></code></li><li id="type-jsonm_lexeme.Name" class="def variant constructor anchored"><a href="#type-jsonm_lexeme.Name" class="anchor"></a><code><span>| </span><span>`Name <span class="keyword">of</span> string</span></code></li><li id="type-jsonm_lexeme.As" class="def variant constructor anchored"><a href="#type-jsonm_lexeme.As" class="anchor"></a><code><span>| </span><span>`As</span></code></li><li id="type-jsonm_lexeme.Ae" class="def variant constructor anchored"><a href="#type-jsonm_lexeme.Ae" class="anchor"></a><code><span>| </span><span>`Ae</span></code></li><li id="type-jsonm_lexeme.Os" class="def variant constructor anchored"><a href="#type-jsonm_lexeme.Os" class="anchor"></a><code><span>| </span><span>`Os</span></code></li><li id="type-jsonm_lexeme.Oe" class="def variant constructor anchored"><a href="#type-jsonm_lexeme.Oe" class="anchor"></a><code><span>| </span><span>`Oe</span></code></li></ol><code><span> ]</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-construct_seq"><a href="#val-construct_seq" class="anchor"></a><code><span><span class="keyword">val</span> construct_seq : <span><span><span class="type-var">'t</span> <a href="../Encoding/index.html#type-t">Encoding.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'t</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-jsonm_lexeme">jsonm_lexeme</a> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p><code>construct_seq enc t</code> is a representation of <code>t</code> as a sequence of json lexeme (<code>jsonm_lexeme Seq.t</code>). This sequence is lazy: lexemes are computed on-demand.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-string_seq_of_jsonm_lexeme_seq"><a href="#val-string_seq_of_jsonm_lexeme_seq" class="anchor"></a><code><span><span class="keyword">val</span> string_seq_of_jsonm_lexeme_seq : 
  <span><span class="label">newline</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">chunk_size_hint</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-jsonm_lexeme">jsonm_lexeme</a> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p><code>string_seq_of_jsonm_lexeme_seq ~newline ~chunk_size_hint s</code> is a sequence of strings, the concatenation of which is a valid textual representation of the json value represented by <code>s</code>. Each string chunk is roughly <code>chunk_size_hint</code> long (except the last one that may be shorter).</p><p>With the <code>newline</code> parameter set to <code>true</code>, a single newline character is appended to the textual representation.</p><p>Forcing one element of the resulting string sequence forces multiple elements of the underlying lexeme sequence. Once enough lexemes have been forced that roughly <code>chunk_size_hint</code> characters are needed to represent them, the representation is returned and the rest of the sequence is held lazily.</p><p>Note that most chunks split at a lexeme boundary. This may not be true for string literals or float literals, the representation of which may be spread across multiple chunks.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-small_string_seq_of_jsonm_lexeme_seq"><a href="#val-small_string_seq_of_jsonm_lexeme_seq" class="anchor"></a><code><span><span class="keyword">val</span> small_string_seq_of_jsonm_lexeme_seq : 
  <span><span class="label">newline</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-jsonm_lexeme">jsonm_lexeme</a> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-blit_instructions_seq_of_jsonm_lexeme_seq"><a href="#val-blit_instructions_seq_of_jsonm_lexeme_seq" class="anchor"></a><code><span><span class="keyword">val</span> blit_instructions_seq_of_jsonm_lexeme_seq : 
  <span><span class="label">newline</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">buffer</span>:bytes <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-jsonm_lexeme">jsonm_lexeme</a> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="xref-unresolved">Stdlib</span>.Bytes.t * int * int)</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p><code>blit_instructions_seq_of_jsonm_lexeme_seq ~newline ~buffer json</code> is a sequence of <code>(buff, offset, length)</code> such that the concatenation of the sub-strings thus designated represents the json value in text form.</p><p>The intended use is to blit each of the substring onto whatever output the consumer decides. In most cases, the Sequence's <code>buff</code> is physically equal to <code>buffer</code>. This is not always true and one cannot rely on that fact. E.g., when the json includes a long string literal, the function might instruct the consumer to blit from that literal directly.</p><p>This function performs few allocations, especially of fresh strings.</p><p>Note that once the next element of the sequence is forced, the blit instructions become invalid: the content of <code>buff</code> may have been rewritten by the side effect of forcing the next element.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>[Invalid_argument]</code> <p>if <code>Bytes.length buffer</code> is less than 32.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-destruct"><a href="#val-destruct" class="anchor"></a><code><span><span class="keyword">val</span> destruct : <span><span class="optlabel">?bson_relaxation</span>:bool <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'t</span> <a href="../Encoding/index.html#type-t">Encoding.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-json">json</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'t</span></span></code></div><div class="spec-doc"><p>Destruct a JSON object into a value. Fail with an exception if the JSON object and encoding do not match.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">[bson_relaxation]</span> <p>(default to <code>false</code>) works around a limitation of the BSON format. Specifically, in BSON, top-level arrays are represented as number-indexed objects. When <code>bson_relaxation</code> is <code>true</code>, then the destructor attempts to automatically translate the indistinguishable values as guided by the encoding.</p></li></ul></div></div><p>JSON Error.</p><div class="odoc-spec"><div class="spec type anchored" id="type-path"><a href="#type-path" class="anchor"></a><code><span><span class="keyword">type</span> path</span><span> = <span><a href="#type-path_item">path_item</a> list</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-path_item"><a href="#type-path_item" class="anchor"></a><code><span><span class="keyword">and</span> path_item</span><span> = </span><span>[ </span></code><ol><li id="type-path_item.Field" class="def variant constructor anchored"><a href="#type-path_item.Field" class="anchor"></a><code><span>| </span><span>`Field <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>A field in an object.</p><span class="comment-delim">*)</span></div></li><li id="type-path_item.Index" class="def variant constructor anchored"><a href="#type-path_item.Index" class="anchor"></a><code><span>| </span><span>`Index <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>An index in an array.</p><span class="comment-delim">*)</span></div></li><li id="type-path_item.Star" class="def variant constructor anchored"><a href="#type-path_item.Star" class="anchor"></a><code><span>| </span><span>`Star</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Any / every field or index.</p><span class="comment-delim">*)</span></div></li><li id="type-path_item.Next" class="def variant constructor anchored"><a href="#type-path_item.Next" class="anchor"></a><code><span>| </span><span>`Next</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The next element after an array.</p><span class="comment-delim">*)</span></div></li></ol><code><span> ]</span></code></div><div class="spec-doc"><p>A set of accessors that point to a location in a JSON object.</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Cannot_destruct"><a href="#exception-Cannot_destruct" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Cannot_destruct</span> <span class="keyword">of</span> <a href="#type-path">path</a> * exn</span></code></div><div class="spec-doc"><p>Exception raised by destructors, with the location in the original JSON structure and the specific error.</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Unexpected"><a href="#exception-Unexpected" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Unexpected</span> <span class="keyword">of</span> string * string</span></code></div><div class="spec-doc"><p>Unexpected kind of data encountered, with the expectation.</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-No_case_matched"><a href="#exception-No_case_matched" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">No_case_matched</span> <span class="keyword">of</span> <span>exn list</span></span></code></div><div class="spec-doc"><p>Some <a href="../index.html#val-union"><code>union</code></a> couldn't be destructed, with the reasons for each <a href="../index.html#val-case"><code>case</code></a>.</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Bad_array_size"><a href="#exception-Bad_array_size" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Bad_array_size</span> <span class="keyword">of</span> int * int</span></code></div><div class="spec-doc"><p>Array of unexpected size encountered, with the expectation.</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Missing_field"><a href="#exception-Missing_field" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Missing_field</span> <span class="keyword">of</span> string</span></code></div><div class="spec-doc"><p>Missing field in an object.</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Unexpected_field"><a href="#exception-Unexpected_field" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Unexpected_field</span> <span class="keyword">of</span> string</span></code></div><div class="spec-doc"><p>Supernumerary field in an object.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print_error"><a href="#val-print_error" class="anchor"></a><code><span><span class="keyword">val</span> print_error : 
  <span><span class="optlabel">?print_unknown</span>:<span>(<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span>exn <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span>exn <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cannot_destruct"><a href="#val-cannot_destruct" class="anchor"></a><code><span><span class="keyword">val</span> cannot_destruct : 
  <span><span><span>(<span class="type-var">'a</span>, <span class="xref-unresolved">Stdlib</span>.Format.formatter, unit, <span class="type-var">'b</span>)</span> <span class="xref-unresolved">Stdlib</span>.format4</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Helpers for writing encoders.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-wrap_error"><a href="#val-wrap_error" class="anchor"></a><code><span><span class="keyword">val</span> wrap_error : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-from_string"><a href="#val-from_string" class="anchor"></a><code><span><span class="keyword">val</span> from_string : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-json">json</a>, string)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p>Read a JSON document from a string.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span><span class="keyword">val</span> to_string : <span><span class="optlabel">?newline</span>:bool <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?minify</span>:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-json">json</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Write a JSON document to a string. This goes via an intermediate buffer and so may be slow on large documents.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span><span class="keyword">val</span> pp : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-json">json</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div></div></body></html>
