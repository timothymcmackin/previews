<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Binary (octez-libs.Data_encoding.V1.Binary)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">octez-libs</a> &#x00BB; <a href="../../index.html">Data_encoding</a> &#x00BB; <a href="../index.html">V1</a> &#x00BB; Binary</nav><header class="odoc-preamble"><h1>Module <code><span>V1.Binary</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-read_error"><a href="#type-read_error" class="anchor"></a><code><span><span class="keyword">type</span> read_error</span><span> = </span></code><ol><li id="type-read_error.Not_enough_data" class="def variant constructor anchored"><a href="#type-read_error.Not_enough_data" class="anchor"></a><code><span>| </span><span><span class="constructor">Not_enough_data</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Decoding requires more bytes than are available in the source of the data. E.g., there are fewer bytes available in the reading buffer than is required by the length field of a dynamically-sized string.</p><span class="comment-delim">*)</span></div></li><li id="type-read_error.Extra_bytes" class="def variant constructor anchored"><a href="#type-read_error.Extra_bytes" class="anchor"></a><code><span>| </span><span><span class="constructor">Extra_bytes</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Decoding requires fewer bytes than were provided.</p><span class="comment-delim">*)</span></div></li><li id="type-read_error.No_case_matched" class="def variant constructor anchored"><a href="#type-read_error.No_case_matched" class="anchor"></a><code><span>| </span><span><span class="constructor">No_case_matched</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Unknown case in a <a href="../index.html#val-string_enum"><code>string_enum</code></a>.</p><span class="comment-delim">*)</span></div></li><li id="type-read_error.Unexpected_tag" class="def variant constructor anchored"><a href="#type-read_error.Unexpected_tag" class="anchor"></a><code><span>| </span><span><span class="constructor">Unexpected_tag</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Unknown case in a <a href="../index.html#val-union"><code>union</code></a> or <a href="../index.html#val-matching"><code>matching</code></a>.</p><span class="comment-delim">*)</span></div></li><li id="type-read_error.Invalid_int" class="def variant constructor anchored"><a href="#type-read_error.Invalid_int" class="anchor"></a><code><span>| </span><span><span class="constructor">Invalid_int</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-read_error.min" class="def record field anchored"><a href="#type-read_error.min" class="anchor"></a><code><span>min : int;</span></code></li><li id="type-read_error.v" class="def record field anchored"><a href="#type-read_error.v" class="anchor"></a><code><span>v : int;</span></code></li><li id="type-read_error.max" class="def record field anchored"><a href="#type-read_error.max" class="anchor"></a><code><span>max : int;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>An integer is out of range. E.g., an integer is beyond a user-provided range.</p><span class="comment-delim">*)</span></div></li><li id="type-read_error.Invalid_float" class="def variant constructor anchored"><a href="#type-read_error.Invalid_float" class="anchor"></a><code><span>| </span><span><span class="constructor">Invalid_float</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-read_error.min" class="def record field anchored"><a href="#type-read_error.min" class="anchor"></a><code><span>min : float;</span></code></li><li id="type-read_error.v" class="def record field anchored"><a href="#type-read_error.v" class="anchor"></a><code><span>v : float;</span></code></li><li id="type-read_error.max" class="def record field anchored"><a href="#type-read_error.max" class="anchor"></a><code><span>max : float;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>A float is out of range.</p><span class="comment-delim">*)</span></div></li><li id="type-read_error.Trailing_zero" class="def variant constructor anchored"><a href="#type-read_error.Trailing_zero" class="anchor"></a><code><span>| </span><span><span class="constructor">Trailing_zero</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>An arbitrary-precision number (N or Z) leads to a null byte.</p><span class="comment-delim">*)</span></div></li><li id="type-read_error.Size_limit_exceeded" class="def variant constructor anchored"><a href="#type-read_error.Size_limit_exceeded" class="anchor"></a><code><span>| </span><span><span class="constructor">Size_limit_exceeded</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>A value is encoded with more bytes than is allowed by the encoding. E.g., the constraints of a <a href="../index.html#val-check_size"><code>check_size</code></a> are being broken.</p><span class="comment-delim">*)</span></div></li><li id="type-read_error.List_too_long" class="def variant constructor anchored"><a href="#type-read_error.List_too_long" class="anchor"></a><code><span>| </span><span><span class="constructor">List_too_long</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>A list contains more elements than is specified in its <code>max_length</code> parameter.</p><span class="comment-delim">*)</span></div></li><li id="type-read_error.Array_too_long" class="def variant constructor anchored"><a href="#type-read_error.Array_too_long" class="anchor"></a><code><span>| </span><span><span class="constructor">Array_too_long</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>An array contains more elements than is specified in its <code>max_length</code> parameter.</p><span class="comment-delim">*)</span></div></li><li id="type-read_error.Exception_raised_in_user_function" class="def variant constructor anchored"><a href="#type-read_error.Exception_raised_in_user_function" class="anchor"></a><code><span>| </span><span><span class="constructor">Exception_raised_in_user_function</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>A function provided by the user raised an exception. E.g., a function in a <a href="../index.html#val-conv"><code>conv</code></a> encoding or a <a href="../index.html#val-delayed"><code>delayed</code></a> encoding raised.</p><span class="comment-delim">*)</span></div></li><li id="type-read_error.User_invariant_guard" class="def variant constructor anchored"><a href="#type-read_error.User_invariant_guard" class="anchor"></a><code><span>| </span><span><span class="constructor">User_invariant_guard</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>A user-provided guard returned an <code>Error _</code>. E.g., in a <a href="../index.html#val-conv_with_guard"><code>conv_with_guard</code></a>.</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>All the errors that might be returned while reading a binary value</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Read_error"><a href="#exception-Read_error" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Read_error</span> <span class="keyword">of</span> <a href="#type-read_error">read_error</a></span></code></div><div class="spec-doc"><p><code>Read_error e</code> is an exception wrapping the <a href="#type-read_error"><code>read_error</code></a> <code>e</code>. It is used only by function suffixed by <code>_exn</code> where the suffix-less function would have returned <code>Error e</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_read_error"><a href="#val-pp_read_error" class="anchor"></a><code><span><span class="keyword">val</span> pp_read_error : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-read_error">read_error</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-read_error_encoding"><a href="#val-read_error_encoding" class="anchor"></a><code><span><span class="keyword">val</span> read_error_encoding : <span><a href="#type-read_error">read_error</a> <a href="../index.html#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-write_error"><a href="#type-write_error" class="anchor"></a><code><span><span class="keyword">type</span> write_error</span><span> = </span></code><ol><li id="type-write_error.Size_limit_exceeded" class="def variant constructor anchored"><a href="#type-write_error.Size_limit_exceeded" class="anchor"></a><code><span>| </span><span><span class="constructor">Size_limit_exceeded</span></span></code></li><li id="type-write_error.No_case_matched" class="def variant constructor anchored"><a href="#type-write_error.No_case_matched" class="anchor"></a><code><span>| </span><span><span class="constructor">No_case_matched</span></span></code></li><li id="type-write_error.Invalid_int" class="def variant constructor anchored"><a href="#type-write_error.Invalid_int" class="anchor"></a><code><span>| </span><span><span class="constructor">Invalid_int</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-write_error.min" class="def record field anchored"><a href="#type-write_error.min" class="anchor"></a><code><span>min : int;</span></code></li><li id="type-write_error.v" class="def record field anchored"><a href="#type-write_error.v" class="anchor"></a><code><span>v : int;</span></code></li><li id="type-write_error.max" class="def record field anchored"><a href="#type-write_error.max" class="anchor"></a><code><span>max : int;</span></code></li></ol><code><span>}</span></code></li><li id="type-write_error.Invalid_float" class="def variant constructor anchored"><a href="#type-write_error.Invalid_float" class="anchor"></a><code><span>| </span><span><span class="constructor">Invalid_float</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-write_error.min" class="def record field anchored"><a href="#type-write_error.min" class="anchor"></a><code><span>min : float;</span></code></li><li id="type-write_error.v" class="def record field anchored"><a href="#type-write_error.v" class="anchor"></a><code><span>v : float;</span></code></li><li id="type-write_error.max" class="def record field anchored"><a href="#type-write_error.max" class="anchor"></a><code><span>max : float;</span></code></li></ol><code><span>}</span></code></li><li id="type-write_error.Invalid_bytes_length" class="def variant constructor anchored"><a href="#type-write_error.Invalid_bytes_length" class="anchor"></a><code><span>| </span><span><span class="constructor">Invalid_bytes_length</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-write_error.expected" class="def record field anchored"><a href="#type-write_error.expected" class="anchor"></a><code><span>expected : int;</span></code></li><li id="type-write_error.found" class="def record field anchored"><a href="#type-write_error.found" class="anchor"></a><code><span>found : int;</span></code></li></ol><code><span>}</span></code></li><li id="type-write_error.Invalid_string_length" class="def variant constructor anchored"><a href="#type-write_error.Invalid_string_length" class="anchor"></a><code><span>| </span><span><span class="constructor">Invalid_string_length</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-write_error.expected" class="def record field anchored"><a href="#type-write_error.expected" class="anchor"></a><code><span>expected : int;</span></code></li><li id="type-write_error.found" class="def record field anchored"><a href="#type-write_error.found" class="anchor"></a><code><span>found : int;</span></code></li></ol><code><span>}</span></code></li><li id="type-write_error.Invalid_natural" class="def variant constructor anchored"><a href="#type-write_error.Invalid_natural" class="anchor"></a><code><span>| </span><span><span class="constructor">Invalid_natural</span></span></code></li><li id="type-write_error.List_invalid_length" class="def variant constructor anchored"><a href="#type-write_error.List_invalid_length" class="anchor"></a><code><span>| </span><span><span class="constructor">List_invalid_length</span></span></code></li><li id="type-write_error.Array_invalid_length" class="def variant constructor anchored"><a href="#type-write_error.Array_invalid_length" class="anchor"></a><code><span>| </span><span><span class="constructor">Array_invalid_length</span></span></code></li><li id="type-write_error.Exception_raised_in_user_function" class="def variant constructor anchored"><a href="#type-write_error.Exception_raised_in_user_function" class="anchor"></a><code><span>| </span><span><span class="constructor">Exception_raised_in_user_function</span> <span class="keyword">of</span> string</span></code></li></ol></div><div class="spec-doc"><p>All the errors that might be returned while writing a binary value</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_write_error"><a href="#val-pp_write_error" class="anchor"></a><code><span><span class="keyword">val</span> pp_write_error : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-write_error">write_error</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-write_error_encoding"><a href="#val-write_error_encoding" class="anchor"></a><code><span><span class="keyword">val</span> write_error_encoding : <span><a href="#type-write_error">write_error</a> <a href="../index.html#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Write_error"><a href="#exception-Write_error" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Write_error</span> <span class="keyword">of</span> <a href="#type-write_error">write_error</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-length"><a href="#val-length" class="anchor"></a><code><span><span class="keyword">val</span> length : <span><span><span class="type-var">'a</span> <a href="../Encoding/index.html#type-t">Encoding.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Compute the expected length of the binary representation of a value.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="#exception-Write_error"><code>Write_error</code></a> <p>in case some size/length invariants are broken.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fixed_length"><a href="#val-fixed_length" class="anchor"></a><code><span><span class="keyword">val</span> fixed_length : <span><span><span class="type-var">'a</span> <a href="../Encoding/index.html#type-t">Encoding.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>int option</span></span></code></div><div class="spec-doc"><p>Returns the size of the binary representation that the given encoding might produce, only when this size does not depends of the value itself.</p><p>E.g., <code>fixed_length (tup2 int64 (Fixed.string 2))</code> is <code>Some _</code></p><p>E.g., <code>fixed_length (result int64 (Fixed.string 2))</code> is <code>None</code></p><p>E.g., <code>fixed_length (list (tup2 int64 (Fixed.string 2)))</code> is <code>None</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-maximum_length"><a href="#val-maximum_length" class="anchor"></a><code><span><span class="keyword">val</span> maximum_length : <span><span><span class="type-var">'a</span> <a href="../Encoding/index.html#type-t">Encoding.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>int option</span></span></code></div><div class="spec-doc"><p>Returns the maximum size of the binary representation that the given encoding might produce, only when this maximum size does not depends of the value itself.</p><p>E.g., <code>maximum_length (tup2 int64 (Fixed.string 2))</code> is <code>Some _</code></p><p>E.g., <code>maximum_length (result int64 (Fixed.string 2))</code> is <code>Some _</code></p><p>E.g., <code>maximum_length (list (tup2 int64 (Fixed.string 2)))</code> is <code>None</code></p><p>Note that the function assumes that recursive encodings (build using <code>mu</code>) are used for recursive data types. As a result, <code>maximum_length</code> will return <code>None</code> if given a recursive encoding.</p><p>If there are static guarantees about the maximum size of the representation for values of a given type, you can wrap your encoding in <code>check_size</code>. This will cause <code>maximum_length</code> to return <code>Some _</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-read"><a href="#val-read" class="anchor"></a><code><span><span class="keyword">val</span> read : 
  <span><span><span class="type-var">'a</span> <a href="../Encoding/index.html#type-t">Encoding.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  <span><span>(int * <span class="type-var">'a</span>, <a href="#type-read_error">read_error</a>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>read enc buf ofs len</code> tries to reconstruct a value from the bytes in <code>buf</code> starting at offset <code>ofs</code> and reading at most <code>len</code> bytes. This function also returns the offset of the first unread bytes in the <code>buf</code>.</p><p>The function will fail (returning <code>Error _</code>) if</p><ul><li>the bytes in <code>buf</code> designated by <code>ofs</code> and <code>len</code> are not compatible with the encoding <code>enc</code> (e.g., an integer is out the range specified in the encoding, or a union's tag is not recognised),</li><li>it needs to read more than <code>len</code> bytes to decode the value,</li><li>a user-provided function (such as that of a <code>conv</code> or <code>delayed</code>) raises an exception,</li><li>etc. In which case the returned error contains minimal diagnosis information about the discrepancy between the bytes and the encoding.</li></ul><p>Other reading functions (<a href="#val-of_string"><code>of_string</code></a>, <a href="#val-of_bytes"><code>of_bytes</code></a>) may fail for the same reasons.</p><p>The returned value contains no pointer back to <code>buf</code> (as a whole or as sub-strings), even in the case where the encoding is or includes <code>Fixed.string</code> or <code>Fixed.bytes</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-read_opt"><a href="#val-read_opt" class="anchor"></a><code><span><span class="keyword">val</span> read_opt : <span><span><span class="type-var">'a</span> <a href="../Encoding/index.html#type-t">Encoding.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span>(int * <span class="type-var">'a</span>)</span> option</span></span></code></div><div class="spec-doc"><p><code>read_opt</code> is like <code>read</code> but in case of failure, the error is ignored and <code>None</code> is returned instead.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-read_exn"><a href="#val-read_exn" class="anchor"></a><code><span><span class="keyword">val</span> read_exn : <span><span><span class="type-var">'a</span> <a href="../Encoding/index.html#type-t">Encoding.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int * <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>read_exn</code> is like <code>read</code> but in case of failure, the error is wrapped in <code>Read_error</code> which is raised.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-status"><a href="#type-status" class="anchor"></a><code><span><span class="keyword">type</span> <span>'ret status</span></span><span> = </span></code><ol><li id="type-status.Success" class="def variant constructor anchored"><a href="#type-status.Success" class="anchor"></a><code><span>| </span><span><span class="constructor">Success</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-status.result" class="def record field anchored"><a href="#type-status.result" class="anchor"></a><code><span>result : <span class="type-var">'ret</span>;</span></code></li><li id="type-status.size" class="def record field anchored"><a href="#type-status.size" class="anchor"></a><code><span>size : int;</span></code></li><li id="type-status.stream" class="def record field anchored"><a href="#type-status.stream" class="anchor"></a><code><span>stream : <a href="../Binary_stream/index.html#type-t">Binary_stream.t</a>;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Fully decoded value, together with the total amount of bytes reads, and the remaining unread stream.</p><span class="comment-delim">*)</span></div></li><li id="type-status.Await" class="def variant constructor anchored"><a href="#type-status.Await" class="anchor"></a><code><span>| </span><span><span class="constructor">Await</span> <span class="keyword">of</span> <span><span class="xref-unresolved">Stdlib</span>.Bytes.t <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'ret</span> <a href="#type-status">status</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Partially decoded value.</p><span class="comment-delim">*)</span></div></li><li id="type-status.Error" class="def variant constructor anchored"><a href="#type-status.Error" class="anchor"></a><code><span>| </span><span><span class="constructor">Error</span> <span class="keyword">of</span> <a href="#type-read_error">read_error</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Failure. The stream is garbled and it should be dropped.</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Return type for the function <code>read_stream</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-read_stream"><a href="#val-read_stream" class="anchor"></a><code><span><span class="keyword">val</span> read_stream : <span><span class="optlabel">?init</span>:<a href="../Binary_stream/index.html#type-t">Binary_stream.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../Encoding/index.html#type-t">Encoding.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-status">status</a></span></span></code></div><div class="spec-doc"><p>Streamed equivalent of <code>read</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>[Invalid_argument]</code> <p>if called with a variable-size encoding.</p><p><code>read_stream e</code> is <code>Await k</code> and you can use <code>k</code> to feed the first bytes to be decoded.</p><p>If you feed invalid bytes (i.e., bytes that do not match <code>e</code>) to <code>k</code>, it returns <code>Error</code>.</p><p>If you feed bytes that form a valid strict prefix for <code>e</code>, then it returns <code>Await k</code>, and you can use <code>k</code> to feed it more bytes.</p><p>If you feed it sufficient bytes to decode a whole value described by <code>e</code>, then it returns <code>Success s</code> where <code>s.result</code> is the decoded value, <code>s.size</code> is the number of bytes that were read to decode this value, and <code>s.stream</code> is the left-over stream.</p><p>The leftover stream may contain more bytes which you may treat however you like depending on your application. You may ignore padding bytes reserved for extensions (in which case you can simply ignore the stream). You may use the leftover stream to call <code>read_stream</code> again to decode the rest of the value.</p><p><code>read_stream ~init e</code> is the same as <code>let (Await k) = read_stream e in k b</code> where <code>b</code> are the leftover bytes of <code>init</code>.</p><p>E.g., reading multiple values from a socket or some such source of bytes that becomes available as time goes by.</p><pre class="language-ocaml"><code>let iter socket encoding f =
   let rec loop = function
      | Success {result; size; stream} -&gt;
         log &quot;read %d bytes&quot; size;
         f result (* apply iterator function on each decoded value *);
         loop (read_stream ~init:stream e) (* continue with leftover *)
      | Await k -&gt;
         loop (k (read_more_bytes_from socket))
      | Error e -&gt;
         log &quot;error: %a&quot; pp_read_error e
   in
   loop (read_stream e)</code></pre></li></ul></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-writer_state"><a href="#type-writer_state" class="anchor"></a><code><span><span class="keyword">type</span> writer_state</span></code></div><div class="spec-doc"><p>The internal state that writers handle. It is presented explicitly as an abstract type so that you must use the constructor to obtain it. The constructor (<a href="#val-make_writer_state"><code>make_writer_state</code></a>) performs basic bound checks.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-make_writer_state"><a href="#val-make_writer_state" class="anchor"></a><code><span><span class="keyword">val</span> make_writer_state : 
  <span>bytes <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">offset</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">allowed_bytes</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-writer_state">writer_state</a> option</span></span></code></div><div class="spec-doc"><p><code>make_writer_state buffer ~offset ~allowed_bytes</code> is <code>None</code> if <code>allowed_bytes &lt; 0</code>, <code>None</code> if <code>allowed_bytes &gt; length buffer - offset</code>, <code>Some _</code> otherwise.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-write"><a href="#val-write" class="anchor"></a><code><span><span class="keyword">val</span> write : 
  <span><span><span class="type-var">'a</span> <a href="../Encoding/index.html#type-t">Encoding.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-writer_state">writer_state</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(int, <a href="#type-write_error">write_error</a>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>write enc v state</code> where <code>Some state</code> is <code>make_writer_state buffer ~offset ~allowed_bytes</code> writes the binary <code>enc</code> representation of <code>v</code> onto <code>buffer</code> starting at <code>offset</code>. The function will fail (returning <code>Error _</code>) if the encoding would use more than <code>allowed_bytes</code>.</p><p>The function returns the offset of first unwritten bytes, or returns <code>Error _</code> in case of failure. In the latter case, some data might have been written on the buffer.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-write_opt"><a href="#val-write_opt" class="anchor"></a><code><span><span class="keyword">val</span> write_opt : <span><span><span class="type-var">'a</span> <a href="../Encoding/index.html#type-t">Encoding.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-writer_state">writer_state</a> <span class="arrow">&#45;&gt;</span></span> <span>int option</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-write_exn"><a href="#val-write_exn" class="anchor"></a><code><span><span class="keyword">val</span> write_exn : <span><span><span class="type-var">'a</span> <a href="../Encoding/index.html#type-t">Encoding.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-writer_state">writer_state</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_bytes"><a href="#val-of_bytes" class="anchor"></a><code><span><span class="keyword">val</span> of_bytes : 
  <span><span><span class="type-var">'a</span> <a href="../Encoding/index.html#type-t">Encoding.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Bytes.t <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span>, <a href="#type-read_error">read_error</a>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>of_bytes enc buf</code> is equivalent to <code>read enc buf 0 (length buf)</code>. The function fails if the buffer is not fully read.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_bytes_opt"><a href="#val-of_bytes_opt" class="anchor"></a><code><span><span class="keyword">val</span> of_bytes_opt : <span><span><span class="type-var">'a</span> <a href="../Encoding/index.html#type-t">Encoding.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Stdlib</span>.Bytes.t <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_bytes_exn"><a href="#val-of_bytes_exn" class="anchor"></a><code><span><span class="keyword">val</span> of_bytes_exn : <span><span><span class="type-var">'a</span> <a href="../Encoding/index.html#type-t">Encoding.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Stdlib</span>.Bytes.t <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>of_bytes_exn enc buf</code> is equivalent to <code>of_bytes</code>, except</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>[Read_error]</code> <p>instead of returning <code>None</code> in case of error.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_string"><a href="#val-of_string" class="anchor"></a><code><span><span class="keyword">val</span> of_string : <span><span><span class="type-var">'a</span> <a href="../Encoding/index.html#type-t">Encoding.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <a href="#type-read_error">read_error</a>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>of_string enc buf</code> is like <code>of_bytes enc buf</code> but it reads bytes from a string.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_string_opt"><a href="#val-of_string_opt" class="anchor"></a><code><span><span class="keyword">val</span> of_string_opt : <span><span><span class="type-var">'a</span> <a href="../Encoding/index.html#type-t">Encoding.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_string_exn"><a href="#val-of_string_exn" class="anchor"></a><code><span><span class="keyword">val</span> of_string_exn : <span><span><span class="type-var">'a</span> <a href="../Encoding/index.html#type-t">Encoding.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_bytes"><a href="#val-to_bytes" class="anchor"></a><code><span><span class="keyword">val</span> to_bytes : 
  <span><span class="optlabel">?buffer_size</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="../Encoding/index.html#type-t">Encoding.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="xref-unresolved">Stdlib</span>.Bytes.t, <a href="#type-write_error">write_error</a>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>to_bytes enc v</code> is the equivalent of <code>write env buf 0 len</code> where <code>buf</code> is a newly allocated buffer. The parameter <code>buffer_size</code> controls the initial size of <code>buf</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>[Invalid_argument]</code> <p>if <code>buffer_size &lt; 0</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_bytes_opt"><a href="#val-to_bytes_opt" class="anchor"></a><code><span><span class="keyword">val</span> to_bytes_opt : 
  <span><span class="optlabel">?buffer_size</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="../Encoding/index.html#type-t">Encoding.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Bytes.t option</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_bytes_exn"><a href="#val-to_bytes_exn" class="anchor"></a><code><span><span class="keyword">val</span> to_bytes_exn : <span><span class="optlabel">?buffer_size</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../Encoding/index.html#type-t">Encoding.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Stdlib</span>.Bytes.t</span></code></div><div class="spec-doc"><p><code>to_bytes_exn enc v</code> is equivalent to <code>to_bytes enc v</code>, except</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>[Write_error]</code> <p>instead of returning <code>None</code> in case of error.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span><span class="keyword">val</span> to_string : 
  <span><span class="optlabel">?buffer_size</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="../Encoding/index.html#type-t">Encoding.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(string, <a href="#type-write_error">write_error</a>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>to_string enc v</code> is like <code>to_bytes</code> but it returns a string.</p><p>Note: <code>to_string enc v</code> is always equal to <code>Bytes.to_string (to_bytes enc v)</code> but more efficient.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>[Invalid_argument]</code> <p>if <code>buffer_size &lt; 0</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_string_opt"><a href="#val-to_string_opt" class="anchor"></a><code><span><span class="keyword">val</span> to_string_opt : <span><span class="optlabel">?buffer_size</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../Encoding/index.html#type-t">Encoding.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>string option</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_string_exn"><a href="#val-to_string_exn" class="anchor"></a><code><span><span class="keyword">val</span> to_string_exn : <span><span class="optlabel">?buffer_size</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../Encoding/index.html#type-t">Encoding.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>[Write_error]</code> <p>instead of returning <code>None</code> in case of error.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-describe"><a href="#val-describe" class="anchor"></a><code><span><span class="keyword">val</span> describe : <span><span><span class="type-var">'a</span> <a href="../Encoding/index.html#type-t">Encoding.t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="../Binary_schema/index.html#type-t">Binary_schema.t</a></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Slicer"><a href="#module-Slicer" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Slicer/index.html">Slicer</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div></div></body></html>
