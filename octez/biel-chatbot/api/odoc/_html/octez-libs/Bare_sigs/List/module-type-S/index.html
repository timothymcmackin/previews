<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>S (octez-libs.Bare_sigs.List.S)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../../index.html">octez-libs</a> &#x00BB; <a href="../../index.html">Bare_sigs</a> &#x00BB; <a href="../index.html">List</a> &#x00BB; S</nav><header class="odoc-preamble"><h1>Module type <code><span>List.S</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#constructors-and-some-such">Constructors and some such</a></li><li><a href="#safe-wrappers">Safe wrappers</a></li><li><a href="#initialisation">Initialisation</a></li><li><a href="#basic-traversal">Basic traversal</a></li><li><a href="#double-list-traversals">Double-list traversals</a></li><li><a href="#monad-aware-variants">Monad-aware variants</a></li><li><a href="#initialisation-variants">Initialisation variants</a></li><li><a href="#query-variants">Query variants</a></li><li><a href="#traversal-variants">Traversal variants</a></li><li><a href="#double-traversal-variants">Double-traversal variants</a></li><li><a href="#scanning-variants">Scanning variants</a></li><li><a href="#double-scanning-variants">Double-scanning variants</a></li><li><a href="#combine-variants">Combine variants</a></li><li><a href="#product">Product</a></li><li><a href="#comparison-and-equality">Comparison and equality</a></li><li><a href="#sorting">Sorting</a></li><li><a href="#conversion">Conversion</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span><span> = <span><span class="type-var">'a</span> list</span></span><span> = </span></code><ol><li id="type-t.[]" class="def variant constructor anchored"><a href="#type-t.[]" class="anchor"></a><code><span>| </span><span><span class="constructor">[]</span></span></code></li><li id="type-t.::" class="def variant constructor anchored"><a href="#type-t.::" class="anchor"></a><code><span>| </span><span><span class="constructor">::</span> <span class="keyword">of</span> <span class="type-var">'a</span> * <span><span class="type-var">'a</span> list</span></span></code></li></ol></div><div class="spec-doc"><p>The list type</p></div></div><h4 id="constructors-and-some-such"><a href="#constructors-and-some-such" class="anchor"></a>Constructors and some such</h4><div class="odoc-spec"><div class="spec value anchored" id="val-nil"><a href="#val-nil" class="anchor"></a><code><span><span class="keyword">val</span> nil : <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>nil</code> is <code>[]</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-nil_e"><a href="#val-nil_e" class="anchor"></a><code><span><span class="keyword">val</span> nil_e : <span><span>(<span><span class="type-var">'a</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>nil_e</code> is <code>Ok []</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-nil_s"><a href="#val-nil_s" class="anchor"></a><code><span><span class="keyword">val</span> nil_s : <span><span><span class="type-var">'a</span> list</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>nil_s</code> is <code>Lwt.return_nil</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-nil_es"><a href="#val-nil_es" class="anchor"></a><code><span><span class="keyword">val</span> nil_es : <span><span><span>(<span><span class="type-var">'a</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>nil_es</code> is <code>Lwt.return (Ok [])</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cons"><a href="#val-cons" class="anchor"></a><code><span><span class="keyword">val</span> cons : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>cons x xs</code> is <code>x :: xs</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span><span class="keyword">val</span> is_empty : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_empty xs</code> is <code>true</code> iff <code>xs</code> is <code>[]</code></p></div></div><h4 id="safe-wrappers"><a href="#safe-wrappers" class="anchor"></a>Safe wrappers</h4><p>This part of the module simply shadows some functions from <code>Stdlib.List</code> with exceptionless variants. As per the design principles of Lwtreslib,</p><ul><li>functions which may fail with <code>Not_found</code> or otherwise from unavailability of data return an <code>option</code> instead,</li><li>function which may fail with <code>Invalid_argument _</code> or otherwise from malformedness of input receive an additional parameter to return as an <code>Error</code> instead,</li><li>functions which perform polymorphic comparison receive an additional parameter for monomorphic comparison instead.</li></ul><div class="odoc-spec"><div class="spec value anchored" id="val-hd"><a href="#val-hd" class="anchor"></a><code><span><span class="keyword">val</span> hd : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p><code>hd xs</code> is the head (first element) of the list or <code>None</code> if the list is empty.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tl"><a href="#val-tl" class="anchor"></a><code><span><span class="keyword">val</span> tl : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> option</span></span></code></div><div class="spec-doc"><p><code>tl xs</code> is the tail of the list (the whole list except the first element) or <code>None</code> if the list is empty.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-nth"><a href="#val-nth" class="anchor"></a><code><span><span class="keyword">val</span> nth : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p><code>nth xs n</code> is the <code>n</code>th element of the list or <code>None</code> if the list has fewer than <code>n</code> elements.</p><p>For example, <code>nth xs 0 = hd xs</code> and <code>nth ['x'; 'y'] 1 = Some 'y'</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-nth_opt"><a href="#val-nth_opt" class="anchor"></a><code><span><span class="keyword">val</span> nth_opt : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p><code>nth_opt</code> is an alias for <code>nth</code> provided for compatibility with <code>Stdlib.List</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-last"><a href="#val-last" class="anchor"></a><code><span><span class="keyword">val</span> last : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>last x xs</code> is the last element of the list <code>xs</code> or <code>x</code> if <code>xs</code> is empty.</p><p>The primary intended use for <code>last</code> is after destructing a list: <code>match l with | [] -&gt; … | x :: xs -&gt; last x xs</code> but it can also be used for a default value: <code>last default_value_if_empty xs</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-last_opt"><a href="#val-last_opt" class="anchor"></a><code><span><span class="keyword">val</span> last_opt : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p><code>last_opt xs</code> is the last element of the list <code>xs</code> or <code>None</code> if the list <code>xs</code> is empty.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-find"><a href="#val-find" class="anchor"></a><code><span><span class="keyword">val</span> find : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p><code>find predicate xs</code> is the first element <code>x</code> of the list <code>xs</code> such that <code>predicate x</code> is <code>true</code> or <code>None</code> if the list <code>xs</code> has no such element.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-find_opt"><a href="#val-find_opt" class="anchor"></a><code><span><span class="keyword">val</span> find_opt : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p><code>find_opt</code> is an alias for <code>find</code> provided for compatibility with <code>Stdlib.List</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-find_map"><a href="#val-find_map" class="anchor"></a><code><span><span class="keyword">val</span> find_map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span></span></code></div><div class="spec-doc"><p><code>find_map f xs</code> applies <code>f</code> to each of the elements of <code>xs</code> until it returns <code>Some _</code> at which point it is returned. If no such elements are found then it returns <code>None</code>.</p><p>Note that it only applies <code>f</code> to a prefix of <code>xs</code>. It doesn't apply <code>f</code> to the elements of <code>xs</code> which are after the found element. Consequently, <code>find_map f xs</code> has better performance and a different semantic than calling <code>map</code> and <code>find</code> separately.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mem"><a href="#val-mem" class="anchor"></a><code><span><span class="keyword">val</span> mem : <span><span class="label">equal</span>:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>mem ~equal a l</code> is <code>true</code> iff there is an element <code>e</code> of <code>l</code> such that <code>equal a e</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-memq"><a href="#val-memq" class="anchor"></a><code><span><span class="keyword">val</span> memq : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>memq a l</code> is the same as <code>mem ~equal:Stdlib.( == ) a l</code>: it uses the physical equality.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-assoc"><a href="#val-assoc" class="anchor"></a><code><span><span class="keyword">val</span> assoc : <span><span class="label">equal</span>:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span></span></code></div><div class="spec-doc"><p><code>assoc ~equal k kvs</code> is <code>Some v</code> such that <code>(k', v)</code> is the first pair in the list such that <code>equal k' k</code> or <code>None</code> if the list contains no such pair.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-assoc_opt"><a href="#val-assoc_opt" class="anchor"></a><code><span><span class="keyword">val</span> assoc_opt : <span><span class="label">equal</span>:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span></span></code></div><div class="spec-doc"><p><code>assoc_opt</code> is an alias for <code>assoc</code> provided for compatibility with <code>Stdlib.List</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-assq"><a href="#val-assq" class="anchor"></a><code><span><span class="keyword">val</span> assq : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span></span></code></div><div class="spec-doc"><p><code>assq k kvs</code> is the same as <code>assoc ~equal:Stdlib.( == ) k kvs</code>: it uses the physical equality.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-assq_opt"><a href="#val-assq_opt" class="anchor"></a><code><span><span class="keyword">val</span> assq_opt : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span></span></code></div><div class="spec-doc"><p><code>assq_opt</code> is an alias for <code>assq</code> provided for compatibility with <code>Stdlib.List</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mem_assoc"><a href="#val-mem_assoc" class="anchor"></a><code><span><span class="keyword">val</span> mem_assoc : <span><span class="label">equal</span>:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>mem_assoc ~equal k l</code> is equivalent to <code>Option.is_some @@ assoc ~equal k l</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mem_assq"><a href="#val-mem_assq" class="anchor"></a><code><span><span class="keyword">val</span> mem_assq : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>mem_assq k l</code> is <code>mem_assoc ~equal:Stdlib.( == ) k l</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-remove_assoc"><a href="#val-remove_assoc" class="anchor"></a><code><span><span class="keyword">val</span> remove_assoc : 
  <span><span class="label">equal</span>:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span></span></code></div><div class="spec-doc"><p><code>remove_assoc ~equal k l</code> is <code>l</code> without the first element <code>(k', _)</code> such that <code>equal k k'</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-remove_assq"><a href="#val-remove_assq" class="anchor"></a><code><span><span class="keyword">val</span> remove_assq : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span></span></code></div><div class="spec-doc"><p><code>remove_assoq k l</code> is <code>remove_assoc ~equal:Stdlib.( == ) k l</code>.</p></div></div><h4 id="initialisation"><a href="#initialisation" class="anchor"></a>Initialisation</h4><div class="odoc-spec"><div class="spec value anchored" id="val-init"><a href="#val-init" class="anchor"></a><code><span><span class="keyword">val</span> init : 
  <span><span class="label">when_negative_length</span>:<span class="type-var">'trace</span> <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>init ~when_negative_length n f</code> is a list of <code>n</code> elements <code>f 0</code>, <code>f 1</code>, etc.</p><p>If <code>n</code> is negative, it is <code>Error when_negative_length</code> instead.</p></div></div><h4 id="basic-traversal"><a href="#basic-traversal" class="anchor"></a>Basic traversal</h4><div class="odoc-spec"><div class="spec value anchored" id="val-length"><a href="#val-length" class="anchor"></a><code><span><span class="keyword">val</span> length : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>length xs</code> is the number of elements in <code>xs</code>.</p><p><code>length []</code> is <code>0</code>, <code>length ['x']</code> is <code>1</code>, etc.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev"><a href="#val-rev" class="anchor"></a><code><span><span class="keyword">val</span> rev : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>rev xs</code> is a list with the elements appearing in the reverse order as in <code>xs</code>.</p><p><code>rev ['x'; 'y']</code> is <code>'y'; 'x'</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-concat"><a href="#val-concat" class="anchor"></a><code><span><span class="keyword">val</span> concat : <span><span><span><span class="type-var">'a</span> list</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>concat xs</code> is a list containing the elements of the elements of <code>xs</code>.</p><p><code>concat [['x'; 'y']; ['a'; 'b']]</code> is <code>['x'; 'y'; 'a'; 'b']</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-append"><a href="#val-append" class="anchor"></a><code><span><span class="keyword">val</span> append : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>append xs ys</code> is a list containing the elements of <code>xs</code> and the elements of <code>ys</code>, in this order.</p><p><code>concat ['x'; 'y'] ['a'; 'b']</code> is <code>['x'; 'y'; 'a'; 'b']</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_append"><a href="#val-rev_append" class="anchor"></a><code><span><span class="keyword">val</span> rev_append : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>rev_append xs ys</code> is <code>append (rev xs) ys</code> but more efficient. In other words, <code>rev_append xs ys</code> is a list containing the elements of xs in reverse order followed by the elements of <code>ys</code>.</p><p>There are two main use-cases for <code>rev_append</code>. First, you should use <code>rev_append</code> when the order of elements is unimportant. In this case you simply replace <code>append xs ys</code> with <code>rev_append xs ys</code>.</p><p>Second, you can use <code>rev_append</code> on an already reversed list. You may obtain an already reversed list from any of the other <code>rev_*</code> functions of this module, or simply via your own traversal. In this case, you replace, say, <code>append (map f xs) ys</code> with <code>rev_append (rev_map f xs) ys</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-flatten"><a href="#val-flatten" class="anchor"></a><code><span><span class="keyword">val</span> flatten : <span><span><span><span class="type-var">'a</span> list</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>flatten</code> is an alias for <a href="#val-concat"><code>concat</code></a>.</p></div></div><h4 id="double-list-traversals"><a href="#double-list-traversals" class="anchor"></a>Double-list traversals</h4><p>These safe-wrappers take an explicit value to handle the case of lists of unequal length. This value is passed as a named parameter: <code>when_different_lengths</code>.</p><p>Note that the traversal function passed as argument (if any) is applied to the common prefix of the two lists, even if they are of different lengths. E.g., in <code>map2 f ['x', 'y'] ['a']</code> the call <code>f 'x' 'a'</code> is made and all its side-effects are performed before the value <code>Error when_different_lengths</code> is returned</p><div class="odoc-spec"><div class="spec value anchored" id="val-combine"><a href="#val-combine" class="anchor"></a><code><span><span class="keyword">val</span> combine : 
  <span><span class="label">when_different_lengths</span>:<span class="type-var">'trace</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>combine ~when_different_lengths l1 l2</code> is either</p><ul><li><code>Error when_different_lengths</code> if <code>List.length l1 &lt;&gt; List.length l2</code></li><li>a list of pairs of elements from <code>l1</code> and <code>l2</code></li></ul><p>E.g., <code>combine ~when_different_lengths [] []</code> is <code>Ok []</code></p><p>E.g., <code>combine ~when_different_lengths [1; 2] ['a'; 'b']</code> is <code>Ok [(1,'a'); (2, 'b')]</code></p><p>E.g., <code>combine ~when_different_lengths:&quot;wrong&quot; [1] []</code> is <code>Error &quot;wrong&quot;</code></p><p>Note: <code>combine ~when_different_lengths l1 l2</code> is equivalent to <code>try Ok (Stdlib.List.combine l1 l2) with Invalid_argument _ -&gt; when_different_lengths</code></p><p>The same equivalence almost holds for the other double traversors below. The notable difference is if the functions passed as argument to the traversors raise the <code>Invalid_argument _</code> exception.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_combine"><a href="#val-rev_combine" class="anchor"></a><code><span><span class="keyword">val</span> rev_combine : 
  <span><span class="label">when_different_lengths</span>:<span class="type-var">'trace</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>rev_combine ~when_different_lengths xs ys</code> is <code>rev (combine ~when_different_lengths xs ys)</code> but more efficient.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-split"><a href="#val-split" class="anchor"></a><code><span><span class="keyword">val</span> split : <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'b</span> list</span></span></code></div><div class="spec-doc"><p><code>split xs</code> is <code>(List.map fst xs, List.map snd xs)</code> but more efficient.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-iter2"><a href="#val-iter2" class="anchor"></a><code><span><span class="keyword">val</span> iter2 : 
  <span><span class="label">when_different_lengths</span>:<span class="type-var">'trace</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(unit, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>iter2 ~when_different_lengths f xs ys</code> is <code>f x0 y0; f x1 y1; …</code>.</p><p>Remember that, even if the lists are of different lengths, the function <code>f</code> is applied to the common prefix of <code>xs</code> and <code>ys</code>. This is true for other traversals, but especially relevant to <code>iter</code> which is commonly used for side-effects.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map2"><a href="#val-map2" class="anchor"></a><code><span><span class="keyword">val</span> map2 : 
  <span><span class="label">when_different_lengths</span>:<span class="type-var">'trace</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'c</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>map2 ~when_different_lengths f xs ys</code> is a list with elements <code>f x0 y0</code>, <code>f x1 y1</code>, etc.</p><p>Remember that, even if the lists are of different lengths, the function <code>f</code> is applied to the common prefix of <code>xs</code> and <code>ys</code>. Beware of side-effects and computational cost.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_map2"><a href="#val-rev_map2" class="anchor"></a><code><span><span class="keyword">val</span> rev_map2 : 
  <span><span class="label">when_different_lengths</span>:<span class="type-var">'trace</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'c</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>rev_map2 ~when_different_lengths f xs ys</code> is <code>Result.map rev @@ map2 ~when_different_lengths f xs ys</code> but more efficient.</p><p>Remember that, even if the lists are of different lengths, the function <code>f</code> is applied to the common prefix of <code>xs</code> and <code>ys</code>. Beware of side-effects and computational cost.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold_left2"><a href="#val-fold_left2" class="anchor"></a><code><span><span class="keyword">val</span> fold_left2 : 
  <span><span class="label">when_different_lengths</span>:<span class="type-var">'trace</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'c</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>fold_left2 ~when_different_lengths f init xs ys</code> is <code>… (f (f init x0 y0) x1 y1)</code>.</p><p>Remember that, even if the lists are of different lengths, the function <code>f</code> is applied to the common prefix of <code>xs</code> and <code>ys</code>. Beware of side-effects and computational cost.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold_right2"><a href="#val-fold_right2" class="anchor"></a><code><span><span class="keyword">val</span> fold_right2 : 
  <span><span class="label">when_different_lengths</span>:<span class="type-var">'trace</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'c</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>fold_right2 ~when_different_lengths f xs ys init</code> is <code>f x0 y0 (f x1 y1 (…))</code>.</p><p>This function is not tail-recursive.</p><p>Note that unlike the left-to-right double-list traversors, <code>fold_right2</code> only calls <code>f</code> if the lists are of the same length.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-for_all2"><a href="#val-for_all2" class="anchor"></a><code><span><span class="keyword">val</span> for_all2 : 
  <span><span class="label">when_different_lengths</span>:<span class="type-var">'trace</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(bool, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>for_all2 ~when_different_lengths f xs ys</code> is <code>f x0 y0 &amp;&amp; f x1 y1 &amp;&amp; …</code>.</p><p>The function stops early if it encounters elements <code>xn</code>, <code>yn</code> such that <code>f
      xn yn</code> is <code>false</code>. (This is consistent with the short-circuit, lazy evaluation strategy of <code>&amp;&amp;</code> in the description above.)</p><p>Also note that, if such an element is found in the common prefix of <code>xs</code> and <code>ys</code>, then the function returns <code>Ok false</code> even if <code>xs</code> and <code>ys</code> are of different lengths.</p><p>Examples:</p><p><code>for_all2 ~when_different_lengths (=) [] []</code> is <code>Ok true</code></p><p><code>for_all2 ~when_different_lengths (=) ['x'] ['a']</code> is <code>Ok false</code></p><p><code>for_all2 ~when_different_lengths (=) ['x'; 'y'] ['a']</code> is <code>Ok false</code></p><p><code>for_all2 ~when_different_lengths (=) ['x'] ['x']</code> is <code>Ok true</code></p><p><code>for_all2 ~when_different_lengths (=) ['x'; 'y'] ['x']</code> is <code>Error when_different_lengths</code></p><p><code>for_all2 ~when_different_lengths (=) ['x'; 'y'] ['x'; 'b']</code> is <code>Ok false</code></p><p><code>for_all2 ~when_different_lengths (=) ['x'; 'y'] ['x'; 'y'; 'c']</code> is <code>Error when_different_lengths</code></p><p>Remember that, when it returns <code>Error when_different_lengths</code>, the function <code>f</code> has already been applied to the common prefix of <code>xs</code> and <code>ys</code>. Beware of side-effects and computational cost.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-exists2"><a href="#val-exists2" class="anchor"></a><code><span><span class="keyword">val</span> exists2 : 
  <span><span class="label">when_different_lengths</span>:<span class="type-var">'trace</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(bool, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>exists2 ~when_different_lengths f xs ys</code> is <code>f x0 y0 || f x1 y1 || …</code>.</p><p>The function stops early if it encounters elements <code>xn</code>, <code>yn</code> such that <code>f
      xn yn</code> is <code>true</code>. (This is consistent with the short-circuit, lazy evaluation strategy of <code>||</code> in the description above.)</p><p>Also note that, if such an element is found in the common prefix of <code>xs</code> and <code>ys</code>, then the function returns <code>Ok true</code> even if <code>xs</code> and <code>ys</code> are of different lengths.</p><p>Examples:</p><p><code>exists2 ~when_different_lengths (=) [] []</code> is <code>Ok false</code></p><p><code>exists2 ~when_different_lengths (=) ['x'] ['a']</code> is <code>Ok false</code></p><p><code>exists2 ~when_different_lengths (=) ['x'; 'y'] ['a']</code> is <code>Error when_different_lengths</code></p><p><code>exists2 ~when_different_lengths (=) ['x'] ['x']</code> is <code>Ok true</code></p><p><code>exists2 ~when_different_lengths (=) ['x'; 'y'] ['x']</code> is <code>Ok true</code></p><p>Remember that, when it returns <code>Error when_different_lengths</code>, the function <code>f</code> has already been applied to the common prefix of <code>xs</code> and <code>ys</code>. Beware of side-effects and computational cost.</p></div></div><h4 id="monad-aware-variants"><a href="#monad-aware-variants" class="anchor"></a>Monad-aware variants</h4><p>The functions below are strict extensions of the standard <code>Stdlib.List</code> module. It is for result-, lwt- and lwt-result-aware variants. The meaning of the suffix is as described above, in <code>Lwtreslib</code>, and in <code>Sigs.Seq</code>.</p><h4 id="initialisation-variants"><a href="#initialisation-variants" class="anchor"></a>Initialisation variants</h4><p>Note that for asynchronous variants (<code>_s</code>, <code>_es</code>, <code>_p</code>, and <code>_ep</code>), if the length parameter is negative, then the promise is returned already fulfilled with <code>Error when_different_lengths</code>.</p><div class="odoc-spec"><div class="spec value anchored" id="val-init_e"><a href="#val-init_e" class="anchor"></a><code><span><span class="keyword">val</span> init_e : 
  <span><span class="label">when_negative_length</span>:<span class="type-var">'trace</span> <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>init_e</code> is a Result-aware variant of <a href="#val-init"><code>init</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-init_s"><a href="#val-init_s" class="anchor"></a><code><span><span class="keyword">val</span> init_s : 
  <span><span class="label">when_negative_length</span>:<span class="type-var">'trace</span> <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><span class="type-var">'a</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>init_s</code> is an Lwt-aware variant of <a href="#val-init"><code>init</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-init_es"><a href="#val-init_es" class="anchor"></a><code><span><span class="keyword">val</span> init_es : 
  <span><span class="label">when_negative_length</span>:<span class="type-var">'trace</span> <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><span class="type-var">'a</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>init_es</code> is an Lwt-Result-aware variant of <a href="#val-init"><code>init</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-init_ep"><a href="#val-init_ep" class="anchor"></a><code><span><span class="keyword">val</span> init_ep : 
  <span><span class="label">when_negative_length</span>:<span class="type-var">'error</span> <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'error</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><span class="type-var">'a</span> list</span>, <span><span class="type-var">'error</span> list</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>init_ep</code> is a variant of <a href="#val-init_es"><code>init_es</code></a> where the promises are evaluated concurrently.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-init_p"><a href="#val-init_p" class="anchor"></a><code><span><span class="keyword">val</span> init_p : 
  <span><span class="label">when_negative_length</span>:<span class="type-var">'trace</span> <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><span class="type-var">'a</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>init_p</code> is a variant of <a href="#val-init_s"><code>init_s</code></a> where the promises are evaluated concurrently.</p></div></div><h4 id="query-variants"><a href="#query-variants" class="anchor"></a>Query variants</h4><div class="odoc-spec"><div class="spec value anchored" id="val-find_e"><a href="#val-find_e" class="anchor"></a><code><span><span class="keyword">val</span> find_e : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(bool, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> option</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>find_e</code> is a Result-aware variant of <a href="#val-find"><code>find</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-find_s"><a href="#val-find_s" class="anchor"></a><code><span><span class="keyword">val</span> find_s : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> option</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>find_s</code> is an Lwt-aware variant of <a href="#val-find"><code>find</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-find_es"><a href="#val-find_es" class="anchor"></a><code><span><span class="keyword">val</span> find_es : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(bool, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><span class="type-var">'a</span> option</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>find_es</code> is an Lwt-Result-aware variant of <a href="#val-find"><code>find</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-find_map_e"><a href="#val-find_map_e" class="anchor"></a><code><span><span class="keyword">val</span> find_map_e : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'b</span> option</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'b</span> option</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>find_map_e</code> is a Result-aware variant of <a href="#val-find_map"><code>find_map</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-find_map_s"><a href="#val-find_map_s" class="anchor"></a><code><span><span class="keyword">val</span> find_map_s : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> option</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> option</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>find_map_s</code> is an Lwt-aware variant of <a href="#val-find_map"><code>find_map</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-find_map_es"><a href="#val-find_map_es" class="anchor"></a><code><span><span class="keyword">val</span> find_map_es : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span><span class="type-var">'b</span> option</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><span class="type-var">'b</span> option</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>find_map_es</code> is an Lwt-Result-aware variant of <a href="#val-find_map"><code>find_map</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span><span class="keyword">val</span> filter : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>filter f xs</code> is the list of all the elements <code>xn</code> of <code>xs</code> such that <code>f xn</code> is <code>true</code>.</p><p><code>filter (fun x -&gt; x &gt; 10) [0; 2; 19; 22; -1; 3; 11]</code> is <code>[19; 22; 11]</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filteri"><a href="#val-filteri" class="anchor"></a><code><span><span class="keyword">val</span> filteri : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>filteri</code> is similar to <a href="#val-filter"><code>filter</code></a> but the predicate also receives the element's index as an argument.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-find_all"><a href="#val-find_all" class="anchor"></a><code><span><span class="keyword">val</span> find_all : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>find_all</code> is an alias for <a href="#val-filter"><code>filter</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_filter"><a href="#val-rev_filter" class="anchor"></a><code><span><span class="keyword">val</span> rev_filter : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>rev_filter f l</code> is <code>rev (filter f l)</code> but more efficient.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_filteri"><a href="#val-rev_filteri" class="anchor"></a><code><span><span class="keyword">val</span> rev_filteri : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>rev_filteri f l</code> is <code>rev (filteri f l)</code> but more efficient.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_filter_some"><a href="#val-rev_filter_some" class="anchor"></a><code><span><span class="keyword">val</span> rev_filter_some : <span><span><span><span class="type-var">'a</span> option</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>rev_filter_some xs</code> is <code>rev @@ filter_some xs</code> but more efficient.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filter_some"><a href="#val-filter_some" class="anchor"></a><code><span><span class="keyword">val</span> filter_some : <span><span><span><span class="type-var">'a</span> option</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>filter_some</code> extracts all the payloads of the <code>Some</code> variants. The order is preserved.</p><p><code>filter_some [None; Some 'a'; None; None; Some 'z'; Some 'u']</code> is <code>['a'; 'z'; 'u']</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_filter_ok"><a href="#val-rev_filter_ok" class="anchor"></a><code><span><span class="keyword">val</span> rev_filter_ok : <span><span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>rev_filter_ok rs</code> is <code>rev @@ filter_ok rs</code> but more efficient.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filter_ok"><a href="#val-filter_ok" class="anchor"></a><code><span><span class="keyword">val</span> filter_ok : <span><span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>filter_ok</code> extracts all the payloads of the <code>Ok</code> variants. The order is preserved.</p><p><code>filter_ok [Error 3; Ok 'a'; Error 3; Error 5; Ok 'z'; Ok 'u']</code> is <code>['a'; 'z'; 'u']</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_filter_error"><a href="#val-rev_filter_error" class="anchor"></a><code><span><span class="keyword">val</span> rev_filter_error : <span><span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span></span></code></div><div class="spec-doc"><p><code>rev_filter_error rs</code> is <code>rev @@ filter_error rs</code> but more efficient.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filter_error"><a href="#val-filter_error" class="anchor"></a><code><span><span class="keyword">val</span> filter_error : <span><span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span></span></code></div><div class="spec-doc"><p><code>filter_error</code> extracts all the payloads of the <code>Error</code> variants. The order is preserved.</p><p><code>filter_ok [Error 3; Ok 'a'; Error 3; Error 5; Ok 'z'; Ok 'u']</code> is <code>[3; 3; 5]</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_filter_left"><a href="#val-rev_filter_left" class="anchor"></a><code><span><span class="keyword">val</span> rev_filter_left : <span><span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span class="xref-unresolved">Stdlib</span>.Either.t</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>rev_filter_left es</code> is <code>rev @@ filter_left es</code> but more efficient.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filter_left"><a href="#val-filter_left" class="anchor"></a><code><span><span class="keyword">val</span> filter_left : <span><span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span class="xref-unresolved">Stdlib</span>.Either.t</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>filter_left</code> extracts all the payloads of the <code>Left</code> variants. The order is preserved.</p><p><code>filter_left [Right 3; Left 'a'; Right 3; Right 5; Left 'z'; Left 'u']</code> is <code>['a'; 'z'; 'u']</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_filter_right"><a href="#val-rev_filter_right" class="anchor"></a><code><span><span class="keyword">val</span> rev_filter_right : <span><span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span class="xref-unresolved">Stdlib</span>.Either.t</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span></span></code></div><div class="spec-doc"><p><code>rev_filter_right es</code> is <code>rev @@ filter_right es</code> but more efficient.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filter_right"><a href="#val-filter_right" class="anchor"></a><code><span><span class="keyword">val</span> filter_right : <span><span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span class="xref-unresolved">Stdlib</span>.Either.t</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span></span></code></div><div class="spec-doc"><p><code>filter_right</code> extracts all the payloads of the <code>Right</code> variants. The order is preserved.</p><p><code>filter_right [Right 3; Left 'a'; Right 3; Right 5; Left 'z'; Left 'u']</code> is <code>[3; 3; 5]</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_filter_e"><a href="#val-rev_filter_e" class="anchor"></a><code><span><span class="keyword">val</span> rev_filter_e : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(bool, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>rev_filter_e</code> is a Result-aware variant of <a href="#val-rev_filter"><code>rev_filter</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filter_e"><a href="#val-filter_e" class="anchor"></a><code><span><span class="keyword">val</span> filter_e : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(bool, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>filter_e</code> is a Result-aware variant of <a href="#val-filter"><code>filter</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_filter_s"><a href="#val-rev_filter_s" class="anchor"></a><code><span><span class="keyword">val</span> rev_filter_s : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>rev_filter_s</code> is an Lwt-aware variant of <a href="#val-rev_filter"><code>rev_filter</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filter_s"><a href="#val-filter_s" class="anchor"></a><code><span><span class="keyword">val</span> filter_s : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>filter_s</code> is an Lwt-aware variant of <a href="#val-filter"><code>filter</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_filter_es"><a href="#val-rev_filter_es" class="anchor"></a><code><span><span class="keyword">val</span> rev_filter_es : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(bool, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><span class="type-var">'a</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>rev_filter_es</code> is an Lwt-Result-aware variant of <a href="#val-rev_filter"><code>rev_filter</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filter_es"><a href="#val-filter_es" class="anchor"></a><code><span><span class="keyword">val</span> filter_es : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(bool, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><span class="type-var">'a</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>filter_es</code> is an Lwt-Result-aware variant of <a href="#val-filter"><code>filter</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filter_ep"><a href="#val-filter_ep" class="anchor"></a><code><span><span class="keyword">val</span> filter_ep : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(bool, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><span class="type-var">'a</span> list</span>, <span><span class="type-var">'trace</span> list</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>filter_ep</code> is a variant of <a href="#val-filter_es"><code>filter_es</code></a> where the promises are evaluated concurrently.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filter_p"><a href="#val-filter_p" class="anchor"></a><code><span><span class="keyword">val</span> filter_p : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>filter_p</code> is a variant of <a href="#val-filter_s"><code>filter_s</code></a> where the promises are evaluated concurrently.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_filteri_e"><a href="#val-rev_filteri_e" class="anchor"></a><code><span><span class="keyword">val</span> rev_filteri_e : 
  <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(bool, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>rev_filteri_e</code> is a Result-aware variant of <a href="#val-rev_filteri"><code>rev_filteri</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filteri_e"><a href="#val-filteri_e" class="anchor"></a><code><span><span class="keyword">val</span> filteri_e : 
  <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(bool, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>filteri_e</code> is a Result-aware variant of <a href="#val-filteri"><code>filteri</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_filteri_s"><a href="#val-rev_filteri_s" class="anchor"></a><code><span><span class="keyword">val</span> rev_filteri_s : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>rev_filteri_s</code> is an Lwt-aware variant of <a href="#val-rev_filteri"><code>rev_filteri</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filteri_s"><a href="#val-filteri_s" class="anchor"></a><code><span><span class="keyword">val</span> filteri_s : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>filteri_s</code> is an Lwt-aware variant of <a href="#val-filteri"><code>filteri</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_filteri_es"><a href="#val-rev_filteri_es" class="anchor"></a><code><span><span class="keyword">val</span> rev_filteri_es : 
  <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(bool, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><span class="type-var">'a</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>rev_filteri_es</code> is an Lwt-Result-aware variant of <a href="#val-rev_filteri"><code>rev_filteri</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filteri_es"><a href="#val-filteri_es" class="anchor"></a><code><span><span class="keyword">val</span> filteri_es : 
  <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(bool, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><span class="type-var">'a</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>filteri_es</code> is an Lwt-Result-aware variant of <a href="#val-filteri"><code>filteri</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filteri_ep"><a href="#val-filteri_ep" class="anchor"></a><code><span><span class="keyword">val</span> filteri_ep : 
  <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(bool, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><span class="type-var">'a</span> list</span>, <span><span class="type-var">'trace</span> list</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>filteri_ep</code> is a variant of <a href="#val-filteri_es"><code>filteri_es</code></a> where the promises are evaluated concurrently.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filteri_p"><a href="#val-filteri_p" class="anchor"></a><code><span><span class="keyword">val</span> filteri_p : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>filteri_p</code> is a variant of <a href="#val-filteri_s"><code>filteri_s</code></a> where the promises are evaluated concurrently.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_partition"><a href="#val-rev_partition" class="anchor"></a><code><span><span class="keyword">val</span> rev_partition : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>rev_partition f xs</code> is <code>let rt, rf = partition f xs in (rev rt, rev rf)</code> but more efficient.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-partition"><a href="#val-partition" class="anchor"></a><code><span><span class="keyword">val</span> partition : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>partition f xs</code> is a couple of lists <code>(ts, fs)</code> where <code>ts</code> contains all the elements of <code>xs</code> such that <code>f x</code> is <code>true</code> and <code>fs</code> contains all the elements of <code>xs</code> such that <code>f x</code> is <code>false</code>.</p><p>The function <code>f</code> is applied once to each element of <code>xs</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_partition_map"><a href="#val-rev_partition_map" class="anchor"></a><code><span><span class="keyword">val</span> rev_partition_map : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'b</span>, <span class="type-var">'c</span>)</span> <span class="xref-unresolved">Stdlib</span>.Either.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'b</span> list</span> * <span><span class="type-var">'c</span> list</span></span></code></div><div class="spec-doc"><p><code>rev_partition_map f xs</code> is <code>let rt, rf = partition_map f xs in (rev rt, rev rf)</code> but more efficient.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-partition_map"><a href="#val-partition_map" class="anchor"></a><code><span><span class="keyword">val</span> partition_map : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'b</span>, <span class="type-var">'c</span>)</span> <span class="xref-unresolved">Stdlib</span>.Either.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'b</span> list</span> * <span><span class="type-var">'c</span> list</span></span></code></div><div class="spec-doc"><p><code>partition_map f xs</code> applies <code>f</code> to each of the element of <code>xs</code> and returns a couple of lists <code>(ls, rs)</code> where <code>ls</code> contains all the <code>l</code> such that <code>f x</code> is <code>Left l</code> and <code>rs</code> contains all the <code>r</code> such that <code>f x</code> is <code>Right r</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_partition_result"><a href="#val-rev_partition_result" class="anchor"></a><code><span><span class="keyword">val</span> rev_partition_result : <span><span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'b</span> list</span></span></code></div><div class="spec-doc"><p><code>rev_partition_result rs</code> is <code>partition_result @@ rev rs</code> but more efficient.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-partition_result"><a href="#val-partition_result" class="anchor"></a><code><span><span class="keyword">val</span> partition_result : <span><span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'b</span> list</span></span></code></div><div class="spec-doc"><p><code>partition_result rs</code> is a tuple of lists <code>(os, es)</code> where <code>os</code> contains all the payloads of <code>Ok</code> variants of <code>rs</code> and <code>es</code> contains all the payloads of <code>Error</code> variants of <code>rs</code>.</p><p><code>partition_result rs</code> is <code>(filter_ok rs, filter_error rs)</code> but more efficient.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_partition_either"><a href="#val-rev_partition_either" class="anchor"></a><code><span><span class="keyword">val</span> rev_partition_either : <span><span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span class="xref-unresolved">Stdlib</span>.Either.t</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'b</span> list</span></span></code></div><div class="spec-doc"><p><code>rev_partition_either rs</code> is <code>partition_either @@ rev rs</code> but more efficient.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-partition_either"><a href="#val-partition_either" class="anchor"></a><code><span><span class="keyword">val</span> partition_either : <span><span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span class="xref-unresolved">Stdlib</span>.Either.t</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'b</span> list</span></span></code></div><div class="spec-doc"><p><code>partition_either es</code> is a tuple of lists <code>(ls, rs)</code> where <code>ls</code> contains all the payloads of <code>Left</code> variants of <code>ls</code> and <code>rs</code> contains all the payloads of <code>Right</code> variants of <code>es</code>.</p><p><code>partition_either es</code> is <code>(filter_left es, filter_right es)</code> but more efficient.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_partition_e"><a href="#val-rev_partition_e" class="anchor"></a><code><span><span class="keyword">val</span> rev_partition_e : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(bool, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'a</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>rev_partition_e</code> is a Result-aware variant of <a href="#val-rev_partition"><code>rev_partition</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-partition_e"><a href="#val-partition_e" class="anchor"></a><code><span><span class="keyword">val</span> partition_e : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(bool, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'a</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>partition_e</code> is a Result-aware variant of <a href="#val-partition"><code>partition</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_partition_s"><a href="#val-rev_partition_s" class="anchor"></a><code><span><span class="keyword">val</span> rev_partition_s : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'a</span> list</span>)</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>rev_partition_s</code> is an Lwt-aware variant of <a href="#val-rev_partition"><code>rev_partition</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-partition_s"><a href="#val-partition_s" class="anchor"></a><code><span><span class="keyword">val</span> partition_s : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'a</span> list</span>)</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>partition_s</code> is an Lwt-aware variant of <a href="#val-partition"><code>partition</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_partition_es"><a href="#val-rev_partition_es" class="anchor"></a><code><span><span class="keyword">val</span> rev_partition_es : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(bool, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'a</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>rev_partition_es</code> is an Lwt-Result-aware variant of <a href="#val-rev_partition"><code>rev_partition</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-partition_es"><a href="#val-partition_es" class="anchor"></a><code><span><span class="keyword">val</span> partition_es : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(bool, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'a</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>partition_es</code> is an Lwt-Result-aware variant of <a href="#val-partition"><code>partition</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-partition_ep"><a href="#val-partition_ep" class="anchor"></a><code><span><span class="keyword">val</span> partition_ep : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(bool, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'a</span> list</span>, <span><span class="type-var">'trace</span> list</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>partition_ep</code> is a variant of <a href="#val-partition_es"><code>partition_es</code></a> where the promises are evaluated concurrently.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-partition_p"><a href="#val-partition_p" class="anchor"></a><code><span><span class="keyword">val</span> partition_p : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> list</span> * <span><span class="type-var">'a</span> list</span>)</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>partition_p</code> is a variant of <a href="#val-partition_s"><code>partition_s</code></a> where the promises are evaluated concurrently.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_partition_map_e"><a href="#val-rev_partition_map_e" class="anchor"></a><code><span><span class="keyword">val</span> rev_partition_map_e : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span>(<span class="type-var">'b</span>, <span class="type-var">'c</span>)</span> <span class="xref-unresolved">Stdlib</span>.Either.t</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'b</span> list</span> * <span><span class="type-var">'c</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>rev_partition_map_e</code> is a Result-aware variant of <a href="#val-rev_partition_map"><code>rev_partition_map</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-partition_map_e"><a href="#val-partition_map_e" class="anchor"></a><code><span><span class="keyword">val</span> partition_map_e : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span>(<span class="type-var">'b</span>, <span class="type-var">'c</span>)</span> <span class="xref-unresolved">Stdlib</span>.Either.t</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'b</span> list</span> * <span><span class="type-var">'c</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>partition_map_e</code> is a Result-aware variant of <a href="#val-partition_map"><code>partition_map</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_partition_map_s"><a href="#val-rev_partition_map_s" class="anchor"></a><code><span><span class="keyword">val</span> rev_partition_map_s : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'b</span>, <span class="type-var">'c</span>)</span> <span class="xref-unresolved">Stdlib</span>.Either.t</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'b</span> list</span> * <span><span class="type-var">'c</span> list</span>)</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>rev_partition_map_s</code> is an Lwt-aware variant of <a href="#val-rev_partition_map"><code>rev_partition_map</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-partition_map_s"><a href="#val-partition_map_s" class="anchor"></a><code><span><span class="keyword">val</span> partition_map_s : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'b</span>, <span class="type-var">'c</span>)</span> <span class="xref-unresolved">Stdlib</span>.Either.t</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'b</span> list</span> * <span><span class="type-var">'c</span> list</span>)</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>partition_map_s</code> is an Lwt-aware variant of <a href="#val-partition_map"><code>partition_map</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_partition_map_es"><a href="#val-rev_partition_map_es" class="anchor"></a><code><span><span class="keyword">val</span> rev_partition_map_es : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span><span>(<span class="type-var">'b</span>, <span class="type-var">'c</span>)</span> <span class="xref-unresolved">Stdlib</span>.Either.t</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><span class="type-var">'b</span> list</span> * <span><span class="type-var">'c</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>rev_partition_map_es</code> is an Lwt-Result-aware variant of <a href="#val-rev_partition_map"><code>rev_partition_map</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-partition_map_es"><a href="#val-partition_map_es" class="anchor"></a><code><span><span class="keyword">val</span> partition_map_es : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span><span>(<span class="type-var">'b</span>, <span class="type-var">'c</span>)</span> <span class="xref-unresolved">Stdlib</span>.Either.t</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><span class="type-var">'b</span> list</span> * <span><span class="type-var">'c</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>partition_map_es</code> is an Lwt-Result-aware variant of <a href="#val-partition_map"><code>partition_map</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-partition_map_ep"><a href="#val-partition_map_ep" class="anchor"></a><code><span><span class="keyword">val</span> partition_map_ep : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span><span>(<span class="type-var">'b</span>, <span class="type-var">'c</span>)</span> <span class="xref-unresolved">Stdlib</span>.Either.t</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><span class="type-var">'b</span> list</span> * <span><span class="type-var">'c</span> list</span>, <span><span class="type-var">'trace</span> list</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>partition_map_ep</code> is a variant of <a href="#val-partition_map_es"><code>partition_map_es</code></a> where the promises are evaluated concurrently.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-partition_map_p"><a href="#val-partition_map_p" class="anchor"></a><code><span><span class="keyword">val</span> partition_map_p : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'b</span>, <span class="type-var">'c</span>)</span> <span class="xref-unresolved">Stdlib</span>.Either.t</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'b</span> list</span> * <span><span class="type-var">'c</span> list</span>)</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>partition_map_p</code> is a variant of <a href="#val-partition_map_s"><code>partition_map_s</code></a> where the promises are evaluated concurrently.</p></div></div><h4 id="traversal-variants"><a href="#traversal-variants" class="anchor"></a>Traversal variants</h4><div class="odoc-spec"><div class="spec value anchored" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span><span class="keyword">val</span> iter : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>iter f xs</code> is <code>f x0; f x1; …</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-iter_e"><a href="#val-iter_e" class="anchor"></a><code><span><span class="keyword">val</span> iter_e : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(unit, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(unit, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>iter_e</code> is a Result-aware variant of <a href="#val-iter"><code>iter</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-iter_s"><a href="#val-iter_s" class="anchor"></a><code><span><span class="keyword">val</span> iter_s : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>iter_s</code> is an Lwt-aware variant of <a href="#val-iter"><code>iter</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-iter_es"><a href="#val-iter_es" class="anchor"></a><code><span><span class="keyword">val</span> iter_es : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(unit, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(unit, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>iter_es</code> is an Lwt-Result-aware variant of <a href="#val-iter"><code>iter</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-iter_ep"><a href="#val-iter_ep" class="anchor"></a><code><span><span class="keyword">val</span> iter_ep : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(unit, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(unit, <span><span class="type-var">'trace</span> list</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>iter_ep</code> is a variant of <a href="#val-iter_es"><code>iter_es</code></a> where the promises are evaluated concurrently.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-iter_p"><a href="#val-iter_p" class="anchor"></a><code><span><span class="keyword">val</span> iter_p : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>iter_p</code> is a variant of <a href="#val-iter_s"><code>iter_s</code></a> where the promises are evaluated concurrently.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-iteri"><a href="#val-iteri" class="anchor"></a><code><span><span class="keyword">val</span> iteri : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>iteri f xs</code> is <code>f 0 x0; f 1 x1; …</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-iteri_e"><a href="#val-iteri_e" class="anchor"></a><code><span><span class="keyword">val</span> iteri_e : 
  <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(unit, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(unit, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>iteri_e</code> is a Result-aware variant of <a href="#val-iteri"><code>iteri</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-iteri_s"><a href="#val-iteri_s" class="anchor"></a><code><span><span class="keyword">val</span> iteri_s : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>iteri_s</code> is an Lwt-aware variant of <a href="#val-iteri"><code>iteri</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-iteri_es"><a href="#val-iteri_es" class="anchor"></a><code><span><span class="keyword">val</span> iteri_es : 
  <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(unit, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(unit, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>iteri_es</code> is an Lwt-Result-aware variant of <a href="#val-iteri"><code>iteri</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-iteri_ep"><a href="#val-iteri_ep" class="anchor"></a><code><span><span class="keyword">val</span> iteri_ep : 
  <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(unit, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(unit, <span><span class="type-var">'trace</span> list</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>iteri_ep</code> is a variant of <a href="#val-iteri_es"><code>iteri_es</code></a> where the promises are evaluated concurrently.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-iteri_p"><a href="#val-iteri_p" class="anchor"></a><code><span><span class="keyword">val</span> iteri_p : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>iteri_p</code> is a variant of <a href="#val-iteri_s"><code>iteri_s</code></a> where the promises are evaluated concurrently.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span></span></code></div><div class="spec-doc"><p><code>map f xs</code> is the list <code>[f x0; f x1; …]</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map_e"><a href="#val-map_e" class="anchor"></a><code><span><span class="keyword">val</span> map_e : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'b</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'b</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>map_e</code> is a Result-aware variant of <a href="#val-map"><code>map</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map_s"><a href="#val-map_s" class="anchor"></a><code><span><span class="keyword">val</span> map_s : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>map_s</code> is an Lwt-aware variant of <a href="#val-map"><code>map</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map_es"><a href="#val-map_es" class="anchor"></a><code><span><span class="keyword">val</span> map_es : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'b</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><span class="type-var">'b</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>map_es</code> is an Lwt-Result-aware variant of <a href="#val-map"><code>map</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map_ep"><a href="#val-map_ep" class="anchor"></a><code><span><span class="keyword">val</span> map_ep : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'b</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><span class="type-var">'b</span> list</span>, <span><span class="type-var">'trace</span> list</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>map_ep</code> is a variant of <a href="#val-map_es"><code>map_es</code></a> where the promises are evaluated concurrently.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map_p"><a href="#val-map_p" class="anchor"></a><code><span><span class="keyword">val</span> map_p : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>map_p</code> is a variant of <a href="#val-map_s"><code>map_s</code></a> where the promises are evaluated concurrently.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mapi"><a href="#val-mapi" class="anchor"></a><code><span><span class="keyword">val</span> mapi : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span></span></code></div><div class="spec-doc"><p><code>mapi f xs</code> is the list <code>[f 0 x0; f 1 x1; …]</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mapi_e"><a href="#val-mapi_e" class="anchor"></a><code><span><span class="keyword">val</span> mapi_e : 
  <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'b</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'b</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>mapi_e</code> is a Result-aware variant of <a href="#val-mapi"><code>mapi</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mapi_s"><a href="#val-mapi_s" class="anchor"></a><code><span><span class="keyword">val</span> mapi_s : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>mapi_s</code> is an Lwt-aware variant of <a href="#val-mapi"><code>mapi</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mapi_es"><a href="#val-mapi_es" class="anchor"></a><code><span><span class="keyword">val</span> mapi_es : 
  <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'b</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><span class="type-var">'b</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>mapi_es</code> is an Lwt-Result-aware variant of <a href="#val-mapi"><code>mapi</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mapi_ep"><a href="#val-mapi_ep" class="anchor"></a><code><span><span class="keyword">val</span> mapi_ep : 
  <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'b</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><span class="type-var">'b</span> list</span>, <span><span class="type-var">'trace</span> list</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>mapi_ep</code> is a variant of <a href="#val-mapi_es"><code>mapi_es</code></a> where the promises are evaluated concurrently.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mapi_p"><a href="#val-mapi_p" class="anchor"></a><code><span><span class="keyword">val</span> mapi_p : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>mapi_p</code> is a variant of <a href="#val-mapi_s"><code>mapi_s</code></a> where the promises are evaluated concurrently.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_map"><a href="#val-rev_map" class="anchor"></a><code><span><span class="keyword">val</span> rev_map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span></span></code></div><div class="spec-doc"><p><code>rev_map f xs</code> is <code>rev @@ map f xs</code> but more efficient.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_mapi"><a href="#val-rev_mapi" class="anchor"></a><code><span><span class="keyword">val</span> rev_mapi : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span></span></code></div><div class="spec-doc"><p><code>rev_mapi f xs</code> is <code>rev @@ mapi f xs</code> but more efficient.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_map_e"><a href="#val-rev_map_e" class="anchor"></a><code><span><span class="keyword">val</span> rev_map_e : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'b</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'b</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>rev_map_e</code> is a Result-aware variant of <a href="#val-rev_map"><code>rev_map</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_map_s"><a href="#val-rev_map_s" class="anchor"></a><code><span><span class="keyword">val</span> rev_map_s : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>rev_map_s</code> is an Lwt-aware variant of <a href="#val-rev_map"><code>rev_map</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_map_es"><a href="#val-rev_map_es" class="anchor"></a><code><span><span class="keyword">val</span> rev_map_es : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'b</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><span class="type-var">'b</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>rev_map_es</code> is an Lwt-Result-aware variant of <a href="#val-rev_map"><code>rev_map</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_map_ep"><a href="#val-rev_map_ep" class="anchor"></a><code><span><span class="keyword">val</span> rev_map_ep : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'b</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><span class="type-var">'b</span> list</span>, <span><span class="type-var">'trace</span> list</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>rev_map_ep</code> is a variant of <a href="#val-rev_map_es"><code>rev_map_es</code></a> where the promises are evaluated concurrently.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_map_p"><a href="#val-rev_map_p" class="anchor"></a><code><span><span class="keyword">val</span> rev_map_p : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>rev_map_p</code> is a variant of <a href="#val-rev_map_s"><code>rev_map_s</code></a> where the promises are evaluated concurrently.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_mapi_e"><a href="#val-rev_mapi_e" class="anchor"></a><code><span><span class="keyword">val</span> rev_mapi_e : 
  <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'b</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'b</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>rev_mapi_e</code> is a Result-aware variant of <a href="#val-rev_mapi"><code>rev_mapi</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_mapi_s"><a href="#val-rev_mapi_s" class="anchor"></a><code><span><span class="keyword">val</span> rev_mapi_s : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>rev_mapi_s</code> is an Lwt-aware variant of <a href="#val-rev_mapi"><code>rev_mapi</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_mapi_es"><a href="#val-rev_mapi_es" class="anchor"></a><code><span><span class="keyword">val</span> rev_mapi_es : 
  <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'b</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><span class="type-var">'b</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>rev_mapi_es</code> is an Lwt-Result-aware variant of <a href="#val-rev_mapi"><code>rev_mapi</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_mapi_ep"><a href="#val-rev_mapi_ep" class="anchor"></a><code><span><span class="keyword">val</span> rev_mapi_ep : 
  <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'b</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><span class="type-var">'b</span> list</span>, <span><span class="type-var">'trace</span> list</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>rev_mapi_ep</code> is a variant of <a href="#val-rev_mapi_es"><code>rev_mapi_es</code></a> where the promises are evaluated concurrently.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_mapi_p"><a href="#val-rev_mapi_p" class="anchor"></a><code><span><span class="keyword">val</span> rev_mapi_p : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>rev_mapi_p</code> is a variant of <a href="#val-rev_mapi_s"><code>rev_mapi_s</code></a> where the promises are evaluated concurrently.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_filter_map"><a href="#val-rev_filter_map" class="anchor"></a><code><span><span class="keyword">val</span> rev_filter_map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span></span></code></div><div class="spec-doc"><p><code>rev_filter_map f xs</code> is <code>rev @@ filter_map f xs</code> but more efficient.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_filter_map_e"><a href="#val-rev_filter_map_e" class="anchor"></a><code><span><span class="keyword">val</span> rev_filter_map_e : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'b</span> option</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'b</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>rev_filter_map_e</code> is a Result-aware variant of <a href="#val-rev_filter_map"><code>rev_filter_map</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filter_map_e"><a href="#val-filter_map_e" class="anchor"></a><code><span><span class="keyword">val</span> filter_map_e : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'b</span> option</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'b</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>filter_map_e</code> is a Result-aware variant of <a href="#val-filter_map"><code>filter_map</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_filter_map_s"><a href="#val-rev_filter_map_s" class="anchor"></a><code><span><span class="keyword">val</span> rev_filter_map_s : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> option</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>rev_filter_map_s</code> is an Lwt-aware variant of <a href="#val-rev_filter_map"><code>rev_filter_map</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filter_map"><a href="#val-filter_map" class="anchor"></a><code><span><span class="keyword">val</span> filter_map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span></span></code></div><div class="spec-doc"><p><code>filter_map f xs</code> is <code>filter_some @@ map f xs</code> but more efficient.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filter_map_s"><a href="#val-filter_map_s" class="anchor"></a><code><span><span class="keyword">val</span> filter_map_s : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> option</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>filter_map_s</code> is an Lwt-aware variant of <a href="#val-filter_map"><code>filter_map</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_filter_map_es"><a href="#val-rev_filter_map_es" class="anchor"></a><code><span><span class="keyword">val</span> rev_filter_map_es : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span><span class="type-var">'b</span> option</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><span class="type-var">'b</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>rev_filter_map_es</code> is an Lwt-Result-aware variant of <a href="#val-rev_filter_map"><code>rev_filter_map</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filter_map_es"><a href="#val-filter_map_es" class="anchor"></a><code><span><span class="keyword">val</span> filter_map_es : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span><span class="type-var">'b</span> option</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><span class="type-var">'b</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>filter_map_es</code> is an Lwt-Result-aware variant of <a href="#val-filter_map"><code>filter_map</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filter_map_ep"><a href="#val-filter_map_ep" class="anchor"></a><code><span><span class="keyword">val</span> filter_map_ep : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span><span class="type-var">'b</span> option</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><span class="type-var">'b</span> list</span>, <span><span class="type-var">'trace</span> list</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>filter_map_ep</code> is a variant of <a href="#val-filter_map_es"><code>filter_map_es</code></a> where the promises are evaluated concurrently.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filter_map_p"><a href="#val-filter_map_p" class="anchor"></a><code><span><span class="keyword">val</span> filter_map_p : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> option</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>filter_map_p</code> is a variant of <a href="#val-filter_map_s"><code>filter_map_s</code></a> where the promises are evaluated concurrently.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-concat_map"><a href="#val-concat_map" class="anchor"></a><code><span><span class="keyword">val</span> concat_map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span></span></code></div><div class="spec-doc"><p><code>concat_map f xs</code> is <code>concat (map f xs)</code> but more efficient.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-concat_map_s"><a href="#val-concat_map_s" class="anchor"></a><code><span><span class="keyword">val</span> concat_map_s : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>concat_map_s</code> is an Lwt-aware variant of <a href="#val-concat_map"><code>concat_map</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-concat_map_e"><a href="#val-concat_map_e" class="anchor"></a><code><span><span class="keyword">val</span> concat_map_e : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'b</span> list</span>, <span class="type-var">'error</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'b</span> list</span>, <span class="type-var">'error</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>concat_map_e</code> is a Result-aware variant of <a href="#val-concat_map"><code>concat_map</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-concat_map_es"><a href="#val-concat_map_es" class="anchor"></a><code><span><span class="keyword">val</span> concat_map_es : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span><span class="type-var">'b</span> list</span>, <span class="type-var">'error</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><span class="type-var">'b</span> list</span>, <span class="type-var">'error</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>concat_map_es</code> is an Lwt-Result-aware variant of <a href="#val-concat_map"><code>concat_map</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-concat_map_p"><a href="#val-concat_map_p" class="anchor"></a><code><span><span class="keyword">val</span> concat_map_p : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>concat_map_p</code> is a variant of <a href="#val-concat_map_s"><code>concat_map_s</code></a> where the promises are evaluated concurrently.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-concat_map_ep"><a href="#val-concat_map_ep" class="anchor"></a><code><span><span class="keyword">val</span> concat_map_ep : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span><span class="type-var">'b</span> list</span>, <span class="type-var">'error</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><span class="type-var">'b</span> list</span>, <span><span class="type-var">'error</span> list</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>concat_map_ep</code> is a variant of <a href="#val-concat_map_es"><code>concat_map_es</code></a> where the promises are evaluated concurrently.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_concat_map"><a href="#val-rev_concat_map" class="anchor"></a><code><span><span class="keyword">val</span> rev_concat_map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span></span></code></div><div class="spec-doc"><p><code>rev_concat_map f xs</code> is <code>rev (concat_map f xs)</code> but more efficient.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_concat_map_s"><a href="#val-rev_concat_map_s" class="anchor"></a><code><span><span class="keyword">val</span> rev_concat_map_s : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>rev_concat_map_s</code> is an Lwt-aware variant of <a href="#val-rev_concat_map"><code>rev_concat_map</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_concat_map_e"><a href="#val-rev_concat_map_e" class="anchor"></a><code><span><span class="keyword">val</span> rev_concat_map_e : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'b</span> list</span>, <span class="type-var">'error</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'b</span> list</span>, <span class="type-var">'error</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>rev_concat_map_e</code> is a Result-aware variant of <a href="#val-rev_concat_map"><code>rev_concat_map</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_concat_map_es"><a href="#val-rev_concat_map_es" class="anchor"></a><code><span><span class="keyword">val</span> rev_concat_map_es : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span><span class="type-var">'b</span> list</span>, <span class="type-var">'error</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><span class="type-var">'b</span> list</span>, <span class="type-var">'error</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>rev_concat_map_es</code> is an Lwt-Result-aware variant of <a href="#val-rev_concat_map"><code>rev_concat_map</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold_left"><a href="#val-fold_left" class="anchor"></a><code><span><span class="keyword">val</span> fold_left : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold_left_e"><a href="#val-fold_left_e" class="anchor"></a><code><span><span class="keyword">val</span> fold_left_e : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>fold_left_e</code> is a Result-aware variant of <a href="#val-fold_left"><code>fold_left</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold_left_s"><a href="#val-fold_left_s" class="anchor"></a><code><span><span class="keyword">val</span> fold_left_s : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>fold_left_s</code> is an Lwt-aware variant of <a href="#val-fold_left"><code>fold_left</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold_left_es"><a href="#val-fold_left_es" class="anchor"></a><code><span><span class="keyword">val</span> fold_left_es : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>fold_left_es</code> is an Lwt-Result-aware variant of <a href="#val-fold_left"><code>fold_left</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold_left_map"><a href="#val-fold_left_map" class="anchor"></a><code><span><span class="keyword">val</span> fold_left_map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> * <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> * <span><span class="type-var">'c</span> list</span></span></code></div><div class="spec-doc"><p><code>fold_left_map f a xs</code> is a combination of <code>fold_left</code> and <code>map</code> that maps over all elements of <code>xs</code> and threads an accumulator with initial value <code>a</code> through calls to <code>f</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold_left_map_e"><a href="#val-fold_left_map_e" class="anchor"></a><code><span><span class="keyword">val</span> fold_left_map_e : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'c</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span> * <span><span class="type-var">'c</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>fold_left_map_e f a xs</code> is a combination of <code>fold_left_e</code> and <code>map_e</code> that maps over all elements of <code>xs</code> and threads an accumulator with initial value <code>a</code> through calls to <code>f</code>. The list is traversed from left to right and the first encountered error is returned.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold_left_map_s"><a href="#val-fold_left_map_s" class="anchor"></a><code><span><span class="keyword">val</span> fold_left_map_s : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'c</span>)</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span> * <span><span class="type-var">'c</span> list</span>)</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>fold_left_map_s f a xs</code> is a combination of <code>fold_left_s</code> and <code>map_s</code> that maps over all elements of <code>xs</code> and threads an accumulator with initial value <code>a</code> through calls to <code>f</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold_left_map_es"><a href="#val-fold_left_map_es" class="anchor"></a><code><span><span class="keyword">val</span> fold_left_map_es : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'c</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span> * <span><span class="type-var">'c</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>fold_left_map_es f a xs</code> is a combination of <code>fold_left_es</code> and <code>map_es</code> that maps over all elements of <code>xs</code> and threads an accumulator with initial value <code>a</code> through calls to <code>f</code>. The list is traversed from left to right and the first encountered error is returned.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold_left_i"><a href="#val-fold_left_i" class="anchor"></a><code><span><span class="keyword">val</span> fold_left_i : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold_left_i_e"><a href="#val-fold_left_i_e" class="anchor"></a><code><span><span class="keyword">val</span> fold_left_i_e : 
  <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold_left_i_s"><a href="#val-fold_left_i_s" class="anchor"></a><code><span><span class="keyword">val</span> fold_left_i_s : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold_left_i_es"><a href="#val-fold_left_i_es" class="anchor"></a><code><span><span class="keyword">val</span> fold_left_i_es : 
  <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold_right"><a href="#val-fold_right" class="anchor"></a><code><span><span class="keyword">val</span> fold_right : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p>This function is not tail-recursive</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold_right_e"><a href="#val-fold_right_e" class="anchor"></a><code><span><span class="keyword">val</span> fold_right_e : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'b</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'b</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p>This function is not tail-recursive</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold_right_s"><a href="#val-fold_right_s" class="anchor"></a><code><span><span class="keyword">val</span> fold_right_s : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p>This function is not tail-recursive</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold_right_es"><a href="#val-fold_right_es" class="anchor"></a><code><span><span class="keyword">val</span> fold_right_es : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'b</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'b</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p>This function is not tail-recursive</p></div></div><h4 id="double-traversal-variants"><a href="#double-traversal-variants" class="anchor"></a>Double-traversal variants</h4><p>As mentioned above, there are no <code>_p</code> and <code>_ep</code> double-traversors. Use <a href="#val-combine"><code>combine</code></a> (and variants) to circumvent this.</p><div class="odoc-spec"><div class="spec value anchored" id="val-iter2_e"><a href="#val-iter2_e" class="anchor"></a><code><span><span class="keyword">val</span> iter2_e : 
  <span><span class="label">when_different_lengths</span>:<span class="type-var">'trace</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(unit, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(unit, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-iter2_s"><a href="#val-iter2_s" class="anchor"></a><code><span><span class="keyword">val</span> iter2_s : 
  <span><span class="label">when_different_lengths</span>:<span class="type-var">'trace</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(unit, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-iter2_es"><a href="#val-iter2_es" class="anchor"></a><code><span><span class="keyword">val</span> iter2_es : 
  <span><span class="label">when_different_lengths</span>:<span class="type-var">'trace</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(unit, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(unit, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map2_e"><a href="#val-map2_e" class="anchor"></a><code><span><span class="keyword">val</span> map2_e : 
  <span><span class="label">when_different_lengths</span>:<span class="type-var">'trace</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'c</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'c</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map2_s"><a href="#val-map2_s" class="anchor"></a><code><span><span class="keyword">val</span> map2_s : 
  <span><span class="label">when_different_lengths</span>:<span class="type-var">'trace</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><span class="type-var">'c</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map2_es"><a href="#val-map2_es" class="anchor"></a><code><span><span class="keyword">val</span> map2_es : 
  <span><span class="label">when_different_lengths</span>:<span class="type-var">'trace</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'c</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><span class="type-var">'c</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_map2_e"><a href="#val-rev_map2_e" class="anchor"></a><code><span><span class="keyword">val</span> rev_map2_e : 
  <span><span class="label">when_different_lengths</span>:<span class="type-var">'trace</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'c</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'c</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_map2_s"><a href="#val-rev_map2_s" class="anchor"></a><code><span><span class="keyword">val</span> rev_map2_s : 
  <span><span class="label">when_different_lengths</span>:<span class="type-var">'trace</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><span class="type-var">'c</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rev_map2_es"><a href="#val-rev_map2_es" class="anchor"></a><code><span><span class="keyword">val</span> rev_map2_es : 
  <span><span class="label">when_different_lengths</span>:<span class="type-var">'trace</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'c</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><span class="type-var">'c</span> list</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold_left2_e"><a href="#val-fold_left2_e" class="anchor"></a><code><span><span class="keyword">val</span> fold_left2_e : 
  <span><span class="label">when_different_lengths</span>:<span class="type-var">'trace</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'c</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold_left2_s"><a href="#val-fold_left2_s" class="anchor"></a><code><span><span class="keyword">val</span> fold_left2_s : 
  <span><span class="label">when_different_lengths</span>:<span class="type-var">'trace</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'c</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold_left2_es"><a href="#val-fold_left2_es" class="anchor"></a><code><span><span class="keyword">val</span> fold_left2_es : 
  <span><span class="label">when_different_lengths</span>:<span class="type-var">'trace</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'c</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold_right2_e"><a href="#val-fold_right2_e" class="anchor"></a><code><span><span class="keyword">val</span> fold_right2_e : 
  <span><span class="label">when_different_lengths</span>:<span class="type-var">'trace</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'c</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'c</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p>This function is not tail-recursive</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold_right2_s"><a href="#val-fold_right2_s" class="anchor"></a><code><span><span class="keyword">val</span> fold_right2_s : 
  <span><span class="label">when_different_lengths</span>:<span class="type-var">'trace</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'c</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p>This function is not tail-recursive</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold_right2_es"><a href="#val-fold_right2_es" class="anchor"></a><code><span><span class="keyword">val</span> fold_right2_es : 
  <span><span class="label">when_different_lengths</span>:<span class="type-var">'trace</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'c</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'c</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p>This function is not tail-recursive</p></div></div><h4 id="scanning-variants"><a href="#scanning-variants" class="anchor"></a>Scanning variants</h4><div class="odoc-spec"><div class="spec value anchored" id="val-for_all"><a href="#val-for_all" class="anchor"></a><code><span><span class="keyword">val</span> for_all : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-for_all_e"><a href="#val-for_all_e" class="anchor"></a><code><span><span class="keyword">val</span> for_all_e : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(bool, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(bool, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-for_all_s"><a href="#val-for_all_s" class="anchor"></a><code><span><span class="keyword">val</span> for_all_s : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-for_all_es"><a href="#val-for_all_es" class="anchor"></a><code><span><span class="keyword">val</span> for_all_es : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(bool, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(bool, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-for_all_ep"><a href="#val-for_all_ep" class="anchor"></a><code><span><span class="keyword">val</span> for_all_ep : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(bool, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(bool, <span><span class="type-var">'trace</span> list</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-for_all_p"><a href="#val-for_all_p" class="anchor"></a><code><span><span class="keyword">val</span> for_all_p : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-exists"><a href="#val-exists" class="anchor"></a><code><span><span class="keyword">val</span> exists : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-exists_e"><a href="#val-exists_e" class="anchor"></a><code><span><span class="keyword">val</span> exists_e : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(bool, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(bool, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-exists_s"><a href="#val-exists_s" class="anchor"></a><code><span><span class="keyword">val</span> exists_s : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-exists_es"><a href="#val-exists_es" class="anchor"></a><code><span><span class="keyword">val</span> exists_es : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(bool, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(bool, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-exists_ep"><a href="#val-exists_ep" class="anchor"></a><code><span><span class="keyword">val</span> exists_ep : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(bool, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(bool, <span><span class="type-var">'trace</span> list</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-exists_p"><a href="#val-exists_p" class="anchor"></a><code><span><span class="keyword">val</span> exists_p : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><h4 id="double-scanning-variants"><a href="#double-scanning-variants" class="anchor"></a>Double-scanning variants</h4><p>As mentioned above, there are no <code>_p</code> and <code>_ep</code> double-scanners. Use <a href="#val-combine"><code>combine</code></a> (and variants) to circumvent this.</p><div class="odoc-spec"><div class="spec value anchored" id="val-for_all2_e"><a href="#val-for_all2_e" class="anchor"></a><code><span><span class="keyword">val</span> for_all2_e : 
  <span><span class="label">when_different_lengths</span>:<span class="type-var">'trace</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(bool, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(bool, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-for_all2_s"><a href="#val-for_all2_s" class="anchor"></a><code><span><span class="keyword">val</span> for_all2_s : 
  <span><span class="label">when_different_lengths</span>:<span class="type-var">'trace</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(bool, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-for_all2_es"><a href="#val-for_all2_es" class="anchor"></a><code><span><span class="keyword">val</span> for_all2_es : 
  <span><span class="label">when_different_lengths</span>:<span class="type-var">'trace</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(bool, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(bool, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-exists2_e"><a href="#val-exists2_e" class="anchor"></a><code><span><span class="keyword">val</span> exists2_e : 
  <span><span class="label">when_different_lengths</span>:<span class="type-var">'trace</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(bool, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(bool, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-exists2_s"><a href="#val-exists2_s" class="anchor"></a><code><span><span class="keyword">val</span> exists2_s : 
  <span><span class="label">when_different_lengths</span>:<span class="type-var">'trace</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(bool, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-exists2_es"><a href="#val-exists2_es" class="anchor"></a><code><span><span class="keyword">val</span> exists2_es : 
  <span><span class="label">when_different_lengths</span>:<span class="type-var">'trace</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(bool, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(bool, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><h4 id="combine-variants"><a href="#combine-variants" class="anchor"></a>Combine variants</h4><p>These are primarily intended to be used for preprocessing before applying a traversor to the resulting list of pairs. They give alternatives to the <code>when_different_lengths</code> mechanism of the immediate double-traversors above.</p><p>In case the semantic of, say, <code>map2_es</code> was unsatisfying, one can use <code>map_es</code> on a <code>combine</code>-preprocessed pair of lists. The different variants of <code>combine</code> give different approaches to different-length handling.</p><div class="odoc-spec"><div class="spec value anchored" id="val-combine_drop"><a href="#val-combine_drop" class="anchor"></a><code><span><span class="keyword">val</span> combine_drop : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span></span></code></div><div class="spec-doc"><p><code>combine_drop ll lr</code> is a list <code>l</code> of pairs of elements taken from the common-length prefix of <code>ll</code> and <code>lr</code>. The suffix of whichever list is longer (if any) is dropped.</p><p>More formally <code>nth l n</code> is:</p><ul><li><code>None</code> if <code>n &gt;= min (length ll) (length lr)</code></li><li><code>Some (Option.get @@ nth ll n, Option.get @@ nth lr n)</code> otherwise</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-combine_with_leftovers"><a href="#val-combine_with_leftovers" class="anchor"></a><code><span><span class="keyword">val</span> combine_with_leftovers : 
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span> * <span><span><span>(<span><span class="type-var">'a</span> list</span>, <span><span class="type-var">'b</span> list</span>)</span> <span class="xref-unresolved">Stdlib</span>.Either.t</span> option</span></span></code></div><div class="spec-doc"><p><code>combine_with_leftovers ll lr</code> is a tuple <code>(combined, leftover)</code> where <code>combined</code> is <code>combine_drop ll lr</code> and <code>leftover</code> is either <code>Either.Left lsuffix</code> or <code>Either.Right rsuffix</code> depending on which of <code>ll</code> or <code>lr</code> is longer. <code>leftover</code> is <code>None</code> if the two lists have the same length.</p></div></div><h4 id="product"><a href="#product" class="anchor"></a>Product</h4><div class="odoc-spec"><div class="spec value anchored" id="val-product"><a href="#val-product" class="anchor"></a><code><span><span class="keyword">val</span> product : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> list</span></span></code></div><div class="spec-doc"><p><code>product xs ys</code> is the cartesian product of <code>xs</code> and <code>ys</code>.</p><p>In other words <code>product xs ys</code> is a list containing all the pairs <code>(x, y)</code> where <code>x</code> is an element of <code>xs</code> and <code>y</code> is an element of <code>ys</code>.</p><p>The order of the elements in the returned list is unspecified.</p></div></div><h4 id="comparison-and-equality"><a href="#comparison-and-equality" class="anchor"></a>Comparison and equality</h4><p>The comparison and equality functions are those of the OCaml <code>Stdlib</code>.</p><div class="odoc-spec"><div class="spec value anchored" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span><span class="keyword">val</span> compare : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compare_lengths"><a href="#val-compare_lengths" class="anchor"></a><code><span><span class="keyword">val</span> compare_lengths : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compare_length_with"><a href="#val-compare_length_with" class="anchor"></a><code><span><span class="keyword">val</span> compare_length_with : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><h4 id="sorting"><a href="#sorting" class="anchor"></a>Sorting</h4><p>The sorting functions are those of the OCaml <code>Stdlib</code>.</p><div class="odoc-spec"><div class="spec value anchored" id="val-sort"><a href="#val-sort" class="anchor"></a><code><span><span class="keyword">val</span> sort : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-stable_sort"><a href="#val-stable_sort" class="anchor"></a><code><span><span class="keyword">val</span> stable_sort : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fast_sort"><a href="#val-fast_sort" class="anchor"></a><code><span><span class="keyword">val</span> fast_sort : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sort_uniq"><a href="#val-sort_uniq" class="anchor"></a><code><span><span class="keyword">val</span> sort_uniq : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-shuffle"><a href="#val-shuffle" class="anchor"></a><code><span><span class="keyword">val</span> shuffle : <span><span class="label">rng</span>:<span class="xref-unresolved">Stdlib</span>.Random.State.t <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>shuffle l</code> is a list that contains the same elements as <code>l</code> but in a random order.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-merge"><a href="#val-merge" class="anchor"></a><code><span><span class="keyword">val</span> merge : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>merge compare xs ys</code> merges the lists <code>xs</code> and <code>ys</code>.</p><p><code>merge</code> assumes that <code>xs</code> and <code>ys</code> are sorted according to the order defined by <code>compare</code>. If <code>xs</code> and <code>ys</code> are not sorted, the returned value of <code>merge compare xs ys</code> is unspecified.</p><p>Assuming that <code>xs</code> and <code>ys</code> are sorted, <code>merge compare xs ys</code> is a list</p><ul><li>containing all the elements of <code>xs</code> and of <code>ys</code>, and</li><li>sorted according to the order defined by <code>compare</code>.</li></ul><p><code>merge</code> is not tail-recursive.</p></div></div><h4 id="conversion"><a href="#conversion" class="anchor"></a>Conversion</h4><p>The conversion functions are those of the OCaml <code>Stdlib</code>.</p><div class="odoc-spec"><div class="spec value anchored" id="val-to_seq"><a href="#val-to_seq" class="anchor"></a><code><span><span class="keyword">val</span> to_seq : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_seq"><a href="#val-of_seq" class="anchor"></a><code><span><span class="keyword">val</span> of_seq : <span><span><span class="type-var">'a</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div></div></div></body></html>
