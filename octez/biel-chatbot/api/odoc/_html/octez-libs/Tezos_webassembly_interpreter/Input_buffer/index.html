<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Input_buffer (octez-libs.Tezos_webassembly_interpreter.Input_buffer)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">octez-libs</a> &#x00BB; <a href="../index.html">Tezos_webassembly_interpreter</a> &#x00BB; Input_buffer</nav><header class="odoc-preamble"><h1>Module <code><span>Tezos_webassembly_interpreter.Input_buffer</span></code></h1><p>This module implements a FIFO queue to model the input. The messages are queued in an input_buffer in their order of appearance in the inbox.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-message"><a href="#type-message" class="anchor"></a><code><span><span class="keyword">type</span> message</span><span> = </span><span>{</span></code><ol><li id="type-message.raw_level" class="def record field anchored"><a href="#type-message.raw_level" class="anchor"></a><code><span>raw_level : int32;</span></code></li><li id="type-message.message_counter" class="def record field anchored"><a href="#type-message.message_counter" class="anchor"></a><code><span>message_counter : <span class="xref-unresolved">Z</span>.t;</span></code></li><li id="type-message.payload" class="def record field anchored"><a href="#type-message.payload" class="anchor"></a><code><span>payload : bytes;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_message"><a href="#val-pp_message" class="anchor"></a><code><span><span class="keyword">val</span> pp_message : 
  <span><span class="xref-unresolved">Ppx_deriving_runtime</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-message">message</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Ppx_deriving_runtime</span>.unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-show_message"><a href="#val-show_message" class="anchor"></a><code><span><span class="keyword">val</span> show_message : <span><a href="#type-message">message</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Ppx_deriving_runtime</span>.string</span></code></div></div><p>An element of type t will have a content which is a lazy_vector of messages and a pointer to the number of elements to be able to dequeue. At this point there is no cleanup operation so an input_buffer content will likely have more than <code>num_elements</code> messages (see #3340).</p><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = <span><a href="#type-message">message</a> <a href="../../Tezos_lazy_containers/Lazy_vector/Mutable/ZVector/index.html#type-t">Tezos_lazy_containers.Lazy_vector.Mutable.ZVector.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Bounds"><a href="#exception-Bounds" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Bounds</span></span></code></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-SizeOverflow"><a href="#exception-SizeOverflow" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">SizeOverflow</span></span></code></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Cannot_store_an_earlier_message"><a href="#exception-Cannot_store_an_earlier_message" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Cannot_store_an_earlier_message</span></span></code></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Dequeue_from_empty_queue"><a href="#exception-Dequeue_from_empty_queue" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Dequeue_from_empty_queue</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-alloc"><a href="#val-alloc" class="anchor"></a><code><span><span class="keyword">val</span> alloc : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>alloc ()</code> returns an empty input_buffer.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-num_elements"><a href="#val-num_elements" class="anchor"></a><code><span><span class="keyword">val</span> num_elements : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Z</span>.t</span></code></div><div class="spec-doc"><p><code>num_elements buffer</code> is the number of elements of <code>buffer</code>. It is used by <code>dequeue</code> to pick the current message. Note that it is not necessarily equal to the length of the content of the inbox (see #3340).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-reset"><a href="#val-reset" class="anchor"></a><code><span><span class="keyword">val</span> reset : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>reset buffer</code> removes the current contents of the buffer.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-dequeue"><a href="#val-dequeue" class="anchor"></a><code><span><span class="keyword">val</span> dequeue : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-message">message</a> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>dequeue buffer</code> pops the current message from buffer and returns it. Note that the input buffer models a FIFO queue so the current message is the oldest in the queue. If the queue is empty it raises <code>Dequeue_from_empty_queue</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-enqueue"><a href="#val-enqueue" class="anchor"></a><code><span><span class="keyword">val</span> enqueue : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-message">message</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>enqueue buffer message</code> pushes the given <code>message</code> into the <code>buffer</code>. Note that the message will have to have a higher raw_level/message_counter than than the newest message in the queue. If that fails it will raise the error <code>Cannot_store_an_earlier_message</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-snapshot"><a href="#val-snapshot" class="anchor"></a><code><span><span class="keyword">val</span> snapshot : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>snapshot buffer</code> returns snapshotted buffer. You can modify original one, snapshotted one will stay untouched</p></div></div></div></body></html>
