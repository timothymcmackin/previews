<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Lwt_result_syntax (octez-libs.Tezos_lwt_result_stdlib.Lwtreslib.Traced.Monad.Lwt_result_syntax)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../../../../index.html">octez-libs</a> &#x00BB; <a href="../../../../index.html">Tezos_lwt_result_stdlib</a> &#x00BB; <a href="../../../index.html">Lwtreslib</a> &#x00BB; <a href="../../index.html">Traced</a> &#x00BB; <a href="../index.html">Monad</a> &#x00BB; Lwt_result_syntax</nav><header class="odoc-preamble"><h1>Module <code><span>Monad.Lwt_result_syntax</span></code></h1><p>Syntax module for Lwt+Result. This is intended to be opened locally in functions which use Lwt and <code>result</code> for control-flow. Within the scope of this module, the code can include binding operators, leading to a <code>let</code>-style syntax.</p><p>See also <code>Lwt</code>, <a href="../../Result/index.html"><code>Result</code></a>, and <code>Lwt_result</code>.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec value anchored" id="val-return"><a href="#val-return" class="anchor"></a><code><span><span class="keyword">val</span> return : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>return x</code> is <code>Lwt.return (Ok x)</code> or <code>Lwt_result.return x</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-return_unit"><a href="#val-return_unit" class="anchor"></a><code><span><span class="keyword">val</span> return_unit : <span><span><span>(unit, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>return_unit</code> is <code>Lwt.return (Ok ())</code> .</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-return_none"><a href="#val-return_none" class="anchor"></a><code><span><span class="keyword">val</span> return_none : <span><span><span>(<span><span class="type-var">'a</span> option</span>, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>return_none</code> is <code>Lwt.return (Ok None)</code> .</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-return_some"><a href="#val-return_some" class="anchor"></a><code><span><span class="keyword">val</span> return_some : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span><span class="type-var">'a</span> option</span>, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>return_some x</code> is <code>Lwt.return (Ok (Some x))</code> .</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-return_nil"><a href="#val-return_nil" class="anchor"></a><code><span><span class="keyword">val</span> return_nil : <span><span><span>(<span><span class="type-var">'a</span> list</span>, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>return_nil</code> is <code>Lwt.return (Ok [])</code> .</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-return_true"><a href="#val-return_true" class="anchor"></a><code><span><span class="keyword">val</span> return_true : <span><span><span>(bool, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>return_true</code> is <code>Lwt.return (Ok true)</code> .</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-return_false"><a href="#val-return_false" class="anchor"></a><code><span><span class="keyword">val</span> return_false : <span><span><span>(bool, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>return_false</code> is <code>Lwt.return (Ok false)</code> .</p></div></div><p>Note that we do not provide <code>return_ok</code> nor <code>return_error</code>. Both of these functions are possible but somewhat confusing and rarely useful in practice. If you need to carry <code>result</code>s within a LwtResult-monad computation (yielding values of the type <code>(('a, 'e) result, 'e) result Lwt.t</code>), you need to do so by hand: <code>return (Ok …)</code> and <code>return (Error …)</code>.</p><div class="odoc-spec"><div class="spec value anchored" id="val-fail"><a href="#val-fail" class="anchor"></a><code><span><span class="keyword">val</span> fail : <span><span class="type-var">'e</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>fail e</code> is <code>Lwt.return (Error e)</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-let*"><a href="#val-let*" class="anchor"></a><code><span><span class="keyword">val</span> let* : 
  <span><span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>let*</code> is a binding operator alias for <code>Lwt_result.bind</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-let+"><a href="#val-let+" class="anchor"></a><code><span><span class="keyword">val</span> let+ : 
  <span><span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>let+</code> is a binding operator alias for <code>Lwt_result.map</code>.</p></div></div><p>Note that we do not provide <code>and*</code> nor <code>and+</code>. Both of these are possible but their type is unsatisfying because the errors do not compose well. You can use <code>both</code> (below) if need be.</p><div class="odoc-spec"><div class="spec value anchored" id="val-lwt_map_error"><a href="#val-lwt_map_error" class="anchor"></a><code><span><span class="keyword">val</span> lwt_map_error : 
  <span><span>(<span><span class="type-var">'e</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'f</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'f</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>lwt_map_error</code> is an Lwt-aware variant of <a href="../../Result/index.html#val-map_error"><code>Result.map_error</code></a>. It is intended for mapping the errors of Lwt-result values. The main use of this function is for mixing results that carry different types of errors.</p><p>E.g., considering <code>fetch : unit -&gt; (string, unit) result Lwt.t</code> and <code>emit : string -&gt; (unit, int) result Lwt.t</code>, you can write</p><pre class="language-ocaml"><code>let* data = lwt_map_error (fun () -&gt; &quot;fetching failed&quot;) @@ fetch () in
let* () =
  lwt_map_error (fun code -&gt; Format.asprintf &quot;emit failed (%d)&quot;)
  @@ emit data
in
..</code></pre></div></div><p>The following values are for mixing expressions that are Lwt-only or Result-only within the LwtResult monad. Note that there are fundamental differences between <code>result</code> and <code>Lwt.t</code>: the former can be simply matched on (i.e., it is possible to get out of the monad at any point) whereas the latter can only be bound on (i.e., it is not possible to get out of the monad). In addition, the former is for aborting computations on failures whereas the latter is for waiting before continuing.</p><p>Still, from a syntax point-of-view, both are handled the same way: with a specialised binding operator.</p><div class="odoc-spec"><div class="spec value anchored" id="val-let*!"><a href="#val-let*!" class="anchor"></a><code><span><span class="keyword">val</span> let*! : <span><span><span class="type-var">'a</span> <span class="xref-unresolved">Lwt</span>.t</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>let*!</code> is for binding Lwt-only expressions into the LwtResult combined monad.</p><pre class="language-ocaml"><code>let open Lwt_result_syntax in
let* x = … in
let*! y = … in
return (x + y)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-let*?"><a href="#val-let*?" class="anchor"></a><code><span><span class="keyword">val</span> let*? : 
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>let*?</code> is for binding the value from Result-only expressions into the LwtResult combined monad.</p><pre class="language-ocaml"><code>let open Lwt_result_syntax in
let* x = … in
let*? y = … in
…</code></pre></div></div><p>Note that you can mix <code>let*</code>, <code>let*!</code>, and <code>let*?</code> as needed, within a single expression.</p><pre class="language-ocaml"><code>let do_thing param =
  let open Lwt_result_syntax in
  let*? () = check_p param in (* Result-only for parameter checking *)
  let*! () = log &quot;starting doing the thing&quot; in (* Lwt-only for infallible logging *)
  let* r = thing param in
  let*! () = log &quot;done doing the thing&quot; in (* Lwt-only for infallible logging *)
  return r</code></pre><div class="odoc-spec"><div class="spec value anchored" id="val-join"><a href="#val-join" class="anchor"></a><code><span><span class="keyword">val</span> join : 
  <span><span><span><span><span>(unit, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(unit, <span><span class="type-var">'e</span> list</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>join</code> is the joining of concurrent success/failure unit values.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-all"><a href="#val-all" class="anchor"></a><code><span><span class="keyword">val</span> all : 
  <span><span><span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><span class="type-var">'a</span> list</span>, <span><span class="type-var">'e</span> list</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>all</code> is the joining of concurrent success/failure non-unit values.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-both"><a href="#val-both" class="anchor"></a><code><span><span class="keyword">val</span> both : 
  <span><span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span><span>(<span class="type-var">'b</span>, <span class="type-var">'e</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>, <span><span class="type-var">'e</span> list</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>both</code> is the joining of two concurrent success/failure non-unit values.</p></div></div></div></body></html>
