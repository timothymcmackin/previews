<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Optimizer (octez-libs.Plompiler.Optimizer)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">octez-libs</a> &#x00BB; <a href="../index.html">Plompiler</a> &#x00BB; Optimizer</nav><header class="odoc-preamble"><h1>Module <code><span>Plompiler.Optimizer</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec value anchored" id="val-list_map"><a href="#val-list_map" class="anchor"></a><code><span><span class="keyword">val</span> list_map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span></span></code></div><div class="spec-doc"><p>The optimizer simplifies a constraint system, producing an equivalent one with fewer constraints in essentially three ways:</p><ul><li>1. <a href="#next_gate_selectors" title="next_gate_selectors">Introducing next-gate selectors</a> <code>qlg</code>, <code>qrg</code> and/or <code>qog</code>, which lead to a more compact representation of sums (linear combinations).</li></ul><ul><li>2. <a href="#shared_wires" title="shared_wires">Reusing shared-wires</a> among different constraints.</li></ul><ul><li>3. <a href="#compacting_blocks" title="compacting_blocks">Compacting blocks</a> which operate on independent wires.</li></ul><p>Optimization Rules</p><p>Introducing next-gate selectors</p><p>In a system with 3-wires architecture, adding (in a linear combination) <code>n</code> elements requires <code>n-1</code> constraints. For example, computing <code>out = 1 + 2 x1 + 4 x2 + 8 x3 + 16 x4 + 32 x5</code> can be implemented in 4 constraints as follows:</p><pre class="language-ocaml"><code>{ a = x1;   b = x2;   c = aux1; identity = [ql 2; qr 4; qo -1; qc 1] };
{ a = x3;   b = x4;   c = aux2; identity = [ql 8; qr 16; qo -1] };
{ a = x5;   b = aux1; c = aux3; identity = [ql 32; qr 1; qo -1] };
{ a = aux2; b = aux3; c = out;  identity = [ql 1; qr 1; qo -1] };</code></pre><p>Instead, by using next-gate selectors, a linear combination of <code>n</code> terms can be implemented in <code>(n-1)/2</code> constraints. In this case, just two:</p><pre class="language-ocaml"><code>{ a = x1; b = x2; c = out; identity = [ql 2; qr 4; qlg 8; qrg 16; qog 32; qo -1; qc 1] };
{ a = x3; b = x4; c = x5;  identity = [] };</code></pre><p>Reusing shared-wires</p><p>Remarkably, two linear combinations that involve some common wires can be implemented more efficiently if they are handled together. For example, <code>out1 = 5 x + 3 y + 9 z</code> and <code>out2 = 2 x - 3 y + 7 t</code> can be implemented with 3 constraints (instead of 4) as follows:</p><pre class="language-ocaml"><code>{ a = z;        c = out1; identity = [ql 9; qlg 5; qrg 3; qog -1] };
{ a = x; b = y; c = out2; identity = [ql 2; qr -3; qrg 7; qog -1] };
{        b = t;         ; identity = [] };</code></pre><p>Furthermore, observe how, conveniently, some wires in the above constraints are unbound, which can lead to our next optimization.</p><p>Compacting blocks</p><p>Consider a gate which only takes one wire as input, e.g. for computing <code>out3 = 3 w + 1</code>, implemented with constraint:</p><pre class="language-ocaml"><code>{ a = w;        c = out3; identity = [ql 3; qo -1; qc 1] }</code></pre><p>This constraint can be merged with our previous block, which only uses wire b in its last constraint and has unbound selectors for it:</p><pre class="language-ocaml"><code>{ a = z;        c = out1; identity = [ql 9; qlg 5; qrg 3; qog -1] };
{ a = x; b = y; c = out2; identity = [ql 2; qr -3; qrg 7; qog -1] };
{ a = w; b = t; c = out3; identity = [ql 3; qo -1; qc 1] };</code></pre><p>Algorithm</p><p>The optimization proceeds in several steps:</p><p>1. Collect information about all linear constraints/gates (see <code>is_linear</code>), including the number of occurrences of their output wire among the circuit.</p><p>2. Inline any <code>linear_computation</code> whose output is used only once among the circuit, in the computation where it is used (only if the latter is also linear).</p><p>3. Transform any non-inlined linear computation into a <a href="#type-pseudo_block"><code>pseudo_block</code></a> and join pseudo blocks that share at least a wire (preferably two wires).</p><p>4. Transform pseudo blocks to actual blocks (also considering the non-linear computations that were left aside) and join blocks that operate on independent wires together.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-nb_wires_arch"><a href="#val-nb_wires_arch" class="anchor"></a><code><span><span class="keyword">val</span> nb_wires_arch : int</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-constr"><a href="#type-constr" class="anchor"></a><code><span><span class="keyword">type</span> constr</span><span> = <a href="../Csir/CS/index.html#type-raw_constraint">Csir.CS.raw_constraint</a></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-scalar"><a href="#type-scalar" class="anchor"></a><code><span><span class="keyword">type</span> scalar</span><span> = <a href="../Csir/Scalar/index.html#type-t">Csir.Scalar.t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-scalar_t"><a href="#val-scalar_t" class="anchor"></a><code><span><span class="keyword">val</span> scalar_t : <span><a href="../Csir/Scalar/index.html#type-t">Csir.Scalar.t</a> <span class="xref-unresolved">Repr</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-block"><a href="#type-block" class="anchor"></a><code><span><span class="keyword">type</span> block</span><span> = <span><a href="#type-constr">constr</a> array</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-term"><a href="#type-term" class="anchor"></a><code><span><span class="keyword">type</span> term</span><span> = <a href="#type-scalar">scalar</a> * int</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-term_t"><a href="#val-term_t" class="anchor"></a><code><span><span class="keyword">val</span> term_t : <span><span>(<a href="../Csir/Scalar/index.html#type-t">Csir.Scalar.t</a> * int)</span> <span class="xref-unresolved">Repr</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-trace_info"><a href="#type-trace_info" class="anchor"></a><code><span><span class="keyword">type</span> trace_info</span><span> = </span><span>{</span></code><ol><li id="type-trace_info.free_wires" class="def record field anchored"><a href="#type-trace_info.free_wires" class="anchor"></a><code><span>free_wires : <span>int list</span>;</span></code></li><li id="type-trace_info.assignments" class="def record field anchored"><a href="#type-trace_info.assignments" class="anchor"></a><code><span>assignments : <span><span>(int * <span><a href="#type-term">term</a> list</span>)</span> list</span>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Type to store the trace_updater information. <code>free_wires</code> represents a list of indices of wires that have been removed from the system and have not been used again for auxiliary computations. If a free wire <code>w</code> is used to store an auxiliary linear computation on some <code>terms</code>, it is removed from <code>free_wires</code> and the pair <code>(v, terms)</code> is added to the list of <code>assignments</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-trace_info_t"><a href="#val-trace_info_t" class="anchor"></a><code><span><span class="keyword">val</span> trace_info_t : <span><a href="#type-trace_info">trace_info</a> <span class="xref-unresolved">Repr</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-pseudo_constr"><a href="#type-pseudo_constr" class="anchor"></a><code><span><span class="keyword">type</span> pseudo_constr</span><span> = </span><span>{</span></code><ol><li id="type-pseudo_constr.pc_head" class="def record field anchored"><a href="#type-pseudo_constr.pc_head" class="anchor"></a><code><span>pc_head : <span><a href="#type-term">term</a> list</span>;</span></code></li><li id="type-pseudo_constr.pc_body" class="def record field anchored"><a href="#type-pseudo_constr.pc_body" class="anchor"></a><code><span>pc_body : <span><a href="#type-term">term</a> list</span>;</span></code></li><li id="type-pseudo_constr.pc_tail" class="def record field anchored"><a href="#type-pseudo_constr.pc_tail" class="anchor"></a><code><span>pc_tail : <span><a href="#type-term">term</a> list</span>;</span></code></li><li id="type-pseudo_constr.pc_const" class="def record field anchored"><a href="#type-pseudo_constr.pc_const" class="anchor"></a><code><span>pc_const : <a href="../Csir/Scalar/index.html#type-t">Csir.Scalar.t</a>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>A pseudo constraint represents an equation between an arbitrary number of terms. In particular, adding all terms from its head, body, tail and its constant term should produce 0. The length of pc_head and pc_tail should never exceed <code>nb_wires_arch</code>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-pseudo_block"><a href="#type-pseudo_block" class="anchor"></a><code><span><span class="keyword">type</span> pseudo_block</span><span> = <span><a href="#type-pseudo_constr">pseudo_constr</a> list</span></span></code></div><div class="spec-doc"><p>A pseudo block is a list of pseudo constraints that have been groupped in order to apply the <a href="#shared_wires" title="shared_wires">Reusing shared-wires</a> heuristic. The constraints in a pseudo block satisfy (by construction) the invariant the pc_head of a constraint starts with the pc_tail of the previous one (when considering the term variables, coefficients may be different). Note that the pc_head may contain extra terms that do not appear in the previous pc_tail. This invariant is important for <code>block_of_pseudo_block</code> to be correct</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-join_list"><a href="#val-join_list" class="anchor"></a><code><span><span class="keyword">val</span> join_list : 
  <span><span class="label">join</span>:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> option</span></span></code></div><div class="spec-doc"><p><code>join_list ~join scope x xs</code> joins <code>x</code> with another element among the first <code>scope</code> elements of the list of candidates <code>xs</code>, or returns <code>None</code> if no union was possible. This function may not preserve the order in <code>xs</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-combine_quadratic"><a href="#val-combine_quadratic" class="anchor"></a><code><span><span class="keyword">val</span> combine_quadratic : 
  <span><span class="label">scope</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">join</span>:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>combine_quadratic ~join xs</code> takes a list of elements <code>xs</code> and returns a (potentially) shorter list <code>xs'</code> where some of the elements have been combined according to <code>join</code>. <code>join x x'</code> is <code>None</code> if <code>x</code> and <code>x'</code> cannot be combined and it is <code>Some union</code> otherwise. This algorithm tries to combine every element of <code>xs</code> with any other element by greedily trying all possible <code>n choose 2</code> different pairings of elements, where <code>n</code> is the length of <code>xs</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-combine_quadratic_efficient"><a href="#val-combine_quadratic_efficient" class="anchor"></a><code><span><span class="keyword">val</span> combine_quadratic_efficient : 
  <span><span class="label">scope</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">join</span>:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>Similar to <code>combine_quadratic</code>, but more efficient. Takes a list of <code>top_candidates</code> that will each be tried to be combined with <code>rest</code>. This function may not preserve the order in <code>rest</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_terms"><a href="#val-add_terms" class="anchor"></a><code><span><span class="keyword">val</span> add_terms : <span><span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-term">term</a> list</span></span></code></div><div class="spec-doc"><p>Concatenates two lists of terms, merging terms with the same wire identifier (by adding their coefficients)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-inline"><a href="#val-inline" class="anchor"></a><code><span><span class="keyword">val</span> inline : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="label">from</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="label">into</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span><span><a href="#type-term">term</a> list</span> array</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>inline w ~from ~into linear</code> takes an array of linear constraints (a linear constraint is represented by list of terms), solves for wire <code>w</code> in constraint <code>linear.(from)</code> and substitutes wire <code>w</code> by the result in constraint <code>linear.(into)</code>. <code>linear.(from)</code> is left empty. This routine should only be called if <code>w</code> does not appear in any other constraint. In that case, constraint <code>linear.(from)</code> can then be removed and wire <code>w</code> is said to be &quot;free&quot;.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-IMap"><a href="#module-IMap" class="anchor"></a><code><span><span class="keyword">module</span> <a href="IMap/index.html">IMap</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The keys are wire indices and the values lists of constraints indices, such that the wire appears in each of the constraints.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-ISet"><a href="#module-ISet" class="anchor"></a><code><span><span class="keyword">module</span> <a href="ISet/index.html">ISet</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-increase_occurrences"><a href="#val-increase_occurrences" class="anchor"></a><code><span><span class="keyword">val</span> increase_occurrences : 
  <span><span><span><span class="type-var">'a</span> list</span> <a href="IMap/index.html#type-t">IMap.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'b</span> * <a href="IMap/index.html#type-key">IMap.key</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <a href="IMap/index.html#type-t">IMap.t</a></span></span></code></div><div class="spec-doc"><p>Auxiliary function used in <code>inline_linear</code>.</p><p><code>increase_occurrences map i terms</code> updates <code>map</code> by adding <code>i</code> to the list of occurrences of wire <code>w</code> for every <code>(_, w)</code> in <code>terms</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pseudo_block_of_terms"><a href="#val-pseudo_block_of_terms" class="anchor"></a><code><span><span class="keyword">val</span> pseudo_block_of_terms : <span><span><a href="#type-term">term</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-pseudo_constr">pseudo_constr</a> list</span></span></code></div><div class="spec-doc"><p>Creates a pseudo block with all terms in the body except for the wire -1 which is set as constant.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-inline_linear"><a href="#val-inline_linear" class="anchor"></a><code><span><span class="keyword">val</span> inline_linear : 
  <span><span class="label">nb_inputs</span>:<a href="IMap/index.html#type-key">IMap.key</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">range_checked</span>:<span class="xref-unresolved">Plompiler__.Range_checks.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span><a href="../Csir/CS/index.html#type-raw_constraint">Csir.CS.raw_constraint</a> array</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-pseudo_constr">pseudo_constr</a> list</span> list</span> * <span><span><a href="../Csir/CS/index.html#type-raw_constraint">Csir.CS.raw_constraint</a> array</span> list</span> * <span><a href="IMap/index.html#type-key">IMap.key</a> list</span></span></code></div><div class="spec-doc"><p>Returns a list of linear gates that have possibly been inlined, the list of wires that were inlined (and thus freed) and the list of unchanged non-linear gates. The wires selected for inlining must:</p><ul><li>appear in exactly two linear gates of size one</li><li>not be inputs</li><li>not be range-checked The inlined linear gates are returned as pseudo blocks because they may need to be split again to fit 3 wires.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-place_over_pseudo_block"><a href="#val-place_over_pseudo_block" class="anchor"></a><code><span><span class="keyword">val</span> place_over_pseudo_block : 
  <span><span class="label">perfectly</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-pseudo_constr">pseudo_constr</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-pseudo_constr">pseudo_constr</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-pseudo_constr">pseudo_constr</a> list</span> option</span></span></code></div><div class="spec-doc"><p><code>place_over_pseudo_block ~perfectly b1 b2</code> tries to join pseudo block <code>b1</code> on top of <code>b2</code>, i.e., link the last pseudo constraint of <code>b1</code> with the first pseudo constraint of <code>b2</code>. It returns an optional argument containing the combined pseudo block if the combination was successful. <code>perfectly</code> is a Boolean argument that specifies whether only &quot;perfect&quot; matches should be accepted. In this context, &quot;perfect&quot; means that the two constraints to be combined share exactly <code>nb_wires_arch</code> wires.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-combine_pseudo_blocks"><a href="#val-combine_pseudo_blocks" class="anchor"></a><code><span><span class="keyword">val</span> combine_pseudo_blocks : 
  <span><span class="label">scope</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">perfectly</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span><span><a href="#type-pseudo_constr">pseudo_constr</a> list</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-pseudo_constr">pseudo_constr</a> list</span> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-linear_combination"><a href="#val-linear_combination" class="anchor"></a><code><span><span class="keyword">val</span> linear_combination : 
  <span><span class="label">this</span>:<span><span>(<a href="../../../bls12-381/Bls12_381/Fr/index.html#type-t">Bls12_381.Fr.t</a> * int)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">next</span>:<span><span>(<a href="../../../bls12-381/Bls12_381/Fr/index.html#type-t">Bls12_381.Fr.t</a> * <span class="type-var">'a</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../bls12-381/Bls12_381/Fr/index.html#type-t">Bls12_381.Fr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../Csir/CS/index.html#type-raw_constraint">Csir.CS.raw_constraint</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-dummy_linear_combination"><a href="#val-dummy_linear_combination" class="anchor"></a><code><span><span class="keyword">val</span> dummy_linear_combination : <span><span><span>(<span class="type-var">'a</span> * int)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="../Csir/CS/index.html#type-raw_constraint">Csir.CS.raw_constraint</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-block_of_pseudo_block"><a href="#val-block_of_pseudo_block" class="anchor"></a><code><span><span class="keyword">val</span> block_of_pseudo_block : 
  <span><a href="#type-trace_info">trace_info</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-pseudo_constr">pseudo_constr</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-trace_info">trace_info</a> * <span><a href="../Csir/CS/index.html#type-raw_constraint">Csir.CS.raw_constraint</a> array</span> * <span><span><a href="#type-pseudo_constr">pseudo_constr</a> list</span> list</span></span></code></div><div class="spec-doc"><p>Given a pseudo block, i.e., a list of pseudo constraints, transform it into a block. Thanks to the invariant that the pc_head of a pseudo constraint starts with the pc_tail of the previous one, it is enough to add a constraint for each pc_head (and encode each pc_tail with next-gate selectors). Note that pc_bodies may need to be freed through auxiliary variables.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-blocks_of_pseudo_blocks"><a href="#val-blocks_of_pseudo_blocks" class="anchor"></a><code><span><span class="keyword">val</span> blocks_of_pseudo_blocks : 
  <span><span class="label">scope</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span>int list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span><a href="#type-pseudo_constr">pseudo_constr</a> list</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-trace_info">trace_info</a> * <span><span><a href="../Csir/CS/index.html#type-raw_constraint">Csir.CS.raw_constraint</a> array</span> list</span></span></code></div><div class="spec-doc"><p>This function takes a list of pseudo blocks, combines them if possible and converts them into blocks. This conversion may lead to residue pseudo blocks (if auxiliary variables were involved to free a pc_body). It then applies the same process on the residue pseudo blocks. Observe that it is relatively rare that a residue pseudo block is produced after the convertion. Consequently the second iteration of this function will be among many fewer pseudo blocks and it quickly reaches termination</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-place_over_block"><a href="#val-place_over_block" class="anchor"></a><code><span><span class="keyword">val</span> place_over_block : <span><span class="label">perfectly</span>:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-block">block</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-block">block</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-block">block</a> option</span></span></code></div><div class="spec-doc"><p><code>place_over_block ~perfectly pb pb'</code> tries to join block <code>b1</code> on top of <code>b2</code>. It works only if the last constraint of <code>b1</code> has no selectors. <code>perfectly</code> returns only matches that have no empty selectors (no holes). It is relevant for a heuristic where we first want to find perfect matches and then any match.</p><p>The joining is done by</p><ul><li>finding a permutation that makes the wires of b1.last and b2.first match (being relaxed about unset wires)</li><li>checking if the permutation if perfect and failing if required</li><li>renaming the selectors of b1.last</li><li>renaming the next selectors of b1.second_last</li></ul><p>Example: <code> (1 1 1)  [ql:a qlg:b]
      (3 2 -1) [] </code> <code> (2 3 4)  [ql:a]
      (1 1 1)  [ql:a] </code> becomes <code> (1 1 1)  [ql:a qrg:b]
      (2 3 4)  [ql:a]
      (1 1 1)  [ql:a] </code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-combine_blocks"><a href="#val-combine_blocks" class="anchor"></a><code><span><span class="keyword">val</span> combine_blocks : <span><span class="label">perfectly</span>:bool <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-block">block</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">scope</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-block">block</a> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-trace_updater"><a href="#val-trace_updater" class="anchor"></a><code><span><span class="keyword">val</span> trace_updater : <span><a href="#type-trace_info">trace_info</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-scalar">scalar</a> array</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-scalar">scalar</a> array</span></span></code></div><div class="spec-doc"><p>Takes <a href="#type-trace_info"><code>trace_info</code></a> and returns a function that updates a given trace to make it compatible with the optimized constraints.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-remove_boolean_gates"><a href="#val-remove_boolean_gates" class="anchor"></a><code><span><span class="keyword">val</span> remove_boolean_gates : 
  <span><span><span><a href="../Csir/CS/index.html#type-raw_constraint">Csir.CS.raw_constraint</a> array</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../Csir/CS/index.html#type-raw_constraint">Csir.CS.raw_constraint</a> array</span> list</span> * <span>int list</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_boolean_checks"><a href="#val-add_boolean_checks" class="anchor"></a><code><span><span class="keyword">val</span> add_boolean_checks : 
  <span><span class="label">boolean_vars</span>:<span><a href="ISet/index.html#type-elt">ISet.elt</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span><a href="../Csir/CS/index.html#type-raw_constraint">Csir.CS.raw_constraint</a> array</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../Csir/CS/index.html#type-raw_constraint">Csir.CS.raw_constraint</a> array</span> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-inline_renamings"><a href="#val-inline_renamings" class="anchor"></a><code><span><span class="keyword">val</span> inline_renamings : 
  <span><span class="label">nb_inputs</span>:<a href="IMap/index.html#type-key">IMap.key</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">range_checked</span>:<span class="xref-unresolved">Plompiler__.Range_checks.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span><a href="../Csir/CS/index.html#type-raw_constraint">Csir.CS.raw_constraint</a> array</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../Csir/CS/index.html#type-raw_constraint">Csir.CS.raw_constraint</a> array</span> list</span> * <span><a href="IMap/index.html#type-key">IMap.key</a> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-remove_trivial"><a href="#val-remove_trivial" class="anchor"></a><code><span><span class="keyword">val</span> remove_trivial : 
  <span><span><span><a href="../Csir/CS/index.html#type-raw_constraint">Csir.CS.raw_constraint</a> array</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../Csir/CS/index.html#type-raw_constraint">Csir.CS.raw_constraint</a> array</span> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-optimize"><a href="#val-optimize" class="anchor"></a><code><span><span class="keyword">val</span> optimize : 
  <span><span class="label">nb_inputs</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">range_checks</span>:<span class="xref-unresolved">Plompiler__.Range_checks.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../Csir/CS/index.html#type-gate">Csir.CS.gate</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Csir/CS/index.html#type-gate">Csir.CS.gate</a> list</span> * <a href="#type-trace_info">trace_info</a></span></code></div><div class="spec-doc"><p>Takes a list of raw_constraints and returns an equivalent constraint system with potentially fewer constraints. As a second output, it returns the necessary information to build a function that updates the trace to make it compatible with the new constraints</p></div></div></div></body></html>
