<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Circular_buffer (octez-libs.Tezos_stdlib.Circular_buffer)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">octez-libs</a> &#x00BB; <a href="../index.html">Tezos_stdlib</a> &#x00BB; Circular_buffer</nav><header class="odoc-preamble"><h1>Module <code><span>Tezos_stdlib.Circular_buffer</span></code></h1><p>This module implements a bufferisation abstraction to store temporary raw data chunks (as bytes) when chunks are read sequentially. The function <code>write</code> allows to store chunks in the buffer and the function read to read them from the buffer.</p><p>The global contract is that if we write consecutively <code>d1;d2</code> onto the buffer, then we have to fully read <code>d1</code> and <code>d2</code>, in that order.</p><p>This contract is not enforced by the library, it is the user responsibility to respect it.</p><p>If the circular buffer is full, a new temporary buffer is allocated to store the chunk of data to be written.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>Type of circular buffers</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-data"><a href="#type-data" class="anchor"></a><code><span><span class="keyword">type</span> data</span></code></div><div class="spec-doc"><p>An abstraction over a chunk of data written in the buffer.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-create"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span><span class="optlabel">?maxlength</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?fresh_buf_size</span>:int <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>create ?maxlength ?fresh_buf_size ()</code> creates a buffer of size <code>maxlength</code> (by default <code>32</code> kb). If the buffer is full, a buffer of size <code>fresh_buf_size</code> is allocated (by default <code>2</code> kb).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-write"><a href="#val-write" class="anchor"></a><code><span><span class="keyword">val</span> write : 
  <span><span class="label">maxlen</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">fill_using</span>:
    <span>(<span><span class="xref-unresolved">Stdlib</span>.Bytes.t <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span>(int, <span class="type-var">'error</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="#type-data">data</a>, <span class="type-var">'error</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>write ~maxlen ~fill_using buffer</code> calls <code>fill_using buf offset
   maxlen</code> where <code>buf</code> is a buffer that has room for <code>maxlen</code> data starting from <code>offset</code>.</p><p>Assumes that <code>fill_using</code> returns the exact amount of written bytes.</p><p>Behaviour is unspecified if <code>fill_using</code> writes more than <code>maxlen</code> data or lies on the number of written bytes.</p><p>It returns a data descriptor for the supposedly written chunk.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-read"><a href="#val-read" class="anchor"></a><code><span><span class="keyword">val</span> read : 
  <span><a href="#type-data">data</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?len</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">into</span>:<span class="xref-unresolved">Stdlib</span>.Bytes.t <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">offset</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-data">data</a> option</span></span></code></div><div class="spec-doc"><p><code>read data ~len ~into:buf buffer ~offset</code> copies <code>len</code> data from the <code>data</code> chunk into <code>buf</code>. If <code>len</code> is not provided, it copies all the data. If <code>len</code> is less than the amount of data available, it returns a new handler of the remainder.</p><ul><li>Assumes that <code>data</code> has been produced by a <a href="#val-write"><code>write</code></a> attempt in <code>buffer</code>.</li><li>Assumes that <code>len</code> is less than <code>length data</code>.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-length"><a href="#val-length" class="anchor"></a><code><span><span class="keyword">val</span> length : <span><a href="#type-data">data</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>length data</code> returns the amount of available bytes in <code>data</code></p></div></div></div></body></html>
