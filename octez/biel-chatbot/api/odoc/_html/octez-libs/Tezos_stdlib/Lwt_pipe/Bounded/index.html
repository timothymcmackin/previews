<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Bounded (octez-libs.Tezos_stdlib.Lwt_pipe.Bounded)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">octez-libs</a> &#x00BB; <a href="../../index.html">Tezos_stdlib</a> &#x00BB; <a href="../index.html">Lwt_pipe</a> &#x00BB; Bounded</nav><header class="odoc-preamble"><h1>Module <code><span>Lwt_pipe.Bounded</span></code></h1><p>Data queues similar to the <code>Pipe</code> module in Jane Street's <code>Async</code> library. They are implemented with <code>Queue</code>s, limited in size, and use Lwt primitives for concurrent access.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span></code></div><div class="spec-doc"><p>Type of queues holding values of type <code>'a</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-create"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span><span class="label">max_size</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="label">compute_size</span>:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>create ~max_size ~compute_size ()</code> is an empty queue that can hold at most <code>max_size</code> &quot;bytes&quot; of data, using <code>compute_size</code> to compute the number of &quot;bytes&quot; in a datum.</p><p>Note that you can use <code>max_size</code>/<code>compute_size</code> to actually limit the size in byte (i.e., the memory footprint of the structure (in this case, consider using <a href="#val-push_overhead"><code>push_overhead</code></a> to account for the boilerplate memory), but you can also use <code>max_size</code>/<code>compute_size</code> to limit the footprint of the structure for some other resource. E.g., you can spin up tasks in separate processes and limit the number of concurrently running processes.</p><p>Also note that the size bound is not inclusive. So with <code>max_size</code> set to <code>2</code> and <code>compute_size</code> to <code>fun _ -&gt; 1</code> you can add one (1) element and then the pipe is full. (It is full because adding any other element would take the total size to <code>2</code> which is not strictly smaller than the <code>max_size</code> bound.)</p><p>Finally, note that when the pipe is empty, inserting an element will always succeed immediately, even if its size exceed the size bound. For the same reason, inserting an element bigger than the size bound will eventually succeeds, but only once the pipe has been emptied. Once such an element has been inserted, no other element can be pushed until the bigger-than-bound element is popped. This behaviour breaks the invariant guaranteed by the module, but is kept for backwards compatibility. It may be changed in the future, but only after a careful review of the potential impact.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-push"><a href="#val-push" class="anchor"></a><code><span><span class="keyword">val</span> push : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>push q v</code> is a promise that is pending until there is enough space in <code>q</code> to accommodate <code>v</code>. When this happens <code>v</code> is added to the end of <code>q</code> and the promise resolves.</p><p>If there is enough space in <code>q</code> to accommodate <code>v</code> when the call is made, then the <code>v</code> is added immediately and an already resolved promise is returned.</p><p>Note that if several writes are stuck because the pipe is full. These writes will succeed in an order that might be different from the order the write attempts were made. Specifically, when pushing elements of different computed sizes, smaller pushes may be resolved earlier if enough space is freed.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>{!Closed}</code> <p>if <code>q</code> is closed. More specifically, the promise is rejected with <a href="../index.html#exception-Closed"><code>Closed</code></a> if <code>q</code> is closed.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pop"><a href="#val-pop" class="anchor"></a><code><span><span class="keyword">val</span> pop : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>pop q</code> is a promise that is pending until there is an element in <code>q</code>. When this happens an element is removed and the promise is fulfilled with it.</p><p>If there is already an element in <code>q</code> when the call is made, the element is removed immediately and an already resolved promise is returned.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>{!Closed}</code> <p>if <code>q</code> is empty and closed. More specifically, the promise is rejected with <a href="../index.html#exception-Closed"><code>Closed</code></a> if <code>q</code> is empty and closed.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pop_with_timeout"><a href="#val-pop_with_timeout" class="anchor"></a><code><span><span class="keyword">val</span> pop_with_timeout : <span><span>unit <span class="xref-unresolved">Lwt</span>.t</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> option</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>pop_with_timeout t q</code> is a promise that behaves similarly to <code>pop q</code> except that it resolves with <code>None</code> if <code>t</code> resolves before there is an element in <code>q</code> to pop.</p><p>Note that there can be multiple promises that are awaiting for an element to pop from the queue. As a result, it is possible that <code>pop_with_timeout</code> is fulfilled with <code>None</code> even though values have been pushed to the <code>q</code>.</p><p><code>t</code> is canceled (i.e., it fails with <code>Canceled</code>) if an element is returned.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>{!Closed}</code> <p>if <code>q</code> is empty and closed. More specifically, the promise is rejected with <a href="../index.html#exception-Closed"><code>Closed</code></a> if <code>q</code> is empty and closed.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pop_all"><a href="#val-pop_all" class="anchor"></a><code><span><span class="keyword">val</span> pop_all : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>pop_all q</code> is a promise that is pending until there is at least one element in <code>q</code>. When this happens, all the elements of <code>q</code> are removed and the promise is fulfilled with the list of elements (in the order in which they were inserted).</p><p>If there is already one or more elements in <code>q</code> when the call is made, the elements are removed immediately and an already resolved promise is returned.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>{!Closed}</code> <p>if <code>q</code> is empty and closed. More specifically, the promise is rejected with <a href="../index.html#exception-Closed"><code>Closed</code></a> if <code>q</code> is empty and closed.</p><p>In practice, this function returns a promise that either:</p><ul><li>is pending and will resolve with a single-element list,</li><li>is already resolved with a list of at least one element,</li><li>or will be rejected with <a href="../index.html#exception-Closed"><code>Closed</code></a>.</li></ul></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pop_all_now"><a href="#val-pop_all_now" class="anchor"></a><code><span><span class="keyword">val</span> pop_all_now : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>pop_all_now q</code> removes and returns all the elements in <code>q</code> (in the order in which they were inserted). If <code>q</code> is empty, <code>[]</code> is returned.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>{!Closed}</code> <p>if <code>q</code> is empty and closed.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-peek"><a href="#val-peek" class="anchor"></a><code><span><span class="keyword">val</span> peek : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>peek q</code> returns the same value as <code>pop q</code> but does not remove the returned element.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>{!Closed}</code> <p>if <code>q</code> is empty and closed. More specifically, the promise is rejected with <a href="../index.html#exception-Closed"><code>Closed</code></a> if <code>q</code> is empty and closed.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-peek_all_now"><a href="#val-peek_all_now" class="anchor"></a><code><span><span class="keyword">val</span> peek_all_now : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>peek_all_now q</code> returns the elements in the <code>q</code> (oldest first), or <code>[]</code> if empty. It does not remove elements from <code>q</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>{!Closed}</code> <p>if <code>q</code> is empty and closed.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-push_now"><a href="#val-push_now" class="anchor"></a><code><span><span class="keyword">val</span> push_now : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>push_now q v</code> either</p><ul><li>adds <code>v</code> at the ends of <code>q</code> immediately and returns <code>true</code>, or</li><li>if <code>q</code> is full, returns <code>false</code>.</li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../index.html#exception-Closed"><code>Closed</code></a> <p>if <code>q</code> is closed.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pop_now"><a href="#val-pop_now" class="anchor"></a><code><span><span class="keyword">val</span> pop_now : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p><code>pop_now q</code> may remove and return the first element in <code>q</code> if <code>q</code> contains at least one element.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../index.html#exception-Closed"><code>Closed</code></a> <p>if <code>q</code> is closed.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-length"><a href="#val-length" class="anchor"></a><code><span><span class="keyword">val</span> length : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>length q</code> is the number of elements in <code>q</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span><span class="keyword">val</span> is_empty : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_empty q</code> is <code>true</code> if <code>q</code> is empty, <code>false</code> otherwise.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-close"><a href="#val-close" class="anchor"></a><code><span><span class="keyword">val</span> close : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>close q</code> the write-end of <code>q</code>:</p><ul><li>Pending and future write attempts will fail with <a href="../index.html#exception-Closed"><code>Closed</code></a>.</li><li>If there is data left in the pipe, then future read attempts will be resolved until the remaining data is drained, after which further reads will fail with <a href="../index.html#exception-Closed"><code>Closed</code></a>.</li><li>If there is no data left in the pipe, then pending and future reads will fail with <a href="../index.html#exception-Closed"><code>Closed</code></a>.</li></ul><p>The <code>close</code> function is idempotent.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_closed"><a href="#val-is_closed" class="anchor"></a><code><span><span class="keyword">val</span> is_closed : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_closed q</code> is <code>true</code> if <code>close q</code> has been called. It is <code>false</code> otherwise.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-push_overhead"><a href="#val-push_overhead" class="anchor"></a><code><span><span class="keyword">val</span> push_overhead : int</span></code></div><div class="spec-doc"><p>The number of bytes used in the internal representation to hold an element in the queue.</p></div></div></div></body></html>
