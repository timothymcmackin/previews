<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>TzBytes (octez-libs.Tezos_stdlib.TzBytes)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">octez-libs</a> &#x00BB; <a href="../index.html">Tezos_stdlib</a> &#x00BB; TzBytes</nav><header class="odoc-preamble"><h1>Module <code><span>Tezos_stdlib.TzBytes</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec value anchored" id="val-logand"><a href="#val-logand" class="anchor"></a><code><span><span class="keyword">val</span> logand : <span>bytes <span class="arrow">&#45;&gt;</span></span> <span>bytes <span class="arrow">&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p>Bitwise AND on bytes.</p><p>If the arguments have different lengths, the prefix of the longer bytes is cut to have the same length as the shorter one before taking bitwise AND.</p><p>Example:</p><p><code>logand (Bytes.of_string &quot;\xff\x0f&quot;) (Bytes.of_string &quot;\xff&quot;) = Bytes.of_string &quot;\x0f&quot;</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-logor"><a href="#val-logor" class="anchor"></a><code><span><span class="keyword">val</span> logor : <span>bytes <span class="arrow">&#45;&gt;</span></span> <span>bytes <span class="arrow">&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p>Bitwise OR on bytes.</p><p>If the arguments have different lengths, the shorter bytes is 0-padded on the left to have the same length before taking bitwise OR.</p><p>Example:</p><p><code>logor (Bytes.of_string &quot;\xf0\x00&quot;) (Bytes.of_string &quot;\x0f&quot;) = Bytes.of_string &quot;\xf0\x0f&quot;</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-logxor"><a href="#val-logxor" class="anchor"></a><code><span><span class="keyword">val</span> logxor : <span>bytes <span class="arrow">&#45;&gt;</span></span> <span>bytes <span class="arrow">&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p>Bitwise XOR on bytes.</p><p>If the arguments have different lengths, the shorter bytes is 0-padded on the left to have the same length before taking bitwise XOR.</p><p>Example:</p><p><code>logxor (Bytes.of_string &quot;\xf0\xff&quot;) (Bytes.of_string &quot;\x0f&quot;) = Bytes.of_string &quot;\xf0\xf0&quot;</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lognot"><a href="#val-lognot" class="anchor"></a><code><span><span class="keyword">val</span> lognot : <span>bytes <span class="arrow">&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p>Bitwise NOT on bytes.</p><p>Example:</p><p><code>lognot (Bytes.of_string &quot;\xff\xf0\xf0&quot;) = Bytes.of_string &quot;\x00\x0f\x0f&quot;</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-shift_left"><a href="#val-shift_left" class="anchor"></a><code><span><span class="keyword">val</span> shift_left : <span>bytes <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p>Logical shift left on bytes.</p><p><code>shift_left bs nbits</code> shifts the byte contents left by <code>nbits</code> bits, using big-endian encoding. The vacated bits on the right are filled with 0s. The shifted bits are minimally 0-padded on the left in order to keep all the original bits: for example, 0x1234 LSL 1 is 0x002468, instead of 0x2468 (the left most bit is lost) or 0x00002468 (not minimal padding).</p><p><code>shift_left bs nbits</code> raises <code>Invalid_argument &quot;shift_left&quot;</code> when <code>nbits &lt; 0</code>.</p><p>Examples:</p><ul><li><code>shift_left (Bytes.of_string &quot;\x12\x34&quot;) 0 = Bytes.of_string &quot;\x12\x34&quot;</code></li><li><code>shift_left (Bytes.of_string &quot;\xff\xff&quot;) 1 = Bytes.of_string &quot;\x01\xff\xfe&quot;</code></li><li><code>shift_left (Bytes.of_string &quot;\x12\x34&quot;) 1 = Bytes.of_string &quot;\x00\x24\x68&quot;</code> (not <code>&quot;\x24\x68&quot;</code>)</li><li><code>shift_left (Bytes.of_string &quot;\x00\x12\x34&quot;) 1 = Bytes.of_string &quot;\x00\x00\x24\x68&quot;</code> (not <code>&quot;\x00\x24\x68&quot;</code>)</li><li><code>shift_left (Bytes.of_string &quot;\x00\x12\x34&quot;) 18 = Bytes.of_string &quot;\x00\x48\xd0\x00\x00&quot;</code> (not <code>&quot;\x48\xd0\x00\x00&quot;</code>)</li><li><code>shift_left Bytes.empty 1 = Bytes.of_string &quot;\x00&quot;</code></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-shift_right"><a href="#val-shift_right" class="anchor"></a><code><span><span class="keyword">val</span> shift_right : <span>bytes <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> bytes</span></code></div><div class="spec-doc"><p>Logical shift right on bytes, using big-endian encoding.</p><p><code>shift_right bs nbits</code> shifts the byte contents right by <code>nbits</code> bits, using big-endian encoding. The shifted bits are minimally 0-padded on the left to fit in bytes. For example, 0x123499 LSR 9 is 0xx091a, instead of 0x00091a (not minimal padding).</p><p><code>shift_right bs nbits</code> raises <code>Invalid_argument &quot;shift_right&quot;</code> when <code>nbits &lt; 0</code>.</p><p>Examples:</p><ul><li><code>shift_right (Bytes.of_string &quot;\x12\x34&quot;) 0 = Bytes.of_string &quot;\x12\x34&quot;</code></li><li><code>shift_right (Bytes.of_string &quot;\x12\x34&quot;) 1 = Bytes.of_string &quot;\x09\x1a&quot;</code></li><li><code>shift_right (Bytes.of_string &quot;\x12\x34&quot;) 8 = Bytes.of_string &quot;\x12&quot;</code> (not <code>&quot;\x00\x12&quot;</code>)</li><li><code>shift_right (Bytes.of_string &quot;\x12\x34\x99&quot;) 9 = Bytes.of_string &quot;\x09\xa&quot;</code></li><li><code>shift_right (Bytes.of_string &quot;\x12\x34&quot;) 18 = Bytes.empty</code></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-chunk_bytes"><a href="#val-chunk_bytes" class="anchor"></a><code><span><span class="keyword">val</span> chunk_bytes : 
  <span><span class="optlabel">?error_on_partial_chunk</span>:<span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  <span>bytes <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>bytes list</span>, <span class="type-var">'a</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>chunk_bytes n b</code> chunks the sequence of bytes <code>b</code> into a list of bytes, each of length <code>n</code>. The last chunk may be a non-empty string of length less than <code>n</code>, in which case the behaviour of the function depends on whether <code>error_on_partial_chunk</code> is set:</p><ul><li>If <code>error_on_partial_chunk</code> is set, then the function returns <code>Error error_on_partial_chunk</code>,</li><li>Otherwise, the function return the list of chunks, where the last chunk is a non-empty string of length less than <code>n</code>.</li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Invalid_argument</code> <p>if <code>n &lt;= 0</code>.</p></li></ul></div></div></div></body></html>
