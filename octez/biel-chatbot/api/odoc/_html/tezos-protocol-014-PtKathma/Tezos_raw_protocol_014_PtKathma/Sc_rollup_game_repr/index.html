<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Sc_rollup_game_repr (tezos-protocol-014-PtKathma.Tezos_raw_protocol_014_PtKathma.Sc_rollup_game_repr)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">tezos-protocol-014-PtKathma</a> &#x00BB; <a href="../index.html">Tezos_raw_protocol_014_PtKathma</a> &#x00BB; Sc_rollup_game_repr</nav><header class="odoc-preamble"><h1>Module <code><span>Tezos_raw_protocol_014_PtKathma.Sc_rollup_game_repr</span></code></h1><p>The smart contract rollup refutation game types are defined here, as well as the basic pure logic for:</p><ul><li>how to create a new game from a pair of commits in the commit tree;</li></ul><ul><li>how to update a game or complete a game when a move is played.</li></ul><p>This game logic is used by the protocol when two commitments are in conflict to determine which one of the commitments is wrong.</p><p>Game state and moves ====================</p><p>At any given moment, the game stores a list <code>dissection</code> of state hashes and tick counts. These are the claims about the PVM history made by the player who has just moved.</p><p>The next player to move will specify a tick count which appears in the <code>dissection</code>; this is the last of the state hashes which she agrees with. She will then either:</p><ul><li>provide a new <code>dissection</code> by giving a list of state hashes and tick counts that starts at the chosen tick count and ends at the next tick count in the previous <code>dissection</code>. It must agree at the start but disagree with the final state.</li></ul><ul><li>if the tick difference between this state and the next is one, there is no 'room' for a new <code>dissection</code>. In this case she must provide a Merkle proof that shows the step in the current <code>dissection</code> is invalid.</li></ul><p>Initializing a game ===================</p><p>In order to trigger the start of a game, one player must publish a first move.</p><p>The <code>initial</code> function is called at this point. It converts a parent-child pair of commitments (belonging to the other player) into an initial <code>dissection</code>. The first move is immediately applied to this to give the first state of the game.</p><p>Note: it is quite possible for the game to end immediately after this first move, either if the commitment has a tick count of one or more probably if the refutation proves that the commitment was 'premature' (the state is not blocked---there are further computation steps to do or more inbox messages to read).</p><p>Expected properties ===================</p><p>P1 - If <code>dissection</code> is honest, the next move must be dishonest:</p><p>There is only one honest state hash for a given tick count. The next player must provide a different hash to the honest hash in the <code>dissection</code>.</p><p>P2 - If <code>dissection</code> is dishonest, there is a strategy for a player equipped with a perfect PVM to play an honest next move:</p><p>The player with a perfect PVM can calculate honest hashes until one disagrees with the <code>dissection</code>, and challenge the dissection at that point, publishing either an honest <code>dissection</code> or an honest <code>Proof</code>.</p><p>Each <code>dissection</code> has a maximum tick count step shorter than the last, so by induction using P1 and P2 we have</p><p>P1' - If <code>dissection</code> is honest, the last player has a winning strategy.</p><p>P2' - If <code>dissection</code> is dishonest, the next player has a winning strategy.</p><p>This allows us to see the following. (We use <code>refuter</code> to mean the first player to move, and <code>defender</code> to mean the other player.)</p><p>Honest refuter wins: An honest refuter will be refuting a dishonest commitment, because there is only one honest state possible per level. Therefore the initial <code>dissection</code> will be dishonest. By P2' the refuter has a winning strategy.</p><p>Honest defender wins: An honest defender will have made an honest commitment which will be translated into an honest initial <code>dissection</code>. By P1' the defender has a winning strategy.</p><p>In the case that both players are dishonest the outcome is slightly harder to determine---it basically comes down to which player gets to play the final move. That means that in this case the refutation game is equivalent to a finite game of nim (by the Sprague-Grundy Theorem, see en.wikipedia.org/wiki/Sprague-Grundy_theorem). However, this fact is completely irrelevant, because if the rollup is working correctly the winner will subsequently be defeated by some honest opponent.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-player"><a href="#type-player" class="anchor"></a><code><span><span class="keyword">type</span> player</span><span> = </span></code><ol><li id="type-player.Alice" class="def variant constructor anchored"><a href="#type-player.Alice" class="anchor"></a><code><span>| </span><span><span class="constructor">Alice</span></span></code></li><li id="type-player.Bob" class="def variant constructor anchored"><a href="#type-player.Bob" class="anchor"></a><code><span>| </span><span><span class="constructor">Bob</span></span></code></li></ol></div><div class="spec-doc"><p>The two stakers index the game in the storage as a pair of public key hashes which is in lexical order. We use <code>Alice</code> and <code>Bob</code> to represent the first and second player in the pair respectively.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-V1"><a href="#module-V1" class="anchor"></a><code><span><span class="keyword">module</span> <a href="V1/index.html">V1</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-include"><div class="spec-doc"><p>Versioning, see <a href="../Sc_rollup_data_version_sig/module-type-S/index.html"><code>Sc_rollup_data_version_sig.S</code></a> for more information.</p></div><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../Sc_rollup_data_version_sig/module-type-S/index.html">Sc_rollup_data_version_sig.S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../Sc_rollup_data_version_sig/module-type-S/index.html#type-t">t</a> = <a href="V1/index.html#type-t">V1.t</a></span></span></code></summary><div class="odoc-spec"><div class="spec type anchored" id="type-versioned"><a href="#type-versioned" class="anchor"></a><code><span><span class="keyword">type</span> versioned</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-versioned_encoding"><a href="#val-versioned_encoding" class="anchor"></a><code><span><span class="keyword">val</span> versioned_encoding : 
  <span><a href="#type-versioned">versioned</a> <a href="../../Tezos_protocol_environment_014_PtKathma/Data_encoding/index.html#type-t">Tezos_protocol_environment_014_PtKathma.Data_encoding.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_versioned"><a href="#val-of_versioned" class="anchor"></a><code><span><span class="keyword">val</span> of_versioned : <span><a href="#type-versioned">versioned</a> <span class="arrow">&#45;&gt;</span></span> <a href="V1/index.html#type-t">V1.t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_versioned"><a href="#val-to_versioned" class="anchor"></a><code><span><span class="keyword">val</span> to_versioned : <span><a href="V1/index.html#type-t">V1.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-versioned">versioned</a></span></code></div></div></details></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <a href="V1/index.html">V1</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="V1/index.html#type-t">t</a> = <a href="V1/index.html#type-t">V1.t</a></span></span></code></summary><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = <a href="V1/index.html#type-t">V1.t</a></span><span> = </span><span>{</span></code><ol><li id="type-t.turn" class="def record field anchored"><a href="#type-t.turn" class="anchor"></a><code><span>turn : <a href="#type-player">player</a>;</span></code></li><li id="type-t.inbox_snapshot" class="def record field anchored"><a href="#type-t.inbox_snapshot" class="anchor"></a><code><span>inbox_snapshot : <a href="../Sc_rollup_inbox_repr/index.html#type-t">Sc_rollup_inbox_repr.t</a>;</span></code></li><li id="type-t.level" class="def record field anchored"><a href="#type-t.level" class="anchor"></a><code><span>level : <a href="../Raw_level_repr/index.html#type-t">Raw_level_repr.t</a>;</span></code></li><li id="type-t.pvm_name" class="def record field anchored"><a href="#type-t.pvm_name" class="anchor"></a><code><span>pvm_name : string;</span></code></li><li id="type-t.dissection" class="def record field anchored"><a href="#type-t.dissection" class="anchor"></a><code><span>dissection : <span><span>(<span><a href="../Sc_rollup_repr/State_hash/index.html#type-t">Sc_rollup_repr.State_hash.t</a> option</span> * <a href="../Sc_rollup_tick_repr/index.html#type-t">Sc_rollup_tick_repr.t</a>)</span> list</span>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>A game state is characterized by:</p><ul><li><code>turn</code>, the player that must provide the next move.</li></ul><ul><li><code>inbox_snapshot</code>, a snapshot of the inbox state at the moment the game is created. This is only used when checking <code>Input_step</code> and <code>Blocked_step</code> proofs; it makes the proofs easier to create--- otherwise they would have a 'moving target' because the actual inbox may be updated continuously.</li></ul><ul><li><code>level</code>, the inbox level of the commitment the game is refuting. This is only used when checking <code>Blocked_step</code> proofs---the proof will show that the next message available in <code>inbox_snapshot</code> is at <code>level</code>, so shouldn't be included in this commitment.</li></ul><ul><li><code>pvm_name</code> identifies the PVM used in this rollup. It is useful to have here so we can check that the proof provided in a refutation is of the correct kind.</li></ul><ul><li><code>dissection</code>, a list of states with tick counts. The current player will specify, in the next move, a tick count that indicates the last of these states that she agrees with.</li></ul><p>Invariants: -----------</p><ul><li><code>dissection</code> must contain at least 3 values</li><li>the first state hash value in <code>dissection</code> must not be <code>None</code></li><li><code>inbox_snapshot</code> never changes once the game is created</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-opponent"><a href="#val-opponent" class="anchor"></a><code><span><span class="keyword">val</span> opponent : <span><a href="#type-player">player</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-player">player</a></span></code></div><div class="spec-doc"><p>Return the other player</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-encoding"><a href="#val-encoding" class="anchor"></a><code><span><span class="keyword">val</span> encoding : <span><a href="#type-t">t</a> <a href="../../Tezos_protocol_environment_014_PtKathma/Data_encoding/index.html#type-t">Tezos_protocol_environment_014_PtKathma.Data_encoding.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_dissection"><a href="#val-pp_dissection" class="anchor"></a><code><span><span class="keyword">val</span> pp_dissection : 
  <span><a href="../../Tezos_protocol_environment_014_PtKathma/Format/index.html#type-formatter">Tezos_protocol_environment_014_PtKathma.Format.formatter</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><a href="../Sc_rollup_repr/State_hash/index.html#type-t">Sc_rollup_repr.State_hash.t</a> option</span> * <a href="../Sc_rollup_tick_repr/index.html#type-t">Sc_rollup_tick_repr.t</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span><span class="keyword">val</span> pp : <span><a href="../../Tezos_protocol_environment_014_PtKathma/Format/index.html#type-formatter">Tezos_protocol_environment_014_PtKathma.Format.formatter</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div></details></div><div class="odoc-spec"><div class="spec module anchored" id="module-Index"><a href="#module-Index" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Index/index.html">Index</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-initial"><a href="#val-initial" class="anchor"></a><code><span><span class="keyword">val</span> initial : 
  <span><a href="../Sc_rollup_inbox_repr/index.html#type-t">Sc_rollup_inbox_repr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">pvm_name</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">parent</span>:<a href="../Sc_rollup_commitment_repr/index.html#type-t">Sc_rollup_commitment_repr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">child</span>:<a href="../Sc_rollup_commitment_repr/index.html#type-t">Sc_rollup_commitment_repr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">refuter</span>:<a href="../Sc_rollup_repr/Staker/index.html#type-t">Sc_rollup_repr.Staker.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">defender</span>:<a href="../Sc_rollup_repr/Staker/index.html#type-t">Sc_rollup_repr.Staker.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>To begin a game, first the conflict point in the commit tree is found, and then this function is applied.</p><p><code>initial inbox parent child refuter defender</code> will construct an initial game where <code>refuter</code> is next to play. The game has <code>dissection</code> with three states:</p><ul><li>firstly, the state (with tick zero) of <code>parent</code>, the commitment that both stakers agree on.</li></ul><ul><li>secondly, the state and tick count of <code>child</code>, the commitment that <code>defender</code> has staked on.</li></ul><ul><li>thirdly, a <code>None</code> state which is a single tick after the <code>child</code> commitment. This represents the claim, implicit in the commitment, that the state given is blocked.</li></ul><p>This gives <code>refuter</code> a binary choice: she can refute the commit itself by providing a new dissection between the two committed states, or she can refute the claim that the <code>child</code> commit is a blocked state by immediately providing a proof of a single tick increment from that state to its successor.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-step"><a href="#type-step" class="anchor"></a><code><span><span class="keyword">type</span> step</span><span> = </span></code><ol><li id="type-step.Dissection" class="def variant constructor anchored"><a href="#type-step.Dissection" class="anchor"></a><code><span>| </span><span><span class="constructor">Dissection</span> <span class="keyword">of</span> <span><span>(<span><a href="../Sc_rollup_repr/State_hash/index.html#type-t">Sc_rollup_repr.State_hash.t</a> option</span> * <a href="../Sc_rollup_tick_repr/index.html#type-t">Sc_rollup_tick_repr.t</a>)</span> list</span></span></code></li><li id="type-step.Proof" class="def variant constructor anchored"><a href="#type-step.Proof" class="anchor"></a><code><span>| </span><span><span class="constructor">Proof</span> <span class="keyword">of</span> <a href="../Sc_rollup_proof_repr/index.html#type-t">Sc_rollup_proof_repr.t</a></span></code></li></ol></div><div class="spec-doc"><p>A <code>step</code> in the game is either a new dissection (if there are intermediate ticks remaining to put in it) or a proof.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-refutation"><a href="#type-refutation" class="anchor"></a><code><span><span class="keyword">type</span> refutation</span><span> = </span><span>{</span></code><ol><li id="type-refutation.choice" class="def record field anchored"><a href="#type-refutation.choice" class="anchor"></a><code><span>choice : <a href="../Sc_rollup_tick_repr/index.html#type-t">Sc_rollup_tick_repr.t</a>;</span></code></li><li id="type-refutation.step" class="def record field anchored"><a href="#type-refutation.step" class="anchor"></a><code><span>step : <a href="#type-step">step</a>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>A <code>refutation</code> is a move in the game. <code>choice</code> is the final tick in the current dissection at which the two players agree.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_refutation"><a href="#val-pp_refutation" class="anchor"></a><code><span><span class="keyword">val</span> pp_refutation : 
  <span><a href="../../Tezos_protocol_environment_014_PtKathma/Format/index.html#type-formatter">Tezos_protocol_environment_014_PtKathma.Format.formatter</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-refutation">refutation</a> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-refutation_encoding"><a href="#val-refutation_encoding" class="anchor"></a><code><span><span class="keyword">val</span> refutation_encoding : 
  <span><a href="#type-refutation">refutation</a> <a href="../../Tezos_protocol_environment_014_PtKathma/Data_encoding/index.html#type-t">Tezos_protocol_environment_014_PtKathma.Data_encoding.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-reason"><a href="#type-reason" class="anchor"></a><code><span><span class="keyword">type</span> reason</span><span> = </span></code><ol><li id="type-reason.Conflict_resolved" class="def variant constructor anchored"><a href="#type-reason.Conflict_resolved" class="anchor"></a><code><span>| </span><span><span class="constructor">Conflict_resolved</span></span></code></li><li id="type-reason.Invalid_move" class="def variant constructor anchored"><a href="#type-reason.Invalid_move" class="anchor"></a><code><span>| </span><span><span class="constructor">Invalid_move</span> <span class="keyword">of</span> string</span></code></li><li id="type-reason.Timeout" class="def variant constructor anchored"><a href="#type-reason.Timeout" class="anchor"></a><code><span>| </span><span><span class="constructor">Timeout</span></span></code></li></ol></div><div class="spec-doc"><p>A game ends for one of three reasons: the conflict has been resolved via a proof, a player has been timed out, or a player has forfeited because of attempting to make an invalid move.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_reason"><a href="#val-pp_reason" class="anchor"></a><code><span><span class="keyword">val</span> pp_reason : 
  <span><a href="../../Tezos_protocol_environment_014_PtKathma/Format/index.html#type-formatter">Tezos_protocol_environment_014_PtKathma.Format.formatter</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-reason">reason</a> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-reason_encoding"><a href="#val-reason_encoding" class="anchor"></a><code><span><span class="keyword">val</span> reason_encoding : 
  <span><a href="#type-reason">reason</a> <a href="../../Tezos_protocol_environment_014_PtKathma/Data_encoding/index.html#type-t">Tezos_protocol_environment_014_PtKathma.Data_encoding.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-status"><a href="#type-status" class="anchor"></a><code><span><span class="keyword">type</span> status</span><span> = </span></code><ol><li id="type-status.Ongoing" class="def variant constructor anchored"><a href="#type-status.Ongoing" class="anchor"></a><code><span>| </span><span><span class="constructor">Ongoing</span></span></code></li><li id="type-status.Ended" class="def variant constructor anchored"><a href="#type-status.Ended" class="anchor"></a><code><span>| </span><span><span class="constructor">Ended</span> <span class="keyword">of</span> <a href="#type-reason">reason</a> * <a href="../Sc_rollup_repr/Staker/index.html#type-t">Sc_rollup_repr.Staker.t</a></span></code></li></ol></div><div class="spec-doc"><p>A type that represents the current game status in a way that is useful to the outside world (using actual <code>Staker.t</code> values instead of the internal <code>player</code> type).</p><p>The <code>Staker.t</code> in the <code>Ended</code> case is the loser of the game: the staker who will have their stake slashed.</p><p>Used in operation result types.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_status"><a href="#val-pp_status" class="anchor"></a><code><span><span class="keyword">val</span> pp_status : 
  <span><a href="../../Tezos_protocol_environment_014_PtKathma/Format/index.html#type-formatter">Tezos_protocol_environment_014_PtKathma.Format.formatter</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-status">status</a> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-status_encoding"><a href="#val-status_encoding" class="anchor"></a><code><span><span class="keyword">val</span> status_encoding : 
  <span><a href="#type-status">status</a> <a href="../../Tezos_protocol_environment_014_PtKathma/Data_encoding/index.html#type-t">Tezos_protocol_environment_014_PtKathma.Data_encoding.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-outcome"><a href="#type-outcome" class="anchor"></a><code><span><span class="keyword">type</span> outcome</span><span> = </span><span>{</span></code><ol><li id="type-outcome.loser" class="def record field anchored"><a href="#type-outcome.loser" class="anchor"></a><code><span>loser : <a href="#type-player">player</a>;</span></code></li><li id="type-outcome.reason" class="def record field anchored"><a href="#type-outcome.reason" class="anchor"></a><code><span>reason : <a href="#type-reason">reason</a>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>A game ends with a single <code>loser</code> and the <code>reason</code> for the game ending. This type uses <code>Alice</code> or <code>Bob</code> to refer to the players without knowing which stakers they are---so it cannot identify an actual staker who should be punished without the associated game index.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_outcome"><a href="#val-pp_outcome" class="anchor"></a><code><span><span class="keyword">val</span> pp_outcome : 
  <span><a href="../../Tezos_protocol_environment_014_PtKathma/Format/index.html#type-formatter">Tezos_protocol_environment_014_PtKathma.Format.formatter</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-outcome">outcome</a> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-outcome_encoding"><a href="#val-outcome_encoding" class="anchor"></a><code><span><span class="keyword">val</span> outcome_encoding : 
  <span><a href="#type-outcome">outcome</a> <a href="../../Tezos_protocol_environment_014_PtKathma/Data_encoding/index.html#type-t">Tezos_protocol_environment_014_PtKathma.Data_encoding.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-find_choice"><a href="#val-find_choice" class="anchor"></a><code><span><span class="keyword">val</span> find_choice : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sc_rollup_tick_repr/index.html#type-t">Sc_rollup_tick_repr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><a href="../Sc_rollup_repr/State_hash/index.html#type-t">Sc_rollup_repr.State_hash.t</a> option</span>
   * <a href="../Sc_rollup_tick_repr/index.html#type-t">Sc_rollup_tick_repr.t</a>
   * <span><a href="../Sc_rollup_repr/State_hash/index.html#type-t">Sc_rollup_repr.State_hash.t</a> option</span>
   * <a href="../Sc_rollup_tick_repr/index.html#type-t">Sc_rollup_tick_repr.t</a>,
    <a href="../../Tezos_protocol_environment_014_PtKathma/Error_monad/index.html#type-error">Tezos_protocol_environment_014_PtKathma.Error_monad.error</a>)</span>
    <a href="../../Tezos_protocol_environment_014_PtKathma/Pervasives/index.html#type-result">Tezos_protocol_environment_014_PtKathma.Pervasives.result</a></span>
    <a href="../../Tezos_protocol_environment_014_PtKathma/Lwt/index.html#type-t">Tezos_protocol_environment_014_PtKathma.Lwt.t</a></span></span></code></div><div class="spec-doc"><p>Checks that the tick count chosen by the current move is one of the ones in the current dissection. Returns a tuple containing the current dissection interval (including the two states) between this tick and the next.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-check_dissection"><a href="#val-check_dissection" class="anchor"></a><code><span><span class="keyword">val</span> check_dissection : 
  <span><span><a href="../Sc_rollup_repr/State_hash/index.html#type-t">Sc_rollup_repr.State_hash.t</a> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sc_rollup_tick_repr/index.html#type-t">Sc_rollup_tick_repr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../Sc_rollup_repr/State_hash/index.html#type-t">Sc_rollup_repr.State_hash.t</a> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sc_rollup_tick_repr/index.html#type-t">Sc_rollup_tick_repr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><a href="../Sc_rollup_repr/State_hash/index.html#type-t">Sc_rollup_repr.State_hash.t</a> option</span> * <a href="../Sc_rollup_tick_repr/index.html#type-t">Sc_rollup_tick_repr.t</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(unit, <a href="../../Tezos_protocol_environment_014_PtKathma/Error_monad/index.html#type-error">Tezos_protocol_environment_014_PtKathma.Error_monad.error</a>)</span>
    <a href="../../Tezos_protocol_environment_014_PtKathma/Pervasives/index.html#type-result">Tezos_protocol_environment_014_PtKathma.Pervasives.result</a></span>
    <a href="../../Tezos_protocol_environment_014_PtKathma/Lwt/index.html#type-t">Tezos_protocol_environment_014_PtKathma.Lwt.t</a></span></span></code></div><div class="spec-doc"><p>We check firstly that <code>dissection</code> is the correct length. It must be 32 values long, unless the distance between <code>start_tick</code> and <code>stop_tick</code> is too small to make this possible, in which case it should be as long as possible. (If the distance is one we fail immediately as there is no possible legal dissection).</p><p>Then we check that <code>dissection</code> starts at the correct tick and state, and that it ends at the correct tick and with a different state to the current dissection.</p><p>Finally, we check that <code>dissection</code> is well formed: it has correctly ordered the ticks, and it begins with a real hash of the form <code>Some
    s</code> not a <code>None</code> state. Note that we have to allow the possibility of multiple <code>None</code> states because the restrictions on dissection shape (which are necessary to prevent a 'linear-time game' attack) will mean that sometimes the honest play is a dissection with multiple <code>None</code> states.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-play"><a href="#val-play" class="anchor"></a><code><span><span class="keyword">val</span> play : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-refutation">refutation</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="#type-outcome">outcome</a>, <a href="#type-t">t</a>)</span> <a href="../../Tezos_protocol_environment_014_PtKathma/Either/index.html#type-t">Tezos_protocol_environment_014_PtKathma.Either.t</a></span>
    <a href="../../Tezos_protocol_environment_014_PtKathma/Lwt/index.html#type-t">Tezos_protocol_environment_014_PtKathma.Lwt.t</a></span></span></code></div><div class="spec-doc"><p>Applies the move <code>refutation</code> to the game. Checks the move is valid and returns an <code>Invalid_move</code> outcome if not.</p><p>In the case of the game continuing, this swaps the current player and updates the <code>dissection</code>. In the case of a <code>Proof</code> being provided this returns an <code>outcome</code>.</p></div></div></div></body></html>
