<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Sc_rollup_refutation_storage (tezos-protocol-014-PtKathma.Tezos_raw_protocol_014_PtKathma.Sc_rollup_refutation_storage)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">tezos-protocol-014-PtKathma</a> &#x00BB; <a href="../index.html">Tezos_raw_protocol_014_PtKathma</a> &#x00BB; Sc_rollup_refutation_storage</nav><header class="odoc-preamble"><h1>Module <code><span>Tezos_raw_protocol_014_PtKathma.Sc_rollup_refutation_storage</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec module anchored" id="module-Commitment_hash"><a href="#module-Commitment_hash" class="anchor"></a><code><span><span class="keyword">module</span> Commitment_hash</span><span> = <a href="../Sc_rollup_commitment_repr/Hash/index.html">Sc_rollup_commitment_repr.Hash</a></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-point"><a href="#type-point" class="anchor"></a><code><span><span class="keyword">type</span> point</span><span> = </span><span>{</span></code><ol><li id="type-point.commitment" class="def record field anchored"><a href="#type-point.commitment" class="anchor"></a><code><span>commitment : <a href="../Sc_rollup_commitment_repr/index.html#type-t">Sc_rollup_commitment_repr.t</a>;</span></code></li><li id="type-point.hash" class="def record field anchored"><a href="#type-point.hash" class="anchor"></a><code><span>hash : <a href="../Sc_rollup_commitment_repr/Hash/index.html#type-t">Commitment_hash.t</a>;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-conflict_point"><a href="#type-conflict_point" class="anchor"></a><code><span><span class="keyword">type</span> conflict_point</span><span> = <a href="#type-point">point</a> * <a href="#type-point">point</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-game_move"><a href="#val-game_move" class="anchor"></a><code><span><span class="keyword">val</span> game_move : 
  <span><a href="../Raw_context/index.html#type-t">Raw_context.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sc_rollup_repr/index.html#type-t">Sc_rollup_repr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">player</span>:<a href="../Sc_rollup_repr/Staker/index.html#type-t">Sc_rollup_repr.Staker.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">opponent</span>:<a href="../Sc_rollup_repr/Staker/index.html#type-t">Sc_rollup_repr.Staker.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sc_rollup_game_repr/index.html#type-refutation">Sc_rollup_game_repr.refutation</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">is_opening_move</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><a href="../Sc_rollup_game_repr/index.html#type-outcome">Sc_rollup_game_repr.outcome</a> option</span> * <a href="../Raw_context/index.html#type-t">Raw_context.t</a>)</span>
    <a href="../../Tezos_protocol_environment_014_PtKathma/Error_monad/index.html#type-tzresult">Tezos_protocol_environment_014_PtKathma.Error_monad.tzresult</a></span>
    <a href="../../Tezos_protocol_environment_014_PtKathma/Lwt/index.html#type-t">Tezos_protocol_environment_014_PtKathma.Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>game_move ctxt rollup player opponent refutation is_opening_move</code> handles the storage-side logic for when one of the players makes a move in the game. It initializes the game if <code>is_opening_move</code> is <code>true</code>. Otherwise, it checks the game already exists. Then it checks that <code>player</code> is the player whose turn it is; if so, it applies <code>refutation</code> using the <code>play</code> function.</p><p>If the result is a new game, this is stored and the timeout level is updated.</p><p>If the result is an <code>outcome</code>, this will be returned.</p><p>May fail with:</p><ul><li><code>Sc_rollup_does_not_exist</code> if <code>rollup</code> does not exist</li><li><code>Sc_rollup_no_game</code> if <code>is_opening_move</code> is <code>false</code> but the game does not exist</li><li><code>Sc_rollup_game_already_started</code> if <code>is_opening_move</code> is <code>true</code> but the game already exists</li><li><code>Sc_rollup_no_conflict</code> if <code>player</code> is staked on an ancestor of the commitment staked on by <code>opponent</code>, or vice versa</li><li><code>Sc_rollup_not_staked</code> if one of the <code>player</code> or <code>opponent</code> is not actually staked</li><li><code>Sc_rollup_staker_in_game</code> if one of the <code>player</code> or <code>opponent</code> is already playing a game</li><li><code>Sc_rollup_wrong_turn</code> if a player is trying to move out of turn</li></ul><p>The <code>is_opening_move</code> argument is included here to make sure that an operation intended to start a refutation game is never mistaken for an operation to play the second move of the game---this may otherwise happen due to non-deterministic ordering of L1 operations. With the <code>is_opening_move</code> parameter, the worst case is that the operation simply fails. Without it, the operation would be mistaken for an invalid move in the game and the staker would lose their stake!</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-timeout"><a href="#val-timeout" class="anchor"></a><code><span><span class="keyword">val</span> timeout : 
  <span><a href="../Raw_context/index.html#type-t">Raw_context.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sc_rollup_repr/index.html#type-t">Sc_rollup_repr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sc_rollup_game_repr/Index/index.html#type-t">Sc_rollup_game_repr.Index.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="../Sc_rollup_game_repr/index.html#type-outcome">Sc_rollup_game_repr.outcome</a> * <a href="../Raw_context/index.html#type-t">Raw_context.t</a>)</span>
    <a href="../../Tezos_protocol_environment_014_PtKathma/Error_monad/index.html#type-tzresult">Tezos_protocol_environment_014_PtKathma.Error_monad.tzresult</a></span>
    <a href="../../Tezos_protocol_environment_014_PtKathma/Lwt/index.html#type-t">Tezos_protocol_environment_014_PtKathma.Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>timeout ctxt rollup stakers</code> checks that the timeout has elapsed and if this function returns a game outcome that punishes whichever of <code>stakers</code> is supposed to have played a move.</p><p>The timeout period is currently defined in <code>timeout_period_in_blocks</code>. This should become a protocol constant soon.</p><p>May fail with:</p><ul><li><code>Sc_rollup_no_game</code> if the game does not in fact exist</li><li><code>Sc_rollup_timeout_level_not_reached</code> if the player still has time in which to play</li></ul><p>Note: this function takes the two stakers as a pair rather than separate arguments. This reflects the fact that for this function the two players are symmetric. This function will normalize the order of the players if necessary to get a valid game index, so the argument <code>stakers</code> doesn't have to be in normal form.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-apply_outcome"><a href="#val-apply_outcome" class="anchor"></a><code><span><span class="keyword">val</span> apply_outcome : 
  <span><a href="../Raw_context/index.html#type-t">Raw_context.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sc_rollup_repr/index.html#type-t">Sc_rollup_repr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sc_rollup_game_repr/Index/index.html#type-t">Sc_rollup_game_repr.Index.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sc_rollup_game_repr/index.html#type-outcome">Sc_rollup_game_repr.outcome</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="../Sc_rollup_game_repr/index.html#type-status">Sc_rollup_game_repr.status</a> * <a href="../Raw_context/index.html#type-t">Raw_context.t</a> * <a href="../Receipt_repr/index.html#type-balance_updates">Receipt_repr.balance_updates</a>)</span>
    <a href="../../Tezos_protocol_environment_014_PtKathma/Error_monad/index.html#type-tzresult">Tezos_protocol_environment_014_PtKathma.Error_monad.tzresult</a></span>
    <a href="../../Tezos_protocol_environment_014_PtKathma/Lwt/index.html#type-t">Tezos_protocol_environment_014_PtKathma.Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>apply_outcome ctxt rollup outcome</code> takes an <code>outcome</code> produced by <code>timeout</code> or <code>game_move</code> and performs the necessary end-of-game cleanup: remove the game itself from the store and punish the losing player by removing their stake.</p><p>It also translates the 'internal' type to represent the end of the game, <code>outcome</code>, into the <code>status</code> type that makes sense to the outside world.</p><p>This is mostly just calling <code>remove_staker</code>, so it can fail with the same errors as that. However, if it is called on an <code>outcome</code> generated by <code>game_move</code> or <code>timeout</code> it should not fail.</p><p>Note: this function takes the two stakers as a pair rather than separate arguments. This reflects the fact that for this function the two players are symmetric. This function will normalize the order of the players if necessary to get a valid game index, so the argument <code>stakers</code> doesn't have to be in normal form.</p></div></div></div></body></html>
