<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>S (tezos-protocol-014-PtKathma.Tezos_raw_protocol_014_PtKathma.Sc_rollup_PVM_sem.S)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">tezos-protocol-014-PtKathma</a> &#x00BB; <a href="../../index.html">Tezos_raw_protocol_014_PtKathma</a> &#x00BB; <a href="../index.html">Sc_rollup_PVM_sem</a> &#x00BB; S</nav><header class="odoc-preamble"><h1>Module type <code><span>Sc_rollup_PVM_sem.S</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-state"><a href="#type-state" class="anchor"></a><code><span><span class="keyword">type</span> state</span></code></div><div class="spec-doc"><p>The state of the PVM denotes a state of the rollup.</p><p>We classify states into two categories: &quot;internal states&quot; do not require any external information to be executed while &quot;input states&quot; are waiting for some information from the inbox to be executable.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-context"><a href="#type-context" class="anchor"></a><code><span><span class="keyword">type</span> context</span></code></div><div class="spec-doc"><p>A state is initialized in a given context. A <code>context</code> represents the executable environment needed by the state to exist. Typically, the rollup node storage can be part of this context to allow the PVM state to be persistent.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-hash"><a href="#type-hash" class="anchor"></a><code><span><span class="keyword">type</span> hash</span><span> = <a href="../../Sc_rollup_repr/State_hash/index.html#type-t">Sc_rollup_repr.State_hash.t</a></span></code></div><div class="spec-doc"><p>A <code>hash</code> characterizes the contents of a state.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-proof"><a href="#type-proof" class="anchor"></a><code><span><span class="keyword">type</span> proof</span></code></div><div class="spec-doc"><p>During interactive refutation games, a player may need to provide a proof that a given execution step is valid. The PVM implementation is responsible for ensuring that this proof type has the correct semantics:</p><p>A proof <code>p</code> has four parameters:</p><p><code>start_hash := proof_start_state p</code> <code>stop_hash := proof_stop_state p</code> <code>input_requested := proof_input_requested p</code> <code>input_given := proof_input_given p</code></p><p>The following predicate must hold of a valid proof:</p><p><code>exists start_state, stop_state.
               (state_hash start_state == start_hash)
           AND (Option.map state_hash stop_state == stop_hash)
           AND (is_input_state start_state == input_requested)
           AND (match (input_given, input_requested) with
                | (None, No_input_required) -&gt; eval start_state == stop_state
                | (None, Initial) -&gt; stop_state == None
                | (None, First_after (l, n)) -&gt; stop_state == None
                | (Some input, No_input_required) -&gt; true
                | (Some input, Initial) -&gt;
                    set_input input_given start_state == stop_state
                | (Some input, First_after (l, n)) -&gt;
                    set_input input_given start_state == stop_state)</code></p><p>In natural language---the two hash parameters <code>start_hash</code> and <code>stop_hash</code> must have actual <code>state</code> values (or possibly <code>None</code> in the case of <code>stop_hash</code>) of which they are the hashes. The <code>input_requested</code> parameter must be the correct request from the <code>start_hash</code>, given according to <code>is_input_state</code>. Finally there are four possibilities of <code>input_requested</code> and <code>input_given</code>.</p><ul><li>if no input is required, or given, the proof is a simple <code>eval</code> step ;</li><li>if input was required but not given, the <code>stop_hash</code> must be <code>None</code> (the machine is blocked) ;</li><li>if no input was required but some was given, this makes no sense and it doesn't matter if the proof is valid or invalid (this case will be ruled out by the inbox proof anyway) ;</li><li>finally, if input was required and given, the proof is a <code>set_input</code> step.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-proof_encoding"><a href="#val-proof_encoding" class="anchor"></a><code><span><span class="keyword">val</span> proof_encoding : 
  <span><a href="#type-proof">proof</a> <a href="../../../Tezos_protocol_environment_014_PtKathma/Data_encoding/index.html#type-t">Tezos_protocol_environment_014_PtKathma.Data_encoding.t</a></span></span></code></div><div class="spec-doc"><p><code>proof</code>s are embedded in L1 refutation game operations using <code>proof_encoding</code>. Given that the size of L1 operations are limited, it is of *critical* importance to make sure that no execution step of the PVM can generate proofs that do not fit in L1 operations when encoded. If such a proof existed, the rollup could get stuck.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-proof_start_state"><a href="#val-proof_start_state" class="anchor"></a><code><span><span class="keyword">val</span> proof_start_state : <span><a href="#type-proof">proof</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-hash">hash</a></span></code></div><div class="spec-doc"><p><code>proof_start_state proof</code> returns the initial state hash of the <code>proof</code> execution step.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-proof_stop_state"><a href="#val-proof_stop_state" class="anchor"></a><code><span><span class="keyword">val</span> proof_stop_state : <span><a href="#type-proof">proof</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-hash">hash</a> option</span></span></code></div><div class="spec-doc"><p><code>proof_stop_state proof</code> returns the final state hash of the <code>proof</code> execution step.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-proof_input_requested"><a href="#val-proof_input_requested" class="anchor"></a><code><span><span class="keyword">val</span> proof_input_requested : <span><a href="#type-proof">proof</a> <span class="arrow">&#45;&gt;</span></span> <a href="../index.html#type-input_request">input_request</a></span></code></div><div class="spec-doc"><p><code>proof_input_requested proof</code> returns the <code>input_request</code> status of the start state of the proof, as given by <code>is_input_state</code>. This must match with the inbox proof to complete a valid refutation game proof.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-proof_input_given"><a href="#val-proof_input_given" class="anchor"></a><code><span><span class="keyword">val</span> proof_input_given : <span><a href="#type-proof">proof</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-input">input</a> option</span></span></code></div><div class="spec-doc"><p><code>proof_input_given proof</code> returns the <code>input</code>, if any, provided to the start state of the proof using the <code>set_input</code> function. If <code>None</code>, the proof is an <code>eval</code> step instead, or the machine is blocked because the inbox is fully read. This must match with the inbox proof to complete a valid refutation game proof.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-state_hash"><a href="#val-state_hash" class="anchor"></a><code><span><span class="keyword">val</span> state_hash : <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-hash">hash</a> <a href="../../../Tezos_protocol_environment_014_PtKathma/Lwt/index.html#type-t">Tezos_protocol_environment_014_PtKathma.Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>state_hash state</code> returns a compressed representation of <code>state</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-initial_state"><a href="#val-initial_state" class="anchor"></a><code><span><span class="keyword">val</span> initial_state : 
  <span><a href="#type-context">context</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-state">state</a> <a href="../../../Tezos_protocol_environment_014_PtKathma/Lwt/index.html#type-t">Tezos_protocol_environment_014_PtKathma.Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>initial_state context boot_sector</code> is the initial state of the PVM, which is a pure function of <code>boot_sector</code>.</p><p>The <code>context</code> argument is required for technical reasons and does not impact the result.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_input_state"><a href="#val-is_input_state" class="anchor"></a><code><span><span class="keyword">val</span> is_input_state : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../index.html#type-input_request">input_request</a> <a href="../../../Tezos_protocol_environment_014_PtKathma/Lwt/index.html#type-t">Tezos_protocol_environment_014_PtKathma.Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>is_input_state state</code> returns the input expectations of the <code>state</code>---does it need input, and if so, how far through the inbox has it read so far?</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_input"><a href="#val-set_input" class="anchor"></a><code><span><span class="keyword">val</span> set_input : 
  <span><a href="../index.html#type-input">input</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-state">state</a> <a href="../../../Tezos_protocol_environment_014_PtKathma/Lwt/index.html#type-t">Tezos_protocol_environment_014_PtKathma.Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>set_input (level, n, msg) state</code> sets <code>msg</code> in <code>state</code> as the next message to be processed. This input message is assumed to be the number <code>n</code> in the inbox messages at the given <code>level</code>. The input message must be the message next to the previous message processed by the rollup.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-eval"><a href="#val-eval" class="anchor"></a><code><span><span class="keyword">val</span> eval : <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-state">state</a> <a href="../../../Tezos_protocol_environment_014_PtKathma/Lwt/index.html#type-t">Tezos_protocol_environment_014_PtKathma.Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>eval s0</code> returns a state <code>s1</code> resulting from the execution of an atomic step of the rollup at state <code>s0</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-verify_proof"><a href="#val-verify_proof" class="anchor"></a><code><span><span class="keyword">val</span> verify_proof : <span><a href="#type-proof">proof</a> <span class="arrow">&#45;&gt;</span></span> <span>bool <a href="../../../Tezos_protocol_environment_014_PtKathma/Lwt/index.html#type-t">Tezos_protocol_environment_014_PtKathma.Lwt.t</a></span></span></code></div><div class="spec-doc"><p>This checks the proof. See the doc-string for the <code>proof</code> type.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-produce_proof"><a href="#val-produce_proof" class="anchor"></a><code><span><span class="keyword">val</span> produce_proof : 
  <span><a href="#type-context">context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../index.html#type-input">input</a> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="#type-proof">proof</a>, <a href="../../../Tezos_protocol_environment_014_PtKathma/Error_monad/index.html#type-error">Tezos_protocol_environment_014_PtKathma.Error_monad.error</a>)</span>
    <a href="../../../Tezos_protocol_environment_014_PtKathma/Pervasives/index.html#type-result">Tezos_protocol_environment_014_PtKathma.Pervasives.result</a></span>
    <a href="../../../Tezos_protocol_environment_014_PtKathma/Lwt/index.html#type-t">Tezos_protocol_environment_014_PtKathma.Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>produce_proof ctxt input_given state</code> should return a <code>proof</code> for the PVM step starting from <code>state</code>, if possible. This may fail for a few reasons:</p><ul><li>the <code>input_given</code> doesn't match the expectations of <code>state</code> ;</li><li>the <code>context</code> for this instance of the PVM doesn't have access to enough of the <code>state</code> to build the proof.</li></ul></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-output_proof"><a href="#type-output_proof" class="anchor"></a><code><span><span class="keyword">type</span> output_proof</span></code></div><div class="spec-doc"><p>The following type is inhabited by the proofs that a given <code>output</code> is part of the outbox of a given <code>state</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-output_proof_encoding"><a href="#val-output_proof_encoding" class="anchor"></a><code><span><span class="keyword">val</span> output_proof_encoding : 
  <span><a href="#type-output_proof">output_proof</a> <a href="../../../Tezos_protocol_environment_014_PtKathma/Data_encoding/index.html#type-t">Tezos_protocol_environment_014_PtKathma.Data_encoding.t</a></span></span></code></div><div class="spec-doc"><p><code>output_proof_encoding</code> encoding value for <code>output_proof</code>s.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-output_of_output_proof"><a href="#val-output_of_output_proof" class="anchor"></a><code><span><span class="keyword">val</span> output_of_output_proof : <span><a href="#type-output_proof">output_proof</a> <span class="arrow">&#45;&gt;</span></span> <a href="../index.html#type-output">output</a></span></code></div><div class="spec-doc"><p><code>output_of_output_proof proof</code> returns the <code>output</code> that is referred to in <code>proof</code>'s statement.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-state_of_output_proof"><a href="#val-state_of_output_proof" class="anchor"></a><code><span><span class="keyword">val</span> state_of_output_proof : <span><a href="#type-output_proof">output_proof</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-hash">hash</a></span></code></div><div class="spec-doc"><p><code>state_of_output_proof proof</code> returns the <code>state</code> hash that is referred to in <code>proof</code>'s statement.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-verify_output_proof"><a href="#val-verify_output_proof" class="anchor"></a><code><span><span class="keyword">val</span> verify_output_proof : 
  <span><a href="#type-output_proof">output_proof</a> <span class="arrow">&#45;&gt;</span></span>
  <span>bool <a href="../../../Tezos_protocol_environment_014_PtKathma/Lwt/index.html#type-t">Tezos_protocol_environment_014_PtKathma.Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>verify_output_proof output_proof</code> returns <code>true</code> iff <code>proof</code> is a valid witness that its <code>output</code> is part of its <code>state</code>'s outbox.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-produce_output_proof"><a href="#val-produce_output_proof" class="anchor"></a><code><span><span class="keyword">val</span> produce_output_proof : 
  <span><a href="#type-context">context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../index.html#type-output">output</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="#type-output_proof">output_proof</a>, <a href="../../../Tezos_protocol_environment_014_PtKathma/Error_monad/index.html#type-error">Tezos_protocol_environment_014_PtKathma.Error_monad.error</a>)</span>
    <a href="../../../Tezos_protocol_environment_014_PtKathma/Pervasives/index.html#type-result">Tezos_protocol_environment_014_PtKathma.Pervasives.result</a></span>
    <a href="../../../Tezos_protocol_environment_014_PtKathma/Lwt/index.html#type-t">Tezos_protocol_environment_014_PtKathma.Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>produce_output_proof ctxt state output</code> returns a proof that witnesses the fact that <code>output</code> is part of <code>state</code>'s outbox.</p></div></div></div></body></html>
