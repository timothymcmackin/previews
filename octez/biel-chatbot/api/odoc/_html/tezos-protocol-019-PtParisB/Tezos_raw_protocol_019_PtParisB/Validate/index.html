<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Validate (tezos-protocol-019-PtParisB.Tezos_raw_protocol_019_PtParisB.Validate)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">tezos-protocol-019-PtParisB</a> &#x00BB; <a href="../index.html">Tezos_raw_protocol_019_PtParisB</a> &#x00BB; Validate</nav><header class="odoc-preamble"><h1>Module <code><span>Tezos_raw_protocol_019_PtParisB.Validate</span></code></h1><p>This module provides functions pertaining to the validation of blocks and operations. Most elements in this module are either used or wrapped in the <a href="../Main/index.html"><code>Main</code></a> module (though some of them are also directly used by the plugin).</p><p>The purpose of validation is to decide quickly whether a block or an operation is valid, with minimal computations and without writing anything in the storage. A block is considered valid if it can be applied without failure (see <a href="../Apply/index.html"><code>Apply</code></a>). An operation is valid if it can be safely included in a block without causing it to fail. Therefore, the current module is responsible for ensuring that calling functions from <a href="../Apply/index.html"><code>Apply</code></a> on validated blocks and operations will not fail.</p></header><nav class="odoc-toc"><ul><li><a href="#block-validation">Block validation</a></li><li><a href="#validation-state">Validation state</a></li><li><a href="#operation-validation">Operation validation</a></li></ul></nav><div class="odoc-content"><h3 id="block-validation"><a href="#block-validation" class="anchor"></a>Block validation</h3><p>The process of validation of a block may be started by calling one of the following functions, depending on the circumstances (aka mode):</p><ul><li><code>begin_application</code> is used for the validation of a preexisting block, typically received through the network, and usually in preparation for its future application.</li></ul><ul><li><code>begin_partial_validation</code> is used to quickly but partially validate an existing block. It is intended for quickly assessing a series of blocks in an alternate branch (multipass validation). For this reason, in this mode, the initial <a href="../Alpha_context/index.html#type-t"><code>Alpha_context.t</code></a> may be based on an ancestor block of the block to validate, instead of necessarily its predecessor as in other modes.</li></ul><ul><li><code>begin_full_construction</code> is used for the construction of a new block, typically by a baker.</li></ul><p>Then, <code>validate_operation</code> should be called on every operation in the block (in order of validation pass: see <a href="../Operation_repr/index.html#val-acceptable_pass"><code>Operation_repr.acceptable_pass</code></a>). Lastly, <code>finalize_block</code> performs final checks on the block; if this function succeeds then the block is valid.</p><h3 id="validation-state"><a href="#validation-state" class="anchor"></a>Validation state</h3><p>The process of block validation relies on a <code>validation_state</code> transmitted throughout the aforementioned function calls. More precisely, this immutable functional state is initialized by the <code>begin_...</code> functions, read and updated by <code>validate_operation</code> (as in, a slightly different <code>validation_state</code> is returned), and required by <code>finalize_block</code>. It consists in three fields:</p><ul><li><code>info</code> contains static information required by <code>validate_operation</code> and <code>finalize_block</code>, notably the initial <a href="../Alpha_context/index.html#type-t"><code>Alpha_context.t</code></a>. It is fully filled in by the <code>begin_...</code> functions, then only read, never updated.</li></ul><ul><li><code>operation_conflict_state</code> keeps track of every validated operation in the block, so that it can detect any conflict between operations (e.g. two manager operations from the same source). Consequently, it is both filled in and read by <code>validate_operation</code>, but not used at all by <code>finalize_block</code>.</li></ul><ul><li><code>block_state</code> registers global block metrics such as total gas used or attestation power. It is filled in by <code>validate_operation</code>, which also uses it, e.g. to immediately return an error if the block gas limit is exceeded. It is also essential to several checks in <code>finalize_block</code>.</li></ul><p>The immutability of the <code>validation_state</code> allows the caller to pause, replay, or backtrack throughout the steps of the validation process.</p><h3 id="operation-validation"><a href="#operation-validation" class="anchor"></a>Operation validation</h3><p>Operations may be validated either as part of the validation of a block in which they are included (see above), or on their own:</p><ul><li><code>begin_partial_construction</code> allows to initialize a <code>validation_state</code> for the validation of operations outside of the process of validation of a block. It is intended for mempools (see <a href="../Mempool_validation/index.html"><code>Mempool_validation</code></a>) and for some RPCs. The global block properties such as total block gas and attestation power are not checked. Calling <code>finalize_block</code> on such a <code>validation_state</code> does not make much sense and simply returns unit.</li></ul><ul><li><code>begin_no_predecessor_info</code> is a special weaker version of <code>begin_partial_construction</code>: see its own documentation below.</li></ul><p>Even outside of the context of a given block validation, the validation of operations aims at deciding whether they could theoretically be included in a future block. Indeed, for a mempool, this means that they are worth transmitting to a baker and propagating to peers; or for the caller of an RPC, it means that the tested operations may be injected in the node.</p><p>An important property to maintain is that applying (see <a href="../Apply/index.html#val-apply_operation"><code>Apply.apply_operation</code></a>) any subset of validated operations should always succeed, even if they are not applied in the same order as they were validated (as long as the order of application respects the validation passes ordering). In other words, for all operations A and B that have both been validated: if A has an earlier or the same validation pass as B, then applying A then B must succeed; and if B has an earlier or the same validation pass as A, then applying B then A must succeed. Some restrictions, such as one-operation-per-manager-per-block (1M), have been introduced to preserve this property, and are enforced with the help of the <code>operation_conflict_state</code>. An important consequence of this property is that a baker may select any subset of validated operations to bake into a new block, which is then guaranteed to be applicable (provided that it verifies some additional global properties such as including enough (pre)attesting power; the baker is responsible for ensuring this).</p><p>For a manager operation, validity is mainly solvability, ie. the operation must be well-formed and we must be able to take its fees. Indeed, this is sufficient for the safe inclusion of the operation in a block: even if there is an error during the subsequent application of the manager operation, this will cause the operation to have no further effects, but won't impact the success of the block's application. The solvability of a manager operation notably requires that it is correctly signed: indeed, we can't take anything from a manager without having checked their signature.</p><p>A non-manager operation is only valid if its effects can be fully applied in an <a href="../Alpha_context/index.html#type-t"><code>Alpha_context.t</code></a> without failure. Indeed, any error during the application of such an operation would cause the whole block to fail; unlike manager operations, there is no notion of failing to have an effect without impacting the application of the whole block. More detailled documentation on checks performed and potential errors can be found in the <code>validate.ml</code> file for some non-manager operations.</p><div class="odoc-spec"><div class="spec type anchored" id="type-info"><a href="#type-info" class="anchor"></a><code><span><span class="keyword">type</span> info</span></code></div><div class="spec-doc"><p>Static information required to validate blocks and operations.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-operation_conflict_state"><a href="#type-operation_conflict_state" class="anchor"></a><code><span><span class="keyword">type</span> operation_conflict_state</span></code></div><div class="spec-doc"><p>State used to keep track of previously validated operations and detect potential conflicts. This state is serializable which allows it to be exchanged with another source. See <a href="../Mempool_validation/index.html"><code>Mempool_validation</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-operation_conflict_state_encoding"><a href="#val-operation_conflict_state_encoding" class="anchor"></a><code><span><span class="keyword">val</span> operation_conflict_state_encoding : 
  <span><a href="#type-operation_conflict_state">operation_conflict_state</a>
    <a href="../../Tezos_protocol_environment_019_PtParisB/Data_encoding/index.html#type-t">Tezos_protocol_environment_019_PtParisB.Data_encoding.t</a></span></span></code></div><div class="spec-doc"><p>Encoding for the <code>operation_conflict_state</code>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-block_state"><a href="#type-block_state" class="anchor"></a><code><span><span class="keyword">type</span> block_state</span></code></div><div class="spec-doc"><p>State used to register global block properties which are relevant to the validity of a block, e.g. the total gas used in the block so far. This state is both used and updated by the <code>validate_operation</code> function, and is also required by <code>finalize_block</code>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-validation_state"><a href="#type-validation_state" class="anchor"></a><code><span><span class="keyword">type</span> validation_state</span><span> = </span><span>{</span></code><ol><li id="type-validation_state.info" class="def record field anchored"><a href="#type-validation_state.info" class="anchor"></a><code><span>info : <a href="#type-info">info</a>;</span></code></li><li id="type-validation_state.operation_state" class="def record field anchored"><a href="#type-validation_state.operation_state" class="anchor"></a><code><span>operation_state : <a href="#type-operation_conflict_state">operation_conflict_state</a>;</span></code></li><li id="type-validation_state.block_state" class="def record field anchored"><a href="#type-validation_state.block_state" class="anchor"></a><code><span>block_state : <a href="#type-block_state">block_state</a>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Validation state (see above).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_initial_ctxt"><a href="#val-get_initial_ctxt" class="anchor"></a><code><span><span class="keyword">val</span> get_initial_ctxt : <span><a href="#type-validation_state">validation_state</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Alpha_context/index.html#type-context">Alpha_context.context</a></span></code></div><div class="spec-doc"><p>Return the context stored in the state.</p><p>Note that this is the context at the beginning of the block / mempool: indeed, it is not modified by <code>validate_operation</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-begin_application"><a href="#val-begin_application" class="anchor"></a><code><span><span class="keyword">val</span> begin_application : 
  <span><a href="../Alpha_context/index.html#type-context">Alpha_context.context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Tezos_protocol_environment_019_PtParisB/Chain_id/index.html#type-t">Tezos_protocol_environment_019_PtParisB.Chain_id.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">predecessor_level</span>:<a href="../Alpha_context/Level/index.html#type-t">Alpha_context.Level.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">predecessor_timestamp</span>:<a href="../../Tezos_protocol_environment_019_PtParisB/Time/index.html#type-t">Tezos_protocol_environment_019_PtParisB.Time.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Alpha_context/Block_header/index.html#type-t">Alpha_context.Block_header.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Alpha_context/Fitness/index.html#type-t">Alpha_context.Fitness.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-validation_state">validation_state</a> <a href="../../Tezos_protocol_environment_019_PtParisB/Error_monad/index.html#type-tzresult">Tezos_protocol_environment_019_PtParisB.Error_monad.tzresult</a></span>
    <a href="../../Tezos_protocol_environment_019_PtParisB/Lwt/index.html#type-t">Tezos_protocol_environment_019_PtParisB.Lwt.t</a></span></span></code></div><div class="spec-doc"><p>Initialize the <a href="#type-validation_state"><code>validation_state</code></a> for the validation of an existing block, usually in preparation for its future application.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-begin_partial_validation"><a href="#val-begin_partial_validation" class="anchor"></a><code><span><span class="keyword">val</span> begin_partial_validation : 
  <span><a href="../Alpha_context/index.html#type-context">Alpha_context.context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Tezos_protocol_environment_019_PtParisB/Chain_id/index.html#type-t">Tezos_protocol_environment_019_PtParisB.Chain_id.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">predecessor_level</span>:<a href="../Alpha_context/Level/index.html#type-t">Alpha_context.Level.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">predecessor_timestamp</span>:<a href="../../Tezos_protocol_environment_019_PtParisB/Time/index.html#type-t">Tezos_protocol_environment_019_PtParisB.Time.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Alpha_context/Block_header/index.html#type-t">Alpha_context.Block_header.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Alpha_context/Fitness/index.html#type-t">Alpha_context.Fitness.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-validation_state">validation_state</a> <a href="../../Tezos_protocol_environment_019_PtParisB/Error_monad/index.html#type-tzresult">Tezos_protocol_environment_019_PtParisB.Error_monad.tzresult</a></span>
    <a href="../../Tezos_protocol_environment_019_PtParisB/Lwt/index.html#type-t">Tezos_protocol_environment_019_PtParisB.Lwt.t</a></span></span></code></div><div class="spec-doc"><p>Initialize the <a href="#type-validation_state"><code>validation_state</code></a> for the partial validation of an existing block.</p><p>The partial validation mode is intended for quickly assessing a series of blocks in a cousin branch (multipass validation). Therefore, it is the only mode in which the given <code>context</code> may be based on any recent ancestor block of the block to validate, instead of only its predecessor (where recent means having a greater level than the <code>last_allowed_fork_level</code> of the current head).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-begin_full_construction"><a href="#val-begin_full_construction" class="anchor"></a><code><span><span class="keyword">val</span> begin_full_construction : 
  <span><a href="../Alpha_context/index.html#type-context">Alpha_context.context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Tezos_protocol_environment_019_PtParisB/Chain_id/index.html#type-t">Tezos_protocol_environment_019_PtParisB.Chain_id.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">predecessor_level</span>:<a href="../Alpha_context/Level/index.html#type-t">Alpha_context.Level.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">predecessor_round</span>:<a href="../Alpha_context/Round/index.html#type-t">Alpha_context.Round.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">predecessor_timestamp</span>:<a href="../../Tezos_protocol_environment_019_PtParisB/Time/index.html#type-t">Tezos_protocol_environment_019_PtParisB.Time.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">predecessor_hash</span>:<a href="../../Tezos_protocol_environment_019_PtParisB/Block_hash/index.html#type-t">Tezos_protocol_environment_019_PtParisB.Block_hash.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Alpha_context/Round/index.html#type-t">Alpha_context.Round.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Alpha_context/Block_header/index.html#type-contents">Alpha_context.Block_header.contents</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-validation_state">validation_state</a> <a href="../../Tezos_protocol_environment_019_PtParisB/Error_monad/index.html#type-tzresult">Tezos_protocol_environment_019_PtParisB.Error_monad.tzresult</a></span>
    <a href="../../Tezos_protocol_environment_019_PtParisB/Lwt/index.html#type-t">Tezos_protocol_environment_019_PtParisB.Lwt.t</a></span></span></code></div><div class="spec-doc"><p>Initialize the <a href="#type-validation_state"><code>validation_state</code></a> for the full construction of a fresh block.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-begin_partial_construction"><a href="#val-begin_partial_construction" class="anchor"></a><code><span><span class="keyword">val</span> begin_partial_construction : 
  <span><a href="../Alpha_context/index.html#type-context">Alpha_context.context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Tezos_protocol_environment_019_PtParisB/Chain_id/index.html#type-t">Tezos_protocol_environment_019_PtParisB.Chain_id.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">predecessor_level</span>:<a href="../Alpha_context/Level/index.html#type-t">Alpha_context.Level.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">predecessor_round</span>:<a href="../Alpha_context/Round/index.html#type-t">Alpha_context.Round.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-validation_state">validation_state</a></span></code></div><div class="spec-doc"><p>Initialize the <a href="#type-validation_state"><code>validation_state</code></a> for the validation of operations outside of the process of validation of a block. The partial construction mode is mainly used to implement the mempool (see <a href="../Mempool_validation/index.html"><code>Mempool_validation</code></a>), but may also be used by some RPCs.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-begin_no_predecessor_info"><a href="#val-begin_no_predecessor_info" class="anchor"></a><code><span><span class="keyword">val</span> begin_no_predecessor_info : 
  <span><a href="../Alpha_context/index.html#type-context">Alpha_context.context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Tezos_protocol_environment_019_PtParisB/Chain_id/index.html#type-t">Tezos_protocol_environment_019_PtParisB.Chain_id.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-validation_state">validation_state</a></span></code></div><div class="spec-doc"><p>Similar to <code>begin_partial_construction</code> but do not require predecessor information that is essential to the validation of preattestation and attestation operations. As a consequence, the validation of these operations will always fail.</p><p>This function is used by the plugin RPC <code>run_operation</code>, which does not support consensus operations anyway.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-validate_operation"><a href="#val-validate_operation" class="anchor"></a><code><span><span class="keyword">val</span> validate_operation : 
  <span><span class="optlabel">?check_signature</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-validation_state">validation_state</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Tezos_protocol_environment_019_PtParisB/Operation_hash/index.html#type-t">Tezos_protocol_environment_019_PtParisB.Operation_hash.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Alpha_context/index.html#type-packed_operation">Alpha_context.packed_operation</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-validation_state">validation_state</a> <a href="../../Tezos_protocol_environment_019_PtParisB/Error_monad/index.html#type-tzresult">Tezos_protocol_environment_019_PtParisB.Error_monad.tzresult</a></span>
    <a href="../../Tezos_protocol_environment_019_PtParisB/Lwt/index.html#type-t">Tezos_protocol_environment_019_PtParisB.Lwt.t</a></span></span></code></div><div class="spec-doc"><p>Check the validity of the given operation and return the updated <a href="#type-validation_state"><code>validation_state</code></a>.</p><p>See the documentation at the top of this module on operation validation.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">check_signature</span> <p>indicates whether the signature check should happen. It defaults to <code>true</code> because the signature needs to be correct for the operation to be valid. This argument exists for special cases where it is acceptable to bypass this check, e.g.:</p><ul><li>A mempool implementation may keep track of operations whose signatures have already been checked: if such an operation needs to be validated again (typically when the head block changes), then the mempool may call <code>validate_operation</code> with <code>check_signature:false</code>.</li></ul><ul><li>The <code>run_operation</code> RPC provided by the plugin explicitly excludes signature checks: see its documentation in <code>lib_plugin/RPC.Scripts.S.run_operation</code>.</li></ul></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-finalize_block"><a href="#val-finalize_block" class="anchor"></a><code><span><span class="keyword">val</span> finalize_block : 
  <span><a href="#type-validation_state">validation_state</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>unit <a href="../../Tezos_protocol_environment_019_PtParisB/Error_monad/index.html#type-tzresult">Tezos_protocol_environment_019_PtParisB.Error_monad.tzresult</a></span>
    <a href="../../Tezos_protocol_environment_019_PtParisB/Lwt/index.html#type-t">Tezos_protocol_environment_019_PtParisB.Lwt.t</a></span></span></code></div><div class="spec-doc"><p>Finish the validation of a block.</p><p>This function should only be used after <a href="#val-validate_operation"><code>validate_operation</code></a> has been called on every operation in the block. It checks the consistency of the block_header with the information computed while validating the block's operations (Attestation power, payload hash, etc.) Checks vary depending on the mode (ie. which of the <code>begin_...</code> functions above was used to initialize the <code>validation_state</code>).</p></div></div><p>The remaining functions are intended for the mempool. See <a href="../Mempool_validation/index.html"><code>Mempool_validation</code></a>.</p><div class="odoc-spec"><div class="spec value anchored" id="val-check_operation"><a href="#val-check_operation" class="anchor"></a><code><span><span class="keyword">val</span> check_operation : 
  <span><span class="optlabel">?check_signature</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-info">info</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'kind</span> <a href="../Alpha_context/index.html#type-operation">Alpha_context.operation</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>unit <a href="../../Tezos_protocol_environment_019_PtParisB/Error_monad/index.html#type-tzresult">Tezos_protocol_environment_019_PtParisB.Error_monad.tzresult</a></span>
    <a href="../../Tezos_protocol_environment_019_PtParisB/Lwt/index.html#type-t">Tezos_protocol_environment_019_PtParisB.Lwt.t</a></span></span></code></div><div class="spec-doc"><p>Check the operation validity, similarly to <a href="#val-validate_operation"><code>validate_operation</code></a>.</p><p>However, this function does not check for conflicts with previously validated operations, nor global block properties such as the respect of the block gas limit. This allows the function to only take an <a href="#type-info"><code>info</code></a> as input rather than a full <a href="#type-validation_state"><code>validation_state</code></a>.</p><p>This function is intended for <a href="../Mempool_validation/index.html"><code>Mempool_validation</code></a> exclusively.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-check_operation_conflict"><a href="#val-check_operation_conflict" class="anchor"></a><code><span><span class="keyword">val</span> check_operation_conflict : 
  <span><a href="#type-operation_conflict_state">operation_conflict_state</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Tezos_protocol_environment_019_PtParisB/Operation_hash/index.html#type-t">Tezos_protocol_environment_019_PtParisB.Operation_hash.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'kind</span> <a href="../Alpha_context/index.html#type-operation">Alpha_context.operation</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(unit, <a href="../Validate_errors/index.html#type-operation_conflict">Validate_errors.operation_conflict</a>)</span>
    <a href="../../Tezos_protocol_environment_019_PtParisB/Pervasives/index.html#type-result">Tezos_protocol_environment_019_PtParisB.Pervasives.result</a></span></span></code></div><div class="spec-doc"><p>Check that the operation does not conflict with other operations already validated and recorded in the <a href="#type-operation_conflict_state"><code>operation_conflict_state</code></a>.</p><p>This function is intended for <a href="../Mempool_validation/index.html"><code>Mempool_validation</code></a> exclusively.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_valid_operation"><a href="#val-add_valid_operation" class="anchor"></a><code><span><span class="keyword">val</span> add_valid_operation : 
  <span><a href="#type-operation_conflict_state">operation_conflict_state</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Tezos_protocol_environment_019_PtParisB/Operation_hash/index.html#type-t">Tezos_protocol_environment_019_PtParisB.Operation_hash.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'kind</span> <a href="../Alpha_context/index.html#type-operation">Alpha_context.operation</a></span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-operation_conflict_state">operation_conflict_state</a></span></code></div><div class="spec-doc"><p>Add a valid operation to the <a href="#type-operation_conflict_state"><code>operation_conflict_state</code></a>.</p><p>The operation should have been previously validated by calling both <a href="#val-check_operation"><code>check_operation</code></a> and <a href="#val-check_operation_conflict"><code>check_operation_conflict</code></a>.</p><p>This function is intended for <a href="../Mempool_validation/index.html"><code>Mempool_validation</code></a> exclusively.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-remove_operation"><a href="#val-remove_operation" class="anchor"></a><code><span><span class="keyword">val</span> remove_operation : 
  <span><a href="#type-operation_conflict_state">operation_conflict_state</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'kind</span> <a href="../Alpha_context/index.html#type-operation">Alpha_context.operation</a></span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-operation_conflict_state">operation_conflict_state</a></span></code></div><div class="spec-doc"><p>Remove a valid operation from the <a href="#type-operation_conflict_state"><code>operation_conflict_state</code></a>.</p><p>Preconditions:</p><ul><li>The operation has already been validated and added to the <code>operation_conflict_state</code>.</li><li>The <code>operation_conflict_state</code> and other states used to validate the operation have been initialized by calling <a href="#val-begin_partial_construction"><code>begin_partial_construction</code></a>.</li></ul><p>This function is intended for <a href="../Mempool_validation/index.html"><code>Mempool_validation</code></a>, though it is also called by the plugin.</p></div></div></div></body></html>
