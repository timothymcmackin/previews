<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Forge_worker (octez-protocol-alpha-libs.Tezos_baking_alpha.Forge_worker)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">octez-protocol-alpha-libs</a> &#x00BB; <a href="../index.html">Tezos_baking_alpha</a> &#x00BB; Forge_worker</nav><header class="odoc-preamble"><h1>Module <code><span>Tezos_baking_alpha.Forge_worker</span></code></h1><p>Concurrent worker for consensus operations and block forging</p></header><nav class="odoc-toc"><ul><li><a href="#description">Description</a></li><li><a href="#concurrency">Concurrency</a></li><li><a href="#cancellation">Cancellation</a></li></ul></nav><div class="odoc-content"><h3 id="description"><a href="#description" class="anchor"></a>Description</h3><p>This component allows the concurrent production of consensus operations and blocks. It's meant to be used by pushing specific requests as tasks and waiting for their completions on a dedicated event stream.</p><p>Block forging implies the retrieval of current operations and context validation (and application if needed) and then producing a signature. For consensus operations, the heavy work is mostly on producing a signature. Signatures are expected to be concurrent in order not to block the main execution thread.</p><h3 id="concurrency"><a href="#concurrency" class="anchor"></a>Concurrency</h3><p>Each task is associated to a delegate. This worker is designed to work concurrently on each delegate's tasks. However, if a request is pushed for a delegate while an existing one is active, this new request will be enqueued and only be executed after the completion of the first one. Hence, only one request may be active per delegate at any time.</p><h3 id="cancellation"><a href="#cancellation" class="anchor"></a>Cancellation</h3><p>It is possible to cancel all pending tasks but it is not possible to cancel each delegate's active tasks. This is explained by the fact that we do not have control over the different signers scheme and, in particular, some are not cancellable at all (e.g., ledger).</p><div class="odoc-spec"><div class="spec type anchored" id="type-worker"><a href="#type-worker" class="anchor"></a><code><span><span class="keyword">type</span> worker</span></code></div><div class="spec-doc"><p>Worker type</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = <a href="#type-worker">worker</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-push_request"><a href="#val-push_request" class="anchor"></a><code><span><span class="keyword">val</span> push_request : <span><a href="#type-worker">worker</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Baking_state/index.html#type-forge_request">Baking_state.forge_request</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>push_request worker request</code> pushes the <code>request</code> to the worker to be treated. Each <code>forge_request</code> is associated to a specific delegate. The request will be treated whenever the delegate's associated queue is available. If, the delegate's queue did not previously exist, it will be created.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_event_stream"><a href="#val-get_event_stream" class="anchor"></a><code><span><span class="keyword">val</span> get_event_stream : <span><a href="#type-worker">worker</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Baking_state/index.html#type-forge_event">Baking_state.forge_event</a> <span class="xref-unresolved">Lwt_stream</span>.t</span></span></code></div><div class="spec-doc"><p><code>get_event_stream worker</code> returns the worker's stream of events onto which tasks completion results are pushed.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cancel_all_pending_tasks"><a href="#val-cancel_all_pending_tasks" class="anchor"></a><code><span><span class="keyword">val</span> cancel_all_pending_tasks : <span><a href="#type-worker">worker</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>cancel_all_pending_tasks worker</code> cancels all the worker's delegate queues pending tasks.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-shutdown"><a href="#val-shutdown" class="anchor"></a><code><span><span class="keyword">val</span> shutdown : <span><a href="#type-worker">worker</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>shutdown worker</code> triggers the <code>worker</code> shutdown. This function cancels all pending tasks but still waits for each active one to complete.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-start"><a href="#val-start" class="anchor"></a><code><span><span class="keyword">val</span> start : <span><a href="../Baking_state/index.html#type-global_state">Baking_state.global_state</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-worker">worker</a></span></code></div><div class="spec-doc"><p><code>start global_state</code> creates and runs a worker based on a baker's <code>global_state</code>.</p></div></div></div></body></html>
