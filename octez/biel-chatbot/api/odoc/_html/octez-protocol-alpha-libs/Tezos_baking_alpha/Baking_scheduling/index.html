<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Baking_scheduling (octez-protocol-alpha-libs.Tezos_baking_alpha.Baking_scheduling)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">octez-protocol-alpha-libs</a> &#x00BB; <a href="../index.html">Tezos_baking_alpha</a> &#x00BB; Baking_scheduling</nav><header class="odoc-preamble"><h1>Module <code><span>Tezos_baking_alpha.Baking_scheduling</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#scheduler-state-type">Scheduler state type</a></li><li><a href="#functions-used-by-the-baker">Functions used by the baker</a></li><li><a href="#functions-only-needed-for-the-baking_lib">Functions only needed for the baking_lib</a></li></ul></nav><div class="odoc-content"><h3 id="scheduler-state-type"><a href="#scheduler-state-type" class="anchor"></a>Scheduler state type</h3><div class="odoc-spec"><div class="spec type anchored" id="type-loop_state"><a href="#type-loop_state" class="anchor"></a><code><span><span class="keyword">type</span> loop_state</span></code></div><div class="spec-doc"><p>the automaton's state</p></div></div><h3 id="functions-used-by-the-baker"><a href="#functions-used-by-the-baker" class="anchor"></a>Functions used by the baker</h3><div class="odoc-spec"><div class="spec value anchored" id="val-retry"><a href="#val-retry" class="anchor"></a><code><span><span class="keyword">val</span> retry : 
  <span><a href="../../Tezos_client_alpha/Protocol_client_context/class-type-full/index.html">Tezos_client_alpha.Protocol_client_context.full</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?max_delay</span>:float <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">delay</span>:float <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">factor</span>:float <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">tries</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?msg</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tzresult">Tezos_base.TzPervasives.tzresult</a></span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> <a href="../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tzresult">Tezos_base.TzPervasives.tzresult</a></span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>retry ctxt ~delay ?max_delay ~factor ~tries ?msg f x</code> retries applying <code>f
    x</code> <code>tries</code> until it succeeds or returns an error different from <code>Connection_failed</code>, at most <code>tries</code> number of times. After each try it waits for a number of seconds, but not more than <code>max_delay</code>, if given. The wait time between tries is given by the initial <code>delay</code>, multiplied by <code>factor</code> at each subsequent try. At each failure, <code>msg</code> together with the current delay is printed using <code>ctxt#message</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-run"><a href="#val-run" class="anchor"></a><code><span><span class="keyword">val</span> run : 
  <span><a href="../../Tezos_client_alpha/Protocol_client_context/class-type-full/index.html">Tezos_client_alpha.Protocol_client_context.full</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?dal_node_rpc_ctxt</span>:<a href="../../../octez-libs/Tezos_rpc/Context/class-type-generic/index.html">Tezos_rpc.Context.generic</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?canceler</span>:<span class="xref-unresolved">Lwt_canceler</span>.t <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?stop_on_event</span>:<span>(<span><a href="../Baking_state/index.html#type-event">Baking_state.event</a> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?on_error</span>:
    <span>(<span><a href="../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tztrace">Tezos_base.TzPervasives.tztrace</a> <span class="arrow">&#45;&gt;</span></span>
      <span><span>unit <a href="../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tzresult">Tezos_base.TzPervasives.tzresult</a></span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?constants</span>:<a href="../../../tezos-protocol-alpha/Tezos_raw_protocol_alpha/Alpha_context/Constants/index.html#type-t">Tezos_protocol_alpha.Protocol.Alpha_context.Constants.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">chain</span>:<a href="../../../octez-shell-libs/Tezos_shell_services/Chain_services/index.html#type-chain">Tezos_shell_services.Chain_services.chain</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Baking_configuration/index.html#type-t">Baking_configuration.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../Baking_state/index.html#type-consensus_key">Baking_state.consensus_key</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>unit <a href="../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tzresult">Tezos_base.TzPervasives.tzresult</a></span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>run context ?canceler ?stop_on_event ?on_error ?constants chain
    baking_configuration consensus_keys</code> is the entry point of the baker automaton. This function performs the following tasks:</p><ul><li>perform a sanity check that check the location of the baking files, nonces, highwatermarks and state files, also verifying that the files are loadable</li></ul><ul><li>create the streams for valid blocks, new heads, and operations from the node's mempool's</li></ul><ul><li>create an initial state, see <a href="#val-create_initial_state"><code>create_initial_state</code></a></li></ul><ul><li>register dal profiles by calling the <code>register_dal_profiles</code> node RPC</li></ul><ul><li>start a revelation worker for nonces by calling <a href="../Baking_nonces/index.html#val-start_revelation_worker"><code>Baking_nonces.start_revelation_worker</code></a></li></ul><ul><li>create the automaton state, see <a href="#val-create_loop_state"><code>create_loop_state</code></a></li></ul><ul><li>run the automaton loop, see <a href="#val-automaton_loop"><code>automaton_loop</code></a></li></ul></div></div><h3 id="functions-only-needed-for-the-baking_lib"><a href="#functions-only-needed-for-the-baking_lib" class="anchor"></a>Functions only needed for the baking_lib</h3><div class="odoc-spec"><div class="spec value anchored" id="val-sleep_until"><a href="#val-sleep_until" class="anchor"></a><code><span><span class="keyword">val</span> sleep_until : <span><a href="../../../octez-libs/Tezos_base/Time/Protocol/index.html#type-t">Tezos_base.TzPervasives.Time.Protocol.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>unit <span class="xref-unresolved">Lwt</span>.t</span> option</span></span></code></div><div class="spec-doc"><p><code>sleep_until time</code> is blocking until it is <code>time</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-first_potential_round_at_next_level"><a href="#val-first_potential_round_at_next_level" class="anchor"></a><code><span><span class="keyword">val</span> first_potential_round_at_next_level : 
  <span><a href="../Baking_state/index.html#type-state">Baking_state.state</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">earliest_round</span>:<a href="../../../tezos-protocol-alpha/Tezos_raw_protocol_alpha/Alpha_context/Round/index.html#type-t">Tezos_protocol_alpha.Protocol.Alpha_context.Round.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../../../tezos-protocol-alpha/Tezos_raw_protocol_alpha/Alpha_context/Round/index.html#type-t">Tezos_protocol_alpha.Protocol.Alpha_context.Round.t</a>
   * <a href="../Baking_state/index.html#type-consensus_key_and_delegate">Baking_state.consensus_key_and_delegate</a>)</span>
    option</span></span></code></div><div class="spec-doc"><p><code>first_potential_round_at_next_level</code> Returns the first round at the next level, at or after <code>earliest_round</code>, whose baking slot belongs to one of our own delegates; also returns the corresponding delegate. Or returns <code>None</code> if no such round exists.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compute_next_potential_baking_time_at_next_level"><a href="#val-compute_next_potential_baking_time_at_next_level" class="anchor"></a><code><span><span class="keyword">val</span> compute_next_potential_baking_time_at_next_level : 
  <span><a href="../Baking_state/index.html#type-state">Baking_state.state</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="../../../octez-libs/Tezos_base/Time/Protocol/index.html#type-t">Tezos_base.TzPervasives.Time.Protocol.t</a>
   * <a href="../../../tezos-protocol-alpha/Tezos_raw_protocol_alpha/Alpha_context/Round/index.html#type-t">Tezos_protocol_alpha.Protocol.Alpha_context.Round.t</a>)</span>
    option</span>
    <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>compute_next_potential_baking_time state</code> From the current <code>state</code>, the function returns an optional association pair, which consists of the next baking timestamp and its baking round. In that case, an elected block must exist.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compute_bootstrap_event"><a href="#val-compute_bootstrap_event" class="anchor"></a><code><span><span class="keyword">val</span> compute_bootstrap_event : 
  <span><a href="../Baking_state/index.html#type-state">Baking_state.state</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Baking_state/index.html#type-event">Baking_state.event</a> <a href="../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tzresult">Tezos_base.TzPervasives.tzresult</a></span></span></code></div><div class="spec-doc"><p><code>compute_bootstrap_event state</code> emits the first event. If the latest proposal is for the current round, then trigger the new proposal event to possibly preattest. Otherwise, trigger the end of round event (for the previous round) to check whether we need to propose at this level or not.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-create_loop_state"><a href="#val-create_loop_state" class="anchor"></a><code><span><span class="keyword">val</span> create_loop_state : 
  <span><span class="optlabel">?get_valid_blocks_stream</span>:<span><span><a href="../Baking_state/index.html#type-proposal">Baking_state.proposal</a> <span class="xref-unresolved">Lwt_stream</span>.t</span> <span class="xref-unresolved">Lwt</span>.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">heads_stream</span>:<span><a href="../Baking_state/index.html#type-proposal">Baking_state.proposal</a> <span class="xref-unresolved">Lwt_stream</span>.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">forge_event_stream</span>:<span><a href="../Baking_state/index.html#type-forge_event">Baking_state.forge_event</a> <span class="xref-unresolved">Lwt_stream</span>.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Operation_worker/index.html#type-t">Operation_worker.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-loop_state">loop_state</a></span></code></div><div class="spec-doc"><p><code>create_loop_state ?get_valid_blocks_stream heads_stream forge_event_stream
    operation_worker</code> creates a loop state with the streams of valid blocks, new heads, forged events and operations from the node's mempool.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-create_initial_state"><a href="#val-create_initial_state" class="anchor"></a><code><span><span class="keyword">val</span> create_initial_state : 
  <span><a href="../../Tezos_client_alpha/Protocol_client_context/class-type-full/index.html">Tezos_client_alpha.Protocol_client_context.full</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?dal_node_rpc_ctxt</span>:<a href="../../../octez-libs/Tezos_rpc/Context/class-type-generic/index.html">Tezos_rpc.Context.generic</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?synchronize</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">chain</span>:<a href="../../../octez-shell-libs/Tezos_shell_services/Chain_services/index.html#type-chain">Tezos_shell_services.Chain_services.chain</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Baking_configuration/index.html#type-t">Baking_configuration.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Operation_worker/index.html#type-t">Operation_worker.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">current_proposal</span>:<a href="../Baking_state/index.html#type-proposal">Baking_state.proposal</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?constants</span>:<a href="../../../tezos-protocol-alpha/Tezos_raw_protocol_alpha/Alpha_context/Constants/index.html#type-t">Tezos_protocol_alpha.Protocol.Alpha_context.Constants.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../Baking_state/index.html#type-consensus_key">Baking_state.consensus_key</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../Baking_state/index.html#type-state">Baking_state.state</a> <a href="../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tzresult">Tezos_base.TzPervasives.tzresult</a></span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>create_initial_state context ?synchronize chain baking_configuration
    operation_worker current_proposal ?constants consensus_keys</code> creates an initial <a href="../Baking_state/index.html#type-t"><code>Baking_state.t</code></a> by initializing a <code>Baking_state.global_state</code>, a <code>Baking_state.level_state</code> and a <code>Baking_state.round_state</code>.</p><ul><li>For the <code>global_state</code> initialization, a validation mode is set based on the <code>baking_configuration</code> and a forge worker is started. If <code>constants</code> is not provided, an RPC is called to recover them from the <code>context</code>.</li></ul><ul><li>For the <code>level_state</code> initialization, information regarding the current level is retrieved (the current level being that of the <code>current_proposal</code>) and delegates slots are computed for the given <code>consensus_keys</code>.</li></ul><ul><li>For the <code>round_state</code> initialization, current round is compute by calling <a href="../Baking_actions/index.html#val-compute_round"><code>Baking_actions.compute_round</code></a> with <code>current_proposal</code> information if <code>synchronize</code> is set to <code>true</code> (which is the default).</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-automaton_loop"><a href="#val-automaton_loop" class="anchor"></a><code><span><span class="keyword">val</span> automaton_loop : 
  <span><span class="optlabel">?stop_on_event</span>:<span>(<span><a href="../Baking_state/index.html#type-event">Baking_state.event</a> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">config</span>:<a href="../Baking_configuration/index.html#type-t">Baking_configuration.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">on_error</span>:
    <span>(<span><a href="../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tztrace">Tezos_base.TzPervasives.tztrace</a> <span class="arrow">&#45;&gt;</span></span>
      <span><span><span>(unit, <a href="../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tztrace">Tezos_base.TzPervasives.tztrace</a>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-loop_state">loop_state</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Baking_state/index.html#type-state">Baking_state.state</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Baking_state/index.html#type-event">Baking_state.event</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span><a href="../Baking_state/index.html#type-event">Baking_state.event</a> option</span> <a href="../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tzresult">Tezos_base.TzPervasives.tzresult</a></span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>automaton_loop ?stop_on_event baking_configuration on_error loop_state
    state event</code>:</p><ul><li>calls <code>State_transition.step</code> with the <code>state</code> and <code>event</code> and recover a new state and an action to perform</li></ul><ul><li>calls <a href="../Baking_actions/index.html#val-perform_action"><code>Baking_actions.perform_action</code></a> on this new state and action</li></ul><ul><li>records the new state on the disk if the <code>baking_configuration</code> is not <a href="../Baking_configuration/index.html#type-state_recorder_config.Memory"><code>Baking_configuration.state_recorder_config.Memory</code></a></li></ul><ul><li>computes the next timeouts from the current <code>state</code> using a function that returns an Lwt promise that fulfills once the nearest timeout (between those computed by <code>wait_end_of_round</code> and <code>wait_baking_time_next_level</code>) is expired (at that moment the state machine will react)</li></ul><ul><li>waits for the next event from the events streams (new valid proposal, new heads, new forged event, (pre)quorum reached), or a timeout (end of round, or a baking time)</li></ul><ul><li>stops if <code>stop_on_event</code> matches the given <code>event</code>; recursively calls itself with the new event otherwise</li></ul></div></div></div></body></html>
