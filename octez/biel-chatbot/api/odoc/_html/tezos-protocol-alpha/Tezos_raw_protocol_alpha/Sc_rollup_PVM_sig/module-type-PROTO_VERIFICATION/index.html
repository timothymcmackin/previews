<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>PROTO_VERIFICATION (tezos-protocol-alpha.Tezos_raw_protocol_alpha.Sc_rollup_PVM_sig.PROTO_VERIFICATION)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../../index.html">tezos-protocol-alpha</a> &#x00BB; <a href="../../index.html">Tezos_raw_protocol_alpha</a> &#x00BB; <a href="../index.html">Sc_rollup_PVM_sig</a> &#x00BB; PROTO_VERIFICATION</nav><header class="odoc-preamble"><h1>Module type <code><span>Sc_rollup_PVM_sig.PROTO_VERIFICATION</span></code></h1><p>Minimal signature for a protocol implementation of a PVM</p></header><div class="odoc-content"><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../module-type-PROTO_ORIGINATION/index.html">PROTO_ORIGINATION</a></span></code></summary><div class="odoc-spec"><div class="spec type anchored" id="type-state"><a href="#type-state" class="anchor"></a><code><span><span class="keyword">type</span> state</span></code></div><div class="spec-doc"><p>The state of the PVM denotes a state of the rollup.</p><p>The life cycle of the PVM is as follows. It starts its execution from an <a href="#val-initial_state"><code>initial_state</code></a>. The initial state is specialized at origination with a <code>boot_sector</code>, using the <a href="#val-install_boot_sector"><code>install_boot_sector</code></a> function. The resulting state is call the “genesis” of the rollup.</p><p>Afterwards, we classify states into two categories: &quot;internal states&quot; do not require any external information to be executed while &quot;input states&quot; are waiting for some information from the inbox to be executable.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-hash"><a href="#type-hash" class="anchor"></a><code><span><span class="keyword">type</span> hash</span><span> = <a href="../../Sc_rollup_repr/State_hash/index.html#type-t">Sc_rollup_repr.State_hash.t</a></span></code></div><div class="spec-doc"><p>A <code>hash</code> characterizes the contents of a state.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-state_hash"><a href="#val-state_hash" class="anchor"></a><code><span><span class="keyword">val</span> state_hash : <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-hash">hash</a> <a href="../../../Tezos_protocol_environment_alpha/Lwt/index.html#type-t">Tezos_protocol_environment_alpha.Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>state_hash state</code> returns a compressed representation of <code>state</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-initial_state"><a href="#val-initial_state" class="anchor"></a><code><span><span class="keyword">val</span> initial_state : <span><span class="label">empty</span>:<a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-state">state</a> <a href="../../../Tezos_protocol_environment_alpha/Lwt/index.html#type-t">Tezos_protocol_environment_alpha.Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>initial_state ~empty</code> is the initial state of the PVM, before its specialization with a given <code>boot_sector</code>. The initial state is built on the <code>empty</code> state which must be provided.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-install_boot_sector"><a href="#val-install_boot_sector" class="anchor"></a><code><span><span class="keyword">val</span> install_boot_sector : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-state">state</a> <a href="../../../Tezos_protocol_environment_alpha/Lwt/index.html#type-t">Tezos_protocol_environment_alpha.Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>install_boot_sector state boot_sector</code> specializes the initial <code>state</code> of a PVM using a dedicated <code>boot_sector</code>, submitted at the origination of the rollup.</p></div></div></details></div><div class="odoc-spec"><div class="spec value anchored" id="val-parse_boot_sector"><a href="#val-parse_boot_sector" class="anchor"></a><code><span><span class="keyword">val</span> parse_boot_sector : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string option</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span><span class="keyword">val</span> pp : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="../../../Tezos_protocol_environment_alpha/Format/index.html#type-formatter">Tezos_protocol_environment_alpha.Format.formatter</a> <span class="arrow">&#45;&gt;</span></span>
    <span>unit <span class="arrow">&#45;&gt;</span></span>
    unit)</span>
    <a href="../../../Tezos_protocol_environment_alpha/Lwt/index.html#type-t">Tezos_protocol_environment_alpha.Lwt.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-context"><a href="#type-context" class="anchor"></a><code><span><span class="keyword">type</span> context</span></code></div><div class="spec-doc"><p>A <code>context</code> represents the executable environment needed by the state to exist. Typically, the rollup node storage can be part of this context to allow the PVM state to be persistent.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-proof"><a href="#type-proof" class="anchor"></a><code><span><span class="keyword">type</span> proof</span></code></div><div class="spec-doc"><p>During interactive refutation games, a player may need to provide a proof that a given execution step is valid. The PVM implementation is responsible for ensuring that this proof type has the correct semantics.</p><p>A proof <code>p</code> has four parameters:</p><ul><li><code>start_hash := proof_start_state p</code></li><li><code>stop_hash := proof_stop_state p</code></li><li><code>input_requested := proof_input_requested p</code></li><li><code>input_given := proof_input_given p</code></li></ul><p>The following predicate must hold of a valid proof:</p><p><code>exists start_state, stop_state.
              (state_hash start_state == start_hash)
          AND (Option.map state_hash stop_state == stop_hash)
          AND (is_input_state start_state == input_requested)
          AND (match (input_given, input_requested) with
              | (None, No_input_required) -&gt; eval start_state == stop_state
              | (None, Initial) -&gt; stop_state == None
              | (None, First_after (l, n)) -&gt; stop_state == None
              | (Some input, No_input_required) -&gt; true
              | (Some input, Initial) -&gt;
                  set_input input_given start_state == stop_state
              | (Some input, First_after (l, n)) -&gt;
                  set_input input_given start_state == stop_state)</code></p><p>In natural language---the two hash parameters <code>start_hash</code> and <code>stop_hash</code> must have actual <code>state</code> values (or possibly <code>None</code> in the case of <code>stop_hash</code>) of which they are the hashes. The <code>input_requested</code> parameter must be the correct request from the <code>start_hash</code>, given according to <code>is_input_state</code>. Finally there are four possibilities of <code>input_requested</code> and <code>input_given</code>.</p><ul><li>if no input is required, or given, the proof is a simple <code>eval</code> step ;</li><li>if input was required but not given, the <code>stop_hash</code> must be <code>None</code> (the machine is blocked) ;</li><li>if no input was required but some was given, this makes no sense and it doesn't matter if the proof is valid or invalid (this case will be ruled out by the inbox proof anyway) ;</li><li>finally, if input was required and given, the proof is a <code>set_input</code> step.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-proof_encoding"><a href="#val-proof_encoding" class="anchor"></a><code><span><span class="keyword">val</span> proof_encoding : <span><a href="#type-proof">proof</a> <a href="../../../Tezos_protocol_environment_alpha/Data_encoding/index.html#type-t">Tezos_protocol_environment_alpha.Data_encoding.t</a></span></span></code></div><div class="spec-doc"><p><code>proof</code>s are embedded in L1 refutation game operations using <code>proof_encoding</code>. Given that the size of L1 operations are limited, it is of *critical* importance to make sure that no execution step of the PVM can generate proofs that do not fit in L1 operations when encoded. If such a proof existed, the rollup could get stuck.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-proof_start_state"><a href="#val-proof_start_state" class="anchor"></a><code><span><span class="keyword">val</span> proof_start_state : <span><a href="#type-proof">proof</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-hash">hash</a></span></code></div><div class="spec-doc"><p><code>proof_start_state proof</code> returns the initial state hash of the <code>proof</code> execution step.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-proof_stop_state"><a href="#val-proof_stop_state" class="anchor"></a><code><span><span class="keyword">val</span> proof_stop_state : <span><a href="#type-proof">proof</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-hash">hash</a></span></code></div><div class="spec-doc"><p><code>proof_stop_state proof</code> returns the final state hash of the <code>proof</code> execution step.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-verify_proof"><a href="#val-verify_proof" class="anchor"></a><code><span><span class="keyword">val</span> verify_proof : 
  <span><span class="label">is_reveal_enabled</span>:<a href="../index.html#type-is_reveal_enabled">is_reveal_enabled</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../index.html#type-input">input</a> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-proof">proof</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../index.html#type-input_request">input_request</a> <a href="../../../Tezos_protocol_environment_alpha/Error_monad/index.html#type-tzresult">Tezos_protocol_environment_alpha.Error_monad.tzresult</a></span>
    <a href="../../../Tezos_protocol_environment_alpha/Lwt/index.html#type-t">Tezos_protocol_environment_alpha.Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>verify_proof ~is_reveal_enabled input p</code> checks the proof <code>p</code> with input <code>input</code> and returns the <code>input_request</code> before the evaluation of the proof. See the doc-string for the <code>proof</code> type.</p><p><code>verify_proof input p</code> fails when the proof is invalid in regards to the given input.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-output_proof"><a href="#type-output_proof" class="anchor"></a><code><span><span class="keyword">type</span> output_proof</span></code></div><div class="spec-doc"><p>The following type is inhabited by the proofs that a given <code>output</code> is part of the outbox of a given <code>state</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-output_proof_encoding"><a href="#val-output_proof_encoding" class="anchor"></a><code><span><span class="keyword">val</span> output_proof_encoding : 
  <span><a href="#type-output_proof">output_proof</a> <a href="../../../Tezos_protocol_environment_alpha/Data_encoding/index.html#type-t">Tezos_protocol_environment_alpha.Data_encoding.t</a></span></span></code></div><div class="spec-doc"><p><code>output_proof_encoding</code> encoding value for <code>output_proof</code>s.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-output_of_output_proof"><a href="#val-output_of_output_proof" class="anchor"></a><code><span><span class="keyword">val</span> output_of_output_proof : <span><a href="#type-output_proof">output_proof</a> <span class="arrow">&#45;&gt;</span></span> <a href="../index.html#type-output">output</a></span></code></div><div class="spec-doc"><p><code>output_of_output_proof proof</code> returns the <code>output</code> that is referred to in <code>proof</code>'s statement.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-state_of_output_proof"><a href="#val-state_of_output_proof" class="anchor"></a><code><span><span class="keyword">val</span> state_of_output_proof : <span><a href="#type-output_proof">output_proof</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-hash">hash</a></span></code></div><div class="spec-doc"><p><code>state_of_output_proof proof</code> returns the <code>state</code> hash that is referred to in <code>proof</code>'s statement.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-verify_output_proof"><a href="#val-verify_output_proof" class="anchor"></a><code><span><span class="keyword">val</span> verify_output_proof : 
  <span><a href="#type-output_proof">output_proof</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../index.html#type-output">output</a> <a href="../../../Tezos_protocol_environment_alpha/Error_monad/index.html#type-tzresult">Tezos_protocol_environment_alpha.Error_monad.tzresult</a></span>
    <a href="../../../Tezos_protocol_environment_alpha/Lwt/index.html#type-t">Tezos_protocol_environment_alpha.Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>verify_output_proof output_proof</code> returns the <code>output_proof</code>'s output iff the proof is a valid witness that its <code>output</code> is part of its <code>state</code>'s outbox.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-check_dissection"><a href="#val-check_dissection" class="anchor"></a><code><span><span class="keyword">val</span> check_dissection : 
  <span><span class="label">default_number_of_sections</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">start_chunk</span>:<a href="../../Sc_rollup_dissection_chunk_repr/index.html#type-t">Sc_rollup_dissection_chunk_repr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">stop_chunk</span>:<a href="../../Sc_rollup_dissection_chunk_repr/index.html#type-t">Sc_rollup_dissection_chunk_repr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../Sc_rollup_dissection_chunk_repr/index.html#type-t">Sc_rollup_dissection_chunk_repr.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span>unit <a href="../../../Tezos_protocol_environment_alpha/Error_monad/index.html#type-tzresult">Tezos_protocol_environment_alpha.Error_monad.tzresult</a></span></span></code></div><div class="spec-doc"><p><code>check_dissection ~default_number_of_sections ~start_chunk
      ~stop_chunk chunks</code> fails if the dissection encoded by the list <code>[start_chunk] @ chunks @ [stop_chunk]</code> does not satisfy the properties expected by the PVM.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_current_level"><a href="#val-get_current_level" class="anchor"></a><code><span><span class="keyword">val</span> get_current_level : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../Raw_level_repr/index.html#type-t">Raw_level_repr.t</a> option</span> <a href="../../../Tezos_protocol_environment_alpha/Lwt/index.html#type-t">Tezos_protocol_environment_alpha.Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>get_current_level state</code> returns the current level of the <code>state</code>, returns <code>None</code> if it is not possible to compute the level.</p></div></div></div></body></html>
