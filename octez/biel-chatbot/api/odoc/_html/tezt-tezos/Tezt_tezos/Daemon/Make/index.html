<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Make (tezt-tezos.Tezt_tezos.Daemon.Make)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">tezt-tezos</a> &#x00BB; <a href="../../index.html">Tezt_tezos</a> &#x00BB; <a href="../index.html">Daemon</a> &#x00BB; Make</nav><header class="odoc-preamble"><h1>Module <code><span>Daemon.Make</span></code></h1><p>Functor for the common parts of all Tezos daemons: node, baker, endorser and accuser. Handles event handling in particular.</p></header><nav class="odoc-toc"><ul><li><a href="#parameters">Parameters</a></li><li><a href="#signature">Signature</a></li></ul></nav><div class="odoc-content"><h2 id="parameters"><a href="#parameters" class="anchor"></a>Parameters</h2><div class="odoc-spec"><div class="spec parameter anchored" id="argument-1-X"><a href="#argument-1-X" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="argument-1-X/index.html">X</a></span><span> : <a href="../module-type-PARAMETERS/index.html">PARAMETERS</a></span></code></div></div><h2 id="signature"><a href="#signature" class="anchor"></a>Signature</h2><div class="odoc-spec"><div class="spec exception anchored" id="exception-Terminated_before_event"><a href="#exception-Terminated_before_event" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Terminated_before_event</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="module-Make.daemon" class="def record field anchored"><a href="#module-Make.daemon" class="anchor"></a><code><span>daemon : string;</span></code></li><li id="module-Make.event" class="def record field anchored"><a href="#module-Make.event" class="anchor"></a><code><span>event : string;</span></code></li><li id="module-Make.where" class="def record field anchored"><a href="#module-Make.where" class="anchor"></a><code><span>where : <span>string option</span>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Exception raised by <code>wait_for</code> functions if the daemon terminates before the event.</p><p>You may catch or let it propagate to cause the test to fail. <code>daemon</code> is the name of the daemon. <code>event</code> is the name of the event. <code>where</code> is an additional optional constraint, such as <code>&quot;level &gt;= 10&quot;</code>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-session_status"><a href="#type-session_status" class="anchor"></a><code><span><span class="keyword">type</span> session_status</span><span> = </span><span>{</span></code><ol><li id="type-session_status.process" class="def record field anchored"><a href="#type-session_status.process" class="anchor"></a><code><span>process : <span class="xref-unresolved">Tezt_wrapper</span>.Process.t;</span></code></li><li id="type-session_status.stdin" class="def record field anchored"><a href="#type-session_status.stdin" class="anchor"></a><code><span>stdin : <span class="xref-unresolved">Lwt_io</span>.output_channel;</span></code></li><li id="type-session_status.session_state" class="def record field anchored"><a href="#type-session_status.session_state" class="anchor"></a><code><span>session_state : <a href="argument-1-X/index.html#type-session_state">X.session_state</a>;</span></code></li><li id="type-session_status.event_loop_promise" class="def record field anchored"><a href="#type-session_status.event_loop_promise" class="anchor"></a><code><span><span class="keyword">mutable</span> event_loop_promise : <span><span>unit <span class="xref-unresolved">Lwt</span>.t</span> option</span>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>When a daemon is running, we store:</p><ul><li>its process, so that we can terminate it for instance;</li><li>the event loop promise, which reads events and cleans them up when the daemon terminates;</li><li>some information about the state of the daemon so that users can query them.</li></ul><p>The event loop promise is particularly important as when we terminate the daemon we must also wait for the event loop to finish cleaning up before we start the daemon again. The event loop is also responsible to set the status of the daemon to <code>Not_running</code>, which is another reason to wait for it to finish before restarting a daemon. Otherwise we could have a <code>Not_running</code> daemon which would be actually running.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-status"><a href="#type-status" class="anchor"></a><code><span><span class="keyword">type</span> status</span><span> = </span></code><ol><li id="type-status.Not_running" class="def variant constructor anchored"><a href="#type-status.Not_running" class="anchor"></a><code><span>| </span><span><span class="constructor">Not_running</span></span></code></li><li id="type-status.Running" class="def variant constructor anchored"><a href="#type-status.Running" class="anchor"></a><code><span>| </span><span><span class="constructor">Running</span> <span class="keyword">of</span> <a href="#type-session_status">session_status</a></span></code></li></ol></div><div class="spec-doc"><p>Daemon status</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-event_handler"><a href="#type-event_handler" class="anchor"></a><code><span><span class="keyword">type</span> event_handler</span><span> = </span></code><ol><li id="type-event_handler.Event_handler" class="def variant constructor anchored"><a href="#type-event_handler.Event_handler" class="anchor"></a><code><span>| </span><span><span class="constructor">Event_handler</span> : </span><span>{</span></code><ol><li id="type-event_handler.filter" class="def record field anchored"><a href="#type-event_handler.filter" class="anchor"></a><code><span>filter : <span><span class="xref-unresolved">Tezt_wrapper</span>.JSON.t <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span>;</span></code></li><li id="type-event_handler.resolver" class="def record field anchored"><a href="#type-event_handler.resolver" class="anchor"></a><code><span>resolver : <span><span><span class="type-var">'a</span> option</span> <span class="xref-unresolved">Lwt</span>.u</span>;</span></code></li></ol><code><span>}</span><span> <span class="arrow">&#45;&gt;</span> <a href="#type-event_handler">event_handler</a></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-event"><a href="#type-event" class="anchor"></a><code><span><span class="keyword">type</span> event</span><span> = </span><span>{</span></code><ol><li id="type-event.name" class="def record field anchored"><a href="#type-event.name" class="anchor"></a><code><span>name : string;</span></code></li><li id="type-event.value" class="def record field anchored"><a href="#type-event.value" class="anchor"></a><code><span>value : <span class="xref-unresolved">Tezt_wrapper</span>.JSON.t;</span></code></li><li id="type-event.timestamp" class="def record field anchored"><a href="#type-event.timestamp" class="anchor"></a><code><span>timestamp : float;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Raw events.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = </span><span>{</span></code><ol><li id="type-t.name" class="def record field anchored"><a href="#type-t.name" class="anchor"></a><code><span>name : string;</span></code></li><li id="type-t.color" class="def record field anchored"><a href="#type-t.color" class="anchor"></a><code><span>color : <span class="xref-unresolved">Tezt_wrapper</span>.Log.Color.t;</span></code></li><li id="type-t.path" class="def record field anchored"><a href="#type-t.path" class="anchor"></a><code><span>path : string;</span></code></li><li id="type-t.persistent_state" class="def record field anchored"><a href="#type-t.persistent_state" class="anchor"></a><code><span>persistent_state : <a href="argument-1-X/index.html#type-persistent_state">X.persistent_state</a>;</span></code></li><li id="type-t.status" class="def record field anchored"><a href="#type-t.status" class="anchor"></a><code><span><span class="keyword">mutable</span> status : <a href="#type-status">status</a>;</span></code></li><li id="type-t.event_pipe" class="def record field anchored"><a href="#type-t.event_pipe" class="anchor"></a><code><span>event_pipe : string;</span></code></li><li id="type-t.stdout_handlers" class="def record field anchored"><a href="#type-t.stdout_handlers" class="anchor"></a><code><span><span class="keyword">mutable</span> stdout_handlers : <span><span>(<span>string <span class="arrow">&#45;&gt;</span></span> unit)</span> list</span>;</span></code></li><li id="type-t.stderr_handlers" class="def record field anchored"><a href="#type-t.stderr_handlers" class="anchor"></a><code><span><span class="keyword">mutable</span> stderr_handlers : <span><span>(<span>string <span class="arrow">&#45;&gt;</span></span> unit)</span> list</span>;</span></code></li><li id="type-t.persistent_event_handlers" class="def record field anchored"><a href="#type-t.persistent_event_handlers" class="anchor"></a><code><span><span class="keyword">mutable</span> persistent_event_handlers : <span><span>(<span><a href="#type-event">event</a> <span class="arrow">&#45;&gt;</span></span> unit)</span> list</span>;</span></code></li><li id="type-t.one_shot_event_handlers" class="def record field anchored"><a href="#type-t.one_shot_event_handlers" class="anchor"></a><code><span><span class="keyword">mutable</span> one_shot_event_handlers : <span><span><a href="#type-event_handler">event_handler</a> list</span>
                                    <span class="xref-unresolved">Tezt_wrapper</span>.Base.String_map.t</span>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Daemon states.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-name"><a href="#val-name" class="anchor"></a><code><span><span class="keyword">val</span> name : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Get the name of a daemon.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-terminate"><a href="#val-terminate" class="anchor"></a><code><span><span class="keyword">val</span> terminate : <span><span class="optlabel">?timeout</span>:float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p>Send SIGTERM to a daemon and wait for it to terminate.</p><p>Default <code>timeout</code> is 30 seconds, after which SIGKILL is sent.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-kill"><a href="#val-kill" class="anchor"></a><code><span><span class="keyword">val</span> kill : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p>Send SIGKILL to a daemon and wait for it to terminate.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-stop"><a href="#val-stop" class="anchor"></a><code><span><span class="keyword">val</span> stop : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p>Send SIGSTOP to a daemon.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-continue"><a href="#val-continue" class="anchor"></a><code><span><span class="keyword">val</span> continue : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p>Send SIGCONT to a daemon.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fresh_name"><a href="#val-fresh_name" class="anchor"></a><code><span><span class="keyword">val</span> fresh_name : <span>unit <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Generate a fresh indentifier based on <code>X.base_default_name</code>. This function ensures that a same name can't be returned twice.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_next_color"><a href="#val-get_next_color" class="anchor"></a><code><span><span class="keyword">val</span> get_next_color : <span>unit <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Tezt_wrapper</span>.Log.Color.t</span></code></div><div class="spec-doc"><p>Evaluates in a different color at each call.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-create"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : 
  <span><span class="label">path</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?runner</span>:<span class="xref-unresolved">Tezt_wrapper</span>.Runner.t <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?name</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?color</span>:<span class="xref-unresolved">Tezt_wrapper</span>.Log.Color.t <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?event_pipe</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-X/index.html#type-persistent_state">X.persistent_state</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create a daemon.</p><p>The standard output and standard error output of the daemon will be logged with prefix <code>name</code> and color <code>color</code>.</p><p>Default <code>event_pipe</code> is a temporary file whose name is derived from <code>name</code>. It will be created as a named pipe so that daemon events can be received.</p><p>If <code>runner</code> is specified, the daemon will be spawned on this runner using SSH.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_event_from_full_event"><a href="#val-get_event_from_full_event" class="anchor"></a><code><span><span class="keyword">val</span> get_event_from_full_event : <span><span class="xref-unresolved">Tezt_wrapper</span>.JSON.t <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-event">event</a> option</span></span></code></div><div class="spec-doc"><p>Takes the given JSON full event of the following form and evaluates in an event using <code>&lt;name&gt;</code> and <code>&lt;value&gt;</code>:</p><pre class="language-ocaml"><code>{
  &quot;fd-sink-item.v0&quot;: {
    [...]
      &quot;event&quot;: { &lt;name&gt;:&lt;value&gt; }
  }
}</code></pre><p>If the given JSON does not match the right structure, and in particular if the value of the field <code>&quot;event&quot;</code> is not a one-field object, the function evaluates in None.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-run"><a href="#val-run" class="anchor"></a><code><span><span class="keyword">val</span> run : 
  <span><span class="optlabel">?env</span>:<span>string <span class="xref-unresolved">Tezt_wrapper</span>.Base.String_map.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?runner</span>:<span class="xref-unresolved">Tezt_wrapper</span>.Runner.t <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?on_terminate</span>:<span>(<span><span class="xref-unresolved">Unix</span>.process_status <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?event_level</span>:<a href="../Level/index.html#type-default_level">Level.default_level</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?event_sections_levels</span>:<span><span>(string * <a href="../Level/index.html#type-level">Level.level</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?capture_stderr</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="argument-1-X/index.html#type-session_state">X.session_state</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>string list</span> <span class="arrow">&#45;&gt;</span></span>
  <span>unit <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p>Spawn a daemon.</p><p>If <code>capture_stderr</code> is <code>true</code> (default to <code>false</code>), then functions like <code>Process.check_and_read_stderr</code> or <code>Process.check_error</code> will not work as expected with the process of the daemon (as stored in its <code>session_status</code>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-wait_for_full"><a href="#val-wait_for_full" class="anchor"></a><code><span><span class="keyword">val</span> wait_for_full : 
  <span><span class="optlabel">?where</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="xref-unresolved">Tezt_wrapper</span>.JSON.t <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p>Wait for a custom event to occur.</p><p>Usage: <code>wait_for_full daemon name filter</code></p><p>If an event named <code>name</code> occurs, apply <code>filter</code> to its whole json, which is of the form:</p><pre class="language-ocaml"><code>{
&quot;fd-sink-item.v0&quot;: {
  &quot;hostname&quot;: &quot;...&quot;,
              &quot;time_stamp&quot;: ...,
              &quot;section&quot;: [ ... ],
              &quot;event&quot;: { &lt;name&gt;: ... }
                       }
}</code></pre><p>If <code>filter</code> returns <code>None</code>, continue waiting. If <code>filter</code> returns <code>Some x</code>, return <code>x</code>.</p><p><code>where</code> is used as the <code>where</code> field of the <code>Terminated_before_event</code> exception if the daemon terminates. It should describe the constraint that <code>filter</code> applies, such as <code>&quot;field level exists&quot;</code>.</p><p>It is advised to register such event handlers before starting the daemon, as if they occur before being registered, they will not trigger your handler. For instance, you can define a promise with <code>let x_event = wait_for daemon &quot;x&quot; (fun x -&gt; Some x)</code> and bind it later with <code>let* x = x_event</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-wait_for"><a href="#val-wait_for" class="anchor"></a><code><span><span class="keyword">val</span> wait_for : 
  <span><span class="optlabel">?where</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="xref-unresolved">Tezt_wrapper</span>.JSON.t <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p>Same as <code>wait_for_full</code> but ignore metadata from the file descriptor sink.</p><p>More precisely, <code>filter</code> is applied to the value of field <code>&quot;fd-sink-item.v0&quot;.&quot;event&quot;.&lt;name&gt;</code>.</p><p>If the daemon receives a JSON value that does not match the right JSON structure, it is not given to <code>filter</code> and the event is ignored. See <code>wait_for_full</code> to know what the JSON value must look like.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-on_event"><a href="#val-on_event" class="anchor"></a><code><span><span class="keyword">val</span> on_event : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="#type-event">event</a> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Add a callback to be called whenever the daemon emits an event.</p><p>Contrary to <code>wait_for</code> functions, this callback is never removed.</p><p>Listening to events with <code>on_event</code> will not prevent <code>wait_for</code> promises to be fulfilled. You can also have multiple <code>on_event</code> handlers, although the order in which they trigger is unspecified.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-on_stdout"><a href="#val-on_stdout" class="anchor"></a><code><span><span class="keyword">val</span> on_stdout : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>string <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Add a callback to be called whenever the daemon prints to its stdout.</p><p>Contrary to <code>wait_for</code> functions, this callback is never removed.</p><p>Listening to events with <code>on_stdout</code> will not prevent <code>wait_for</code> promises to be fulfilled. You can also have multiple <code>on_stdout</code> handlers, although the order in which they trigger is unspecified.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-on_stderr"><a href="#val-on_stderr" class="anchor"></a><code><span><span class="keyword">val</span> on_stderr : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>string <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Add a callback to be called whenever the daemon prints to its stderr. <a href="#val-run"><code>run</code></a> must have been called with <code>capture_stderr</code> flag set to true, to call callbacks registered this way.</p><p>Contrary to <code>wait_for</code> functions, this callback is never removed.</p><p>Listening to events with <code>on_stderr</code> will not prevent <code>wait_for</code> promises to be fulfilled. You can also have multiple <code>on_stderr</code> handlers, although the order in which they trigger is unspecified.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-log_events"><a href="#val-log_events" class="anchor"></a><code><span><span class="keyword">val</span> log_events : <span><span class="optlabel">?max_length</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Register an event handler that logs all events.</p><p>Use this when you need to debug or reverse engineer incoming events. Usually you do not want to keep that in the final versions of your tests.</p><p>The <code>max_length</code> optional parameter can be used to limit the length of the output of each event; outputs longer than the limit are truncated at the limit and &quot;<code>...</code>&quot; is appended to them to mark the truncation.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-observe_memory_consumption"><a href="#type-observe_memory_consumption" class="anchor"></a><code><span><span class="keyword">type</span> observe_memory_consumption</span><span> = </span></code><ol><li id="type-observe_memory_consumption.Observe" class="def variant constructor anchored"><a href="#type-observe_memory_consumption.Observe" class="anchor"></a><code><span>| </span><span><span class="constructor">Observe</span> <span class="keyword">of</span> <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span>int option</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></li></ol></div><div class="spec-doc"><p>Values returned by <a href="#val-memory_consumption"><code>memory_consumption</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-memory_consumption"><a href="#val-memory_consumption" class="anchor"></a><code><span><span class="keyword">val</span> memory_consumption : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-observe_memory_consumption">observe_memory_consumption</a> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p>Observe memory consumption of the daemon.</p><p>This function requires <code>perf</code> and <code>heaptrack</code> in the PATH and <code>kernel.perf_event_paranoid</code> to be permissive enough. Otherwise, the observation will always return <code>None</code>.</p><p>The returned function gives the peak of memory consumption observed since the observation has started.</p><p><code>memory_consumption daemon</code> starts the observation and returns <code>Some (Observe get)</code>. <code>get ()</code> stops the observation and returns the observation memory consumption.</p></div></div></div></body></html>
