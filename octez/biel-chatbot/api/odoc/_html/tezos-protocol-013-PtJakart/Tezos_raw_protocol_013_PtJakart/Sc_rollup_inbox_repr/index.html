<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Sc_rollup_inbox_repr (tezos-protocol-013-PtJakart.Tezos_raw_protocol_013_PtJakart.Sc_rollup_inbox_repr)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">tezos-protocol-013-PtJakart</a> &#x00BB; <a href="../index.html">Tezos_raw_protocol_013_PtJakart</a> &#x00BB; Sc_rollup_inbox_repr</nav><header class="odoc-preamble"><h1>Module <code><span>Tezos_raw_protocol_013_PtJakart.Sc_rollup_inbox_repr</span></code></h1><p>Merkelizing inbox for smart-contract rollups.</p></header><nav class="odoc-toc"><ul><li><a href="#overview">Overview</a></li><li><a href="#inbox-messages">Inbox messages</a></li><li><a href="#merkelization-of-the-inbox">Merkelization of the inbox</a></li><li><a href="#a-level-indexed-chain-of-inboxes">A level-indexed chain of inboxes</a></li><li><a href="#clients">Clients</a></li></ul></nav><div class="odoc-content"><h2 id="overview"><a href="#overview" class="anchor"></a>Overview</h2><p>The inbox of a smart-contract rollup denotes the incoming messages of the rollup. This inbox is the source of truth about what operations are being published and have an effect on the rollup state. As such, the inbox completely determines the state of the rollup. Hence, if two claims disagree about the state of the rollup, there are only two possibilities: either these two claims correspond to two distinct interpretations of the same inbox ; or, these two claims differ on their views about the contents of the inbox itself. <a href="../Sc_rollup_PVM_sem/index.html"><code>Sc_rollup_PVM_sem</code></a> is meant to arbitrate the first kind of conflicts while <code>Sc_rollup_inbox</code> focuses on the second kind of conflicts.</p><h2 id="inbox-messages"><a href="#inbox-messages" class="anchor"></a>Inbox messages</h2><p>A message is a chunk of bytes. Messages are indexed using natural numbers and the level they are introduced.</p><p>A message is said to be *consumed* when its processing has been cemented, that is, when no refutation about its insertion can happen anymore because the commitment that describes the effect of this message on the state is cemented. A message is said to be *available* (for dispute) if it is not consumed.</p><p>A message processed by the rollup can be consumed or available. A message unprocessed by the rollup is always available.</p><p>The number of available messages is bounded by <a href="../Constants_repr/index.html#type-parametric.sc_rollup_max_available_messages"><code>Constants_repr.parametric.sc_rollup_max_available_messages</code></a>. When an inbox reaches the maximum number of available messages, the inbox is said to be full and cannot accept more messages. This limitation is meant to ensure that Merkle proofs about the inbox contents have a bounded size. (See next section.)</p><h2 id="merkelization-of-the-inbox"><a href="#merkelization-of-the-inbox" class="anchor"></a>Merkelization of the inbox</h2><p>As for the state of the <a href="../Sc_rollup_PVM_sem/index.html"><code>Sc_rollup_PVM_sem</code></a>, the layer 1 does not have to store the entire inbox but only a compressed form (typically a low number of hashes) that witnesses its contents, so that the protocol can check the validity of a proof about its contents. This saves space in the context of the layer 1 and is sufficient for the level 1 to provide a source of truth about the contents of the inbox at the current level.</p><h2 id="a-level-indexed-chain-of-inboxes"><a href="#a-level-indexed-chain-of-inboxes" class="anchor"></a>A level-indexed chain of inboxes</h2><p>By design, inboxes are logically indexed by Tezos levels. This is required to have a simple way to decide if two commitments are in conflict. (See <a href="../Sc_rollup_storage/index.html"><code>Sc_rollup_storage</code></a>.)</p><p>A commitment included in the block at level L describes the effect of the messages of the inboxes with a level between a starting level L_0 and a stopping level L_1, both strictly inferior to L. The level L_0 must be the inbox level of its parent commitment.</p><p>To be valid, a commitment needs to prove that it is reading messages from an inbox which is consistent with the inbox at level L stored in the layer 1 context. So, it should be possible at any time to build a proof that a given inbox is a previous version at level L_1 of the inbox found at level L: these are called inclusion proofs.</p><h2 id="clients"><a href="#clients" class="anchor"></a>Clients</h2><p>This module is meant to be used both by the protocol and by the rollup node in order to maintain consistent inboxes on both side. These two clients slightly differ on the amount of information they store about the inbox.</p><p>On the one hand, to reduce the space consumption of rollups on the chain storage, the protocol only stores metadata about the inbox. The messages of the current level are kept in memory during block validation only (See <a href="../Raw_context/Sc_rollup_in_memory_inbox/index.html"><code>Raw_context.Sc_rollup_in_memory_inbox</code></a>). By contrast, the messages of the previous levels are not kept in the context at all. They can be retrieved from the chain history though. However, being absent from the context, they are not accessible to the protocol.</p><p>On the other hand, the rollup node must keep a more precise inbox to be able to produce Merkle proofs about the content of specific messages, at least during the refutation period.</p><p>To cope with the discrepancy of requirements in terms of inbox storage while preserving a consistent Merkelization between the protocol and the rollup node, this module exposes the hashing schemes used to merkelize the inbox as a functor parameterized by the exact context where Merkle trees are stored.</p><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>The type of the inbox for a smart-contract rollup as stored by the protocol in the context. Values that inhabit this type only act as fingerprint for inboxes.</p><p>Inbox contents is represented using <code>Raw_context.TREE.tree</code>s. (See below.)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span><span class="keyword">val</span> pp : <span><a href="../../Tezos_protocol_environment_013_PtJakart/Format/index.html#type-formatter">Tezos_protocol_environment_013_PtJakart.Format.formatter</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-encoding"><a href="#val-encoding" class="anchor"></a><code><span><span class="keyword">val</span> encoding : <span><a href="#type-t">t</a> <a href="../../Tezos_protocol_environment_013_PtJakart/Data_encoding/index.html#type-t">Tezos_protocol_environment_013_PtJakart.Data_encoding.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : <span><a href="../Sc_rollup_repr/index.html#type-t">Sc_rollup_repr.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Raw_level_repr/index.html#type-t">Raw_level_repr.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>empty level</code> is an inbox started at some given <code>level</code> with no message at all.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-inbox_level"><a href="#val-inbox_level" class="anchor"></a><code><span><span class="keyword">val</span> inbox_level : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Raw_level_repr/index.html#type-t">Raw_level_repr.t</a></span></code></div><div class="spec-doc"><p><code>level inbox</code> returns the maximum level of message insertion in <code>inbox</code> or its initial level.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-number_of_available_messages"><a href="#val-number_of_available_messages" class="anchor"></a><code><span><span class="keyword">val</span> number_of_available_messages : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../Tezos_protocol_environment_013_PtJakart/Z/index.html#type-t">Tezos_protocol_environment_013_PtJakart.Z.t</a></span></code></div><div class="spec-doc"><p><code>number_of_available_messages inbox</code> returns the number of messages that can be consumed in <code>inbox</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-consume_n_messages"><a href="#val-consume_n_messages" class="anchor"></a><code><span><span class="keyword">val</span> consume_n_messages : 
  <span>int <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-t">t</a> option</span> <a href="../../Tezos_protocol_environment_013_PtJakart/Error_monad/index.html#type-tzresult">Tezos_protocol_environment_013_PtJakart.Error_monad.tzresult</a></span></span></code></div><div class="spec-doc"><p><code>consume_n_messages n inbox</code> returns an inbox where <code>n</code> messages have been consumed, or <code>None</code> if there are strictly less than <code>n</code> messages available in <code>inbox</code>.</p></div></div><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-MerkelizedOperations"><a href="#module-type-MerkelizedOperations" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-MerkelizedOperations/index.html">MerkelizedOperations</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The following operations are subject to cross-validation between rollup nodes and the layer 1.</p></div></div><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-TREE"><a href="#module-type-TREE" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-TREE/index.html">TREE</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-MakeHashingScheme"><a href="#module-MakeHashingScheme" class="anchor"></a><code><span><span class="keyword">module</span> <a href="MakeHashingScheme/index.html">MakeHashingScheme</a></span><span>
  (<a href="MakeHashingScheme/argument-1-Tree/index.html">Tree</a> : <a href="module-type-TREE/index.html">TREE</a>) : 
  <a href="module-type-MerkelizedOperations/index.html">MerkelizedOperations</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="module-type-MerkelizedOperations/index.html#type-tree">tree</a> = <a href="MakeHashingScheme/argument-1-Tree/index.html#type-tree">Tree.tree</a></span></span></code></div><div class="spec-doc"><p>This validation is based on a standardized Merkelization scheme. The definition of this scheme is independent from the exact data model of the context but it depends on the <code>Tree</code> arity and internal hashing scheme.</p></div></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="module-type-MerkelizedOperations/index.html">MerkelizedOperations</a>
  <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="module-type-MerkelizedOperations/index.html#type-tree">tree</a> = <a href="../../Tezos_protocol_environment_013_PtJakart/Context/index.html#type-tree">Tezos_protocol_environment_013_PtJakart.Context.tree</a></span></span></code></summary><div class="odoc-spec"><div class="spec type anchored" id="type-tree"><a href="#type-tree" class="anchor"></a><code><span><span class="keyword">type</span> tree</span><span> = <a href="../../Tezos_protocol_environment_013_PtJakart/Context/index.html#type-tree">Tezos_protocol_environment_013_PtJakart.Context.tree</a></span></code></div><div class="spec-doc"><p>The type for the Merkle trees used in this module.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-message"><a href="#type-message" class="anchor"></a><code><span><span class="keyword">type</span> message</span><span> = <a href="#type-tree">tree</a></span></code></div><div class="spec-doc"><p>A merkelized message.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-messages"><a href="#type-messages" class="anchor"></a><code><span><span class="keyword">type</span> messages</span><span> = <a href="#type-tree">tree</a></span></code></div><div class="spec-doc"><p>A merkelized sequence of messages.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-history"><a href="#type-history" class="anchor"></a><code><span><span class="keyword">type</span> history</span></code></div><div class="spec-doc"><p>The history is a merkelized sequence of <code>messages</code>, one per level. The history is typically used by the rollup node to produce inclusion proofs. The protocol only manipulates an empty history as it does not remember previous messages and only keeps a witness of the latest state of the history.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-history_encoding"><a href="#val-history_encoding" class="anchor"></a><code><span><span class="keyword">val</span> history_encoding : 
  <span><a href="#type-history">history</a> <a href="../../Tezos_protocol_environment_013_PtJakart/Data_encoding/index.html#type-t">Tezos_protocol_environment_013_PtJakart.Data_encoding.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_history"><a href="#val-pp_history" class="anchor"></a><code><span><span class="keyword">val</span> pp_history : 
  <span><a href="../../Tezos_protocol_environment_013_PtJakart/Format/index.html#type-formatter">Tezos_protocol_environment_013_PtJakart.Format.formatter</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-history">history</a> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-history_at_genesis"><a href="#val-history_at_genesis" class="anchor"></a><code><span><span class="keyword">val</span> history_at_genesis : <span><span class="label">bound</span>:int64 <span class="arrow">&#45;&gt;</span></span> <a href="#type-history">history</a></span></code></div><div class="spec-doc"><p>The beginning of the history is an empty sequence of <code>messages</code>. Fail with <code>Invalid_bound_on_history</code> if <code>bound</code> is not strictly positive.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_messages"><a href="#val-add_messages" class="anchor"></a><code><span><span class="keyword">val</span> add_messages : 
  <span><a href="#type-history">history</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Raw_level_repr/index.html#type-t">Raw_level_repr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>string list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-messages">messages</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="#type-messages">messages</a> * <a href="#type-history">history</a> * <a href="#type-t">t</a>)</span>
    <a href="../../Tezos_protocol_environment_013_PtJakart/Error_monad/index.html#type-tzresult">Tezos_protocol_environment_013_PtJakart.Error_monad.tzresult</a></span>
    <a href="../../Tezos_protocol_environment_013_PtJakart/Lwt/index.html#type-t">Tezos_protocol_environment_013_PtJakart.Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>add_messages history inbox level payloads messages</code> inserts a list of <code>payloads</code> as new messages in the <code>messages</code> of the current <code>level</code> of the <code>inbox</code>. This function returns the new sequence of messages as well as updated <code>inbox</code> and <code>history</code>.</p><p>If the <code>inbox</code>'s level is older than <code>level</code>, the <code>inbox</code> is updated so that the messages of the levels older than <code>level</code> are archived. To archive a sequence of <code>messages</code> for a given <code>level</code>, we push it at the end of the <code>history</code> and update the witness of this history in the <code>inbox</code>. The <code>inbox</code>'s messages for the current level is also emptied to insert the <code>payloads</code> in a fresh sequence of <code>messages</code> for <code>level</code>.</p><p>This function fails if <code>level</code> is older than <code>inbox</code>'s <code>level</code>.</p><p>This function fails with <code>Max_number_of_available_messages_reached</code> if the inbox is full.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_messages_no_history"><a href="#val-add_messages_no_history" class="anchor"></a><code><span><span class="keyword">val</span> add_messages_no_history : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Raw_level_repr/index.html#type-t">Raw_level_repr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>string list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-message">message</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="#type-message">message</a> * <a href="#type-t">t</a>,
    <span><a href="../../Tezos_protocol_environment_013_PtJakart/Error_monad/index.html#type-error">Tezos_protocol_environment_013_PtJakart.Error_monad.error</a>
      <a href="../../Tezos_protocol_environment_013_PtJakart/Error_monad/index.html#type-trace">Tezos_protocol_environment_013_PtJakart.Error_monad.trace</a></span>)</span>
    <a href="../../Tezos_protocol_environment_013_PtJakart/Pervasives/index.html#type-result">Tezos_protocol_environment_013_PtJakart.Pervasives.result</a></span>
    <a href="../../Tezos_protocol_environment_013_PtJakart/Lwt/index.html#type-t">Tezos_protocol_environment_013_PtJakart.Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>add_messages_no_history inbox level payloads messages</code> behaves a <code>add_messages</code> except that it does not remember the inbox history.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_message"><a href="#val-get_message" class="anchor"></a><code><span><span class="keyword">val</span> get_message : 
  <span><a href="#type-messages">messages</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Tezos_protocol_environment_013_PtJakart/Z/index.html#type-t">Tezos_protocol_environment_013_PtJakart.Z.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-message">message</a> option</span> <a href="../../Tezos_protocol_environment_013_PtJakart/Lwt/index.html#type-t">Tezos_protocol_environment_013_PtJakart.Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>get_message messages idx</code> returns <code>Some message</code> if the sequence of <code>messages</code> has a more than <code>idx</code> messages and <code>message</code> is at position <code>idx</code> in this sequence. Returns <code>None</code> otherwise.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_message_payload"><a href="#val-get_message_payload" class="anchor"></a><code><span><span class="keyword">val</span> get_message_payload : 
  <span><a href="#type-messages">messages</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Tezos_protocol_environment_013_PtJakart/Z/index.html#type-t">Tezos_protocol_environment_013_PtJakart.Z.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>string option</span> <a href="../../Tezos_protocol_environment_013_PtJakart/Lwt/index.html#type-t">Tezos_protocol_environment_013_PtJakart.Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>get_message_payload messages idx</code> returns <code>Some payload</code> if the sequence of <code>messages</code> has a more than <code>idx</code> messages, <code>message</code> is at position <code>idx</code> in this sequence, and is defined by <code>payload</code>. Returns <code>None</code> otherwise.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-inclusion_proof"><a href="#type-inclusion_proof" class="anchor"></a><code><span><span class="keyword">type</span> inclusion_proof</span></code></div><div class="spec-doc"><p>Given a inbox <code>A</code> at some level <code>L</code> and another inbox <code>B</code> at some level <code>L' &gt;= L</code>, an <code>inclusion_proof</code> guarantees that <code>A</code> is an older version of <code>B</code>.</p><p>To be more precise, an <code>inclusion_proof</code> guarantees that the previous levels messages of <code>A</code> are included in the previous levels messages of <code>B</code>. The current messages of <code>A</code> and <code>B</code> are not considered.</p><p>The size of this proof is O(log_basis (L' - L)).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_inclusion_proof"><a href="#val-pp_inclusion_proof" class="anchor"></a><code><span><span class="keyword">val</span> pp_inclusion_proof : 
  <span><a href="../../Tezos_protocol_environment_013_PtJakart/Format/index.html#type-formatter">Tezos_protocol_environment_013_PtJakart.Format.formatter</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-inclusion_proof">inclusion_proof</a> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-number_of_proof_steps"><a href="#val-number_of_proof_steps" class="anchor"></a><code><span><span class="keyword">val</span> number_of_proof_steps : <span><a href="#type-inclusion_proof">inclusion_proof</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>number_of_proof_steps proof</code> returns the length of <code>proof</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-produce_inclusion_proof"><a href="#val-produce_inclusion_proof" class="anchor"></a><code><span><span class="keyword">val</span> produce_inclusion_proof : <span><a href="#type-history">history</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-inclusion_proof">inclusion_proof</a> option</span></span></code></div><div class="spec-doc"><p><code>produce_inclusion_proof history inbox1 inbox2</code> exploits <code>history</code> to produce a self-contained proof that <code>inbox1</code> is an older version of <code>inbox2</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-verify_inclusion_proof"><a href="#val-verify_inclusion_proof" class="anchor"></a><code><span><span class="keyword">val</span> verify_inclusion_proof : <span><a href="#type-inclusion_proof">inclusion_proof</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>verify_inclusion_proof proof inbox1 inbox2</code> returns <code>true</code> iff <code>proof</code> is a minimal and valid proof that <code>inbox1</code> is included in <code>inbox2</code>.</p></div></div></details></div></div></body></html>
