<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Sc_rollup_storage (tezos-protocol-013-PtJakart.Tezos_raw_protocol_013_PtJakart.Sc_rollup_storage)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../index.html">tezos-protocol-013-PtJakart</a> &#x00BB; <a href="../index.html">Tezos_raw_protocol_013_PtJakart</a> &#x00BB; Sc_rollup_storage</nav><header class="odoc-preamble"><h1>Module <code><span>Tezos_raw_protocol_013_PtJakart.Sc_rollup_storage</span></code></h1><p>Defines storage for Smart Contract Optimistic Rollups.</p></header><nav class="odoc-toc"><ul><li><a href="#commitments">Commitments</a><ul><li><a href="#predecessors-and-boot-state">Predecessors and Boot state</a></li><li><a href="#cemented-and-disputable-commitments">Cemented and Disputable commitments</a></li><li><a href="#stakers">Stakers</a></li><li><a href="#dispute">Dispute</a></li><li><a href="#dispute-resolution">Dispute resolution</a></li><li><a href="#conflicts">Conflicts</a></li></ul></li></ul></nav><div class="odoc-content"><h3 id="commitments"><a href="#commitments" class="anchor"></a>Commitments</h3><p><code>Commitment</code>s are stored directly in the L1 context. Commitments are immutable and content-addressed, and can be indexed by a <code>Commitment_hash</code>.</p><p>A commitment represents a claim about the state of a PVM.</p><p>We also keep auxiliary state about each commitment, namely:</p><ul><li>When it was first added.</li><li>Its current number of stakers.</li></ul><p>This auxiliary data is not part of the commitment itself. They represent information that the L1 knows about the claim, not the claim itself.</p><h4 id="predecessors-and-boot-state"><a href="#predecessors-and-boot-state" class="anchor"></a>Predecessors and Boot state</h4><p>Each commitment contains the hash of its <i>predecessor</i>. Multiple commitments can have the same predecessor. Therefore, commitments form a Merkle tree.</p><p>Conceptually the root of this tree is the <code>Commitment_hash.zero</code>. This commitment claims that the PVM (Proof-generating Virtual Machine) is in a pre-boot state and waiting to start booting by interpreting the boot sector with respect to the Machine semantics.</p><h4 id="cemented-and-disputable-commitments"><a href="#cemented-and-disputable-commitments" class="anchor"></a>Cemented and Disputable commitments</h4><p>Commitments accepted as true by the protocol are referred to as Cemented.</p><h4 id="stakers"><a href="#stakers" class="anchor"></a>Stakers</h4><p>The Stakers table maps Stakers (implicit accounts) to commitments.</p><p>Let <code>Stakers(S)</code> mean &quot;looking up the key S in <code>Stakers</code>&quot;.</p><p>A staker <code>S</code> is directly staked on <code>C</code> if <code>Stakers(S) = C</code>. A staker <code>S</code> is indirectly staked on <code>C</code> if <code>C</code> is an ancestor of <code>Stakers(S)</code> in the commitment tree.</p><h4 id="dispute"><a href="#dispute" class="anchor"></a>Dispute</h4><p>Commitments that have at least one sibling are referred to as Disputed. More formally, a commitment C is disputed if at least one staker is not (directly or indirectly) staked on C.</p><h4 id="dispute-resolution"><a href="#dispute-resolution" class="anchor"></a>Dispute resolution</h4><p>The rollup protocol ensures that all disputes are resolved before cementing a commitment. Therefore, cemented commitments form a list rather than a tree.</p><p>In the context we only store the Last Cemented Commitment (LCC), which is by definition a descendant of <code>zero</code>. We also store all Disputable commitments that have at least one Staker.</p><p>For example, assuming the full set of commitments for a rollup looks like this:</p><pre class="language-ocaml"><code>           LCC  staker1  staker2
            |      |        |
            |      V        |
            V   --c3        |
zero--c1 --c2--/            |
               \            V
                --c4------ c5</code></pre><p>then commitments <code>c2..c5</code> will be stored in the context.</p><h4 id="conflicts"><a href="#conflicts" class="anchor"></a>Conflicts</h4><p>Let Commitments(S) be the set of commitments directly staked on by staker S.</p><p>Two stakers A and B are:</p><ul><li>In total agreement iff Commitments(A) = Commitments(B).</li><li>In partial agreement iff either Commitments(A) ⊂ Commitments(B), or Commitments(B) ⊂ Commitments(A).</li><li>In conflict iff they are neither in total or partial agreement.</li></ul><p>We can further refine a conflict to note what they are in conflict about, e.g. they may be in conflict about the inbox, about execution, or both. We can resolve conflicts by first resolving the conflict about inbox, then about execution (since execution is irrelevant if the inbox is not correct).</p><div class="odoc-spec"><div class="spec type extension anchored" id="extension-decl-Sc_rollup_does_not_exist"><a href="#extension-decl-Sc_rollup_does_not_exist" class="anchor"></a><code><span><span class="keyword">type</span> <a href="../../Tezos_protocol_environment_013_PtJakart/Error_monad/index.html#type-error">Tezos_protocol_environment_013_PtJakart.Error_monad.error</a> += </span></code><ol><li id="extension-Sc_rollup_does_not_exist" class="def variant extension anchored"><a href="#extension-Sc_rollup_does_not_exist" class="anchor"></a><code><span>| </span><span><span class="extension">Sc_rollup_does_not_exist</span> <span class="keyword">of</span> <a href="../Sc_rollup_repr/index.html#type-t">Sc_rollup_repr.t</a></span></code></li><li id="extension-Sc_rollup_already_staked" class="def variant extension anchored"><a href="#extension-Sc_rollup_already_staked" class="anchor"></a><code><span>| </span><span><span class="extension">Sc_rollup_already_staked</span></span></code></li><li id="extension-Sc_rollup_not_staked_on_lcc" class="def variant extension anchored"><a href="#extension-Sc_rollup_not_staked_on_lcc" class="anchor"></a><code><span>| </span><span><span class="extension">Sc_rollup_not_staked_on_lcc</span></span></code></li><li id="extension-Sc_rollup_staker_backtracked" class="def variant extension anchored"><a href="#extension-Sc_rollup_staker_backtracked" class="anchor"></a><code><span>| </span><span><span class="extension">Sc_rollup_staker_backtracked</span></span></code></li><li id="extension-Sc_rollup_unknown_commitment" class="def variant extension anchored"><a href="#extension-Sc_rollup_unknown_commitment" class="anchor"></a><code><span>| </span><span><span class="extension">Sc_rollup_unknown_commitment</span> <span class="keyword">of</span> <a href="../Sc_rollup_repr/Commitment_hash/index.html#type-t">Sc_rollup_repr.Commitment_hash.t</a></span></code></li><li id="extension-Sc_rollup_parent_not_lcc" class="def variant extension anchored"><a href="#extension-Sc_rollup_parent_not_lcc" class="anchor"></a><code><span>| </span><span><span class="extension">Sc_rollup_parent_not_lcc</span></span></code></li><li id="extension-Sc_rollup_too_far_ahead" class="def variant extension anchored"><a href="#extension-Sc_rollup_too_far_ahead" class="anchor"></a><code><span>| </span><span><span class="extension">Sc_rollup_too_far_ahead</span></span></code></li><li id="extension-Sc_rollup_too_recent" class="def variant extension anchored"><a href="#extension-Sc_rollup_too_recent" class="anchor"></a><code><span>| </span><span><span class="extension">Sc_rollup_too_recent</span></span></code></li><li id="extension-Sc_rollup_no_stakers" class="def variant extension anchored"><a href="#extension-Sc_rollup_no_stakers" class="anchor"></a><code><span>| </span><span><span class="extension">Sc_rollup_no_stakers</span></span></code></li><li id="extension-Sc_rollup_disputed" class="def variant extension anchored"><a href="#extension-Sc_rollup_disputed" class="anchor"></a><code><span>| </span><span><span class="extension">Sc_rollup_disputed</span></span></code></li><li id="extension-Sc_rollup_no_conflict" class="def variant extension anchored"><a href="#extension-Sc_rollup_no_conflict" class="anchor"></a><code><span>| </span><span><span class="extension">Sc_rollup_no_conflict</span></span></code></li><li id="extension-Sc_rollup_not_staked" class="def variant extension anchored"><a href="#extension-Sc_rollup_not_staked" class="anchor"></a><code><span>| </span><span><span class="extension">Sc_rollup_not_staked</span></span></code></li><li id="extension-Sc_rollup_remove_lcc" class="def variant extension anchored"><a href="#extension-Sc_rollup_remove_lcc" class="anchor"></a><code><span>| </span><span><span class="extension">Sc_rollup_remove_lcc</span></span></code></li><li id="extension-Sc_rollup_bad_inbox_level" class="def variant extension anchored"><a href="#extension-Sc_rollup_bad_inbox_level" class="anchor"></a><code><span>| </span><span><span class="extension">Sc_rollup_bad_inbox_level</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-originate"><a href="#val-originate" class="anchor"></a><code><span><span class="keyword">val</span> originate : 
  <span><a href="../Raw_context/index.html#type-t">Raw_context.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">kind</span>:<a href="../Sc_rollup_repr/Kind/index.html#type-t">Sc_rollup_repr.Kind.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">boot_sector</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="../Sc_rollup_repr/Address/index.html#type-t">Sc_rollup_repr.Address.t</a>
   * <a href="../../Tezos_protocol_environment_013_PtJakart/Z/index.html#type-t">Tezos_protocol_environment_013_PtJakart.Z.t</a>
   * <a href="../Raw_context/index.html#type-t">Raw_context.t</a>)</span>
    <a href="../../Tezos_protocol_environment_013_PtJakart/Error_monad/index.html#type-tzresult">Tezos_protocol_environment_013_PtJakart.Error_monad.tzresult</a></span>
    <a href="../../Tezos_protocol_environment_013_PtJakart/Lwt/index.html#type-t">Tezos_protocol_environment_013_PtJakart.Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>originate context ~kind ~boot_sector</code> produces an address <code>a</code> for a smart contract rollup using the origination nonce found in <code>context</code>. This function also initializes the storage with a new entry indexed by <code>a</code> to remember the <code>kind</code> of the rollup at address <code>a</code> and also to remember its <code>boot_sector</code>.</p><p>Also returns the number of allocated bytes.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-kind"><a href="#val-kind" class="anchor"></a><code><span><span class="keyword">val</span> kind : 
  <span><a href="../Raw_context/index.html#type-t">Raw_context.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sc_rollup_repr/index.html#type-t">Sc_rollup_repr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span><a href="../Sc_rollup_repr/Kind/index.html#type-t">Sc_rollup_repr.Kind.t</a> option</span>
    <a href="../../Tezos_protocol_environment_013_PtJakart/Error_monad/index.html#type-tzresult">Tezos_protocol_environment_013_PtJakart.Error_monad.tzresult</a></span>
    <a href="../../Tezos_protocol_environment_013_PtJakart/Lwt/index.html#type-t">Tezos_protocol_environment_013_PtJakart.Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>kind context address</code> returns <code>Some kind</code> iff <code>address</code> is an existing rollup of some <code>kind</code>. Returns <code>None</code> if <code>address</code> is not the address of an existing rollup.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_messages"><a href="#val-add_messages" class="anchor"></a><code><span><span class="keyword">val</span> add_messages : 
  <span><a href="../Raw_context/index.html#type-t">Raw_context.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sc_rollup_repr/index.html#type-t">Sc_rollup_repr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>string list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="../Sc_rollup_inbox_repr/index.html#type-t">Sc_rollup_inbox_repr.t</a>
   * <a href="../../Tezos_protocol_environment_013_PtJakart/Z/index.html#type-t">Tezos_protocol_environment_013_PtJakart.Z.t</a>
   * <a href="../Raw_context/index.html#type-t">Raw_context.t</a>)</span>
    <a href="../../Tezos_protocol_environment_013_PtJakart/Error_monad/index.html#type-tzresult">Tezos_protocol_environment_013_PtJakart.Error_monad.tzresult</a></span>
    <a href="../../Tezos_protocol_environment_013_PtJakart/Lwt/index.html#type-t">Tezos_protocol_environment_013_PtJakart.Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>add_message context rollup msg</code> adds <code>msg</code> to <code>rollup</code>'s inbox.</p><p>This function returns the updated context as well as the size diff.</p><p>May fail with:</p><ul><li><code>sc_rollup_max_available_messages</code> if <code>inbox</code> is full</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-inbox"><a href="#val-inbox" class="anchor"></a><code><span><span class="keyword">val</span> inbox : 
  <span><a href="../Raw_context/index.html#type-t">Raw_context.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sc_rollup_repr/index.html#type-t">Sc_rollup_repr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="../Sc_rollup_inbox_repr/index.html#type-t">Sc_rollup_inbox_repr.t</a> * <a href="../Raw_context/index.html#type-t">Raw_context.t</a>)</span>
    <a href="../../Tezos_protocol_environment_013_PtJakart/Error_monad/index.html#type-tzresult">Tezos_protocol_environment_013_PtJakart.Error_monad.tzresult</a></span>
    <a href="../../Tezos_protocol_environment_013_PtJakart/Lwt/index.html#type-t">Tezos_protocol_environment_013_PtJakart.Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>inbox context rollup</code> returns the current state of the inbox.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-deposit_stake"><a href="#val-deposit_stake" class="anchor"></a><code><span><span class="keyword">val</span> deposit_stake : 
  <span><a href="../Raw_context/index.html#type-t">Raw_context.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sc_rollup_repr/index.html#type-t">Sc_rollup_repr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sc_rollup_repr/Staker/index.html#type-t">Sc_rollup_repr.Staker.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../Raw_context/index.html#type-t">Raw_context.t</a> <a href="../../Tezos_protocol_environment_013_PtJakart/Error_monad/index.html#type-tzresult">Tezos_protocol_environment_013_PtJakart.Error_monad.tzresult</a></span>
    <a href="../../Tezos_protocol_environment_013_PtJakart/Lwt/index.html#type-t">Tezos_protocol_environment_013_PtJakart.Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>deposit_stake context rollup staker</code> stakes <code>staker</code> at the last cemented commitment, freezing <code>sc_rollup_deposit</code> from <code>staker</code>'s account balance.</p><p>May fail with:</p><ul><li><code>Sc_rollup_does_not_exist</code> if <code>rollup</code> does not exist</li><li><code>Sc_rollup_already_staked</code> if <code>staker</code> is already staked</li><li><code>Sc_rollup_staker_funds_too_low</code> if <code>staker</code> does not have enough funds to cover the deposit</li></ul><p>This should usually be followed by <code>refine_stake</code> to stake on a specific commitment.</p><p>This function does not authenticate the staker.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-withdraw_stake"><a href="#val-withdraw_stake" class="anchor"></a><code><span><span class="keyword">val</span> withdraw_stake : 
  <span><a href="../Raw_context/index.html#type-t">Raw_context.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sc_rollup_repr/index.html#type-t">Sc_rollup_repr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sc_rollup_repr/Staker/index.html#type-t">Sc_rollup_repr.Staker.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../Raw_context/index.html#type-t">Raw_context.t</a> <a href="../../Tezos_protocol_environment_013_PtJakart/Error_monad/index.html#type-tzresult">Tezos_protocol_environment_013_PtJakart.Error_monad.tzresult</a></span>
    <a href="../../Tezos_protocol_environment_013_PtJakart/Lwt/index.html#type-t">Tezos_protocol_environment_013_PtJakart.Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>withdraw_stake context rollup staker</code> removes <code>staker</code> and returns any deposit previously frozen by <code>deposit_stake</code>.</p><p>May fail with:</p><ul><li><code>Sc_rollup_does_not_exist</code> if <code>rollup</code> does not exist</li><li><code>Sc_rollup_not_staked_on_lcc</code> if <code>staker</code> is not staked on the last cemented commitment</li></ul><p>Note that it is not possible to be staked on a Cemented commitment other than the Last, because of Cementation Rule #4. See <code>cement_commitment</code> for details.</p><p>By design, the operation wrapping this should <i>not</i> be authenticated, as it may be necessary for nodes on the honest branch to refund stakers on the LCC. They must do so by using <code>withdraw_stake</code> as they are implicitly staked on the LCC and can not dispute it.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-refine_stake"><a href="#val-refine_stake" class="anchor"></a><code><span><span class="keyword">val</span> refine_stake : 
  <span><a href="../Raw_context/index.html#type-t">Raw_context.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sc_rollup_repr/index.html#type-t">Sc_rollup_repr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sc_rollup_repr/Staker/index.html#type-t">Sc_rollup_repr.Staker.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sc_rollup_repr/Commitment/index.html#type-t">Sc_rollup_repr.Commitment.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="../Sc_rollup_repr/Commitment_hash/index.html#type-t">Sc_rollup_repr.Commitment_hash.t</a> * <a href="../Raw_context/index.html#type-t">Raw_context.t</a>)</span>
    <a href="../../Tezos_protocol_environment_013_PtJakart/Error_monad/index.html#type-tzresult">Tezos_protocol_environment_013_PtJakart.Error_monad.tzresult</a></span>
    <a href="../../Tezos_protocol_environment_013_PtJakart/Lwt/index.html#type-t">Tezos_protocol_environment_013_PtJakart.Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>refine_stake context rollup staker commitment</code> moves the stake of <code>staker</code> to <code>commitment</code>. Because we do not assume any form of coordination between validators, we do not distinguish between <i>adding new</i> commitments and <i>staking on existing commitments</i>. The storage of commitments is content-addressable to minimize storage duplication.</p><p>Subsequent calls to <code>refine_stake</code> and <code>cement_commitment</code> must use a <code>context</code> with greater level, or behavior is undefined.</p><p>The first time a commitment hash is staked on, it is assigned a deadline, which is counted in Tezos blocks (levels). Further stakes on the block does not affect the deadline. The commitment can not be cemented before the deadline has expired. Note that if a commitment is removed due to disputes and then re-entered, a later deadline may be assigned. Assuming one honest staker is always available, this only affects invalid commitments.</p><p>May fail with:</p><ul><li><code>Sc_rollup_does_not_exist</code> if <code>rollup</code> does not exist</li><li><code>Sc_rollup_too_far_ahead</code> if <code>staker</code> would be more than <code>sc_rollup_max_future_commitments</code> ahead of the Last Cemented Commitment</li><li><code>Sc_rollup_bad_inbox_level</code> if <code>commitment</code>'s predecessor is less than <code>sc_rollup_commitment_frequency</code> blocks ahead</li><li><code>Sc_rollup_not_staked</code> if <code>staker</code> is not staked</li><li><code>Sc_rollup_staker_backtracked</code> if <code>staker</code> is not staked on an ancestor of <code>commitment</code></li><li><code>Sc_rollup_unknown_commitment</code> if the parent of the given commitment does not exist</li></ul><p>Returns the hash of the given commitment.</p><p>This function does not authenticate the staker.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-publish_commitment"><a href="#val-publish_commitment" class="anchor"></a><code><span><span class="keyword">val</span> publish_commitment : 
  <span><a href="../Raw_context/index.html#type-t">Raw_context.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sc_rollup_repr/index.html#type-t">Sc_rollup_repr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sc_rollup_repr/Staker/index.html#type-t">Sc_rollup_repr.Staker.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sc_rollup_repr/Commitment/index.html#type-t">Sc_rollup_repr.Commitment.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="../Sc_rollup_repr/Commitment_hash/index.html#type-t">Sc_rollup_repr.Commitment_hash.t</a> * <a href="../Raw_context/index.html#type-t">Raw_context.t</a>)</span>
    <a href="../../Tezos_protocol_environment_013_PtJakart/Error_monad/index.html#type-tzresult">Tezos_protocol_environment_013_PtJakart.Error_monad.tzresult</a></span>
    <a href="../../Tezos_protocol_environment_013_PtJakart/Lwt/index.html#type-t">Tezos_protocol_environment_013_PtJakart.Lwt.t</a></span></span></code></div><div class="spec-doc"><p>This is a wrapper around <code>deposit_stake</code> and <code>refine_stake</code> that deposits a stake and then refines it to the specified commitment, creating that commitment if necessary. Before calling <code>deposit_stake</code> it checks that the staker is not already staked, and if so will skip that step and go straight to calling <code>refine_stake</code>.</p><p>May fail with:</p><ul><li><code>Sc_rollup_does_not_exist</code> if <code>rollup</code> does not exist</li><li><code>Sc_rollup_too_far_ahead</code> if <code>staker</code> would be more than <code>sc_rollup_max_future_commitments</code> ahead of the Last Cemented Commitment</li><li><code>Sc_rollup_bad_inbox_level</code> if <code>commitment</code>'s predecessor is less than <code>sc_rollup_commitment_frequency</code> blocks ahead</li><li><code>Sc_rollup_staker_backtracked</code> if <code>staker</code> is not staked on an ancestor of <code>commitment</code></li><li><code>Sc_rollup_unknown_commitment</code> if the parent of the given commitment does not exist</li><li><code>Sc_rollup_staker_funds_too_low</code> if <code>staker</code> is not previously a staker, and does not have enough funds to cover the deposit</li></ul><p>Returns the hash of the given commitment.</p><p>This function does not authenticate the staker.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-last_cemented_commitment"><a href="#val-last_cemented_commitment" class="anchor"></a><code><span><span class="keyword">val</span> last_cemented_commitment : 
  <span><a href="../Raw_context/index.html#type-t">Raw_context.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sc_rollup_repr/index.html#type-t">Sc_rollup_repr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="../Sc_rollup_repr/Commitment_hash/index.html#type-t">Sc_rollup_repr.Commitment_hash.t</a> * <a href="../Raw_context/index.html#type-t">Raw_context.t</a>)</span>
    <a href="../../Tezos_protocol_environment_013_PtJakart/Error_monad/index.html#type-tzresult">Tezos_protocol_environment_013_PtJakart.Error_monad.tzresult</a></span>
    <a href="../../Tezos_protocol_environment_013_PtJakart/Lwt/index.html#type-t">Tezos_protocol_environment_013_PtJakart.Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>last_cemented_commitment context rollup</code> returns the last cemented commitment of the rollup.</p><p>If no commitments have been cemented, the rollup is said to be in a pre-boot state, and <code>last_cemented_commitment = Commitment_hash.zero</code>.</p><p>May fail with:</p><ul><li><code>Sc_rollup_does_not_exist</code> if <code>rollup</code> does not exist</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cement_commitment"><a href="#val-cement_commitment" class="anchor"></a><code><span><span class="keyword">val</span> cement_commitment : 
  <span><a href="../Raw_context/index.html#type-t">Raw_context.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sc_rollup_repr/index.html#type-t">Sc_rollup_repr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sc_rollup_repr/Commitment_hash/index.html#type-t">Sc_rollup_repr.Commitment_hash.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../Raw_context/index.html#type-t">Raw_context.t</a> <a href="../../Tezos_protocol_environment_013_PtJakart/Error_monad/index.html#type-tzresult">Tezos_protocol_environment_013_PtJakart.Error_monad.tzresult</a></span>
    <a href="../../Tezos_protocol_environment_013_PtJakart/Lwt/index.html#type-t">Tezos_protocol_environment_013_PtJakart.Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>cement_commitment context rollup commitment</code> cements the given commitment.</p><p>Subsequent calls to <code>refine_stake</code> and <code>cement_commitment</code> must use a <code>context</code> with greater level, or behavior is undefined.</p><p>For cementing to succeed, the following must hold:</p><ol><li>The deadline for <code>commitment</code> must have passed.</li><li>The predecessor of <code>commitment</code> must be the Last Cemented Commitment.</li><li>There must be at least one staker.</li><li>All stakers must be indirectly staked on <code>commitment</code>.</li></ol><p>If successful, <code>last_cemented_commitment</code> is set to the given <code>commitment</code> and the appropriate amount of inbox messages is consumed.</p><p>May fail with:</p><ul><li><code>Sc_rollup_does_not_exist</code> if <code>rollup</code> does not exist</li><li><code>Sc_rollup_unknown_commitment</code> if <code>commitment</code> does not exist</li><li><code>Sc_rollup_parent_not_lcc</code> if <code>commitment</code> is not the child of the last cemented commitment</li><li><code>Sc_rollup_too_recent</code> if <code>commitment</code> has not passed its deadline</li><li><code>Sc_rollup_no_stakers</code> if there are zero stakers</li><li><code>Sc_rollup_disputed</code> if at least one staker is not staked on <code>commitment</code></li></ul></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-conflict_point"><a href="#type-conflict_point" class="anchor"></a><code><span><span class="keyword">type</span> conflict_point</span><span> =
  <a href="../Sc_rollup_repr/Commitment_hash/index.html#type-t">Sc_rollup_repr.Commitment_hash.t</a> * <a href="../Sc_rollup_repr/Commitment_hash/index.html#type-t">Sc_rollup_repr.Commitment_hash.t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_conflict_point"><a href="#val-get_conflict_point" class="anchor"></a><code><span><span class="keyword">val</span> get_conflict_point : 
  <span><a href="../Raw_context/index.html#type-t">Raw_context.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sc_rollup_repr/index.html#type-t">Sc_rollup_repr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sc_rollup_repr/Staker/index.html#type-t">Sc_rollup_repr.Staker.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sc_rollup_repr/Staker/index.html#type-t">Sc_rollup_repr.Staker.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="#type-conflict_point">conflict_point</a> * <a href="../Raw_context/index.html#type-t">Raw_context.t</a>)</span>
    <a href="../../Tezos_protocol_environment_013_PtJakart/Error_monad/index.html#type-tzresult">Tezos_protocol_environment_013_PtJakart.Error_monad.tzresult</a></span>
    <a href="../../Tezos_protocol_environment_013_PtJakart/Lwt/index.html#type-t">Tezos_protocol_environment_013_PtJakart.Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>get_conflict_point context rollup staker1 staker2</code> returns the first point of disagreement between the given stakers. The returned commitments are distinct, and have the same <code>parent</code> commitment.</p><p>May fail with:</p><ul><li><code>Sc_rollup_does_not_exist</code> if <code>rollup</code> does not exist</li><li><code>Sc_rollup_no_conflict</code> if <code>staker1</code> is staked on an ancestor of the commitment staked on by <code>staker2</code>, or vice versa</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_commitment"><a href="#val-get_commitment" class="anchor"></a><code><span><span class="keyword">val</span> get_commitment : 
  <span><a href="../Raw_context/index.html#type-t">Raw_context.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sc_rollup_repr/index.html#type-t">Sc_rollup_repr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sc_rollup_repr/Commitment_hash/index.html#type-t">Sc_rollup_repr.Commitment_hash.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="../Sc_rollup_repr/Commitment/index.html#type-t">Sc_rollup_repr.Commitment.t</a> * <a href="../Raw_context/index.html#type-t">Raw_context.t</a>)</span>
    <a href="../../Tezos_protocol_environment_013_PtJakart/Error_monad/index.html#type-tzresult">Tezos_protocol_environment_013_PtJakart.Error_monad.tzresult</a></span>
    <a href="../../Tezos_protocol_environment_013_PtJakart/Lwt/index.html#type-t">Tezos_protocol_environment_013_PtJakart.Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>get_commitment context rollup commitment_hash</code> returns the commitment with the given hash.</p><p>May fail with:</p><ul><li><code>Sc_rollup_does_not_exist</code> if <code>rollup</code> does not exist</li><li><code>Sc_rollup_unknown_commitment</code> if <code>commitment</code> does not exist</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-remove_staker"><a href="#val-remove_staker" class="anchor"></a><code><span><span class="keyword">val</span> remove_staker : 
  <span><a href="../Raw_context/index.html#type-t">Raw_context.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sc_rollup_repr/index.html#type-t">Sc_rollup_repr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sc_rollup_repr/Staker/index.html#type-t">Sc_rollup_repr.Staker.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../Raw_context/index.html#type-t">Raw_context.t</a> <a href="../../Tezos_protocol_environment_013_PtJakart/Error_monad/index.html#type-tzresult">Tezos_protocol_environment_013_PtJakart.Error_monad.tzresult</a></span>
    <a href="../../Tezos_protocol_environment_013_PtJakart/Lwt/index.html#type-t">Tezos_protocol_environment_013_PtJakart.Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>remove_staker context rollup staker</code> forcibly removes the given <code>staker</code> and confiscates their frozen deposits.</p><p>Any commitments no longer staked on are removed and storage reclaimed by <code>remove_staker</code>. Because of this there is no need to explicitly reject commitments.</p><p>May fail with:</p><ul><li><code>Sc_rollup_does_not_exist</code> if <code>rollup</code> does not exist</li><li><code>Sc_rollup_not_staked</code> if <code>staker</code> is not staked</li><li><code>Sc_rollup_remove_lcc</code> if <code>staker</code> is staked on a cemented commitment</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-list"><a href="#val-list" class="anchor"></a><code><span><span class="keyword">val</span> list : 
  <span><a href="../Raw_context/index.html#type-t">Raw_context.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span><a href="../Sc_rollup_repr/index.html#type-t">Sc_rollup_repr.t</a> list</span>
    <a href="../../Tezos_protocol_environment_013_PtJakart/Error_monad/index.html#type-tzresult">Tezos_protocol_environment_013_PtJakart.Error_monad.tzresult</a></span>
    <a href="../../Tezos_protocol_environment_013_PtJakart/Lwt/index.html#type-t">Tezos_protocol_environment_013_PtJakart.Lwt.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-initial_level"><a href="#val-initial_level" class="anchor"></a><code><span><span class="keyword">val</span> initial_level : 
  <span><a href="../Raw_context/index.html#type-t">Raw_context.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sc_rollup_repr/index.html#type-t">Sc_rollup_repr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../Raw_level_repr/index.html#type-t">Raw_level_repr.t</a> <a href="../../Tezos_protocol_environment_013_PtJakart/Error_monad/index.html#type-tzresult">Tezos_protocol_environment_013_PtJakart.Error_monad.tzresult</a></span>
    <a href="../../Tezos_protocol_environment_013_PtJakart/Lwt/index.html#type-t">Tezos_protocol_environment_013_PtJakart.Lwt.t</a></span></span></code></div></div></div></body></html>
