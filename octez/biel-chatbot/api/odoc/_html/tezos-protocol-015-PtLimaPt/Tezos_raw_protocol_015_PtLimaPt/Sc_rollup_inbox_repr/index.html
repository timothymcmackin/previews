<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Sc_rollup_inbox_repr (tezos-protocol-015-PtLimaPt.Tezos_raw_protocol_015_PtLimaPt.Sc_rollup_inbox_repr)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">tezos-protocol-015-PtLimaPt</a> &#x00BB; <a href="../index.html">Tezos_raw_protocol_015_PtLimaPt</a> &#x00BB; Sc_rollup_inbox_repr</nav><header class="odoc-preamble"><h1>Module <code><span>Tezos_raw_protocol_015_PtLimaPt.Sc_rollup_inbox_repr</span></code></h1><p>Merkelizing inbox for smart-contract rollups.</p></header><nav class="odoc-toc"><ul><li><a href="#overview">Overview</a></li><li><a href="#inbox-messages">Inbox messages</a></li><li><a href="#merkelization-of-the-inbox">Merkelization of the inbox</a></li><li><a href="#a-level-indexed-chain-of-inboxes">A level-indexed chain of inboxes</a></li><li><a href="#clients">Clients</a></li></ul></nav><div class="odoc-content"><h2 id="overview"><a href="#overview" class="anchor"></a>Overview</h2><p>The inbox of a smart-contract rollup denotes the incoming messages of the rollup. This inbox is the source of truth about what operations are being published and have an effect on the rollup state. As such, the inbox completely determines the state of the rollup. Hence, if two claims disagree about the state of the rollup, there are only two possibilities: either these two claims correspond to two distinct interpretations of the same inbox ; or, these two claims differ on their views about the contents of the inbox itself. <a href="../Sc_rollup_PVM_sig/index.html"><code>Sc_rollup_PVM_sig</code></a> is meant to arbitrate the first kind of conflicts while <code>Sc_rollup_inbox</code> focuses on the second kind of conflicts.</p><h2 id="inbox-messages"><a href="#inbox-messages" class="anchor"></a>Inbox messages</h2><p>A message is a chunk of bytes. Messages are indexed using natural numbers and the level they are introduced.</p><p>A message is said to be *consumed* when its processing has been cemented, that is, when no refutation about its insertion can happen anymore because the commitment that describes the effect of this message on the state is cemented. A message is said to be *available* (for dispute) if it is not consumed.</p><p>A message processed by the rollup can be consumed or available. A message unprocessed by the rollup is always available.</p><p>The number of messages in a commitment period is bounded by <a href="../Constants_storage/index.html#val-sc_rollup_max_number_of_messages_per_commitment_period"><code>Constants_storage.sc_rollup_max_number_of_messages_per_commitment_period</code></a>. When an inbox reaches the maximum number of messages in the commitment period, the inbox is said to be full and cannot accept more messages. This limitation is meant to ensure that Merkle proofs about the inbox contents have a bounded size. (See next section.)</p><h2 id="merkelization-of-the-inbox"><a href="#merkelization-of-the-inbox" class="anchor"></a>Merkelization of the inbox</h2><p>As for the state of the <a href="../Sc_rollup_PVM_sig/index.html"><code>Sc_rollup_PVM_sig</code></a>, the layer 1 does not have to store the entire inbox but only a compressed form (typically a low number of hashes) that witnesses its contents, so that the protocol can check the validity of a proof about its contents. This saves space in the context of the layer 1 and is sufficient for the layer 1 to provide a source of truth about the contents of the inbox at the current level.</p><h2 id="a-level-indexed-chain-of-inboxes"><a href="#a-level-indexed-chain-of-inboxes" class="anchor"></a>A level-indexed chain of inboxes</h2><p>By design, inboxes are logically indexed by Tezos levels. This is required to have a simple way to decide if two commitments are in conflict. (See <a href="../Sc_rollup_storage/index.html"><code>Sc_rollup_storage</code></a>.)</p><p>A commitment included in the block at level L describes the effect of the messages of the inboxes with a level between a starting level L_0 and a stopping level L_1, both strictly inferior to L. The level L_0 must be the inbox level of its parent commitment.</p><p>To be valid, a commitment needs to prove that it is reading messages from an inbox which is consistent with the inbox at level L stored in the layer 1 context. So, it should be possible at any time to build a proof that a given inbox is a previous version at level L_1 of the inbox found at level L: these are called inclusion proofs.</p><h2 id="clients"><a href="#clients" class="anchor"></a>Clients</h2><p>This module is meant to be used both by the protocol and by the rollup node in order to maintain consistent inboxes on both sides. These two clients slightly differ on the amount of information they store about the inbox.</p><p>On the one hand, to reduce the space consumption of rollups on the chain storage, the protocol only stores metadata about the inbox. The messages of the current level are kept in memory during block validation only (See <a href="../Raw_context/Sc_rollup_in_memory_inbox/index.html"><code>Raw_context.Sc_rollup_in_memory_inbox</code></a>). By contrast, the messages of the previous levels are not kept in the context at all. They can be retrieved from the chain history though. However, being absent from the context, they are not accessible to the protocol.</p><p>On the other hand, the rollup node must keep a more precise inbox to be able to produce Merkle proofs about the content of specific messages, at least during the refutation period.</p><p>To cope with the discrepancy of requirements in terms of inbox storage while preserving a consistent Merkelization between the protocol and the rollup node, this module exposes the hashing schemes used to merkelize the inbox as a functor parameterized by the exact context where Merkle trees are stored.</p><div class="odoc-spec"><div class="spec module anchored" id="module-Hash"><a href="#module-Hash" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Hash/index.html">Hash</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-V1"><a href="#module-V1" class="anchor"></a><code><span><span class="keyword">module</span> <a href="V1/index.html">V1</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-include"><div class="spec-doc"><p>Versioning, see <a href="../Sc_rollup_data_version_sig/module-type-S/index.html"><code>Sc_rollup_data_version_sig.S</code></a> for more information.</p></div><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../Sc_rollup_data_version_sig/module-type-S/index.html">Sc_rollup_data_version_sig.S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../Sc_rollup_data_version_sig/module-type-S/index.html#type-t">t</a> = <a href="V1/index.html#type-t">V1.t</a></span></span></code></summary><div class="odoc-spec"><div class="spec type anchored" id="type-versioned"><a href="#type-versioned" class="anchor"></a><code><span><span class="keyword">type</span> versioned</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-versioned_encoding"><a href="#val-versioned_encoding" class="anchor"></a><code><span><span class="keyword">val</span> versioned_encoding : 
  <span><a href="#type-versioned">versioned</a> <a href="../../Tezos_protocol_environment_015_PtLimaPt/Data_encoding/index.html#type-t">Tezos_protocol_environment_015_PtLimaPt.Data_encoding.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_versioned"><a href="#val-of_versioned" class="anchor"></a><code><span><span class="keyword">val</span> of_versioned : <span><a href="#type-versioned">versioned</a> <span class="arrow">&#45;&gt;</span></span> <a href="V1/index.html#type-t">V1.t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_versioned"><a href="#val-to_versioned" class="anchor"></a><code><span><span class="keyword">val</span> to_versioned : <span><a href="V1/index.html#type-t">V1.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-versioned">versioned</a></span></code></div></div></details></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <a href="V1/index.html">V1</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="V1/index.html#type-t">t</a> = <a href="V1/index.html#type-t">V1.t</a></span></span></code></summary><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = <a href="V1/index.html#type-t">V1.t</a></span></code></div><div class="spec-doc"><p>The type of the inbox for a smart-contract rollup as stored by the protocol in the context. Values that inhabit this type only act as fingerprint for inboxes.</p><p>Inbox contents is represented using <code>Raw_context.TREE.tree</code>s. (See below.)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span><span class="keyword">val</span> pp : <span><a href="../../Tezos_protocol_environment_015_PtLimaPt/Format/index.html#type-formatter">Tezos_protocol_environment_015_PtLimaPt.Format.formatter</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-encoding"><a href="#val-encoding" class="anchor"></a><code><span><span class="keyword">val</span> encoding : <span><a href="#type-t">t</a> <a href="../../Tezos_protocol_environment_015_PtLimaPt/Data_encoding/index.html#type-t">Tezos_protocol_environment_015_PtLimaPt.Data_encoding.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-inbox_level"><a href="#val-inbox_level" class="anchor"></a><code><span><span class="keyword">val</span> inbox_level : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Raw_level_repr/index.html#type-t">Raw_level_repr.t</a></span></code></div><div class="spec-doc"><p><code>inbox_level inbox</code> returns the maximum level of message insertion in <code>inbox</code> or its initial level.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-history_proof"><a href="#type-history_proof" class="anchor"></a><code><span><span class="keyword">type</span> history_proof</span></code></div><div class="spec-doc"><p>A <code>history_proof</code> is a <code>Skip_list.cell</code> that stores multiple hashes. <code>Skip_list.content history_proof</code> gives the hash of the level tree for this cell, while <code>Skip_list.back_pointers
    history_proof</code> is an array of hashes of earlier <code>history_proof</code>s in the inbox.</p><p>On the one hand, we think of this type as representing the whole Merkle structure of an inbox at a given level---it is the part of <a href="#type-t"><code>t</code></a> above that can actually be used to prove things (it cannot be forged by a malicious node because it much match the hash stored by the L1).</p><p>On the other hand, we think of this type as representing a single proof-step back through the history of the inbox; given a hash that appears at some point later in the inbox this type proves that that hash points to this particular combination of a level tree and further back-pointers.</p><p>In terms of size, this type is a small set of hashes; one for the current level tree and `O(log2(ix))` in the back-pointers, where <code>ix</code> is the index of the cell in the skip list. That is, <code>ix</code> is the number of non-empty levels between now and the origination level of the rollup.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-History"><a href="#module-History" class="anchor"></a><code><span><span class="keyword">module</span> <a href="History/index.html">History</a></span><span> : 
  <a href="../Bounded_history_repr/module-type-S/index.html">Bounded_history_repr.S</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../Bounded_history_repr/module-type-S/index.html#type-key">key</a> = <a href="Hash/index.html#type-t">Hash.t</a></span> <span class="keyword">and</span> <span><span class="keyword">type</span> <a href="../Bounded_history_repr/module-type-S/index.html#type-value">value</a> = <a href="#type-history_proof">history_proof</a></span></span></code></div><div class="spec-doc"><p>A <code>History.t</code> is basically a lookup table of <a href="#type-history_proof"><code>history_proof</code></a>s. We need this if we want to produce inbox proofs because it allows us to dereference the 'pointer' hashes in any of the <code>history_proof</code>s. This <code>deref</code> function is passed to <code>Skip_list.back_path</code> or <code>Skip_list.search</code> to allow these functions to construct valid paths back through the skip list.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_history_proof"><a href="#val-pp_history_proof" class="anchor"></a><code><span><span class="keyword">val</span> pp_history_proof : 
  <span><a href="../../Tezos_protocol_environment_015_PtLimaPt/Format/index.html#type-formatter">Tezos_protocol_environment_015_PtLimaPt.Format.formatter</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-history_proof">history_proof</a> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-history_proof_encoding"><a href="#val-history_proof_encoding" class="anchor"></a><code><span><span class="keyword">val</span> history_proof_encoding : 
  <span><a href="#type-history_proof">history_proof</a> <a href="../../Tezos_protocol_environment_015_PtLimaPt/Data_encoding/index.html#type-t">Tezos_protocol_environment_015_PtLimaPt.Data_encoding.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal_history_proof"><a href="#val-equal_history_proof" class="anchor"></a><code><span><span class="keyword">val</span> equal_history_proof : <span><a href="#type-history_proof">history_proof</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-history_proof">history_proof</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-old_levels_messages"><a href="#val-old_levels_messages" class="anchor"></a><code><span><span class="keyword">val</span> old_levels_messages : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-history_proof">history_proof</a></span></code></div><div class="spec-doc"><p><code>old_levels_messages inbox</code> returns the skip list of the inbox history. How much data there actually is depends on the context---in the L1 most of the history is forgotten and just a root hash of the skip list is kept.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-number_of_messages_during_commitment_period"><a href="#val-number_of_messages_during_commitment_period" class="anchor"></a><code><span><span class="keyword">val</span> number_of_messages_during_commitment_period : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int64</span></code></div><div class="spec-doc"><p><code>number_of_messages_during_commitment_period inbox</code> returns the number of messages added in the inbox since the beginning of the current commitment period.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-refresh_commitment_period"><a href="#val-refresh_commitment_period" class="anchor"></a><code><span><span class="keyword">val</span> refresh_commitment_period : 
  <span><span class="label">commitment_period</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">level</span>:<a href="../Raw_level_repr/index.html#type-t">Raw_level_repr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>refresh_commitment_period ~commitment_period ~level inbox</code> updates <code>inbox</code> to take into account the commitment_period: this resets a counter for the number of messages in a given commitment period (which is limited).</p></div></div></details></div><div class="odoc-spec"><div class="spec value anchored" id="val-current_level_hash"><a href="#val-current_level_hash" class="anchor"></a><code><span><span class="keyword">val</span> current_level_hash : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="Hash/index.html#type-t">Hash.t</a></span></code></div><div class="spec-doc"><p>This extracts the current level hash from the inbox. Note: the current level hash is stored lazily as <code>fun () -&gt; ...</code>, and this function will call that function. So don't use this if you want to preserve the laziness.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-serialized_proof"><a href="#type-serialized_proof" class="anchor"></a><code><span><span class="keyword">type</span> serialized_proof</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-serialized_proof_encoding"><a href="#val-serialized_proof_encoding" class="anchor"></a><code><span><span class="keyword">val</span> serialized_proof_encoding : 
  <span><a href="#type-serialized_proof">serialized_proof</a> <a href="../../Tezos_protocol_environment_015_PtLimaPt/Data_encoding/index.html#type-t">Tezos_protocol_environment_015_PtLimaPt.Data_encoding.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-Merkelized_operations"><a href="#module-type-Merkelized_operations" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Merkelized_operations/index.html">Merkelized_operations</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The following operations are subject to cross-validation between rollup nodes and the layer 1.</p></div></div><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-P"><a href="#module-type-P" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-P/index.html">P</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Make_hashing_scheme"><a href="#module-Make_hashing_scheme" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Make_hashing_scheme/index.html">Make_hashing_scheme</a></span><span>
  (<a href="Make_hashing_scheme/argument-1-P/index.html">P</a> : <a href="module-type-P/index.html">P</a>) : 
  <a href="module-type-Merkelized_operations/index.html">Merkelized_operations</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="module-type-Merkelized_operations/index.html#type-tree">tree</a> = <a href="Make_hashing_scheme/argument-1-P/index.html#type-tree">P.tree</a></span> <span class="keyword">and</span> <span><span class="keyword">type</span> <a href="module-type-Merkelized_operations/index.html#type-inbox_context">inbox_context</a> = <a href="Make_hashing_scheme/argument-1-P/index.html#type-t">P.t</a></span></span></code></div><div class="spec-doc"><p>This validation is based on a standardized Merkelization scheme. The definition of this scheme is independent from the exact data model of the context but it depends on the <code>Tree</code> arity and internal hashing scheme.</p></div></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="module-type-Merkelized_operations/index.html">Merkelized_operations</a>
  <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="module-type-Merkelized_operations/index.html#type-tree">tree</a> = <a href="../../Tezos_protocol_environment_015_PtLimaPt/Context/index.html#type-tree">Tezos_protocol_environment_015_PtLimaPt.Context.tree</a></span>
   <span class="keyword">and</span> <span><span class="keyword">type</span> <a href="module-type-Merkelized_operations/index.html#type-inbox_context">inbox_context</a> = <a href="../../Tezos_protocol_environment_015_PtLimaPt/Context/index.html#type-t">Tezos_protocol_environment_015_PtLimaPt.Context.t</a></span></span></code></summary><div class="odoc-spec"><div class="spec type anchored" id="type-tree"><a href="#type-tree" class="anchor"></a><code><span><span class="keyword">type</span> tree</span><span> = <a href="../../Tezos_protocol_environment_015_PtLimaPt/Context/index.html#type-tree">Tezos_protocol_environment_015_PtLimaPt.Context.tree</a></span></code></div><div class="spec-doc"><p>The type for the Merkle trees used in this module.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-inbox_context"><a href="#type-inbox_context" class="anchor"></a><code><span><span class="keyword">type</span> inbox_context</span><span> = <a href="../../Tezos_protocol_environment_015_PtLimaPt/Context/index.html#type-t">Tezos_protocol_environment_015_PtLimaPt.Context.t</a></span></code></div><div class="spec-doc"><p>The context used by the trees.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-hash_level_tree"><a href="#val-hash_level_tree" class="anchor"></a><code><span><span class="keyword">val</span> hash_level_tree : <span><a href="#type-tree">tree</a> <span class="arrow">&#45;&gt;</span></span> <a href="Hash/index.html#type-t">Hash.t</a></span></code></div><div class="spec-doc"><p>Standard hashing function used for trees in this module.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-new_level_tree"><a href="#val-new_level_tree" class="anchor"></a><code><span><span class="keyword">val</span> new_level_tree : 
  <span><a href="#type-inbox_context">inbox_context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Raw_level_repr/index.html#type-t">Raw_level_repr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-tree">tree</a> <a href="../../Tezos_protocol_environment_015_PtLimaPt/Lwt/index.html#type-t">Tezos_protocol_environment_015_PtLimaPt.Lwt.t</a></span></span></code></div><div class="spec-doc"><p>Initialise a new level. <code>new_level_tree ctxt level</code> is a merkle tree with no messages yet, but has the <code>level</code> stored so we can check that in proofs.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_messages"><a href="#val-add_messages" class="anchor"></a><code><span><span class="keyword">val</span> add_messages : 
  <span><a href="#type-inbox_context">inbox_context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="History/index.html#type-t">History.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Raw_level_repr/index.html#type-t">Raw_level_repr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../Sc_rollup_inbox_message_repr/index.html#type-serialized">Sc_rollup_inbox_message_repr.serialized</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-tree">tree</a> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="#type-tree">tree</a> * <a href="History/index.html#type-t">History.t</a> * <a href="#type-t">t</a>)</span>
    <a href="../../Tezos_protocol_environment_015_PtLimaPt/Error_monad/index.html#type-tzresult">Tezos_protocol_environment_015_PtLimaPt.Error_monad.tzresult</a></span>
    <a href="../../Tezos_protocol_environment_015_PtLimaPt/Lwt/index.html#type-t">Tezos_protocol_environment_015_PtLimaPt.Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>add_messages ctxt history inbox level payloads level_tree</code> inserts a list of <code>payloads</code> as new messages in the <code>level_tree</code> of the current <code>level</code> of the <code>inbox</code>. This function returns the new level tree as well as updated <code>inbox</code> and <code>history</code>.</p><p>If the <code>inbox</code>'s level is older than <code>level</code>, the <code>inbox</code> is updated so that the level trees of the levels older than <code>level</code> are archived. To archive a <code>level_tree</code> for a given <code>level</code>, we push it at the end of the <code>history</code> and update the witness of this history in the <code>inbox</code>. The <code>inbox</code>'s level tree for the current level is emptied to insert the <code>payloads</code> in a fresh <code>level_tree</code> for <code>level</code>.</p><p>This function fails if <code>level</code> is older than <code>inbox</code>'s <code>level</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_messages_no_history"><a href="#val-add_messages_no_history" class="anchor"></a><code><span><span class="keyword">val</span> add_messages_no_history : 
  <span><a href="#type-inbox_context">inbox_context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Raw_level_repr/index.html#type-t">Raw_level_repr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../Sc_rollup_inbox_message_repr/index.html#type-serialized">Sc_rollup_inbox_message_repr.serialized</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-tree">tree</a> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="#type-tree">tree</a> * <a href="#type-t">t</a>,
    <span><a href="../../Tezos_protocol_environment_015_PtLimaPt/Error_monad/index.html#type-error">Tezos_protocol_environment_015_PtLimaPt.Error_monad.error</a>
      <a href="../../Tezos_protocol_environment_015_PtLimaPt/Error_monad/index.html#type-trace">Tezos_protocol_environment_015_PtLimaPt.Error_monad.trace</a></span>)</span>
    <a href="../../Tezos_protocol_environment_015_PtLimaPt/Pervasives/index.html#type-result">Tezos_protocol_environment_015_PtLimaPt.Pervasives.result</a></span>
    <a href="../../Tezos_protocol_environment_015_PtLimaPt/Lwt/index.html#type-t">Tezos_protocol_environment_015_PtLimaPt.Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>add_messages_no_history ctxt inbox level payloads level_tree</code> behaves as <code>add_external_messages</code> except that it does not remember the inbox history.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_message_payload"><a href="#val-get_message_payload" class="anchor"></a><code><span><span class="keyword">val</span> get_message_payload : 
  <span><a href="#type-tree">tree</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Tezos_protocol_environment_015_PtLimaPt/Z/index.html#type-t">Tezos_protocol_environment_015_PtLimaPt.Z.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../Sc_rollup_inbox_message_repr/index.html#type-serialized">Sc_rollup_inbox_message_repr.serialized</a> option</span>
    <a href="../../Tezos_protocol_environment_015_PtLimaPt/Lwt/index.html#type-t">Tezos_protocol_environment_015_PtLimaPt.Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>get_message_payload level_tree idx</code> returns <code>Some payload</code> if the <code>level_tree</code> has more than <code>idx</code> messages, and <code>payload</code> is at position <code>idx</code>. Returns <code>None</code> otherwise.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-form_history_proof"><a href="#val-form_history_proof" class="anchor"></a><code><span><span class="keyword">val</span> form_history_proof : 
  <span><a href="#type-inbox_context">inbox_context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="History/index.html#type-t">History.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-tree">tree</a> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="History/index.html#type-t">History.t</a> * <a href="#type-history_proof">history_proof</a>)</span>
    <a href="../../Tezos_protocol_environment_015_PtLimaPt/Error_monad/index.html#type-tzresult">Tezos_protocol_environment_015_PtLimaPt.Error_monad.tzresult</a></span>
    <a href="../../Tezos_protocol_environment_015_PtLimaPt/Lwt/index.html#type-t">Tezos_protocol_environment_015_PtLimaPt.Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>form_history_proof ctxt history inbox level_tree</code> creates the skip list structure that includes the current inbox level, while also updating the <code>history</code> and making sure the <code>level_tree</code> has been committed to the <code>ctxt</code>.</p><p>This is used in <code>archive_if_needed</code> to produce the <code>old_levels_messages</code> value for the next level of the inbox. It is also needed if you want to produce a fully-up-to-date skip list for proof production. Just taking the skip list stored in the inbox at <code>old_levels_messages</code> will not include the current level (and that current level could be quite far back in terms of blocks if the inbox hasn't been added to for a while).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-take_snapshot"><a href="#val-take_snapshot" class="anchor"></a><code><span><span class="keyword">val</span> take_snapshot : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-history_proof">history_proof</a></span></code></div><div class="spec-doc"><p>This is similar to <a href="#val-form_history_proof"><code>form_history_proof</code></a> except that it is just to be used on the protocol side because it doesn't ensure the history is remembered or the trees are committed in the context. Used at the beginning of a refutation game to create the snapshot against which proofs in that game must be valid.</p><p>This will however produce a <code>history_proof</code> with exactly the same hash as the one produced by <code>form_history_proof</code>, run on a node with a complete <code>inbox_context</code>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-inclusion_proof"><a href="#type-inclusion_proof" class="anchor"></a><code><span><span class="keyword">type</span> inclusion_proof</span></code></div><div class="spec-doc"><p>Given a inbox <code>A</code> at some level <code>L</code> and another inbox <code>B</code> at some level <code>L' &gt;= L</code>, an <code>inclusion_proof</code> guarantees that <code>A</code> is an older version of <code>B</code>.</p><p>To be more precise, an <code>inclusion_proof</code> guarantees that the previous levels <code>level_tree</code>s of <code>A</code> are included in the previous levels <code>level_tree</code>s of <code>B</code>. The current <code>level_tree</code> of <code>A</code> and <code>B</code> are not considered.</p><p>The size of this proof is O(log_basis (L' - L)).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-inclusion_proof_encoding"><a href="#val-inclusion_proof_encoding" class="anchor"></a><code><span><span class="keyword">val</span> inclusion_proof_encoding : 
  <span><a href="#type-inclusion_proof">inclusion_proof</a> <a href="../../Tezos_protocol_environment_015_PtLimaPt/Data_encoding/index.html#type-t">Tezos_protocol_environment_015_PtLimaPt.Data_encoding.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_inclusion_proof"><a href="#val-pp_inclusion_proof" class="anchor"></a><code><span><span class="keyword">val</span> pp_inclusion_proof : 
  <span><a href="../../Tezos_protocol_environment_015_PtLimaPt/Format/index.html#type-formatter">Tezos_protocol_environment_015_PtLimaPt.Format.formatter</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-inclusion_proof">inclusion_proof</a> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-number_of_proof_steps"><a href="#val-number_of_proof_steps" class="anchor"></a><code><span><span class="keyword">val</span> number_of_proof_steps : <span><a href="#type-inclusion_proof">inclusion_proof</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>number_of_proof_steps proof</code> returns the length of <code>proof</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-verify_inclusion_proof"><a href="#val-verify_inclusion_proof" class="anchor"></a><code><span><span class="keyword">val</span> verify_inclusion_proof : 
  <span><a href="#type-inclusion_proof">inclusion_proof</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-history_proof">history_proof</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-history_proof">history_proof</a> <span class="arrow">&#45;&gt;</span></span>
  bool</span></code></div><div class="spec-doc"><p><code>verify_inclusion_proof proof a b</code> returns <code>true</code> iff <code>proof</code> is a minimal and valid proof that <code>a</code> is included in <code>b</code>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-proof"><a href="#type-proof" class="anchor"></a><code><span><span class="keyword">type</span> proof</span></code></div><div class="spec-doc"><p>An inbox proof has three parameters:</p><ul><li>the <code>starting_point</code>, of type <code>Raw_level_repr.t * Z.t</code>, specifying a location in the inbox ;</li></ul><ul><li>the <code>message</code>, of type <code>Sc_rollup_PVM_sig.input option</code> ;</li></ul><ul><li>and a reference <code>snapshot</code> inbox.</li></ul><p>A valid inbox proof implies the following semantics: beginning at <code>starting_point</code> and reading forward through <code>snapshot</code>, the first message you reach will be <code>message</code>.</p><p>Usually this is fairly simple because there will actually be a message at the location specified by <code>starting_point</code>. But in some cases <code>starting_point</code> is past the last message within a level, and then the inbox proof must prove that and also provide another proof about the message at the beginning of the next non-empty level.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_proof"><a href="#val-pp_proof" class="anchor"></a><code><span><span class="keyword">val</span> pp_proof : 
  <span><a href="../../Tezos_protocol_environment_015_PtLimaPt/Format/index.html#type-formatter">Tezos_protocol_environment_015_PtLimaPt.Format.formatter</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-proof">proof</a> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_serialized_proof"><a href="#val-to_serialized_proof" class="anchor"></a><code><span><span class="keyword">val</span> to_serialized_proof : <span><a href="#type-proof">proof</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-serialized_proof">serialized_proof</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_serialized_proof"><a href="#val-of_serialized_proof" class="anchor"></a><code><span><span class="keyword">val</span> of_serialized_proof : <span><a href="#type-serialized_proof">serialized_proof</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-proof">proof</a> option</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-verify_proof"><a href="#val-verify_proof" class="anchor"></a><code><span><span class="keyword">val</span> verify_proof : 
  <span><span>(<a href="../Raw_level_repr/index.html#type-t">Raw_level_repr.t</a> * <a href="../../Tezos_protocol_environment_015_PtLimaPt/Z/index.html#type-t">Tezos_protocol_environment_015_PtLimaPt.Z.t</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-history_proof">history_proof</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-proof">proof</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span><a href="../Sc_rollup_PVM_sig/index.html#type-inbox_message">Sc_rollup_PVM_sig.inbox_message</a> option</span>
    <a href="../../Tezos_protocol_environment_015_PtLimaPt/Error_monad/index.html#type-tzresult">Tezos_protocol_environment_015_PtLimaPt.Error_monad.tzresult</a></span>
    <a href="../../Tezos_protocol_environment_015_PtLimaPt/Lwt/index.html#type-t">Tezos_protocol_environment_015_PtLimaPt.Lwt.t</a></span></span></code></div><div class="spec-doc"><p>See the docstring for the <code>proof</code> type for details of proof semantics.</p><p><code>verify_proof starting_point inbox proof</code> will return the third parameter of the proof, <code>message</code>, iff the proof is valid.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-produce_proof"><a href="#val-produce_proof" class="anchor"></a><code><span><span class="keyword">val</span> produce_proof : 
  <span><a href="#type-inbox_context">inbox_context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="History/index.html#type-t">History.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-history_proof">history_proof</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../Raw_level_repr/index.html#type-t">Raw_level_repr.t</a> * <a href="../../Tezos_protocol_environment_015_PtLimaPt/Z/index.html#type-t">Tezos_protocol_environment_015_PtLimaPt.Z.t</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="#type-proof">proof</a> * <span><a href="../Sc_rollup_PVM_sig/index.html#type-inbox_message">Sc_rollup_PVM_sig.inbox_message</a> option</span>)</span>
    <a href="../../Tezos_protocol_environment_015_PtLimaPt/Error_monad/index.html#type-tzresult">Tezos_protocol_environment_015_PtLimaPt.Error_monad.tzresult</a></span>
    <a href="../../Tezos_protocol_environment_015_PtLimaPt/Lwt/index.html#type-t">Tezos_protocol_environment_015_PtLimaPt.Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>produce_proof ctxt history inbox (level, counter)</code> creates an inbox proof proving the first message after the index <code>counter</code> at location <code>level</code>. This will fail if the <code>ctxt</code> given doesn't have sufficient data (it needs to be run on an <code>inbox_context</code> with the full history).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : 
  <span><a href="#type-inbox_context">inbox_context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Sc_rollup_repr/index.html#type-t">Sc_rollup_repr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Raw_level_repr/index.html#type-t">Raw_level_repr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <a href="../../Tezos_protocol_environment_015_PtLimaPt/Lwt/index.html#type-t">Tezos_protocol_environment_015_PtLimaPt.Lwt.t</a></span></span></code></div><div class="spec-doc"><p><code>empty ctxt level</code> is an inbox started at some given <code>level</code> with no message at all.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Internal_for_tests"><a href="#module-Internal_for_tests" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Internal_for_tests/index.html">Internal_for_tests</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div></details></div><div class="odoc-spec"><div class="spec type anchored" id="type-inbox"><a href="#type-inbox" class="anchor"></a><code><span><span class="keyword">type</span> inbox</span><span> = <a href="#type-t">t</a></span></code></div></div></div></body></html>
