<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>G1 (bls12-381.Bls12_381.G1)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">bls12-381</a> &#x00BB; <a href="../index.html">Bls12_381</a> &#x00BB; G1</nav><header class="odoc-preamble"><h1>Module <code><span>Bls12_381.G1</span></code></h1><p>Elliptic curve built over the field <code>Fq</code> and the equation <code>y^2 = x^3 + 4</code></p></header><div class="odoc-content"><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../module-type-CURVE/index.html">CURVE</a></span></code></summary><div class="odoc-spec"><div class="spec exception anchored" id="exception-Not_on_curve"><a href="#exception-Not_on_curve" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Not_on_curve</span> <span class="keyword">of</span> <span class="xref-unresolved">Stdlib</span>.Bytes.t</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>The type of the element on the curve and in the prime subgroup. The point is given in jacobian coordinates</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-affine"><a href="#type-affine" class="anchor"></a><code><span><span class="keyword">type</span> affine</span></code></div><div class="spec-doc"><p>An element on the curve and in the prime subgroup, in affine coordinates</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-affine_of_jacobian"><a href="#val-affine_of_jacobian" class="anchor"></a><code><span><span class="keyword">val</span> affine_of_jacobian : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-affine">affine</a></span></code></div><div class="spec-doc"><p><code>affine_of_jacobian p</code> creates a new value of type <code>affine</code> representing the point <code>p</code> in affine coordinates</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-jacobian_of_affine"><a href="#val-jacobian_of_affine" class="anchor"></a><code><span><span class="keyword">val</span> jacobian_of_affine : <span><a href="#type-affine">affine</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>jacobian_of_affine p</code> creates a new value of type <code>t</code> representing the point <code>p</code> in jacobian coordinates</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-affine_array"><a href="#type-affine_array" class="anchor"></a><code><span><span class="keyword">type</span> affine_array</span></code></div><div class="spec-doc"><p>Contiguous C array containing points in affine coordinates</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_affine_array"><a href="#val-to_affine_array" class="anchor"></a><code><span><span class="keyword">val</span> to_affine_array : <span><span><a href="#type-t">t</a> array</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-affine_array">affine_array</a></span></code></div><div class="spec-doc"><p><code>to_affine_array pts</code> builds a contiguous C array and populate it with the points <code>pts</code> in affine coordinates. Use it with <a href="#val-pippenger_with_affine_array"><code>pippenger_with_affine_array</code></a> to get better performance.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_affine_array"><a href="#val-of_affine_array" class="anchor"></a><code><span><span class="keyword">val</span> of_affine_array : <span><a href="#type-affine_array">affine_array</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> array</span></span></code></div><div class="spec-doc"><p>Build a OCaml array of <code>t</code> values from the contiguous C array</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-size_of_affine_array"><a href="#val-size_of_affine_array" class="anchor"></a><code><span><span class="keyword">val</span> size_of_affine_array : <span><a href="#type-affine_array">affine_array</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Return the number of elements in the array</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-size_in_memory"><a href="#val-size_in_memory" class="anchor"></a><code><span><span class="keyword">val</span> size_in_memory : int</span></code></div><div class="spec-doc"><p>Actual number of bytes allocated for a value of type t</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compressed_size_in_bytes"><a href="#val-compressed_size_in_bytes" class="anchor"></a><code><span><span class="keyword">val</span> compressed_size_in_bytes : int</span></code></div><div class="spec-doc"><p>Size in bytes for the compressed representation</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-size_in_bytes"><a href="#val-size_in_bytes" class="anchor"></a><code><span><span class="keyword">val</span> size_in_bytes : int</span></code></div><div class="spec-doc"><p>The size of a point representation, in bytes</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Scalar"><a href="#module-Scalar" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Scalar/index.html">Scalar</a></span><span> : <a href="../Ff_sig/module-type-PRIME/index.html">Ff_sig.PRIME</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../Ff_sig/module-type-PRIME/index.html#type-t">t</a> = <a href="../Fr/index.html#type-t">Fr.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-check_bytes"><a href="#val-check_bytes" class="anchor"></a><code><span><span class="keyword">val</span> check_bytes : <span><span class="xref-unresolved">Stdlib</span>.Bytes.t <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Check if a point, represented as a byte array, is on the curve and in the prime subgroup. The bytes must be of length <a href="#val-size_in_bytes"><code>size_in_bytes</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_bytes_opt"><a href="#val-of_bytes_opt" class="anchor"></a><code><span><span class="keyword">val</span> of_bytes_opt : <span><span class="xref-unresolved">Stdlib</span>.Bytes.t <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> option</span></span></code></div><div class="spec-doc"><p>Attempt to construct a point from a byte array of length <a href="#val-size_in_bytes"><code>size_in_bytes</code></a>. Return <code>None</code> if the bytes do not represent a point on the curve and in the prime subgroup.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_bytes_exn"><a href="#val-of_bytes_exn" class="anchor"></a><code><span><span class="keyword">val</span> of_bytes_exn : <span><span class="xref-unresolved">Stdlib</span>.Bytes.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Attempt to construct a point from a byte array of length <a href="#val-size_in_bytes"><code>size_in_bytes</code></a>. Raise <a href="#exception-Not_on_curve"><code>Not_on_curve</code></a> if the point is not on the curve and in the prime subgroup.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_compressed_bytes_opt"><a href="#val-of_compressed_bytes_opt" class="anchor"></a><code><span><span class="keyword">val</span> of_compressed_bytes_opt : <span><span class="xref-unresolved">Stdlib</span>.Bytes.t <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> option</span></span></code></div><div class="spec-doc"><p>Allocates a new point from a byte of length <code>size_in_bytes / 2</code> array representing a point in compressed form. Return <code>None</code> if the bytes do not represent a point on the curve and in the prime subgroup.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_compressed_bytes_exn"><a href="#val-of_compressed_bytes_exn" class="anchor"></a><code><span><span class="keyword">val</span> of_compressed_bytes_exn : <span><span class="xref-unresolved">Stdlib</span>.Bytes.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Allocates a new point from a byte array of length <code>size_in_bytes / 2</code> representing a point in compressed form. Raise <a href="#exception-Not_on_curve"><code>Not_on_curve</code></a> if the point is not on the curve and in the prime subgroup.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_bytes"><a href="#val-to_bytes" class="anchor"></a><code><span><span class="keyword">val</span> to_bytes : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Stdlib</span>.Bytes.t</span></code></div><div class="spec-doc"><p>Return a representation in bytes</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_compressed_bytes"><a href="#val-to_compressed_bytes" class="anchor"></a><code><span><span class="keyword">val</span> to_compressed_bytes : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Stdlib</span>.Bytes.t</span></code></div><div class="spec-doc"><p>Return a compressed bytes representation</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-zero"><a href="#val-zero" class="anchor"></a><code><span><span class="keyword">val</span> zero : <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Zero of the elliptic curve</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-one"><a href="#val-one" class="anchor"></a><code><span><span class="keyword">val</span> one : <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>A fixed generator of the elliptic curve</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_zero"><a href="#val-is_zero" class="anchor"></a><code><span><span class="keyword">val</span> is_zero : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Return <code>true</code> if the given element is zero</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-copy"><a href="#val-copy" class="anchor"></a><code><span><span class="keyword">val</span> copy : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>copy x</code> return a fresh copy of <code>x</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-random"><a href="#val-random" class="anchor"></a><code><span><span class="keyword">val</span> random : <span><span class="optlabel">?state</span>:<span class="xref-unresolved">Stdlib</span>.Random.State.t <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Generate a random element. The function ensures the element is on the curve and in the prime subgroup.</p><p>The routines in the module <code>Random.State</code> are used to generate the elements. A state can be given to the function to be used. If no state is given, <code>Random.get_state</code> is used.</p><p>To create a value of type <code>Random.State.t</code>, you can use <code>Random.State.make
      [|42|]</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add"><a href="#val-add" class="anchor"></a><code><span><span class="keyword">val</span> add : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Return the addition of two element</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_inplace"><a href="#val-add_inplace" class="anchor"></a><code><span><span class="keyword">val</span> add_inplace : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>add_inplace a b</code> is the same than <a href="#val-add"><code>add</code></a> but writes the output in <code>a</code>. No allocation happens.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_bulk"><a href="#val-add_bulk" class="anchor"></a><code><span><span class="keyword">val</span> add_bulk : <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>add_bulk xs</code> returns the sum of the elements of <code>xs</code> by performing only one allocation for the output. This method is recommended to save the allocation overhead of using <code>n</code> times <a href="#val-add"><code>add</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-double"><a href="#val-double" class="anchor"></a><code><span><span class="keyword">val</span> double : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>double g</code> returns <code>2g</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-negate"><a href="#val-negate" class="anchor"></a><code><span><span class="keyword">val</span> negate : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Return the opposite of the element</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-eq"><a href="#val-eq" class="anchor"></a><code><span><span class="keyword">val</span> eq : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Return <code>true</code> if the two elements are algebraically the same</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mul"><a href="#val-mul" class="anchor"></a><code><span><span class="keyword">val</span> mul : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="Scalar/index.html#type-t">Scalar.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Multiply an element by a scalar</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mul_inplace"><a href="#val-mul_inplace" class="anchor"></a><code><span><span class="keyword">val</span> mul_inplace : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="Scalar/index.html#type-t">Scalar.t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>mul_inplace g x</code> is the same than <a href="#val-mul"><code>mul</code></a> but writes the output in <code>g</code>. No allocation happens.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-hash_to_curve"><a href="#val-hash_to_curve" class="anchor"></a><code><span><span class="keyword">val</span> hash_to_curve : <span><span class="xref-unresolved">Stdlib</span>.Bytes.t <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Stdlib</span>.Bytes.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>hash_to_curve msg dst</code> follows the standard <a href="https://www.ietf.org/archive/id/draft-irtf-cfrg-hash-to-curve-14.txt">Hashing to Elliptic Curves</a> applied to BLS12-381</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pippenger"><a href="#val-pippenger" class="anchor"></a><code><span><span class="keyword">val</span> pippenger : <span><span class="optlabel">?start</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?len</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> array</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="Scalar/index.html#type-t">Scalar.t</a> array</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>pippenger ?start ?len pts scalars</code> computes the multi scalar exponentiation/multiplication. The scalars are given in <code>scalars</code> and the points in <code>pts</code>. If <code>pts</code> and <code>scalars</code> are not of the same length, perform the computation on the first <code>n</code> points where <code>n</code> is the smallest size. Arguments <code>start</code> and <code>len</code> can be used to take advantages of multicore OCaml. Default value for <code>start</code> (resp. <code>len</code>) is <code>0</code> (resp. the length of the array <code>scalars</code>).</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Invalid_argument</code> <p>if <code>start</code> or <code>len</code> would infer out of bounds array access.</p><p>Perform allocations on the C heap to convert scalars to bytes and to convert the points <code>pts</code> in affine coordinates as values of type <code>t</code> are in jacobian coordinates.</p><p><b>Warning.</b> Undefined behavior if the point to infinity is in the array</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pippenger_with_affine_array"><a href="#val-pippenger_with_affine_array" class="anchor"></a><code><span><span class="keyword">val</span> pippenger_with_affine_array : 
  <span><span class="optlabel">?start</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?len</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-affine_array">affine_array</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="Scalar/index.html#type-t">Scalar.t</a> array</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>pippenger_with_affine_array ?start ?len pts scalars</code> computes the multi scalar exponentiation/multiplication. The scalars are given in <code>scalars</code> and the points in <code>pts</code>. If <code>pts</code> and <code>scalars</code> are not of the same length, perform the computation on the first <code>n</code> points where <code>n</code> is the smallest length. The differences with <a href="#val-pippenger"><code>pippenger</code></a> are 1. the points are loaded in a contiguous C array to speed up the access to the elements by relying on the CPU cache 2. and the points are in affine coordinates, the form expected by the algorithm implementation, avoiding new allocations and field inversions required to convert from jacobian (representation of a points of type <code>t</code>, as expected by <a href="#val-pippenger"><code>pippenger</code></a>) to affine coordinates. Expect a speed improvement around 20% compared to <a href="#val-pippenger"><code>pippenger</code></a>, and less allocation on the C heap. A value of <code>affine_array</code> can be built using <a href="#val-to_affine_array"><code>to_affine_array</code></a>. Arguments <code>start</code> and <code>len</code> can be used to take advantages of multicore OCaml. Default value for <code>start</code> (resp. <code>len</code>) is <code>0</code> (resp. the length of the array <code>scalars</code>).</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Invalid_argument</code> <p>if <code>start</code> or <code>len</code> would infer out of bounds array access.</p><p>Perform allocations on the C heap to convert scalars to bytes.</p><p><b>Warning.</b> Undefined behavior if the point to infinity is in the array</p></li></ul></div></div></details></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_z_opt"><a href="#val-of_z_opt" class="anchor"></a><code><span><span class="keyword">val</span> of_z_opt : <span><span class="label">x</span>:<span class="xref-unresolved">Z</span>.t <span class="arrow">&#45;&gt;</span></span> <span><span class="label">y</span>:<span class="xref-unresolved">Z</span>.t <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> option</span></span></code></div><div class="spec-doc"><p>Create a point from the coordinates. If the point is not on the curve and in the prime subgroup,returns <code>None</code>. The points must be given modulo the order of <code>Fq</code>. To create the point at infinity, use <a href="#val-zero"><code>zero</code></a></p></div></div></div></body></html>
