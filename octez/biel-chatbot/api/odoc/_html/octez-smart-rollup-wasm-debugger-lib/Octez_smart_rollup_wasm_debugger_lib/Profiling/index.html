<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Profiling (octez-smart-rollup-wasm-debugger-lib.Octez_smart_rollup_wasm_debugger_lib.Profiling)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">octez-smart-rollup-wasm-debugger-lib</a> &#x00BB; <a href="../index.html">Octez_smart_rollup_wasm_debugger_lib</a> &#x00BB; Profiling</nav><header class="odoc-preamble"><h1>Module <code><span>Octez_smart_rollup_wasm_debugger_lib.Profiling</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec module anchored" id="module-Vector"><a href="#module-Vector" class="anchor"></a><code><span><span class="keyword">module</span> Vector</span><span> = <a href="../../../octez-libs/Tezos_lazy_containers/Lazy_vector/Int32Vector/index.html">Tezos_lazy_containers.Lazy_vector.Int32Vector</a></span></code></div></div><p>Call stack representation and construction.</p><p>The call stack computation algorithm is the following:</p><p>There are two components: the current node (or stack frame) and the continuation (a list of stack frames). There's a &quot;toplevel node&quot; describing the execution at the toplevel of the interpreter. A node contains:</p><ul><li><code>id</code>: a function call representation (an identifier)</li><li><code>t</code>: the ticks elapsed during the call</li><li><code>time</code>: the time elapsed during the call</li><li><code>sub</code>: the subcalls.</li></ul><p>Note that for the rest of the algorithm, `time` will be eluded as its computation is equivalent to the ticks.</p><p>The algorithm starts with an empty toplevel and an empty continuation.</p><ul><li>on function call (id, current_tick, current_node, continuation): 1. create a node N_id: (id, t: current_tick, sub:) 2. update current_node N_curr with t:(current_tick - t) =&gt; the number of ticks is now the diff between the moment the call started and the subcall started. 3. push N_curr on the continuation 4. return N_id, continuation</li></ul><ul><li>on function end (current_tick, current_node, continuation): 1. update current_node N_curr with t:(current_tick - t) 2. pop N_prev from the continuation 3. update N_prev: t:(current_tick - t) sub:(sub + N_curr) 4. return N_prev, continuation</li></ul><p>Let's take an example: call: f () { ...... g () { .... h () { ...... } .......... } ......... } tick: 0 ----------&gt; 10 -------&gt; 30 ---------&gt; 60 --------&gt; 100 -----&gt; 160 <code>  10 ticks  </code> <code> 20 ticks </code> <code> 30 ticks </code> <code> 40 ticks </code> <code> 60 ticks </code></p><ul><li>`f` takes 10 + 60 = 70 ticks</li><li>`g` takes 20 + 40 = 60 ticks</li><li>`h` takes 30 ticks</li></ul><p>T (<code>nodes</code>) : toplevel K : continuation (list) N : current node (N(id) means it hasn't changed from previous step)</p><p>N, K |- exec</p><p>Start: T,  |- f () { g () { h () { } } } ==&gt; at tick 0 N (f, 0, ), <code>T</code> |- g () { h () { } } } ==&gt; at tick 10 N (g, 10, ), <code>N (f, 10 - 0 = 10, []); T</code> |- h () { } } } ==&gt; at tick 30 N (h, 30, ), <code>N (g, 30 - 10 = 20, []); N(f); T</code> |- } } } ==&gt; at tick 60 N (g, 60 - 20 = 40, <code>N (h, 60 - 30 = 30, [])</code>), <code>N(f); T</code> |- } } ==&gt; at tick 100 N (f, 100 - 10 = 90, <code>N (g, 100 - 40 = 60, [N(h)])</code>), <code>T</code> |- } ==&gt; at tick 160 T <code>N (f, 160 - 90 = 70, [N(g, 60, [N(h, 30, [])])])</code>,  |- _</p><div class="odoc-spec"><div class="spec type anchored" id="type-call_stack"><a href="#type-call_stack" class="anchor"></a><code><span><span class="keyword">type</span> <span>'function_call call_stack</span></span><span> = </span></code><ol><li id="type-call_stack.Node" class="def variant constructor anchored"><a href="#type-call_stack.Node" class="anchor"></a><code><span>| </span><span><span class="constructor">Node</span> <span class="keyword">of</span> <span class="type-var">'function_call</span>
  * <span class="xref-unresolved">Z</span>.t
  * <span><span class="xref-unresolved">Ptime</span>.span option</span>
  * <span><span><span class="type-var">'function_call</span> <a href="#type-call_stack">call_stack</a></span> list</span></span></code></li><li id="type-call_stack.Toplevel" class="def variant constructor anchored"><a href="#type-call_stack.Toplevel" class="anchor"></a><code><span>| </span><span><span class="constructor">Toplevel</span> <span class="keyword">of</span> <span><span><span class="type-var">'function_call</span> <a href="#type-call_stack">call_stack</a></span> list</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold_call_stack"><a href="#val-fold_call_stack" class="anchor"></a><code><span><span class="keyword">val</span> fold_call_stack : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Z</span>.t <span class="arrow">&#45;&gt;</span></span> <span><span><span class="xref-unresolved">Ptime</span>.span option</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> <a href="#type-call_stack">call_stack</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'a</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sub_opt_times"><a href="#val-sub_opt_times" class="anchor"></a><code><span><span class="keyword">val</span> sub_opt_times : <span><span><span class="xref-unresolved">Ptime</span>.span option</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="xref-unresolved">Ptime</span>.span option</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Ptime</span>.span option</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_opt_times"><a href="#val-add_opt_times" class="anchor"></a><code><span><span class="keyword">val</span> add_opt_times : <span><span><span class="xref-unresolved">Ptime</span>.span option</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="xref-unresolved">Ptime</span>.span option</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Ptime</span>.span option</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-end_function_call"><a href="#val-end_function_call" class="anchor"></a><code><span><span class="keyword">val</span> end_function_call : 
  <span><span class="xref-unresolved">Z</span>.t <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Ptime</span>.span option</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-call_stack">call_stack</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span><span class="type-var">'a</span> <a href="#type-call_stack">call_stack</a></span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="#type-call_stack">call_stack</a></span> * <span><span><span class="type-var">'a</span> <a href="#type-call_stack">call_stack</a></span> list</span></span></code></div><div class="spec-doc"><p><code>end_function_call current_tick current_function call_stack</code> implements an ending call. Please refer to the prelude of the file.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-call_function"><a href="#val-call_function" class="anchor"></a><code><span><span class="keyword">val</span> call_function : 
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Z</span>.t <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Ptime</span>.span option</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> <a href="#type-call_stack">call_stack</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span><span class="type-var">'b</span> <a href="#type-call_stack">call_stack</a></span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="#type-call_stack">call_stack</a></span> * <span><span><span class="type-var">'b</span> <a href="#type-call_stack">call_stack</a></span> list</span></span></code></div><div class="spec-doc"><p><code>call_function called_function current_tick current_function call_stack</code> implements a function start. Please refere to the prelude of the module.</p></div></div><p>Profiling the execution of the PVM</p><div class="odoc-spec"><div class="spec type anchored" id="type-function_call"><a href="#type-function_call" class="anchor"></a><code><span><span class="keyword">type</span> function_call</span><span> = </span></code><ol><li id="type-function_call.Function" class="def variant constructor anchored"><a href="#type-function_call.Function" class="anchor"></a><code><span>| </span><span><span class="constructor">Function</span> <span class="keyword">of</span> string</span></code></li><li id="type-function_call.CallDirect" class="def variant constructor anchored"><a href="#type-function_call.CallDirect" class="anchor"></a><code><span>| </span><span><span class="constructor">CallDirect</span> <span class="keyword">of</span> int32</span></code></li><li id="type-function_call.CallRef" class="def variant constructor anchored"><a href="#type-function_call.CallRef" class="anchor"></a><code><span>| </span><span><span class="constructor">CallRef</span> <span class="keyword">of</span> int32</span></code></li><li id="type-function_call.Internal" class="def variant constructor anchored"><a href="#type-function_call.Internal" class="anchor"></a><code><span>| </span><span><span class="constructor">Internal</span> <span class="keyword">of</span> string</span></code></li></ol></div><div class="spec-doc"><p>A function call can be either a direct call, a call through a reference or an internal step of the PVM.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_call"><a href="#val-pp_call" class="anchor"></a><code><span><span class="keyword">val</span> pp_call : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-function_call">function_call</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-initial_eval_call"><a href="#val-initial_eval_call" class="anchor"></a><code><span><span class="keyword">val</span> initial_eval_call : <a href="#type-function_call">function_call</a></span></code></div><div class="spec-doc"><p><code>initial_eval_call</code> is `kernel_run` function call.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-update_on_decode"><a href="#val-update_on_decode" class="anchor"></a><code><span><span class="keyword">val</span> update_on_decode : 
  <span><span class="xref-unresolved">Z</span>.t <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Ptime</span>.span option</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> <a href="#type-call_stack">call_stack</a></span> * <span><span><span class="type-var">'a</span> <a href="#type-call_stack">call_stack</a></span> list</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../octez-libs/Tezos_webassembly_interpreter/Decode/index.html#type-module_kont">Tezos_webassembly_interpreter.Decode.module_kont</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><a href="#type-function_call">function_call</a> <a href="#type-call_stack">call_stack</a></span> * <span><span><span class="type-var">'a</span> <a href="#type-call_stack">call_stack</a></span> list</span>)</span> option</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>update_on_decode current_tick current_call_state</code> starts and stop `internal` calls related to the <b>Decode</b> step of the PVM.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-update_on_link"><a href="#val-update_on_link" class="anchor"></a><code><span><span class="keyword">val</span> update_on_link : 
  <span><span class="xref-unresolved">Z</span>.t <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Ptime</span>.span option</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> <a href="#type-call_stack">call_stack</a></span> * <span><span><span class="type-var">'a</span> <a href="#type-call_stack">call_stack</a></span> list</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../../octez-libs/Tezos_webassembly_interpreter/Ast/index.html#type-module_'">Tezos_webassembly_interpreter.Ast.module_'</a>
    <a href="../../../octez-libs/Tezos_webassembly_interpreter/Source/index.html#type-phrase">Tezos_webassembly_interpreter.Source.phrase</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../octez-libs/Tezos_lazy_containers/Lazy_vector/Int32Vector/index.html#type-key">Vector.key</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><a href="#type-function_call">function_call</a> <a href="#type-call_stack">call_stack</a></span> * <span><span><span class="type-var">'a</span> <a href="#type-call_stack">call_stack</a></span> list</span>)</span> option</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>update_on_link current_tick current_call_state</code> starts and stop `internal` call to the <b>Link</b> step of the PVM.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-update_on_init"><a href="#val-update_on_init" class="anchor"></a><code><span><span class="keyword">val</span> update_on_init : 
  <span><span class="xref-unresolved">Z</span>.t <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Ptime</span>.span option</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> <a href="#type-call_stack">call_stack</a></span> * <span><span><span class="type-var">'a</span> <a href="#type-call_stack">call_stack</a></span> list</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../octez-libs/Tezos_webassembly_interpreter/Eval/index.html#type-init_kont">Tezos_webassembly_interpreter.Eval.init_kont</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><a href="#type-function_call">function_call</a> <a href="#type-call_stack">call_stack</a></span> * <span><span><span class="type-var">'a</span> <a href="#type-call_stack">call_stack</a></span> list</span>)</span> option</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>update_on_init current_tick current_call_state</code> starts and stop `internal` call to the <b>Init</b> step of the PVM.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-update_on_instr"><a href="#val-update_on_instr" class="anchor"></a><code><span><span class="keyword">val</span> update_on_instr : 
  <span><span class="xref-unresolved">Z</span>.t <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Ptime</span>.span option</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-call_stack">call_stack</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span><span class="type-var">'a</span> <a href="#type-call_stack">call_stack</a></span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>string <a href="../Custom_section/FuncMap/index.html#type-t">Custom_section.FuncMap.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../octez-libs/Tezos_webassembly_interpreter/Eval/index.html#type-admin_instr'">Tezos_webassembly_interpreter.Eval.admin_instr'</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><a href="#type-function_call">function_call</a> <a href="#type-call_stack">call_stack</a></span> * <span><span><span class="type-var">'a</span> <a href="#type-call_stack">call_stack</a></span> list</span>)</span> option</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>update_on_instr current_tick current_node call_stack</code> handle function calls during the evaluation.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-update_on_eval"><a href="#val-update_on_eval" class="anchor"></a><code><span><span class="keyword">val</span> update_on_eval : 
  <span><span class="xref-unresolved">Z</span>.t <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Ptime</span>.span option</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-function_call">function_call</a> <a href="#type-call_stack">call_stack</a></span> * <span><span><a href="#type-function_call">function_call</a> <a href="#type-call_stack">call_stack</a></span> list</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>string <a href="../Custom_section/FuncMap/index.html#type-t">Custom_section.FuncMap.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../octez-libs/Tezos_webassembly_interpreter/Eval/index.html#type-step_kont">Tezos_webassembly_interpreter.Eval.step_kont</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><a href="#type-function_call">function_call</a> <a href="#type-call_stack">call_stack</a></span> * <span><span><a href="#type-function_call">function_call</a> <a href="#type-call_stack">call_stack</a></span> list</span>)</span> option</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>update_on_eval current_tick current_call_state</code> handle function calls and end during the evaluation.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-update_call_stack"><a href="#val-update_call_stack" class="anchor"></a><code><span><span class="keyword">val</span> update_call_stack : 
  <span><span class="xref-unresolved">Z</span>.t <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Ptime</span>.span option</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-function_call">function_call</a> <a href="#type-call_stack">call_stack</a></span> * <span><span><a href="#type-function_call">function_call</a> <a href="#type-call_stack">call_stack</a></span> list</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>string <a href="../Custom_section/FuncMap/index.html#type-t">Custom_section.FuncMap.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../octez-libs/Tezos_scoru_wasm/Wasm_pvm_state/Internal_state/index.html#type-tick_state">Tezos_scoru_wasm.Wasm_pvm_state.Internal_state.tick_state</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><a href="#type-function_call">function_call</a> <a href="#type-call_stack">call_stack</a></span> * <span><span><a href="#type-function_call">function_call</a> <a href="#type-call_stack">call_stack</a></span> list</span>)</span> option</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>update_call_stack current_tick current_state_call symbols state</code> returns the call state changes for any state. Returns <code>None</code> if no change happened.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-State"><a href="#module-State" class="anchor"></a><code><span><span class="keyword">module</span> <a href="State/index.html">State</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Make"><a href="#module-Make" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Make/index.html">Make</a></span><span>
  (<a href="Make/argument-1-Wasm_utils/index.html">Wasm_utils</a> : <a href="../../../octez-l2-libs/Tezos_scoru_wasm_helpers_intf/Wasm_utils_intf/module-type-S/index.html">Tezos_scoru_wasm_helpers_intf.Wasm_utils_intf.S</a>) : 
  <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><p>Flamegraph building</p><p>Flamegraph are an aggregation of all the same callstacks, thus there is no longer a notion of time. We can easily collapse all nodes into a single one.</p><div class="odoc-spec"><div class="spec module anchored" id="module-StringMap"><a href="#module-StringMap" class="anchor"></a><code><span><span class="keyword">module</span> <a href="StringMap/index.html">StringMap</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-collapse_stack"><a href="#val-collapse_stack" class="anchor"></a><code><span><span class="keyword">val</span> collapse_stack : 
  <span><span class="label">max_depth</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-call_stack">call_stack</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="StringMap/index.html#type-key">StringMap.key</a> * <span class="xref-unresolved">Z</span>.t)</span> list</span></span></code></div><div class="spec-doc"><p><code>collapse_stack ~max_depth pp_call call_stack</code> collapses a call stack into a valid flamegraph. Node deeper than <code>max_depth</code> are not considered. <code>pp_call</code> is used to print the identifiers.</p></div></div><p>Pretty printing and flamegraph output</p><div class="odoc-spec"><div class="spec value anchored" id="val-pp_indent"><a href="#val-pp_indent" class="anchor"></a><code><span><span class="keyword">val</span> pp_indent : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>pp_indent ppf depth</code> prints an indentation corresponding to the given <code>depth</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_time_opt"><a href="#val-pp_time_opt" class="anchor"></a><code><span><span class="keyword">val</span> pp_time_opt : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span><span class="xref-unresolved">Ptime</span>.span option</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_nodes"><a href="#val-pp_nodes" class="anchor"></a><code><span><span class="keyword">val</span> pp_nodes : 
  <span><span class="optlabel">?max_depth</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span><span><span class="type-var">'a</span> <a href="#type-call_stack">call_stack</a></span> list</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_stack"><a href="#val-pp_stack" class="anchor"></a><code><span><span class="keyword">val</span> pp_stack : 
  <span><span class="optlabel">?max_depth</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-call_stack">call_stack</a></span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>pp_stack ~max_depth ppf stack</code> pretty prints the stack. It should be used for debug only.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_flame_callstack_node"><a href="#val-pp_flame_callstack_node" class="anchor"></a><code><span><span class="keyword">val</span> pp_flame_callstack_node : 
  <span><span class="label">prefix</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">depth</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">max_depth</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-call_stack">call_stack</a></span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_flame_callstack_nodes"><a href="#val-pp_flame_callstack_nodes" class="anchor"></a><code><span><span class="keyword">val</span> pp_flame_callstack_nodes : 
  <span><span class="label">prefix</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">depth</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">max_depth</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span><span><span class="type-var">'a</span> <a href="#type-call_stack">call_stack</a></span> list</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_callstack_as_flamegraph"><a href="#val-pp_callstack_as_flamegraph" class="anchor"></a><code><span><span class="keyword">val</span> pp_callstack_as_flamegraph : 
  <span><span class="label">max_depth</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-call_stack">call_stack</a></span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>pp_callstack_as_flamegraph</code> if <code>pp_stack</code> with the syntax of flamegraphs.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_collapsed_flamegraph"><a href="#val-pp_collapsed_flamegraph" class="anchor"></a><code><span><span class="keyword">val</span> pp_collapsed_flamegraph : 
  <span><span class="label">max_depth</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-call_stack">call_stack</a></span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>pp_flamegraph</code> collapses the stack and print it as a valid flamegraph.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_flamegraph"><a href="#val-pp_flamegraph" class="anchor"></a><code><span><span class="keyword">val</span> pp_flamegraph : 
  <span><span class="label">collapse</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">max_depth</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-call_stack">call_stack</a></span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>pp_flamegraph ~collapsed ~max_depth pp_call ppf call_stack</code> outputs the given <code>call_stack</code> with its `flamegraph` representation. If <code>collapse =
    true</code>, the stacks are collapsed. This can be useful to output smaller files, but the stack cannot be analyzed on a time basis (i.e. as a flamechart).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-aggregate_toplevel_time_and_ticks"><a href="#val-aggregate_toplevel_time_and_ticks" class="anchor"></a><code><span><span class="keyword">val</span> aggregate_toplevel_time_and_ticks : 
  <span><span><span class="type-var">'a</span> <a href="#type-call_stack">call_stack</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span> * <span class="xref-unresolved">Z</span>.t * <span><span class="xref-unresolved">Ptime</span>.span option</span>)</span> list</span></span></code></div><div class="spec-doc"><p><code>aggregate_toplevel_time_and_ticks ~call_stack</code> counts the time and ticks spent in each toplevel phases during an execution.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-full_ticks_and_time"><a href="#val-full_ticks_and_time" class="anchor"></a><code><span><span class="keyword">val</span> full_ticks_and_time : 
  <span><span><span>(<span class="type-var">'a</span> * <span class="xref-unresolved">Z</span>.t * <span><span class="xref-unresolved">Ptime</span>.span option</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Z</span>.t * <span><span class="xref-unresolved">Ptime</span>.span option</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_ticks_and_time"><a href="#val-pp_ticks_and_time" class="anchor"></a><code><span><span class="keyword">val</span> pp_ticks_and_time : 
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="#type-function_call">function_call</a> * <span class="xref-unresolved">Z</span>.t * <span><span class="xref-unresolved">Ptime</span>.span option</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div></div></div></body></html>
