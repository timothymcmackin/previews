<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Data_encoding (octez-proto-libs.Tezos_protocol_environment_structs.V9.Data_encoding)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">octez-proto-libs</a> &#x00BB; <a href="../../index.html">Tezos_protocol_environment_structs</a> &#x00BB; <a href="../index.html">V9</a> &#x00BB; Data_encoding</nav><header class="odoc-preamble"><h1>Module <code><span>V9.Data_encoding</span></code></h1></header><div class="odoc-content"><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <span class="keyword">struct</span> <span class="keyword">include</span> <a href="../../../../octez-libs/Data_encoding/index.html">Data_encoding</a> <span class="keyword">end</span></span></code></summary><div class="odoc-spec"><div class="spec module anchored" id="module-V1"><a href="#module-V1" class="anchor"></a><code><span><span class="keyword">module</span> V1</span><span> = <a href="../../../../octez-libs/Data_encoding/V1/index.html">Data_encoding.V1</a></span></code></div></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <span class="keyword">struct</span> <span class="keyword">include</span> <a href="../../../../octez-libs/Data_encoding/V1/index.html">V1</a> <span class="keyword">end</span></span></code></summary><p>This page is for the API documentation of data-encoding: the technical description of each of the available type and combinator exported by the data-encoding library.</p><p>For a high-level view and a tutorial, see <code>tutorial</code>.</p><h2 id="data-encoding"><a href="#data-encoding" class="anchor"></a>Data Encoding</h2><h3 id="overview"><a href="#overview" class="anchor"></a>Overview</h3><p>This module provides type-safe serialization and deserialization of data structures. Backends are provided to both /ad hoc/ binary, JSON and BSON.</p><p>This works by writing type descriptors by hand, using the provided combinators. These combinators can fine-tune the binary representation to be compact and efficient, but also provide proper field names and meta information. As a result, an API that uses those descriptors can be automatically introspected and documented.</p><p>Here is an example encoding for type <code>(int * string)</code>.</p><p><code>let enc = obj2 (req &quot;code&quot; uint16) (req &quot;message&quot; string)</code></p><p>In JSON, this encoding maps values of type <code>int * string</code> to JSON objects with a field <code>code</code> whose value is a number and a field <code>message</code> whose value is a string.</p><p>In binary, this encoding maps to two raw bytes for the <code>int</code> followed by the size of the string in bytes, and finally the raw contents of the string. This binary format is mostly tagless, meaning that serialized data cannot be interpreted without the encoding that was used for serialization.</p><p>Regarding binary serialization, encodings are classified as either:</p><ul><li>fixed size (booleans, integers, numbers) data is always the same size for that type ;</li><li>dynamically sized (arbitrary strings and bytes) data is of unknown size and requires an explicit length field ;</li><li>variable size (special case of strings, bytes, and arrays) data makes up the remainder of an object of known size, thus its size is given by the context, and does not have to be serialized.</li></ul><p>JSON operations are delegated to <code>json-data-encoding</code>.</p><h3 id="module-structure"><a href="#module-structure" class="anchor"></a>Module structure</h3><p>This <code>Data_encoding</code> module provides multiple submodules:</p><ul><li><a href="Encoding/index.html"><code>Encoding</code></a> contains the necessary types and constructors for making the type descriptors.</li><li><a href="../../../../octez-libs/Data_encoding/V1/Json/index.html"><code>Json</code></a>, <a href="../../../../octez-libs/Data_encoding/V1/Bson/index.html"><code>Bson</code></a>, and <a href="../../../../octez-libs/Data_encoding/V1/Binary/index.html"><code>Binary</code></a> contain functions to serialize and deserialize values.</li></ul><h4 id="ground-descriptors"><a href="#ground-descriptors" class="anchor"></a>Ground descriptors</h4><h5 id="voids"><a href="#voids" class="anchor"></a>voids</h5><h5 id="ground-numerical-types"><a href="#ground-numerical-types" class="anchor"></a>ground numerical types</h5><p>All encodings are big-endians.</p><ul><li>8-bit integers (signed or unsigned) are encoded over 1 single byte.</li><li>16-bit integers (signed or unsigned) are encoded over 2 bytes.</li><li>31-bit integers are always signed and always encoded over 4 bytes.</li><li>32-bit integers are always signed and always encoded over 4 bytes.</li><li>64-bit integers are always signed and always encoded over 8 bytes.</li></ul><p>A note on 31-bit integers. The internal representation of integers in OCaml reserves one bit for GC tagging. The remaining bits encode a signed integer. For compatibility with 32-bit machine, we restrict these native integers to the 31-bit range.</p><h5 id="other-ground-type-encodings"><a href="#other-ground-type-encodings" class="anchor"></a>Other ground type encodings</h5><h4 id="descriptor-combinators"><a href="#descriptor-combinators" class="anchor"></a>Descriptor combinators</h4><h4 id="product-descriptors"><a href="#product-descriptors" class="anchor"></a>Product descriptors</h4><h5 id="constructors-for-objects-with-n-fields"><a href="#constructors-for-objects-with-n-fields" class="anchor"></a>Constructors for objects with N fields</h5><p>These are serialized to binary by converting each internal object to binary and placing them in the order of the original object. These are serialized to JSON as a JSON object with the field names. An object might only contains one 'variable' field, typically the last one. If the encoding of more than one field are 'variable', the first ones should be wrapped with <code>dynamic_size</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Invalid_argument</code> <p>if more than one field is a variable one.</p></li></ul><h5 id="constructors-for-tuples-with-n-fields"><a href="#constructors-for-tuples-with-n-fields" class="anchor"></a>Constructors for tuples with N fields</h5><p>These are serialized to binary by converting each internal object to binary and placing them in the order of the original object. These are serialized to JSON as JSON arrays/lists. Like objects, a tuple might only contains one 'variable' field, typically the last one. If the encoding of more than one field are 'variable', the first ones should be wrapped with <code>dynamic_size</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Invalid_argument</code> <p>if more than one field is a variable one.</p></li></ul><h4 id="sum-descriptors"><a href="#sum-descriptors" class="anchor"></a>Sum descriptors</h4><h4 id="predicates-over-descriptors"><a href="#predicates-over-descriptors" class="anchor"></a>Predicates over descriptors</h4><h4 id="specialized-descriptors"><a href="#specialized-descriptors" class="anchor"></a>Specialized descriptors</h4><h4 id="documenting-descriptors"><a href="#documenting-descriptors" class="anchor"></a>Documenting descriptors</h4><div class="odoc-spec"><div class="spec module anchored" id="module-With_version"><a href="#module-With_version" class="anchor"></a><code><span><span class="keyword">module</span> With_version</span><span> = <a href="../../../../octez-libs/Data_encoding/V1/With_version/index.html">Data_encoding.With_version</a></span></code></div><div class="spec-doc"><p>Create a <a href="#type-t"><code>Data_encoding.t</code></a> value which records knowledge of older versions of a given encoding as long as one can &quot;upgrade&quot; from an older version to the next (if upgrade is impossible one should consider that the encoding is completely different).</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Json"><a href="#module-Json" class="anchor"></a><code><span><span class="keyword">module</span> Json</span><span> = <a href="../../../../octez-libs/Data_encoding/V1/Json/index.html">Data_encoding.Json</a></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Bson"><a href="#module-Bson" class="anchor"></a><code><span><span class="keyword">module</span> Bson</span><span> = <a href="../../../../octez-libs/Data_encoding/V1/Bson/index.html">Data_encoding.Bson</a></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Binary_schema"><a href="#module-Binary_schema" class="anchor"></a><code><span><span class="keyword">module</span> Binary_schema</span><span> = <a href="../../../../octez-libs/Data_encoding/V1/Binary_schema/index.html">Data_encoding.Binary_schema</a></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Binary_stream"><a href="#module-Binary_stream" class="anchor"></a><code><span><span class="keyword">module</span> Binary_stream</span><span> = <a href="../../../../octez-libs/Data_encoding/V1/Binary_stream/index.html">Data_encoding.Binary_stream</a></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Binary"><a href="#module-Binary" class="anchor"></a><code><span><span class="keyword">module</span> Binary</span><span> = <a href="../../../../octez-libs/Data_encoding/V1/Binary/index.html">Data_encoding.Binary</a></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-json"><a href="#type-json" class="anchor"></a><code><span><span class="keyword">type</span> json</span><span> = <a href="../../../../octez-libs/Data_encoding/V1/Json/index.html#type-t">Json.t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-json"><a href="#val-json" class="anchor"></a><code><span><span class="keyword">val</span> json : <span><a href="#type-json">json</a> <span class="xref-unresolved">{Encoding}1646</span>.t</span></span></code></div><div class="spec-doc"><p><code>json</code> is an encoding for JSON values. It is mostly intended for internal use or for defining your own low-level combinators.</p><p>WARNING! Due to a limitation of BSON, this encoding does not safely roundtrip. Specifically, <code>Json.destruct json (Json.construct json v)</code> is not guaranteed to be equal to <code>v</code>. More specifically, in BSON, top-level Arrays are represented as number-indexed Objects and this library has no way to distinguish between the two, doubly so for empty collections.</p><p>See <a href="../../../../octez-libs/Data_encoding/V1/Json/index.html#val-destruct"><code>Json.destruct</code></a>'s <code>?bson_relaxation</code> optional parameter.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-json_schema"><a href="#type-json_schema" class="anchor"></a><code><span><span class="keyword">type</span> json_schema</span><span> = <a href="../../../../octez-libs/Data_encoding/V1/Json/index.html#type-schema">Json.schema</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-json_schema"><a href="#val-json_schema" class="anchor"></a><code><span><span class="keyword">val</span> json_schema : <span><a href="#type-json_schema">json_schema</a> <span class="xref-unresolved">{Encoding}1646</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-bson"><a href="#type-bson" class="anchor"></a><code><span><span class="keyword">type</span> bson</span><span> = <a href="../../../../octez-libs/Data_encoding/V1/Bson/index.html#type-t">Bson.t</a></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Registration"><a href="#module-Registration" class="anchor"></a><code><span><span class="keyword">module</span> Registration</span><span> = <a href="../../../../octez-libs/Data_encoding/V1/Registration/index.html">Data_encoding.Registration</a></span></code></div></div></details></div></details></div><div class="odoc-spec"><div class="spec module anchored" id="module-Encoding"><a href="#module-Encoding" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Encoding/index.html">Encoding</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <span class="keyword">struct</span> <span class="keyword">include</span> <a href="Encoding/index.html">Encoding</a> <span class="keyword">end</span></span></code></summary><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span><span> = <span><span class="type-var">'a</span> <a href="../../../../octez-libs/Data_encoding__/V1/Encoding/index.html#type-t">Data_encoding.Encoding.t</a></span></span></code></div><div class="spec-doc"><p>The type descriptors for values of type <code>'a</code>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-encoding"><a href="#type-encoding" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a encoding</span></span><span> = <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-string_json_repr"><a href="#type-string_json_repr" class="anchor"></a><code><span><span class="keyword">type</span> string_json_repr</span><span> = <a href="../../../../octez-libs/Data_encoding/V1/Encoding/index.html#type-string_json_repr">Data_encoding.V1.Encoding.string_json_repr</a></span><span> = </span></code><ol><li id="type-string_json_repr.Hex" class="def variant constructor anchored"><a href="#type-string_json_repr.Hex" class="anchor"></a><code><span>| </span><span><span class="constructor">Hex</span></span></code></li><li id="type-string_json_repr.Plain" class="def variant constructor anchored"><a href="#type-string_json_repr.Plain" class="anchor"></a><code><span>| </span><span><span class="constructor">Plain</span></span></code></li></ol></div></div><h4 id="ground-descriptors_2"><a href="#ground-descriptors_2" class="anchor"></a>Ground descriptors</h4><h5 id="voids_2"><a href="#voids_2" class="anchor"></a>voids</h5><div class="odoc-spec"><div class="spec value anchored" id="val-null"><a href="#val-null" class="anchor"></a><code><span><span class="keyword">val</span> null : <span>unit <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>Special value <code>null</code> in JSON, nothing in binary.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : <span>unit <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>Empty object (not included in binary, encoded as empty object in JSON).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unit"><a href="#val-unit" class="anchor"></a><code><span><span class="keyword">val</span> unit : <span>unit <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>Unit value, omitted in binary. Serialized as an empty object in JSON, accepts any object when deserializing.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-constant"><a href="#val-constant" class="anchor"></a><code><span><span class="keyword">val</span> constant : <span>string <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>Constant string (data is not included in the binary data).</p></div></div><h5 id="ground-numerical-types_2"><a href="#ground-numerical-types_2" class="anchor"></a>ground numerical types</h5><p>All encodings are big-endians.</p><ul><li>8-bit integers (signed or unsigned) are encoded over 1 single byte.</li><li>16-bit integers (signed or unsigned) are encoded over 2 bytes.</li><li>31-bit integers are always signed and always encoded over 4 bytes.</li><li>32-bit integers are always signed and always encoded over 4 bytes.</li><li>64-bit integers are always signed and always encoded over 8 bytes.</li></ul><p>A note on 31-bit integers. The internal representation of integers in OCaml reserves one bit for GC tagging. The remaining bits encode a signed integer. For compatibility with 32-bit machine, we restrict these native integers to the 31-bit range.</p><div class="odoc-spec"><div class="spec value anchored" id="val-int8"><a href="#val-int8" class="anchor"></a><code><span><span class="keyword">val</span> int8 : <span>int <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>Signed 8 bit integer (data is encoded as a byte in binary and an integer in JSON).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-uint8"><a href="#val-uint8" class="anchor"></a><code><span><span class="keyword">val</span> uint8 : <span>int <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>Unsigned 8 bit integer (data is encoded as a byte in binary and an integer in JSON).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-int16"><a href="#val-int16" class="anchor"></a><code><span><span class="keyword">val</span> int16 : <span>int <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>Signed 16 bit integer (data is encoded as a short in binary and an integer in JSON).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-uint16"><a href="#val-uint16" class="anchor"></a><code><span><span class="keyword">val</span> uint16 : <span>int <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>Unsigned 16 bit integer (data is encoded as a short in binary and an integer in JSON).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-int31"><a href="#val-int31" class="anchor"></a><code><span><span class="keyword">val</span> int31 : <span>int <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>Signed 31 bit integer, which corresponds to type int on 32-bit OCaml systems (data is encoded as a 32 bit int in binary and an integer in JSON).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-int32"><a href="#val-int32" class="anchor"></a><code><span><span class="keyword">val</span> int32 : <span>int32 <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>Signed 32 bit integer (data is encoded as a 32-bit int in binary and an integer in JSON).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-int64"><a href="#val-int64" class="anchor"></a><code><span><span class="keyword">val</span> int64 : <span>int64 <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>Signed 64 bit integer (data is encoded as a 64-bit int in binary and a decimal string in JSON).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ranged_int"><a href="#val-ranged_int" class="anchor"></a><code><span><span class="keyword">val</span> ranged_int : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>Integer with bounds in a given range. Both bounds are inclusive.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Invalid_argument</code> <p>if the bounds are beyond the interval <code>-2^30; 2^30-1</code>. These bounds are chosen to be compatible with all versions of OCaml.</p></li></ul></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Big_endian"><a href="#module-Big_endian" class="anchor"></a><code><span><span class="keyword">module</span> Big_endian</span><span> = <a href="../../../../octez-libs/Data_encoding/V1/Encoding/Big_endian/index.html">Encoding.Big_endian</a></span></code></div><div class="spec-doc"><p>Integers with the same ranges, restrictions, and representations as above. The endianness is explicitly (rather than implicitly) big.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Little_endian"><a href="#module-Little_endian" class="anchor"></a><code><span><span class="keyword">module</span> Little_endian</span><span> = <a href="../../../../octez-libs/Data_encoding/V1/Encoding/Little_endian/index.html">Encoding.Little_endian</a></span></code></div><div class="spec-doc"><p>Integers with the same ranges and restrictions as above, but in little-endian representation. The JSON representation is unaffected.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-z"><a href="#val-z" class="anchor"></a><code><span><span class="keyword">val</span> z : <span><span class="xref-unresolved">Z</span>.t <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>Big number</p><p>In JSON, data is encoded as a string containing the decimal representation of the number.</p><p>In binary, data is encoded as a variable length sequence of bytes, with a running unary size bit: the most significant bit of each byte tells is this is the last byte in the sequence (0) or if there is more to read (1). The second most significant bit of the first byte is reserved for the sign (positive if zero). Sizing and sign bits ignored, data is then the binary representation of the absolute value of the number in little-endian order.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-n"><a href="#val-n" class="anchor"></a><code><span><span class="keyword">val</span> n : <span><span class="xref-unresolved">Z</span>.t <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>Positive big number.</p><p>In JSON, data is encoded as a string containing the decimal representation of the number.</p><p>In binary, data is encoded similarly to <code>z</code> but the sign bit is omitted. In other words:</p><p>Data is encoded as a variable length sequence of bytes, with a running unary size bit: the most significant bit of each byte tells is this is the last byte in the sequence (0) or if there is more to read (1). Sizing bits ignored, data is then the binary representation of the number in little-endian order.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-uint_like_n"><a href="#val-uint_like_n" class="anchor"></a><code><span><span class="keyword">val</span> uint_like_n : <span><span class="optlabel">?max_value</span>:int <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <span>int <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p><code>uint_like_n ()</code> is an encoding for <code>int</code> which uses the same representation as <a href="#val-n"><code>n</code></a>.</p><p>For compatibility with 32-bit machines, this encoding supports the same range of encodings as <code>int31</code>, but only the positive ones. I.e., it supports the inclusive range <code>0</code> to <code>(1 lsl 30) - 1</code>.</p><p>The optional parameter <code>?max_value</code> can be used to further restrict the range of values. If <code>max_value</code> is set and is greater than <code>(1 lsl 30) - 1</code> then the function raises <code>Invalid_argument</code>.</p><p>The encoding is partial: attempting to de/serialise values which are outside of the supported range will fail. In addition, in binary, a maximum size for the serialised representation is computed based on the maximum value in the range, and the de/serialisation process fails before attempting any conversion if the size is exceeded.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Invalid_argument</code> <p>if <code>max_value &lt; 0</code> or <code>max_value &gt; (1 lsl 30) - 1</code></p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-int_like_z"><a href="#val-int_like_z" class="anchor"></a><code><span><span class="keyword">val</span> int_like_z : <span><span class="optlabel">?min_value</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?max_value</span>:int <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <span>int <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p><code>int_like_z ()</code> is an encoding for <code>int</code> which uses the same representation as <a href="#val-z"><code>z</code></a>.</p><p>For compatibility with 32-bit machines, this encoding supports the same range of encodings as <code>int31</code>. I.e., it supports the inclusive range <code>-(1 lsl 30)</code> to <code>(1 lsl 30) - 1</code>.</p><p>The optional parameters <code>?min_value</code> and <code>?max_value</code> can be used to further restrict the range of values. If <code>min_value</code> is set and less than <code>-(1 lsl 30)</code> or if <code>max_value</code> is set and is greater than <code>(1 lsl 30) - 1</code> then the function raises <code>Invalid_argument</code>.</p><p>The encoding is partial: attempting to de/serialise values which are outside of the supported range will fail. In addition, in binary, a maximum size for the serialised representation is computed based on the encoding's range, and the de/serialisation process fails before attempting any conversion if the size is exceeded.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Invalid_argument</code> <p>if <code>max_value &lt; min_value</code></p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Invalid_argument</code> <p>if <code>max_value &gt; (1 lsl 30) - 1</code></p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Invalid_argument</code> <p>if <code>min_value &lt; -(1 lsl 30)</code></p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-float"><a href="#val-float" class="anchor"></a><code><span><span class="keyword">val</span> float : <span>float <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>Encoding of floating point number (encoded as a floating point number in JSON and a double in binary).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ranged_float"><a href="#val-ranged_float" class="anchor"></a><code><span><span class="keyword">val</span> ranged_float : <span>float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span>float <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>Float with bounds in a given range. Both bounds are inclusive</p></div></div><h5 id="other-ground-type-encodings_2"><a href="#other-ground-type-encodings_2" class="anchor"></a>Other ground type encodings</h5><div class="odoc-spec"><div class="spec value anchored" id="val-bool"><a href="#val-bool" class="anchor"></a><code><span><span class="keyword">val</span> bool : <span>bool <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>Encoding of a boolean (data is encoded as a byte in binary and a boolean in JSON).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-string'"><a href="#val-string'" class="anchor"></a><code><span><span class="keyword">val</span> string' : 
  <span><span class="optlabel">?length_kind</span>:<span>[ `N <span>| `Uint30</span> <span>| `Uint16</span> <span>| `Uint8</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-string_json_repr">string_json_repr</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>Encoding of a string</p><ul><li>In binary, encoded as a byte sequence prefixed by the length of the string. The length is represented as specified by the <code>length_kind</code> parameter (default <code>`Uint30</code>).</li><li>in JSON when <code>string_json_repr = Plain</code>, encoded as a string</li><li>in JSON when <code>string_json_repr = Hex</code>, encoded via hex.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-bytes'"><a href="#val-bytes'" class="anchor"></a><code><span><span class="keyword">val</span> bytes' : 
  <span><span class="optlabel">?length_kind</span>:<span>[ `N <span>| `Uint30</span> <span>| `Uint16</span> <span>| `Uint8</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-string_json_repr">string_json_repr</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Bytes.t <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>Encoding of arbitrary bytes. See <code>string'</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-string"><a href="#val-string" class="anchor"></a><code><span><span class="keyword">val</span> string : <span>string <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>same as <code>string' Plain</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-bytes"><a href="#val-bytes" class="anchor"></a><code><span><span class="keyword">val</span> bytes : <span><span class="xref-unresolved">Stdlib</span>.Bytes.t <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>same as <code>bytes' Hex</code></p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-bigstring"><a href="#type-bigstring" class="anchor"></a><code><span><span class="keyword">type</span> bigstring</span><span> =
  <span><span>(char, <span class="xref-unresolved">Stdlib</span>.Bigarray.int8_unsigned_elt, <span class="xref-unresolved">Stdlib</span>.Bigarray.c_layout)</span>
    <span class="xref-unresolved">Stdlib</span>.Bigarray.Array1.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-bigstring"><a href="#val-bigstring" class="anchor"></a><code><span><span class="keyword">val</span> bigstring : 
  <span><span class="optlabel">?length_kind</span>:<span>[ `N <span>| `Uint30</span> <span>| `Uint16</span> <span>| `Uint8</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?string_json_repr</span>:<a href="#type-string_json_repr">string_json_repr</a> <span class="arrow">&#45;&gt;</span></span>
  <span>unit <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-bigstring">bigstring</a> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>same as <code>string'</code> but for bigstring.</p></div></div><h4 id="descriptor-combinators_2"><a href="#descriptor-combinators_2" class="anchor"></a>Descriptor combinators</h4><div class="odoc-spec"><div class="spec value anchored" id="val-option"><a href="#val-option" class="anchor"></a><code><span><span class="keyword">val</span> option : <span><span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> option</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>Combinator to make an optional value (represented as a 1-byte tag followed by the data (or nothing) in binary and either the raw value or a null in JSON).</p><p>Note that the JSON representation is only weakly discriminating. Specifically, the value <code>Some None</code> is represented as the raw value <code>None</code> and so the two are indistinguishable. For this reason, this combinator does not support nesting, nor does it support use within a recursive (<a href="#val-mu"><code>mu</code></a>) encoding.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Invalid_argument</code> <p>if called on an encoding which may be represented as <code>null</code> in JSON. This includes an encoding of the form <code>option _</code>, <code>conv _ _ (option _)</code>, <code>dynamic_size (option _)</code>, etc.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Invalid_argument</code> <p>if called within the body of a <a href="#val-mu"><code>mu</code></a>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-result"><a href="#val-result" class="anchor"></a><code><span><span class="keyword">val</span> result : <span><span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>Combinator to make a <a href="#val-result"><code>result</code></a> value (represented as a 1-byte tag followed by the data of either type in binary, and either unwrapped value in JSON (the caller must ensure that both encodings do not collide)).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-array"><a href="#val-array" class="anchor"></a><code><span><span class="keyword">val</span> array : <span><span class="optlabel">?max_length</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> array</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>Array combinator.</p><ul><li>encoded as an array in JSON</li><li>encoded as the concatenation of all the element in binary prefixed by its size in bytes</li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">[max_length]</span> <p>If <code>max_length</code> is passed and the encoding of elements has fixed size, a <a href="#val-check_size"><code>check_size</code></a> is automatically added for earlier rejection.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Invalid_argument</code> <p>if the inner encoding is variable.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-array_with_length"><a href="#val-array_with_length" class="anchor"></a><code><span><span class="keyword">val</span> array_with_length : 
  <span><span class="optlabel">?max_length</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span>[ `N <span>| `Uint8</span> <span>| `Uint16</span> <span>| `Uint30</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> array</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>Array combinator.</p><ul><li>encoded as an array in JSON</li><li>encoded as the concatenation of its length (number of elements) and all the element in binary</li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">kind</span> <p>(<code>[`N | `Uint8 | `Uint16 | `Uint30]</code>) controls the representation of the length: <a href="#val-uint_like_n"><code>uint_like_n</code></a>, <a href="#val-uint8"><code>uint8</code></a>, <a href="#val-uint16"><code>uint16</code></a>, or <a href="#val-int31"><code>int31</code></a> (but only positive values).</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">[max_length]</span> <p>If <code>max_length</code> is passed and the encoding of elements has fixed size, a <a href="#val-check_size"><code>check_size</code></a> is automatically added for earlier rejection.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Invalid_argument</code> <p>if the inner encoding is variable.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-list"><a href="#val-list" class="anchor"></a><code><span><span class="keyword">val</span> list : <span><span class="optlabel">?max_length</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>List combinator.</p><ul><li>encoded as an array in JSON</li><li>encoded as the concatenation of all the element in binary prefixed by its size in bytes</li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">[max_length]</span> <p>If <code>max_length</code> is passed and the encoding of elements has fixed size, a <a href="#val-check_size"><code>check_size</code></a> is automatically added for earlier rejection.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Invalid_argument</code> <p>if the inner encoding is variable.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-list_with_length"><a href="#val-list_with_length" class="anchor"></a><code><span><span class="keyword">val</span> list_with_length : 
  <span><span class="optlabel">?max_length</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span>[ `N <span>| `Uint8</span> <span>| `Uint16</span> <span>| `Uint30</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>List combinator.</p><ul><li>encoded as an array in JSON</li><li>encoded as the concatenation of its length (number of elements) and all the element in binary</li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">kind</span> <p>(<code>[`N | `Uint8 | `Uint16 | `Uint30]</code>) controls the representation of the length: <a href="#val-uint_like_n"><code>uint_like_n</code></a>, <a href="#val-uint8"><code>uint8</code></a>, <a href="#val-uint16"><code>uint16</code></a>, or <a href="#val-int31"><code>int31</code></a> (but only positive values).</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">[max_length]</span> <p>If <code>max_length</code> is passed and the encoding of elements has fixed size, a <a href="#val-check_size"><code>check_size</code></a> is automatically added for earlier rejection.</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Invalid_argument</code> <p>if the inner encoding is variable.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-conv"><a href="#val-conv" class="anchor"></a><code><span><span class="keyword">val</span> conv : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?schema</span>:<a href="../../../../octez-libs/Json_schema/index.html#type-schema">Json_schema.schema</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>Provide a transformer from one encoding to a different one.</p><p>Used to simplify nested encodings or to change the generic tuples built by <a href="#val-obj1"><code>obj1</code></a>, <a href="#val-tup1"><code>tup1</code></a> and the like into proper records.</p><p>A schema may optionally be provided as documentation of the new encoding.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-conv_with_guard"><a href="#val-conv_with_guard" class="anchor"></a><code><span><span class="keyword">val</span> conv_with_guard : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, string)</span> <span class="xref-unresolved">Stdlib</span>.result</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?schema</span>:<a href="../../../../octez-libs/Json_schema/index.html#type-schema">Json_schema.schema</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p><code>conv_with_guard</code> is similar to <a href="#val-conv"><code>conv</code></a> but the function that takes in the value from the outside (untrusted) world has a chance to fail.</p><p>Specifically, if the function returns <code>Error msg</code> then the decoding is interrupted with an error carrying the message <code>msg</code>. If the function returns <code>Ok _</code> then the decoding proceeds normally.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-with_decoding_guard"><a href="#val-with_decoding_guard" class="anchor"></a><code><span><span class="keyword">val</span> with_decoding_guard : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(unit, string)</span> <span class="xref-unresolved">Stdlib</span>.result</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p><code>with_decoding_guard g e</code> is similar to <code>e</code> but decoding fails if <code>g</code> returns <code>Error _</code> on the decoded value.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-assoc"><a href="#val-assoc" class="anchor"></a><code><span><span class="keyword">val</span> assoc : <span><span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(string * <span class="type-var">'a</span>)</span> list</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>Association list. An object in JSON, a list of pairs in binary.</p></div></div><h4 id="product-descriptors_2"><a href="#product-descriptors_2" class="anchor"></a>Product descriptors</h4><div class="odoc-spec"><div class="spec type anchored" id="type-field"><a href="#type-field" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a field</span></span><span> = <span><span class="type-var">'a</span> <a href="../../../../octez-libs/Data_encoding/V1/Encoding/index.html#type-field">Data_encoding.V1.Encoding.field</a></span></span></code></div><div class="spec-doc"><p>An enriched encoding to represent a component in a structured type, augmenting the encoding with a name and whether it is a required or optional. Fields are used to encode OCaml tuples as objects in JSON, and as sequences in binary, using combinator <a href="#val-obj1"><code>obj1</code></a> and the like.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-req"><a href="#val-req" class="anchor"></a><code><span><span class="keyword">val</span> req : 
  <span><span class="optlabel">?title</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?description</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'t</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'t</span> <a href="#type-field">field</a></span></span></code></div><div class="spec-doc"><p>Required field.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-opt"><a href="#val-opt" class="anchor"></a><code><span><span class="keyword">val</span> opt : 
  <span><span class="optlabel">?title</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?description</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'t</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'t</span> option</span> <a href="#type-field">field</a></span></span></code></div><div class="spec-doc"><p>Optional field. Omitted entirely in JSON encoding if None. Omitted in binary if the only optional field in a <code>`Variable</code> encoding, otherwise a 1-byte prefix (`0` or `255`) tells if the field is present or not.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-varopt"><a href="#val-varopt" class="anchor"></a><code><span><span class="keyword">val</span> varopt : 
  <span><span class="optlabel">?title</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?description</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'t</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'t</span> option</span> <a href="#type-field">field</a></span></span></code></div><div class="spec-doc"><p>Optional field of variable length. Only one can be present in a given object.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-dft"><a href="#val-dft" class="anchor"></a><code><span><span class="keyword">val</span> dft : 
  <span><span class="optlabel">?title</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?description</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'t</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'t</span> <a href="#type-field">field</a></span></span></code></div><div class="spec-doc"><p>Required field with a default value. If the default value is passed, the field is omitted in JSON. The value is always serialized in binary.</p></div></div><h5 id="constructors-for-objects-with-n-fields_2"><a href="#constructors-for-objects-with-n-fields_2" class="anchor"></a>Constructors for objects with N fields</h5><p>These are serialized to binary by converting each internal object to binary and placing them in the order of the original object. These are serialized to JSON as a JSON object with the field names. An object might only contains one 'variable' field, typically the last one. If the encoding of more than one field are 'variable', the first ones should be wrapped with <code>dynamic_size</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Invalid_argument</code> <p>if more than one field is a variable one.</p></li></ul><div class="odoc-spec"><div class="spec value anchored" id="val-obj1"><a href="#val-obj1" class="anchor"></a><code><span><span class="keyword">val</span> obj1 : <span><span><span class="type-var">'f1</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'f1</span> <a href="#type-encoding">encoding</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-obj2"><a href="#val-obj2" class="anchor"></a><code><span><span class="keyword">val</span> obj2 : <span><span><span class="type-var">'f1</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'f2</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-obj3"><a href="#val-obj3" class="anchor"></a><code><span><span class="keyword">val</span> obj3 : <span><span><span class="type-var">'f1</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'f2</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'f3</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-obj4"><a href="#val-obj4" class="anchor"></a><code><span><span class="keyword">val</span> obj4 : 
  <span><span><span class="type-var">'f1</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f2</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f3</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f4</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span> * <span class="type-var">'f4</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-obj5"><a href="#val-obj5" class="anchor"></a><code><span><span class="keyword">val</span> obj5 : 
  <span><span><span class="type-var">'f1</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f2</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f3</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f4</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f5</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span> * <span class="type-var">'f4</span> * <span class="type-var">'f5</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-obj6"><a href="#val-obj6" class="anchor"></a><code><span><span class="keyword">val</span> obj6 : 
  <span><span><span class="type-var">'f1</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f2</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f3</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f4</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f5</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f6</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span> * <span class="type-var">'f4</span> * <span class="type-var">'f5</span> * <span class="type-var">'f6</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-obj7"><a href="#val-obj7" class="anchor"></a><code><span><span class="keyword">val</span> obj7 : 
  <span><span><span class="type-var">'f1</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f2</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f3</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f4</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f5</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f6</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f7</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span> * <span class="type-var">'f4</span> * <span class="type-var">'f5</span> * <span class="type-var">'f6</span> * <span class="type-var">'f7</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-obj8"><a href="#val-obj8" class="anchor"></a><code><span><span class="keyword">val</span> obj8 : 
  <span><span><span class="type-var">'f1</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f2</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f3</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f4</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f5</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f6</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f7</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f8</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span> * <span class="type-var">'f4</span> * <span class="type-var">'f5</span> * <span class="type-var">'f6</span> * <span class="type-var">'f7</span> * <span class="type-var">'f8</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-obj9"><a href="#val-obj9" class="anchor"></a><code><span><span class="keyword">val</span> obj9 : 
  <span><span><span class="type-var">'f1</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f2</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f3</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f4</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f5</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f6</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f7</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f8</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f9</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span> * <span class="type-var">'f4</span> * <span class="type-var">'f5</span> * <span class="type-var">'f6</span> * <span class="type-var">'f7</span> * <span class="type-var">'f8</span> * <span class="type-var">'f9</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-obj10"><a href="#val-obj10" class="anchor"></a><code><span><span class="keyword">val</span> obj10 : 
  <span><span><span class="type-var">'f1</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f2</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f3</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f4</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f5</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f6</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f7</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f8</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f9</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f10</span> <a href="#type-field">field</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span> * <span class="type-var">'f4</span> * <span class="type-var">'f5</span> * <span class="type-var">'f6</span> * <span class="type-var">'f7</span> * <span class="type-var">'f8</span> * <span class="type-var">'f9</span> * <span class="type-var">'f10</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-merge_objs"><a href="#val-merge_objs" class="anchor"></a><code><span><span class="keyword">val</span> merge_objs : <span><span><span class="type-var">'o1</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'o2</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'o1</span> * <span class="type-var">'o2</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>Create a larger object from the encodings of two smaller ones.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Invalid_argument</code> <p>if both arguments are not objects or if both tuples contains a variable field..</p></li></ul></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-With_field_name_duplicate_checks"><a href="#module-With_field_name_duplicate_checks" class="anchor"></a><code><span><span class="keyword">module</span> With_field_name_duplicate_checks</span><span> =
  <a href="../../../../octez-libs/Data_encoding/V1/Encoding/With_field_name_duplicate_checks/index.html">Encoding.With_field_name_duplicate_checks</a></span></code></div><div class="spec-doc"><p><code>With_field_name_duplicate_checks</code> is a subset of <code>Encoding</code> where all the constructed objects are checked for duplicates.</p></div></div><h5 id="constructors-for-tuples-with-n-fields_2"><a href="#constructors-for-tuples-with-n-fields_2" class="anchor"></a>Constructors for tuples with N fields</h5><p>These are serialized to binary by converting each internal object to binary and placing them in the order of the original object. These are serialized to JSON as JSON arrays/lists. Like objects, a tuple might only contains one 'variable' field, typically the last one. If the encoding of more than one field are 'variable', the first ones should be wrapped with <code>dynamic_size</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Invalid_argument</code> <p>if more than one field is a variable one.</p></li></ul><div class="odoc-spec"><div class="spec value anchored" id="val-tup1"><a href="#val-tup1" class="anchor"></a><code><span><span class="keyword">val</span> tup1 : <span><span><span class="type-var">'f1</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'f1</span> <a href="#type-encoding">encoding</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tup2"><a href="#val-tup2" class="anchor"></a><code><span><span class="keyword">val</span> tup2 : <span><span><span class="type-var">'f1</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'f2</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tup3"><a href="#val-tup3" class="anchor"></a><code><span><span class="keyword">val</span> tup3 : 
  <span><span><span class="type-var">'f1</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f2</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f3</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tup4"><a href="#val-tup4" class="anchor"></a><code><span><span class="keyword">val</span> tup4 : 
  <span><span><span class="type-var">'f1</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f2</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f3</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f4</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span> * <span class="type-var">'f4</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tup5"><a href="#val-tup5" class="anchor"></a><code><span><span class="keyword">val</span> tup5 : 
  <span><span><span class="type-var">'f1</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f2</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f3</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f4</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f5</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span> * <span class="type-var">'f4</span> * <span class="type-var">'f5</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tup6"><a href="#val-tup6" class="anchor"></a><code><span><span class="keyword">val</span> tup6 : 
  <span><span><span class="type-var">'f1</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f2</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f3</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f4</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f5</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f6</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span> * <span class="type-var">'f4</span> * <span class="type-var">'f5</span> * <span class="type-var">'f6</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tup7"><a href="#val-tup7" class="anchor"></a><code><span><span class="keyword">val</span> tup7 : 
  <span><span><span class="type-var">'f1</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f2</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f3</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f4</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f5</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f6</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f7</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span> * <span class="type-var">'f4</span> * <span class="type-var">'f5</span> * <span class="type-var">'f6</span> * <span class="type-var">'f7</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tup8"><a href="#val-tup8" class="anchor"></a><code><span><span class="keyword">val</span> tup8 : 
  <span><span><span class="type-var">'f1</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f2</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f3</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f4</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f5</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f6</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f7</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f8</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span> * <span class="type-var">'f4</span> * <span class="type-var">'f5</span> * <span class="type-var">'f6</span> * <span class="type-var">'f7</span> * <span class="type-var">'f8</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tup9"><a href="#val-tup9" class="anchor"></a><code><span><span class="keyword">val</span> tup9 : 
  <span><span><span class="type-var">'f1</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f2</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f3</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f4</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f5</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f6</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f7</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f8</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f9</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span> * <span class="type-var">'f4</span> * <span class="type-var">'f5</span> * <span class="type-var">'f6</span> * <span class="type-var">'f7</span> * <span class="type-var">'f8</span> * <span class="type-var">'f9</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tup10"><a href="#val-tup10" class="anchor"></a><code><span><span class="keyword">val</span> tup10 : 
  <span><span><span class="type-var">'f1</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f2</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f3</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f4</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f5</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f6</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f7</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f8</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f9</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'f10</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'f1</span> * <span class="type-var">'f2</span> * <span class="type-var">'f3</span> * <span class="type-var">'f4</span> * <span class="type-var">'f5</span> * <span class="type-var">'f6</span> * <span class="type-var">'f7</span> * <span class="type-var">'f8</span> * <span class="type-var">'f9</span> * <span class="type-var">'f10</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-merge_tups"><a href="#val-merge_tups" class="anchor"></a><code><span><span class="keyword">val</span> merge_tups : <span><span><span class="type-var">'a1</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a2</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a1</span> * <span class="type-var">'a2</span>)</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>Create a large tuple encoding from two smaller ones.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Invalid_argument</code> <p>if both values are not tuples or if both tuples contains a variable field.</p></li></ul></div></div><h4 id="sum-descriptors_2"><a href="#sum-descriptors_2" class="anchor"></a>Sum descriptors</h4><div class="odoc-spec"><div class="spec type anchored" id="type-case"><a href="#type-case" class="anchor"></a><code><span><span class="keyword">type</span> <span>'t case</span></span><span> = <span><span class="type-var">'t</span> <a href="../../../../octez-libs/Data_encoding/V1/Encoding/index.html#type-case">Data_encoding.V1.Encoding.case</a></span></span></code></div><div class="spec-doc"><p>A partial encoding to represent a case in a variant type. Hides the (existentially bound) type of the parameter to the specific case, providing its encoder, and converter functions to and from the union type.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-case_tag"><a href="#type-case_tag" class="anchor"></a><code><span><span class="keyword">type</span> case_tag</span><span> = <a href="../../../../octez-libs/Data_encoding/V1/Encoding/index.html#type-case_tag">Data_encoding.V1.Encoding.case_tag</a></span><span> = </span></code><ol><li id="type-case_tag.Tag" class="def variant constructor anchored"><a href="#type-case_tag.Tag" class="anchor"></a><code><span>| </span><span><span class="constructor">Tag</span> <span class="keyword">of</span> int</span></code></li><li id="type-case_tag.Json_only" class="def variant constructor anchored"><a href="#type-case_tag.Json_only" class="anchor"></a><code><span>| </span><span><span class="constructor">Json_only</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-matching_function"><a href="#type-matching_function" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a matching_function</span></span><span> = <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-match_result">match_result</a></span></code></div><div class="spec-doc"><p>A sum descriptor can be optimized by providing a specific <code>matching_function</code> which efficiently determines in which case some value of type <code>'a</code> falls.</p><p>Note that in general you should use a total function (i.e., one defined over the whole of the <code>'a</code> type) for the <code>matching_function</code>. However, in the case where you have a good reason to use a partial function, you should raise <code>No_case_matched</code> in the dead branches. Reasons why you may want to do so include:</p><ul><li><code>'a</code> is an open variant and you will complete the matching function later, and</li><li>there is a code invariant that guarantees that <code>'a</code> is not fully inhabited.</li></ul></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-match_result"><a href="#type-match_result" class="anchor"></a><code><span><span class="keyword">and</span> match_result</span><span> = <a href="../../../../octez-libs/Data_encoding/V1/Encoding/index.html#type-match_result">Data_encoding.V1.Encoding.match_result</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-matched"><a href="#val-matched" class="anchor"></a><code><span><span class="keyword">val</span> matched : 
  <span><span class="optlabel">?tag_size</span>:<span>[ `Uint8 <span>| `Uint16</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-match_result">match_result</a></span></code></div><div class="spec-doc"><p><code>matched t e u</code> represents the fact that a value is tagged with <code>t</code> and carries the payload <code>u</code> which can be encoded with <code>e</code>.</p><p>The optional argument <code>tag_size</code> must match the one passed to the <a href="#val-matching"><code>matching</code></a> function <code>matched</code> is called inside of.</p><p>An example is given in the documentation of <a href="#val-matching"><code>matching</code></a>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>[Invalid_argument]</code> <p>if <code>t &lt; 0</code></p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>[Invalid_argument]</code> <p>if <code>t</code> does not fit in <code>tag_size</code></p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-case"><a href="#val-case" class="anchor"></a><code><span><span class="keyword">val</span> case : 
  <span><span class="label">title</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?description</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-case_tag">case_tag</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'t</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'t</span> <a href="#type-case">case</a></span></span></code></div><div class="spec-doc"><p>Encodes a variant constructor. Takes the encoding for the specific parameters, a recognizer function that will extract the parameters in case the expected case of the variant is being serialized, and a constructor function for deserialization.</p><p>The tag must be less than the tag size of the union in which you use the case. An optional tag gives a name to a case and should be used to maintain compatibility.</p><p>An optional name for the case can be provided, which is used in the binary documentation.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>[Invalid_argument]</code> <p>if <code>case_tag</code> is <code>Tag t</code> with <code>t &lt; 0</code></p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-matching"><a href="#val-matching" class="anchor"></a><code><span><span class="keyword">val</span> matching : 
  <span><span class="optlabel">?tag_size</span>:<span>[ `Uint8 <span>| `Uint16</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'t</span> <a href="#type-matching_function">matching_function</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span><span class="type-var">'t</span> <a href="#type-case">case</a></span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'t</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>Create a single encoding from a series of cases.</p><p>In JSON, all cases are tried one after the other using the <code>case list</code>. The caller is responsible for avoiding collisions. If there are collisions (i.e., if multiple cases produce the same JSON output) then the encoding and decoding processes might not be inverse of each other. In other words, <code>destruct e (construct e v)</code> may not be equal to <code>v</code>.</p><p>In binary, a prefix tag is added to discriminate quickly between cases. The default is <code>`Uint8</code> and you must use a <code>`Uint16</code> if you are going to have more than 256 cases.</p><p>The matching function is used during binary encoding of a value <code>v</code> to efficiently determine which of the cases corresponds to <code>v</code>. The case list is used during decoding to reconstruct a value based on the encoded tag. (Decoding is optimised internally: tag look-up has a constant cost.)</p><p>The caller is responsible for ensuring that the <code>matching_function</code> and the <code>case list</code> describe the same encoding. If they describe different encodings, then the decoding and encoding processes will not be inverses of each others. In other words, <code>of_bytes e (to_bytes e v)</code> will not be equal to <code>v</code>.</p><p>If you do not wish to be responsible for this, you can use the unoptimised <a href="#val-union"><code>union</code></a> that uses a <code>case list</code> only (see below). Beware that in <a href="#val-union"><code>union</code></a> the complexity of the encoding is linear in the number of cases.</p><p>Following: a basic example use. Note that the <code>matching_function</code> uses the same tags, payload conversions, and payload encoding as the <code>case list</code>.</p><pre class="language-ocaml"><code>type t = A of string | B of int * int | C
let encoding_t =
  (* Tags and payload encodings for each constructors *)
  let a_tag = 0 and a_encoding = string in
  let b_tag = 1 and b_encoding = obj2 (req &quot;x&quot; int) (req &quot;y&quot; int) in
  let c_tag = 2 and c_encoding = unit in
  matching
    (* optimised encoding function *)
    (function
       | A s -&gt; matched a_tag a_encoding s
       | B (x, y) -&gt; matched b_tag b_encoding (x, y)
       | C -&gt; matched c_tag c_encoding ())
    (* decoding case list *)
    [
       case ~title:&quot;A&quot;
         (Tag a_tag)
         a_encoding
         (function A s -&gt; Some s | _ -&gt; None) (fun s -&gt; A s);
       case ~title:&quot;B&quot;
         (Tag b_tag)
         b_encoding
         (function B (x, y) -&gt; Some (x, y) | _ -&gt; None) (fun (x, y) -&gt; B (x, y));
       case ~title:&quot;C&quot;
         (Tag c_tag)
         c_encoding
         (function C -&gt; Some () | _ -&gt; None) (fun () -&gt; C);
    ]</code></pre><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>[Invalid_argument]</code> <p>if it is given an empty <code>case list</code></p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>[Invalid_argument]</code> <p>if there are more than one <code>case</code> with the same <code>tag</code> in the <code>case list</code></p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>[Invalid_argument]</code> <p>if there are more cases in the <code>case list</code> than can fit in the <code>tag_size</code></p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-union"><a href="#val-union" class="anchor"></a><code><span><span class="keyword">val</span> union : <span><span class="optlabel">?tag_size</span>:<span>[ `Uint8 <span>| `Uint16</span> ]</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span><span class="type-var">'t</span> <a href="#type-case">case</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'t</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>Same as matching except that the matching function is a linear traversal of the cases.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>[Invalid_argument]</code> <p>if it is given an empty <code>case list</code></p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>[Invalid_argument]</code> <p>if there are more than one <code>case</code> with the same <code>tag</code> in the <code>case list</code></p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>[Invalid_argument]</code> <p>if there are more cases in the <code>case list</code> than can fit in the <code>tag_size</code></p></li></ul></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-With_JSON_discriminant"><a href="#module-With_JSON_discriminant" class="anchor"></a><code><span><span class="keyword">module</span> With_JSON_discriminant</span><span> = <a href="../../../../octez-libs/Data_encoding/V1/Encoding/With_JSON_discriminant/index.html">Encoding.With_JSON_discriminant</a></span></code></div><div class="spec-doc"><p><code>With_JSON_discriminant</code> is a subset of <code>Encoding</code> where the union/matching combinators (and associated functions) add discriminant for the JSON backend.</p></div></div><h4 id="predicates-over-descriptors_2"><a href="#predicates-over-descriptors_2" class="anchor"></a>Predicates over descriptors</h4><div class="odoc-spec"><div class="spec value anchored" id="val-is_obj"><a href="#val-is_obj" class="anchor"></a><code><span><span class="keyword">val</span> is_obj : <span><span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Is the given encoding serialized as a JSON object?</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_tup"><a href="#val-is_tup" class="anchor"></a><code><span><span class="keyword">val</span> is_tup : <span><span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Does the given encoding encode a tuple?</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-classify"><a href="#val-classify" class="anchor"></a><code><span><span class="keyword">val</span> classify : <span><span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span> <span>[ <span>`Fixed of int</span> <span>| `Dynamic</span> <span>| `Variable</span> ]</span></span></code></div><div class="spec-doc"><p>Classify the binary serialization of an encoding as explained in the preamble.</p></div></div><h4 id="specialized-descriptors_2"><a href="#specialized-descriptors_2" class="anchor"></a>Specialized descriptors</h4><div class="odoc-spec"><div class="spec value anchored" id="val-string_enum"><a href="#val-string_enum" class="anchor"></a><code><span><span class="keyword">val</span> string_enum : <span><span><span>(string * <span class="type-var">'a</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>Encode enumeration via association list</p><ul><li>represented as a string in JSON and</li><li>represented as an integer representing the element's position in the list in binary. The integer size depends on the list size.</li></ul></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Fixed"><a href="#module-Fixed" class="anchor"></a><code><span><span class="keyword">module</span> Fixed</span><span> = <a href="../../../../octez-libs/Data_encoding/V1/Encoding/Fixed/index.html">Encoding.Fixed</a></span></code></div><div class="spec-doc"><p>Create encodings that produce data of a fixed length when binary encoded. See the preamble for an explanation.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Variable"><a href="#module-Variable" class="anchor"></a><code><span><span class="keyword">module</span> Variable</span><span> = <a href="../../../../octez-libs/Data_encoding/V1/Encoding/Variable/index.html">Encoding.Variable</a></span></code></div><div class="spec-doc"><p>Create encodings that produce data of a variable length when binary encoded. See the preamble for an explanation.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Bounded"><a href="#module-Bounded" class="anchor"></a><code><span><span class="keyword">module</span> Bounded</span><span> = <a href="../../../../octez-libs/Data_encoding/V1/Encoding/Bounded/index.html">Encoding.Bounded</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-dynamic_size"><a href="#val-dynamic_size" class="anchor"></a><code><span><span class="keyword">val</span> dynamic_size : 
  <span><span class="optlabel">?kind</span>:<span>[ `N <span>| `Uint30</span> <span>| `Uint16</span> <span>| `Uint8</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>Mark an encoding as being of dynamic size. Forces the size to be stored alongside content when needed. Typically used to combine two variable encodings in a same objects or tuple, or to use a variable encoding in an array or a list.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-check_size"><a href="#val-check_size" class="anchor"></a><code><span><span class="keyword">val</span> check_size : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p><code>check_size size encoding</code> ensures that the binary encoding of a value will not be allowed to exceed <code>size</code> bytes. The reader and the writer fails otherwise. This function do not modify the JSON encoding.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Invalid_argument</code> <p>if <code>size &lt; 0</code></p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-delayed"><a href="#val-delayed" class="anchor"></a><code><span><span class="keyword">val</span> delayed : <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>Recompute the encoding definition each time it is used. Useful for dynamically updating the encoding of values of an extensible type via a global reference (e.g., exceptions).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-splitted"><a href="#val-splitted" class="anchor"></a><code><span><span class="keyword">val</span> splitted : <span><span class="label">json</span>:<span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">binary</span>:<span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>Define different encodings for JSON and binary serialization.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mu"><a href="#val-mu" class="anchor"></a><code><span><span class="keyword">val</span> mu : 
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?title</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?description</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>Combinator for recursive encodings.</p><p>Notice that the function passed to <code>mu</code> must be pure. Otherwise, the behavior is unspecified.</p><p>A stateful recursive encoding can still be put under a <code>delayed</code> combinator to make sure that a new encoding is generated each time it is used. Caching the encoding generation when the state has not changed is then the responsability of the client.</p></div></div><h4 id="documenting-descriptors_2"><a href="#documenting-descriptors_2" class="anchor"></a>Documenting descriptors</h4><div class="odoc-spec"><div class="spec value anchored" id="val-def"><a href="#val-def" class="anchor"></a><code><span><span class="keyword">val</span> def : 
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?title</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?description</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'t</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'t</span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>Give a name to an encoding and optionally add documentation to an encoding.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-lazy_t"><a href="#type-lazy_t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a lazy_t</span></span><span> = <span><span class="type-var">'a</span> <a href="../../../../octez-libs/Data_encoding/V1/Encoding/index.html#type-lazy_t">Data_encoding.V1.Encoding.lazy_t</a></span></span></code></div><div class="spec-doc"><p>See <a href="#val-lazy_encoding"><code>lazy_encoding</code></a> below.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lazy_encoding"><a href="#val-lazy_encoding" class="anchor"></a><code><span><span class="keyword">val</span> lazy_encoding : <span><span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-lazy_t">lazy_t</a></span> <a href="#type-encoding">encoding</a></span></span></code></div><div class="spec-doc"><p>Combinator to have a part of the binary encoding lazily deserialized. This is transparent on the JSON side.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-force_decode"><a href="#val-force_decode" class="anchor"></a><code><span><span class="keyword">val</span> force_decode : <span><span><span class="type-var">'a</span> <a href="#type-lazy_t">lazy_t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p>Force the decoding (memoized for later calls), and return the value if successful.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-force_bytes"><a href="#val-force_bytes" class="anchor"></a><code><span><span class="keyword">val</span> force_bytes : <span><span><span class="type-var">'a</span> <a href="#type-lazy_t">lazy_t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Stdlib</span>.Bytes.t</span></code></div><div class="spec-doc"><p>Obtain the bytes without actually deserializing. Will serialize and memoize the result if the value is not the result of a lazy deserialization.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-make_lazy"><a href="#val-make_lazy" class="anchor"></a><code><span><span class="keyword">val</span> make_lazy : <span><span><span class="type-var">'a</span> <a href="#type-encoding">encoding</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-lazy_t">lazy_t</a></span></span></code></div><div class="spec-doc"><p>Make a lazy value from an immediate one.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-apply_lazy"><a href="#val-apply_lazy" class="anchor"></a><code><span><span class="keyword">val</span> apply_lazy : 
  <span><span class="label">fun_value</span>:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">fun_bytes</span>:<span>(<span><span class="xref-unresolved">Stdlib</span>.Bytes.t <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">fun_combine</span>:<span>(<span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-lazy_t">lazy_t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p>Apply on structure of lazy value, and combine results</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Compact"><a href="#module-Compact" class="anchor"></a><code><span><span class="keyword">module</span> Compact</span><span> = <a href="../../../../octez-libs/Data_encoding/V1/Encoding/Compact/index.html">Encoding.Compact</a></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-compact"><a href="#type-compact" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a compact</span></span><span> = <span><span class="type-var">'a</span> <a href="../../../../octez-libs/Data_encoding/V1/Encoding/Compact/index.html#type-t">Compact.t</a></span></span></code></div></div></details></div></div></body></html>
