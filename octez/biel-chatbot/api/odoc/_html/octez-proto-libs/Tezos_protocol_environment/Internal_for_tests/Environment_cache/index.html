<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Environment_cache (octez-proto-libs.Tezos_protocol_environment.Internal_for_tests.Environment_cache)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">octez-proto-libs</a> &#x00BB; <a href="../../index.html">Tezos_protocol_environment</a> &#x00BB; <a href="../index.html">Internal_for_tests</a> &#x00BB; Environment_cache</nav><header class="odoc-preamble"><h1>Module <code><span>Internal_for_tests.Environment_cache</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#lru-generic">An LRU inter-blocks cache for the economic protocol</a></li><li><a href="#cache-layout">Cache layout</a><ul><li><a href="#keys">Keys</a></li><li><a href="#cache-getters/setters">Cache Getters/Setters</a></li></ul></li><li><a href="#cache-synchronisation">Cache synchronisation</a></li></ul></nav><div class="odoc-content"><h3 id="lru-generic"><a href="#lru-generic" class="anchor"></a>An LRU inter-blocks cache for the economic protocol</h3><p><b>This is for use *within* the <code>Environment_context</code> only.</b></p><p>Frequently used data should be kept in memory and persist along a chain of blocks. The caching mechanism allows the economic protocol to declare such data and to rely on an Least Recently Used strategy to keep the cache size under a fixed limit.</p><p>One important difficulty is to correctly maintain this in-memory cache. There are three issues related to this mechanism from the shell perspective:</p><p>1. The in-memory cache must take chain reorganization into account. (Chain reorganizations occur when the node's preferred chain is not the one that has been chosen by the consensus algorithm.)</p><p>2. The in-memory cache must be completely determined by the storage.</p><p>3. The loading of the cache should introduce minimal latency during node reboots, RPC processing, or other operations. The cache should also have similar reactivity time on every node, independently of the fact that the node has just been rebooted or not.</p><p>This module implements the core logic of the cache mechanism (not the storage) part. The implementation provided to the protocol is implemented in <code>Environment_context.Cache</code>.</p><p>The type of a cache is parameterized by the type of the values stored.</p><p>When a value is cached, we also stored metadata about the status of this value in the cache. The value's key and its metadata are the only data stored in the context. The set of all the keys and metadatas of the cache is called the *domain*.</p><p>The actual cached values are introduced at runtime during cache lifetime. When the node needs to load a cache in memory for a specific context, it uses a *builder*, i.e., a function which reconstructs a cached value from a key. We can reconstruct all the values in a cache given its domain. In practice, such builder is provided by the cache mechanism client, i.e., the economic protocol.</p><p>Finally, notice that the cache is divided into sub-caches which have their own size limit. Each sub-cache is referenced by an index (as a positive integer). This layout is defined by the economic protocol.</p><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'value t</span></span></code></div><div class="spec-doc"><p>Abstract type for a cache parameterized by the value type.</p></div></div><h3 id="cache-layout"><a href="#cache-layout" class="anchor"></a>Cache layout</h3><p>A layout determines the number of sub-caches as well as the size limit of those sub-caches. No assumption is made on the unit of each of those sub-cache sizes. All we use is the natural ordering of <code>int</code>. In particular, the size units for different sub-caches need not be the same.</p><p>There are only two constructors for a cache:</p><ul><li><a href="#val-uninitialised"><code>uninitialised</code></a> which returns an uninitialised cache ;</li></ul><ul><li><a href="#val-from_layout"><code>from_layout</code></a> which initialises a cache with a layout.</li></ul><p>Moreover, the layout of the cache cannot be resized. This way, the cache's layout is determined uniquely by the one given to <code>from_layout</code>.</p><p>The only way to change the <code>layout</code> of a cache is to create a new cache and explicitly copy all the values from the previous cache to the new one. Such constraint may be relaxed in the future if necessary.</p><div class="odoc-spec"><div class="spec type anchored" id="type-size"><a href="#type-size" class="anchor"></a><code><span><span class="keyword">type</span> size</span><span> = int</span></code></div><div class="spec-doc"><p>Size of sub-caches or values.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-index"><a href="#type-index" class="anchor"></a><code><span><span class="keyword">type</span> index</span><span> = int</span></code></div><div class="spec-doc"><p>Index of the subcache in the cache. Values of this type should stay between <code>0</code> and <code>16383</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-uninitialised"><a href="#val-uninitialised" class="anchor"></a><code><span><span class="keyword">val</span> uninitialised : <span><span class="type-var">'value</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>uninitialised</code> is a special value which identify cache without a layout. Most functions of this interface will raise <code>Invalid_argument</code> is they are called on this value.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-from_layout"><a href="#val-from_layout" class="anchor"></a><code><span><span class="keyword">val</span> from_layout : <span><span><a href="#type-size">size</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'value</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>from_layout layout</code> initializes a cache with the <code>layout</code>. Such function is intended to be called by the <code>init</code> function of the economic protocol. In particular, this means that the cache's values will be reset after stitching of context.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compatible_layout"><a href="#val-compatible_layout" class="anchor"></a><code><span><span class="keyword">val</span> compatible_layout : <span><span><span class="type-var">'value</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-size">size</a> list</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>compatible_layout cache layout</code> returns <code>true</code> if the layout is compatible with the one <code>cache</code> was initialised with, <code>false</code> otherwise. By compatible, we mean that the layouts are actually precisely the same.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-clear"><a href="#val-clear" class="anchor"></a><code><span><span class="keyword">val</span> clear : <span><span><span class="type-var">'value</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'value</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>clear cache</code> resets the <code>cache</code> except the layout. It is equivalent to <code>from_layout layout</code> where <code>layout</code> was the <code>layout</code> provided to initialise the cache.</p></div></div><h4 id="keys"><a href="#keys" class="anchor"></a>Keys</h4><p>A key is built from an identifier and an index of the corresponding cache.</p><div class="odoc-spec"><div class="spec type anchored" id="type-key"><a href="#type-key" class="anchor"></a><code><span><span class="keyword">type</span> key</span></code></div><div class="spec-doc"><p>Abstract type for a cache key.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-identifier"><a href="#type-identifier" class="anchor"></a><code><span><span class="keyword">type</span> identifier</span><span> = string</span></code></div><div class="spec-doc"><p>Identifier of a key.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-key_of_identifier"><a href="#val-key_of_identifier" class="anchor"></a><code><span><span class="keyword">val</span> key_of_identifier : <span><span class="label">cache_index</span>:<a href="#type-index">index</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-identifier">identifier</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-key">key</a></span></code></div><div class="spec-doc"><p><code>key_of_identifier ~cache_index identifier</code> builds a key from the <code>cache_index</code> and the <code>identifier</code>.</p><p>No checks are made to ensure the validity of the index.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-identifier_of_key"><a href="#val-identifier_of_key" class="anchor"></a><code><span><span class="keyword">val</span> identifier_of_key : <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-identifier">identifier</a></span></code></div><div class="spec-doc"><p><code>identifier_of_key key</code> returns the identifier associated to the <code>key</code>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-value_metadata"><a href="#type-value_metadata" class="anchor"></a><code><span><span class="keyword">type</span> value_metadata</span><span> = </span><span>{</span></code><ol><li id="type-value_metadata.size" class="def record field anchored"><a href="#type-value_metadata.size" class="anchor"></a><code><span>size : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>size</code> must be strictly positive. This attribute is used to computed the cache size. The unit of the size is not specified at this stage. It is up to the economic protocol to give a measure of it.</p><span class="comment-delim">*)</span></div></li><li id="type-value_metadata.birth" class="def record field anchored"><a href="#type-value_metadata.birth" class="anchor"></a><code><span>birth : int64;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>birth</code> must be greater than 1. This number corresponds to the number of entries inserted in the cache after the insertion of this entry. The <code>birth</code> is used to determine which entry is the oldest one. The risk of overflow is minor.</p><span class="comment-delim">*)</span></div></li><li id="type-value_metadata.cache_nonce" class="def record field anchored"><a href="#type-value_metadata.cache_nonce" class="anchor"></a><code><span>cache_nonce : <a href="../../../../octez-libs/Tezos_base/TzPervasives/Bytes/index.html#type-t">Tezos_base.TzPervasives.Bytes.t</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>cache_nonce</code> identifies the block that introduced this cache entry. The nonce must uniquely identify the block which modifies this value. It cannot be the block hash for circularity reasons: The value of the nonce is stored onto the context and consequently influences the context hash of the very same block. Such nonce cannot be determined by the shell and its computation is delegated to the economic protocol.</p><p><code>cache_nonce</code>s are used by the shell to properly relate the cached entries with the current block and its predecessors. In particular in case of reorganizations, that is a context which is not on the same branch as the current branch, <code>cache_nonce</code>s are used to filter out entries that do not exist in the target branch.</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Metadata associated to a value in the cache.</p></div></div><h4 id="cache-getters/setters"><a href="#cache-getters/setters" class="anchor"></a>Cache Getters/Setters</h4><div class="odoc-spec"><div class="spec value anchored" id="val-find"><a href="#val-find" class="anchor"></a><code><span><span class="keyword">val</span> find : <span><span><span class="type-var">'value</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'value</span> option</span></span></code></div><div class="spec-doc"><p><code>find cache key</code> is <code>Some v</code> if <code>key</code> has an associated cached value <code>v</code> in <code>cache</code>, or <code>None</code> otherwise.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lookup"><a href="#val-lookup" class="anchor"></a><code><span><span class="keyword">val</span> lookup : <span><span><span class="type-var">'value</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'value</span> * <a href="#type-value_metadata">value_metadata</a>)</span> option</span></span></code></div><div class="spec-doc"><p><code>lookup cache key</code> is <code>Some (v, m)</code> where <code>v</code> is the value associated to <code>key</code> and <code>m</code> is the corresponding metadata. This function returns <code>None</code> if <code>key</code> is not in the cache domain.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-update"><a href="#val-update" class="anchor"></a><code><span><span class="keyword">val</span> update : <span><span><span class="type-var">'value</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'value</span> * <a href="#type-size">size</a>)</span> option</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'value</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>update cache key request</code> returns a new version of <code>cache</code> where a <code>request</code>ed change has been applied to the <code>key</code>.</p><p>More specifically:</p><ul><li><code>update cache key None</code> removes <code>key</code> from the <code>cache</code>.</li></ul><ul><li><code>update cache key (Some (value, size))</code> is <code>cache</code> where <code>key</code> is now associated to <code>value</code>.</li></ul><p>The metadata of the <code>key</code> is also updated in the returned cache:</p><ul><li>the <code>size</code> field is modified in the metadata ;</li><li>the <code>birth</code> is the higher birth, so that the key is the most recently used key.</li></ul><p>The <code>cache_nonce</code> of the entry is preserved.</p><p>If the cache is full, the insertion of a new entry provokes the removal of the least recently used entries.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-future_cache_expectation"><a href="#val-future_cache_expectation" class="anchor"></a><code><span><span class="keyword">val</span> future_cache_expectation : <span><span><span class="type-var">'value</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">time_in_blocks</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'value</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>future_cache_expectation cache ~time_in_blocks</code> returns a predicted cache that tries to anticipate the state of <code>cache</code> in <code>time_in_blocks</code>. This function is using an heuristic.</p></div></div><h3 id="cache-synchronisation"><a href="#cache-synchronisation" class="anchor"></a>Cache synchronisation</h3><p>Synchronisation of a cache aims to be done once all the accesses to the caches have been done by the economic protocol.</p><p>For each value added or updated since the last synchronisation, they are updated with the <code>nonce</code> provided by the economic protocol.</p><div class="odoc-spec"><div class="spec type anchored" id="type-domain"><a href="#type-domain" class="anchor"></a><code><span><span class="keyword">type</span> domain</span></code></div><div class="spec-doc"><p>The domain is the on-disk representation of the cache. Notice that in-memory values must be constructed from a domain to get a cache.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-domain_encoding"><a href="#val-domain_encoding" class="anchor"></a><code><span><span class="keyword">val</span> domain_encoding : <span><a href="#type-domain">domain</a> <a href="../../../../octez-libs/Data_encoding/index.html#type-t">Tezos_base.TzPervasives.Data_encoding.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-empty_domain"><a href="#val-empty_domain" class="anchor"></a><code><span><span class="keyword">val</span> empty_domain : <span><a href="#type-domain">domain</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>empty_domain d</code> returns <code>true</code> iff <code>d</code> is the domain of an uninitialized cache.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-from_cache"><a href="#val-from_cache" class="anchor"></a><code><span><span class="keyword">val</span> from_cache : 
  <span><span><span class="type-var">'value</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-domain">domain</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">value_of_key</span>:<span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'value</span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><span class="type-var">'value</span> <a href="#type-t">t</a></span>, <span class="type-var">'trace</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>from_cache initial domain ~value_of_key</code> initializes a cache with the given <code>domain</code> by reusing values from <code>initial</code> if nonces match, or by calling <code>value_of_key</code> otherwise.</p><p><code>domain</code> and <code>initial</code> must share the same layout.</p><p>This function is typically used when the cache is loaded from the context. See <code>Environment_context</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sync"><a href="#val-sync" class="anchor"></a><code><span><span class="keyword">val</span> sync : 
  <span><span><span class="type-var">'value</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">cache_nonce</span>:<a href="../../../../octez-libs/Tezos_base/TzPervasives/Bytes/index.html#type-t">Tezos_base.TzPervasives.Bytes.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'value</span> <a href="#type-t">t</a></span> * <a href="#type-domain">domain</a></span></code></div><div class="spec-doc"><p><code>sync cache ~cache_nonce</code> computes a new cache with a new domain.</p></div></div><p>Various functions used to introspect the content of the cache.</p><div class="odoc-spec"><div class="spec value anchored" id="val-number_of_caches"><a href="#val-number_of_caches" class="anchor"></a><code><span><span class="keyword">val</span> number_of_caches : <span><span><span class="type-var">'value</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>number_of_caches cache</code> returns the number of sub-caches in the cache.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cache_size"><a href="#val-cache_size" class="anchor"></a><code><span><span class="keyword">val</span> cache_size : <span><span><span class="type-var">'value</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">cache_index</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-size">size</a> option</span></span></code></div><div class="spec-doc"><p><code>cache_size cache ~cache_index</code> returns an overapproximation of the size of the cache. Returns <code>None</code> if <code>cache_index</code> is an invalid index.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cache_size_limit"><a href="#val-cache_size_limit" class="anchor"></a><code><span><span class="keyword">val</span> cache_size_limit : <span><span><span class="type-var">'value</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">cache_index</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-size">size</a> option</span></span></code></div><div class="spec-doc"><p><code>cache_size_limit cache ~cache_index</code> returns the maximal size of the cache indexed by <code>cache_index</code>. Returns <code>None</code> if <code>cache_index</code> is an invalid index.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-list_keys"><a href="#val-list_keys" class="anchor"></a><code><span><span class="keyword">val</span> list_keys : <span><span><span class="type-var">'value</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">cache_index</span>:<a href="#type-index">index</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<a href="#type-key">key</a> * <a href="#type-size">size</a>)</span> list</span> option</span></span></code></div><div class="spec-doc"><p><code>list_keys cache ~cache_index</code> returns the list of keys along with their size recorded into the subcache with index <code>cache_index</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-key_rank"><a href="#val-key_rank" class="anchor"></a><code><span><span class="keyword">val</span> key_rank : <span><span><span class="type-var">'value</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span>int option</span></span></code></div><div class="spec-doc"><p><code>key_rank cache key</code> returns the rank of the value associated to the given <code>key</code>. The rank is defined as the number of values older than the current one. Returns <code>None</code> if the <code>key</code> is not in the cache.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span><span class="keyword">val</span> pp : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'value</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>pp fmt cache</code> is a pretty printer for a <code>cache</code>.</p></div></div></div></body></html>
