<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Context (octez-proto-libs.Tezos_protocol_environment.Context)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">octez-proto-libs</a> &#x00BB; <a href="../index.html">Tezos_protocol_environment</a> &#x00BB; Context</nav><header class="odoc-preamble"><h1>Module <code><span>Tezos_protocol_environment.Context</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#getters">Getters</a></li><li><a href="#setters">Setters</a></li><li><a href="#folding">Folding</a></li><li><a href="#configuration">Configuration</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-ops"><a href="#type-ops" class="anchor"></a><code><span><span class="keyword">type</span> <span>('ctxt, 'tree) ops</span></span><span> =
  <span>(<span class="keyword">module</span> <span class="xref-unresolved">Tezos_protocol_environment__.Environment_context_intf.V5.S</span>
  <span class="keyword">with</span> <span class="keyword">type</span> <span class="xref-unresolved">t</span> = <span class="type-var">'ctxt</span>
   <span class="keyword">and</span> <span class="keyword">type</span> <span class="xref-unresolved">tree</span> = <span class="type-var">'tree</span>)</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-kind"><a href="#type-kind" class="anchor"></a><code><span><span class="keyword">type</span> <span>_ kind</span></span><span> = <span class="keyword">private</span> </span><span>..</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-equality_witness"><a href="#type-equality_witness" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'b) equality_witness</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-cache"><a href="#type-cache" class="anchor"></a><code><span><span class="keyword">type</span> cache</span></code></div><div class="spec-doc"><p>Abstract type of a cache. A cache is made of subcaches. Each subcache has its own size limit. The limit of its subcache is called a layout and can be initialized via the <code>set_cache_layout</code> function.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = <span class="keyword">private</span> </span></code><ol><li id="type-t.Context" class="def variant constructor anchored"><a href="#type-t.Context" class="anchor"></a><code><span>| </span><span><span class="constructor">Context</span> : </span><span>{</span></code><ol><li id="type-t.kind" class="def record field anchored"><a href="#type-t.kind" class="anchor"></a><code><span>kind : <span><span class="type-var">'a</span> <a href="#type-kind">kind</a></span>;</span></code></li><li id="type-t.impl_name" class="def record field anchored"><a href="#type-t.impl_name" class="anchor"></a><code><span>impl_name : string;</span></code></li><li id="type-t.ctxt" class="def record field anchored"><a href="#type-t.ctxt" class="anchor"></a><code><span>ctxt : <span class="type-var">'a</span>;</span></code></li><li id="type-t.ops" class="def record field anchored"><a href="#type-t.ops" class="anchor"></a><code><span>ops : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-ops">ops</a></span>;</span></code></li><li id="type-t.equality_witness" class="def record field anchored"><a href="#type-t.equality_witness" class="anchor"></a><code><span>equality_witness : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-equality_witness">equality_witness</a></span>;</span></code></li><li id="type-t.cache" class="def record field anchored"><a href="#type-t.cache" class="anchor"></a><code><span>cache : <a href="#type-cache">cache</a>;</span></code></li></ol><code><span>}</span><span> <span class="arrow">&#45;&gt;</span> <a href="#type-t">t</a></span></code></li></ol></div><div class="spec-doc"><p>A context is purely functional description of a state. This state is used to interpret operations, and more generally, to validate blocks.</p><p>This type is private because a context must be constructed using <code>make</code>, which is a smart constructor.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal_config"><a href="#val-equal_config" class="anchor"></a><code><span><span class="keyword">val</span> equal_config : 
  <span><a href="../../../octez-libs/Tezos_context_sigs/Config/index.html#type-t">Tezos_context_sigs.Config.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../octez-libs/Tezos_context_sigs/Config/index.html#type-t">Tezos_context_sigs.Config.t</a> <span class="arrow">&#45;&gt;</span></span>
  bool</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-key"><a href="#type-key" class="anchor"></a><code><span><span class="keyword">type</span> key</span><span> = <span>string list</span></span></code></div><div class="spec-doc"><p>The type for context keys.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-value"><a href="#type-value" class="anchor"></a><code><span><span class="keyword">type</span> value</span><span> = bytes</span></code></div><div class="spec-doc"><p>The type for context values.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-tree"><a href="#type-tree" class="anchor"></a><code><span><span class="keyword">type</span> tree</span></code></div><div class="spec-doc"><p>The type for context trees.</p></div></div><h3 id="getters"><a href="#getters" class="anchor"></a>Getters</h3><div class="odoc-spec"><div class="spec value anchored" id="val-mem"><a href="#val-mem" class="anchor"></a><code><span><span class="keyword">val</span> mem : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>mem t k</code> is an Lwt promise that resolves to <code>true</code> iff <code>k</code> is bound to a value in <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mem_tree"><a href="#val-mem_tree" class="anchor"></a><code><span><span class="keyword">val</span> mem_tree : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>mem_tree t k</code> is like <a href="#val-mem"><code>mem</code></a> but for trees.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-find"><a href="#val-find" class="anchor"></a><code><span><span class="keyword">val</span> find : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-value">value</a> option</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>find t k</code> is an Lwt promise that resolves to <code>Some v</code> if <code>k</code> is bound to the value <code>v</code> in <code>t</code> and <code>None</code> otherwise.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-find_tree"><a href="#val-find_tree" class="anchor"></a><code><span><span class="keyword">val</span> find_tree : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-tree">tree</a> option</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>find_tree t k</code> is like <a href="#val-find"><code>find</code></a> but for trees.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-list"><a href="#val-list" class="anchor"></a><code><span><span class="keyword">val</span> list : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?offset</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?length</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(string * <a href="#type-tree">tree</a>)</span> list</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>list t key</code> is the list of files and sub-nodes stored under <code>k</code> in <code>t</code>. The result order is not specified but is stable.</p><p><code>offset</code> and <code>length</code> are used for pagination.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-length"><a href="#val-length" class="anchor"></a><code><span><span class="keyword">val</span> length : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>length t key</code> is an Lwt promise that resolves to the number of files and sub-nodes stored under <code>k</code> in <code>t</code>.</p><p>It is equivalent to <code>let+ l = list t k in List.length l</code> but has a constant-time complexity.</p></div></div><h3 id="setters"><a href="#setters" class="anchor"></a>Setters</h3><div class="odoc-spec"><div class="spec value anchored" id="val-add"><a href="#val-add" class="anchor"></a><code><span><span class="keyword">val</span> add : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-value">value</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>add t k v</code> is an Lwt promise that resolves to <code>c</code> such that:</p><ul><li><code>k</code> is bound to <code>v</code> in <code>c</code>;</li><li>and <code>c</code> is similar to <code>t</code> otherwise.</li></ul><p>If <code>k</code> was already bound in <code>t</code> to a value that is physically equal to <code>v</code>, the result of the function is a promise that resolves to <code>t</code>. Otherwise, the previous binding of <code>k</code> in <code>t</code> disappears.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_tree"><a href="#val-add_tree" class="anchor"></a><code><span><span class="keyword">val</span> add_tree : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-tree">tree</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>add_tree</code> is like <a href="#val-add"><code>add</code></a> but for trees.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-remove"><a href="#val-remove" class="anchor"></a><code><span><span class="keyword">val</span> remove : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>remove t k v</code> is an Lwt promise that resolves to <code>c</code> such that:</p><ul><li><code>k</code> is unbound in <code>c</code>;</li><li>and <code>c</code> is similar to <code>t</code> otherwise.</li></ul></div></div><h3 id="folding"><a href="#folding" class="anchor"></a>Folding</h3><div class="odoc-spec"><div class="spec value anchored" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span><span class="keyword">val</span> fold : 
  <span><span class="optlabel">?depth</span>:<a href="../../../octez-libs/Tezos_context_sigs/Context/index.html#type-depth">Tezos_context_sigs.Context.depth</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">order</span>:<span>[ `Sorted <span>| `Undefined</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">init</span>:<span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">f</span>:<span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-tree">tree</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>fold ?depth t root ~order ~init ~f</code> recursively folds over the trees and values of <code>t</code>. The <code>f</code> callbacks are called with a key relative to <code>root</code>. <code>f</code> is never called with an empty key for values; i.e., folding over a value is a no-op.</p><p>The depth is 0-indexed. If <code>depth</code> is set (by default it is not), then <code>f</code> is only called when the conditions described by the parameter is true:</p><ul><li><code>Eq d</code> folds over nodes and values of depth exactly <code>d</code>.</li><li><code>Lt d</code> folds over nodes and values of depth strictly less than <code>d</code>.</li><li><code>Le d</code> folds over nodes and values of depth less than or equal to <code>d</code>.</li><li><code>Gt d</code> folds over nodes and values of depth strictly more than <code>d</code>.</li><li><code>Ge d</code> folds over nodes and values of depth more than or equal to <code>d</code>.</li></ul><p>If <code>order</code> is <code>`Sorted</code> (the default), the elements are traversed in lexicographic order of their keys. For large nodes, it is memory-consuming, use <code>`Undefined</code> for a more memory efficient <code>fold</code>.</p></div></div><h3 id="configuration"><a href="#configuration" class="anchor"></a>Configuration</h3><div class="odoc-spec"><div class="spec value anchored" id="val-config"><a href="#val-config" class="anchor"></a><code><span><span class="keyword">val</span> config : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../../octez-libs/Tezos_context_sigs/Config/index.html#type-t">Tezos_context_sigs.Config.t</a></span></code></div><div class="spec-doc"><p><code>config t</code> is <code>t</code>'s hash configuration.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Tree"><a href="#module-Tree" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Tree/index.html">Tree</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_protocol"><a href="#val-set_protocol" class="anchor"></a><code><span><span class="keyword">val</span> set_protocol : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../octez-libs/Tezos_crypto/Hashed/Protocol_hash/index.html#type-t">Tezos_crypto.Hashed.Protocol_hash.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_protocol"><a href="#val-get_protocol" class="anchor"></a><code><span><span class="keyword">val</span> get_protocol : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../octez-libs/Tezos_crypto/Hashed/Protocol_hash/index.html#type-t">Tezos_crypto.Hashed.Protocol_hash.t</a> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fork_test_chain"><a href="#val-fork_test_chain" class="anchor"></a><code><span><span class="keyword">val</span> fork_test_chain : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">protocol</span>:<a href="../../../octez-libs/Tezos_crypto/Hashed/Protocol_hash/index.html#type-t">Tezos_crypto.Hashed.Protocol_hash.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">expiration</span>:<a href="../../../octez-libs/Tezos_base/Time/Protocol/index.html#type-t">Tezos_base.TzPervasives.Time.Protocol.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_hash_version"><a href="#val-set_hash_version" class="anchor"></a><code><span><span class="keyword">val</span> set_hash_version : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../octez-libs/Tezos_crypto/Hashed/Context_hash/Version/index.html#type-t">Tezos_crypto.Hashed.Context_hash.Version.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-t">t</a> <a href="../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tzresult">Tezos_base.TzPervasives.tzresult</a></span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_hash_version"><a href="#val-get_hash_version" class="anchor"></a><code><span><span class="keyword">val</span> get_hash_version : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../../octez-libs/Tezos_crypto/Hashed/Context_hash/Version/index.html#type-t">Tezos_crypto.Hashed.Context_hash.Version.t</a></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Proof"><a href="#module-Proof" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Proof/index.html">Proof</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec type subst anchored" id="type-tree_proof"><a href="#type-tree_proof" class="anchor"></a><code><span><span class="keyword">type</span> tree_proof</span><span> := <span><a href="Proof/index.html#type-tree">Proof.tree</a> <a href="Proof/index.html#type-t">Proof.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type subst anchored" id="type-stream_proof"><a href="#type-stream_proof" class="anchor"></a><code><span><span class="keyword">type</span> stream_proof</span><span> := <span><a href="Proof/index.html#type-stream">Proof.stream</a> <a href="Proof/index.html#type-t">Proof.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type subst anchored" id="type-verifier"><a href="#type-verifier" class="anchor"></a><code><span><span class="keyword">type</span> <span>('proof, 'result) verifier</span></span><span> :=
  <span><span class="type-var">'proof</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-tree">tree</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-tree">tree</a> * <span class="type-var">'result</span>)</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="#type-tree">tree</a> * <span class="type-var">'result</span>,
    <span>[ <span>`Proof_mismatch of string</span>
    <span><span>| `Stream_too_long</span> of string</span>
    <span><span>| `Stream_too_short</span> of string</span> ]</span>)</span>
    <span class="xref-unresolved">Stdlib</span>.result</span>
    <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-verify_tree_proof"><a href="#val-verify_tree_proof" class="anchor"></a><code><span><span class="keyword">val</span> verify_tree_proof : <span><span>(<a href="#type-tree_proof">tree_proof</a>, <span class="type-var">'a</span>)</span> <a href="#type-verifier">verifier</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-verify_stream_proof"><a href="#val-verify_stream_proof" class="anchor"></a><code><span><span class="keyword">val</span> verify_stream_proof : <span><span>(<a href="#type-stream_proof">stream_proof</a>, <span class="type-var">'a</span>)</span> <a href="#type-verifier">verifier</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-make"><a href="#val-make" class="anchor"></a><code><span><span class="keyword">val</span> make : 
  <span><span class="label">kind</span>:<span><span class="type-var">'a</span> <a href="#type-kind">kind</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">impl_name</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">ctxt</span>:<span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">ops</span>:<span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-ops">ops</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">equality_witness</span>:<span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-equality_witness">equality_witness</a></span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>make kind impl_name ctxt ops equality_witness</code> builds a context value. In this context, the cache is uninitialized: one must call <code>load_cache</code> to obtain a context with a valid cache. Otherwise, the context is not usable for all protocol-level features based on the cache, e.g., smart contract execution.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-cache_key"><a href="#type-cache_key" class="anchor"></a><code><span><span class="keyword">type</span> cache_key</span></code></div><div class="spec-doc"><p>A key uniquely identifies a cached <code>value</code> in the some subcache.</p></div></div><p>Abstract type for cached values.</p><p>This type is an extensible type since values stored in the cache are heterogeneous. Notice that the cache must be cleared during during protocol stitching because the data constructors of this type are incompatible between two protocols: if there remains values built with a data constructor of an old protocol, the new protocol will be confused to find that some keys it is interesting in have unexploitable values.</p><div class="odoc-spec"><div class="spec type anchored" id="type-cache_value"><a href="#type-cache_value" class="anchor"></a><code><span><span class="keyword">type</span> cache_value</span><span> = </span><span>..</span></code></div><div class="spec-doc"><p>Cached values inhabit an extensible type.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Cache"><a href="#module-Cache" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Cache/index.html">Cache</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>See <code>Context.CACHE</code> in <code>sigs/v3/context.mli</code> for documentation.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-block_cache"><a href="#type-block_cache" class="anchor"></a><code><span><span class="keyword">type</span> block_cache</span><span> = </span><span>{</span></code><ol><li id="type-block_cache.context_hash" class="def record field anchored"><a href="#type-block_cache.context_hash" class="anchor"></a><code><span>context_hash : <a href="../../../octez-libs/Tezos_crypto/Hashed/Context_hash/index.html#type-t">Tezos_crypto.Hashed.Context_hash.t</a>;</span></code></li><li id="type-block_cache.cache" class="def record field anchored"><a href="#type-block_cache.cache" class="anchor"></a><code><span>cache : <a href="#type-cache">cache</a>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>A cache is a block-dependent value: to know whether a cache can be reused or recycled in a given block, we need the block that produces it.</p></div></div><p>During its loading, a cache can be populated in two different ways:</p><ul><li>values are computed immediately via the builder and inserted into the cache ; or,</li></ul><ul><li>the computation of the values is delayed and will be computed only when such value is required.</li></ul><p>The first mode is intended to be used after a rebooting of the node for example. The main benefit being that it does not impact the validation time of a block since the cache's values will be reconstructed beforehand. The second mode is intended to be used for RPCs where reactivity is important: we do not want to recompute the full cache to execute the RPC but only the values which are necessary.</p><div class="odoc-spec"><div class="spec type anchored" id="type-source_of_cache"><a href="#type-source_of_cache" class="anchor"></a><code><span><span class="keyword">type</span> source_of_cache</span><span> = </span><span>[ </span></code><ol><li id="type-source_of_cache.Force_load" class="def variant constructor anchored"><a href="#type-source_of_cache.Force_load" class="anchor"></a><code><span>| </span><span>`Force_load</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Force the cache domain to be reloaded from the context.</p><span class="comment-delim">*)</span></div></li><li id="type-source_of_cache.Load" class="def variant constructor anchored"><a href="#type-source_of_cache.Load" class="anchor"></a><code><span>| </span><span>`Load</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Load a cache by iterating over the keys of its domain and by building a cached value for each key.</p><p>This operation can introduce a significant slowdown proportional to the number of entries in the cache, and depending on their nature. As a consequence, loading a cache from that source should be done when the system has no strict constraint on execution time, e.g., during startup.</p><span class="comment-delim">*)</span></div></li><li id="type-source_of_cache.Lazy" class="def variant constructor anchored"><a href="#type-source_of_cache.Lazy" class="anchor"></a><code><span>| </span><span>`Lazy</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Same as Load except that cached values are built on demand.</p><p>This strategy makes <code>load_cache</code> run a lot faster and the overall cost of loading the cache is only proportional to the number of entries *actually used* (and also depends on their nature).</p><p>Notice that, contrary to the <code>`Load</code> source of cache, this loading mode may also introduce latencies when entries are actually used since they are reconstructed on-the-fly.</p><p>RPCs are a typical place where this Lazy loading makes sense since the number of entries used is generally low, and the cache cannot be inherited (as in the next case).</p><span class="comment-delim">*)</span></div></li><li id="type-source_of_cache.Inherited" class="def variant constructor anchored"><a href="#type-source_of_cache.Inherited" class="anchor"></a><code><span>| </span><span>`Inherited <span class="keyword">of</span> <a href="#type-block_cache">block_cache</a> * <a href="../../../octez-libs/Tezos_crypto/Hashed/Context_hash/index.html#type-t">Tezos_crypto.Hashed.Context_hash.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>When we already have some <code>block_cache.cache</code> in memory coming from the validation of some block <code>block_cache.context_hash</code>, we can reuse or recycle its entries to reconstruct a cache to check some other block identified by a given <code>Context_hash.t</code>, which typically comes after <code>block_cache.context_hash</code> in the chain.</p><p>This source is usually the most efficient way to build a cache in memory since the cache entries only change marginally from one block to one of its close descendants.</p><span class="comment-delim">*)</span></div></li></ol><code><span> ]</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-builder"><a href="#type-builder" class="anchor"></a><code><span><span class="keyword">type</span> builder</span><span> = <span><a href="#type-cache_key">cache_key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-cache_value">cache_value</a> <a href="../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tzresult">Tezos_base.TzPervasives.tzresult</a></span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p>To <code>load_cache</code> in memory, we need to iterate over its domain and for each key found in the domain, a <code>builder</code> produces the associated value.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-load_cache"><a href="#val-load_cache" class="anchor"></a><code><span><span class="keyword">val</span> load_cache : 
  <span><a href="../../../octez-libs/Tezos_crypto/Hashed/Block_hash/index.html#type-t">Tezos_crypto.Hashed.Block_hash.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-source_of_cache">source_of_cache</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-builder">builder</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-t">t</a> <a href="../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tzresult">Tezos_base.TzPervasives.tzresult</a></span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>load_cache predecessor ctxt source builder</code> populates the in-memory cache values cached in the current context during the validation of <code>predecessor</code> block. To achieve that, the function uses the strategy described by <code>source</code>, exploiting the <code>builder</code> to create cached values that are not already available in memory.</p><p>The <code>builder</code> is assumed to never fail when evaluated on the keys of the cache domain. Indeed, if a key had an associated value in the cache at some point in the past, it should have been a valid key. In other words, the construction of cache should be reproducible. For this reason, an error in <code>builder</code> is fatal.</p></div></div></div></body></html>
