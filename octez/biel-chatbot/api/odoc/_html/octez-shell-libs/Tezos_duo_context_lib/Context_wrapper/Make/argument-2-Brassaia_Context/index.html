<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Brassaia_Context (octez-shell-libs.Tezos_duo_context_lib.Context_wrapper.Make.Brassaia_Context)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../../index.html">octez-shell-libs</a> &#x00BB; <a href="../../../index.html">Tezos_duo_context_lib</a> &#x00BB; <a href="../../index.html">Context_wrapper</a> &#x00BB; <a href="../index.html">Make</a> &#x00BB; Brassaia_Context</nav><header class="odoc-preamble"><h1>Parameter <code><span>Make.Brassaia_Context</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#generic-interface">Generic interface</a></li><li><a href="#accessing-and-updating-versions">Accessing and Updating Versions</a></li><li><a href="#hash-version">Hash version</a></li><li><a href="#predefined-fields">Predefined Fields</a></li></ul></nav><div class="odoc-content"><h3 id="generic-interface"><a href="#generic-interface" class="anchor"></a>Generic interface</h3><div class="odoc-spec"><div class="spec type anchored" id="type-index"><a href="#type-index" class="anchor"></a><code><span><span class="keyword">type</span> index</span></code></div><div class="spec-doc"><p>A block-indexed (key x value) store directory.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal_config"><a href="#val-equal_config" class="anchor"></a><code><span><span class="keyword">val</span> equal_config : 
  <span><a href="../../../../../octez-libs/Tezos_context_sigs/Config/index.html#type-t">Tezos_context_sigs.Config.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../../octez-libs/Tezos_context_sigs/Config/index.html#type-t">Tezos_context_sigs.Config.t</a> <span class="arrow">&#45;&gt;</span></span>
  bool</span></code></div></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../../../../../octez-libs/Tezos_context_sigs/Context/module-type-VIEW/index.html">Tezos_context_sigs.Context.VIEW</a>
  <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../../../../../octez-libs/Tezos_context_sigs/Context/module-type-VIEW/index.html#type-key">key</a> = <span>string list</span></span>
   <span class="keyword">and</span> <span><span class="keyword">type</span> <a href="../../../../../octez-libs/Tezos_context_sigs/Context/module-type-VIEW/index.html#type-value">value</a> = bytes</span></span></code></summary><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>The type for context views.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-key"><a href="#type-key" class="anchor"></a><code><span><span class="keyword">type</span> key</span><span> = <span>string list</span></span></code></div><div class="spec-doc"><p>The type for context keys.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-value"><a href="#type-value" class="anchor"></a><code><span><span class="keyword">type</span> value</span><span> = bytes</span></code></div><div class="spec-doc"><p>The type for context values.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-tree"><a href="#type-tree" class="anchor"></a><code><span><span class="keyword">type</span> tree</span></code></div><div class="spec-doc"><p>The type for context trees.</p></div></div><h3 id="getters"><a href="#getters" class="anchor"></a>Getters</h3><div class="odoc-spec"><div class="spec value anchored" id="val-mem"><a href="#val-mem" class="anchor"></a><code><span><span class="keyword">val</span> mem : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>mem t k</code> is an Lwt promise that resolves to <code>true</code> iff <code>k</code> is bound to a value in <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mem_tree"><a href="#val-mem_tree" class="anchor"></a><code><span><span class="keyword">val</span> mem_tree : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>mem_tree t k</code> is like <a href="#val-mem"><code>mem</code></a> but for trees.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-find"><a href="#val-find" class="anchor"></a><code><span><span class="keyword">val</span> find : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-value">value</a> option</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>find t k</code> is an Lwt promise that resolves to <code>Some v</code> if <code>k</code> is bound to the value <code>v</code> in <code>t</code> and <code>None</code> otherwise.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-find_tree"><a href="#val-find_tree" class="anchor"></a><code><span><span class="keyword">val</span> find_tree : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-tree">tree</a> option</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>find_tree t k</code> is like <a href="#val-find"><code>find</code></a> but for trees.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-list"><a href="#val-list" class="anchor"></a><code><span><span class="keyword">val</span> list : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?offset</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?length</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(string * <a href="#type-tree">tree</a>)</span> list</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>list t key</code> is the list of files and sub-nodes stored under <code>k</code> in <code>t</code>. The result order is not specified but is stable.</p><p><code>offset</code> and <code>length</code> are used for pagination.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-length"><a href="#val-length" class="anchor"></a><code><span><span class="keyword">val</span> length : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>length t key</code> is an Lwt promise that resolves to the number of files and sub-nodes stored under <code>k</code> in <code>t</code>.</p><p>It is equivalent to <code>let+ l = list t k in List.length l</code> but has a constant-time complexity.</p></div></div><h3 id="setters"><a href="#setters" class="anchor"></a>Setters</h3><div class="odoc-spec"><div class="spec value anchored" id="val-add"><a href="#val-add" class="anchor"></a><code><span><span class="keyword">val</span> add : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-value">value</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>add t k v</code> is an Lwt promise that resolves to <code>c</code> such that:</p><ul><li><code>k</code> is bound to <code>v</code> in <code>c</code>;</li><li>and <code>c</code> is similar to <code>t</code> otherwise.</li></ul><p>If <code>k</code> was already bound in <code>t</code> to a value that is physically equal to <code>v</code>, the result of the function is a promise that resolves to <code>t</code>. Otherwise, the previous binding of <code>k</code> in <code>t</code> disappears.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_tree"><a href="#val-add_tree" class="anchor"></a><code><span><span class="keyword">val</span> add_tree : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-tree">tree</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>add_tree</code> is like <a href="#val-add"><code>add</code></a> but for trees.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-remove"><a href="#val-remove" class="anchor"></a><code><span><span class="keyword">val</span> remove : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>remove t k v</code> is an Lwt promise that resolves to <code>c</code> such that:</p><ul><li><code>k</code> is unbound in <code>c</code>;</li><li>and <code>c</code> is similar to <code>t</code> otherwise.</li></ul></div></div><h3 id="folding"><a href="#folding" class="anchor"></a>Folding</h3><div class="odoc-spec"><div class="spec value anchored" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span><span class="keyword">val</span> fold : 
  <span><span class="optlabel">?depth</span>:<a href="../../../../../octez-libs/Tezos_context_sigs/Context/index.html#type-depth">Tezos_context_sigs.Context.depth</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">order</span>:<span>[ `Sorted <span>| `Undefined</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">init</span>:<span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">f</span>:<span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-tree">tree</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>fold ?depth t root ~order ~init ~f</code> recursively folds over the trees and values of <code>t</code>. The <code>f</code> callbacks are called with a key relative to <code>root</code>. <code>f</code> is never called with an empty key for values; i.e., folding over a value is a no-op.</p><p>The depth is 0-indexed. If <code>depth</code> is set (by default it is not), then <code>f</code> is only called when the conditions described by the parameter is true:</p><ul><li><code>Eq d</code> folds over nodes and values of depth exactly <code>d</code>.</li><li><code>Lt d</code> folds over nodes and values of depth strictly less than <code>d</code>.</li><li><code>Le d</code> folds over nodes and values of depth less than or equal to <code>d</code>.</li><li><code>Gt d</code> folds over nodes and values of depth strictly more than <code>d</code>.</li><li><code>Ge d</code> folds over nodes and values of depth more than or equal to <code>d</code>.</li></ul><p>If <code>order</code> is <code>`Sorted</code> (the default), the elements are traversed in lexicographic order of their keys. For large nodes, it is memory-consuming, use <code>`Undefined</code> for a more memory efficient <code>fold</code>.</p></div></div><h3 id="configuration"><a href="#configuration" class="anchor"></a>Configuration</h3><div class="odoc-spec"><div class="spec value anchored" id="val-config"><a href="#val-config" class="anchor"></a><code><span><span class="keyword">val</span> config : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../../../../octez-libs/Tezos_context_sigs/Config/index.html#type-t">Tezos_context_sigs.Config.t</a></span></code></div><div class="spec-doc"><p><code>config t</code> is <code>t</code>'s hash configuration.</p></div></div></details></div><div class="odoc-spec"><div class="spec module anchored" id="module-Proof"><a href="#module-Proof" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Proof/index.html">Proof</a></span><span> : <a href="../../../../../octez-libs/Tezos_context_sigs/Context/module-type-PROOF/index.html">Tezos_context_sigs.Context.PROOF</a></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-node_key"><a href="#type-node_key" class="anchor"></a><code><span><span class="keyword">type</span> node_key</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-value_key"><a href="#type-value_key" class="anchor"></a><code><span><span class="keyword">type</span> value_key</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-kinded_key"><a href="#type-kinded_key" class="anchor"></a><code><span><span class="keyword">type</span> kinded_key</span><span> = </span><span>[ </span></code><ol><li id="type-kinded_key.Node" class="def variant constructor anchored"><a href="#type-kinded_key.Node" class="anchor"></a><code><span>| </span><span>`Node <span class="keyword">of</span> <a href="#type-node_key">node_key</a></span></code></li><li id="type-kinded_key.Value" class="def variant constructor anchored"><a href="#type-kinded_key.Value" class="anchor"></a><code><span>| </span><span>`Value <span class="keyword">of</span> <a href="#type-value_key">value_key</a></span></code></li></ol><code><span> ]</span></code></div><div class="spec-doc"><p>The type of references to tree objects annotated with the type of that object (either a value or a node). Used to build a shallow tree with <code>Tree.shallow</code></p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Tree"><a href="#module-Tree" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Tree/index.html">Tree</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec type subst anchored" id="type-producer"><a href="#type-producer" class="anchor"></a><code><span><span class="keyword">type</span> <span>('proof, 'result) producer</span></span><span> :=
  <span><a href="#type-index">index</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-kinded_key">kinded_key</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-tree">tree</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-tree">tree</a> * <span class="type-var">'result</span>)</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'proof</span> * <span class="type-var">'result</span>)</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>produce r h f</code> runs <code>f</code> on top of a real store <code>r</code>, producing a proof and a result using the initial root hash <code>h</code>.</p><p>The trees produced during <code>f</code>'s computation will carry the full history of reads. This history will be reset when <code>f</code> is complete so subtrees escaping the scope of <code>f</code> will not cause memory leaks.</p><p>Calling <code>produce_proof</code> recursively has an undefined behaviour.</p></div></div><div class="odoc-spec"><div class="spec type subst anchored" id="type-verifier"><a href="#type-verifier" class="anchor"></a><code><span><span class="keyword">type</span> <span>('proof, 'result) verifier</span></span><span> :=
  <span><span class="type-var">'proof</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-tree">tree</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-tree">tree</a> * <span class="type-var">'result</span>)</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="#type-tree">tree</a> * <span class="type-var">'result</span>,
    <span>[ <span>`Proof_mismatch of string</span>
    <span><span>| `Stream_too_long</span> of string</span>
    <span><span>| `Stream_too_short</span> of string</span> ]</span>)</span>
    <span class="xref-unresolved">Stdlib</span>.result</span>
    <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>verify p f</code> runs <code>f</code> in checking mode. <code>f</code> is a function that takes a tree as input and returns a new version of the tree and a result. <code>p</code> is a proof, that is a minimal representation of the tree that contains what <code>f</code> should be expecting.</p><p>Therefore, contrary to trees found in a storage, the contents of the trees passed to <code>f</code> may not be available. For this reason, looking up a value at some <code>path</code> can now produce three distinct outcomes:</p><ul><li>A value <code>v</code> is present in the proof <code>p</code> and returned : <code>find tree path</code> is a promise returning <code>Some v</code>;</li><li><code>path</code> is known to have no value in <code>tree</code> : <code>find tree path</code> is a promise returning <code>None</code>; and</li><li><code>path</code> is known to have a value in <code>tree</code> but <code>p</code> does not provide it because <code>f</code> should not need it: <code>verify</code> returns an error classifying <code>path</code> as an invalid path (see below).</li></ul><p>The same semantics apply to all operations on the tree <code>t</code> passed to <code>f</code> and on all operations on the trees built from <code>f</code>.</p><p>The generated tree is the tree after <code>f</code> has completed. That tree is disconnected from any storage (i.e. <code>index</code>). It is possible to run operations on it as long as they don't require loading shallowed subtrees.</p><p>The result is <code>Error (`Msg _)</code> if the proof is rejected:</p><ul><li>For tree proofs: when <code>p.before</code> is different from the hash of <code>p.state</code>;</li><li>For tree and stream proofs: when <code>p.after</code> is different from the hash of <code>f p.state</code>;</li><li>For tree proofs: when <code>f p.state</code> tries to access invalid paths in <code>p.state</code>;</li><li>For stream proofs: when the proof is not consumed in the exact same order it was produced;</li><li>For stream proofs: when the proof is too short or not empty once <code>f</code> is done.</li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Failure</code> <p>if the proof version is invalid or incompatible with the verifier.</p></li></ul></div></div><div class="odoc-spec"><div class="spec type subst anchored" id="type-tree_proof"><a href="#type-tree_proof" class="anchor"></a><code><span><span class="keyword">type</span> tree_proof</span><span> := <span><a href="Proof/index.html#type-tree">Proof.tree</a> <a href="Proof/index.html#type-t">Proof.t</a></span></span></code></div><div class="spec-doc"><p>The type for tree proofs.</p><p>Guarantee that the given computation performs exactly the same state operations as the generating computation, *in some order*.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-produce_tree_proof"><a href="#val-produce_tree_proof" class="anchor"></a><code><span><span class="keyword">val</span> produce_tree_proof : <span><span>(<a href="#type-tree_proof">tree_proof</a>, <span class="type-var">'a</span>)</span> <a href="#type-producer">producer</a></span></span></code></div><div class="spec-doc"><p><code>produce_tree_proof</code> is the producer of tree proofs.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-verify_tree_proof"><a href="#val-verify_tree_proof" class="anchor"></a><code><span><span class="keyword">val</span> verify_tree_proof : <span><span>(<a href="#type-tree_proof">tree_proof</a>, <span class="type-var">'a</span>)</span> <a href="#type-verifier">verifier</a></span></span></code></div><div class="spec-doc"><p><code>verify_tree_proof</code> is the verifier of tree proofs.</p></div></div><div class="odoc-spec"><div class="spec type subst anchored" id="type-stream_proof"><a href="#type-stream_proof" class="anchor"></a><code><span><span class="keyword">type</span> stream_proof</span><span> := <span><a href="Proof/index.html#type-stream">Proof.stream</a> <a href="Proof/index.html#type-t">Proof.t</a></span></span></code></div><div class="spec-doc"><p>The type for stream proofs.</p><p>Guarantee that the given computation performs exactly the same state operations as the generating computation, in the exact same order.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-produce_stream_proof"><a href="#val-produce_stream_proof" class="anchor"></a><code><span><span class="keyword">val</span> produce_stream_proof : <span><span>(<a href="#type-stream_proof">stream_proof</a>, <span class="type-var">'a</span>)</span> <a href="#type-producer">producer</a></span></span></code></div><div class="spec-doc"><p><code>produce_stream_proof</code> is the producer of stream proofs.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-verify_stream_proof"><a href="#val-verify_stream_proof" class="anchor"></a><code><span><span class="keyword">val</span> verify_stream_proof : <span><span>(<a href="#type-stream_proof">stream_proof</a>, <span class="type-var">'a</span>)</span> <a href="#type-verifier">verifier</a></span></span></code></div><div class="spec-doc"><p><code>verify_stream</code> is the verifier of stream proofs.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-context"><a href="#type-context" class="anchor"></a><code><span><span class="keyword">type</span> context</span><span> = <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-index"><a href="#val-index" class="anchor"></a><code><span><span class="keyword">val</span> index : <span><a href="#type-context">context</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-index">index</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-init"><a href="#val-init" class="anchor"></a><code><span><span class="keyword">val</span> init : 
  <span><span class="optlabel">?patch_context</span>:<span>(<span><a href="#type-context">context</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-context">context</a> <a href="../../../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tzresult">Tezos_base.TzPervasives.tzresult</a></span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?readonly</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?index_log_size</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-index">index</a> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p>Open or initialize a versioned store at a given path.</p><p>The indexing_strategy, which determines whether newly-exported objects by this store handle should also be added to the store's index, is set to <code>`Minimal</code> by default.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-close"><a href="#val-close" class="anchor"></a><code><span><span class="keyword">val</span> close : <span><a href="#type-index">index</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p>Close the index. Does not fail when the context is already closed.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compute_testchain_chain_id"><a href="#val-compute_testchain_chain_id" class="anchor"></a><code><span><span class="keyword">val</span> compute_testchain_chain_id : 
  <span><a href="../../../../../octez-libs/Tezos_crypto/Hashed/Block_hash/index.html#type-t">Tezos_base.TzPervasives.Block_hash.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../../../../octez-libs/Tezos_crypto/Hashed/Chain_id/index.html#type-t">Tezos_base.TzPervasives.Chain_id.t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compute_testchain_genesis"><a href="#val-compute_testchain_genesis" class="anchor"></a><code><span><span class="keyword">val</span> compute_testchain_genesis : 
  <span><a href="../../../../../octez-libs/Tezos_crypto/Hashed/Block_hash/index.html#type-t">Tezos_base.TzPervasives.Block_hash.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../../../../octez-libs/Tezos_crypto/Hashed/Block_hash/index.html#type-t">Tezos_base.TzPervasives.Block_hash.t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : <span><a href="#type-index">index</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Build an empty context from an index. The resulting context should not be committed.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span><span class="keyword">val</span> is_empty : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Returns <code>true</code> if the context is empty.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-commit_genesis"><a href="#val-commit_genesis" class="anchor"></a><code><span><span class="keyword">val</span> commit_genesis : 
  <span><a href="#type-index">index</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">chain_id</span>:<a href="../../../../../octez-libs/Tezos_crypto/Hashed/Chain_id/index.html#type-t">Tezos_base.TzPervasives.Chain_id.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">time</span>:<a href="../../../../../octez-libs/Tezos_base/Time/Protocol/index.html#type-t">Tezos_base.TzPervasives.Time.Protocol.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">protocol</span>:<a href="../../../../../octez-libs/Tezos_crypto/Hashed/Protocol_hash/index.html#type-t">Tezos_base.TzPervasives.Protocol_hash.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../../../../octez-libs/Tezos_crypto/Hashed/Context_hash/index.html#type-t">Tezos_base.TzPervasives.Context_hash.t</a> <a href="../../../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tzresult">Tezos_base.TzPervasives.tzresult</a></span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-commit_test_chain_genesis"><a href="#val-commit_test_chain_genesis" class="anchor"></a><code><span><span class="keyword">val</span> commit_test_chain_genesis : 
  <span><a href="#type-context">context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../../octez-libs/Tezos_base/Block_header/index.html#type-t">Tezos_base.TzPervasives.Block_header.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../../octez-libs/Tezos_base/Block_header/index.html#type-t">Tezos_base.TzPervasives.Block_header.t</a> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_memory_tree"><a href="#val-to_memory_tree" class="anchor"></a><code><span><span class="keyword">val</span> to_memory_tree : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>string list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../../../../octez-libs/Tezos_context_brassaia_memory/Tezos_context_memory/Context/index.html#type-tree">Tezos_context_brassaia_memory.Tezos_context_memory.Context.tree</a> option</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p>Extract a subtree from the <a href="../../../../../octez-libs/Tezos_context_disk/Context/index.html#type-t"><code>Tezos_context.Context.t</code></a> argument and returns it as a <a href="../../../../../octez-libs/Tezos_context_memory/Context/index.html#type-tree"><code>Tezos_context_memory.Context.tree</code></a> (note the the type change!). *</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-merkle_tree"><a href="#val-merkle_tree" class="anchor"></a><code><span><span class="keyword">val</span> merkle_tree : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../../octez-libs/Tezos_context_sigs/Context/Proof_types/index.html#type-merkle_leaf_kind">Tezos_context_sigs.Context.Proof_types.merkle_leaf_kind</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../../octez-libs/Tezos_context_sigs/Context/Proof_types/index.html#type-merkle_tree">Tezos_context_sigs.Context.Proof_types.merkle_tree</a> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>merkle_tree t leaf_kind key</code> returns a Merkle proof for <code>key</code> (i.e. whose hashes reach <code>key</code>). If <code>leaf_kind</code> is <code>Block_services.Hole</code>, the value at <code>key</code> is a hash. If <code>leaf_kind</code> is <code>Block_services.Raw_context</code>, the value at <code>key</code> is a <code>Block_services.raw_context</code>. Values higher in the returned tree are hashes of the siblings on the path to reach <code>key</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-merkle_tree_v2"><a href="#val-merkle_tree_v2" class="anchor"></a><code><span><span class="keyword">val</span> merkle_tree_v2 : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../../octez-libs/Tezos_context_sigs/Context/Proof_types/index.html#type-merkle_leaf_kind">Tezos_context_sigs.Context.Proof_types.merkle_leaf_kind</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="Proof/index.html#type-tree">Proof.tree</a> <a href="Proof/index.html#type-t">Proof.t</a></span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>merkle_tree_v2 t leaf_kind key</code> returns an Irmin Merkle proof for <code>key</code> (i.e. a proof that *something* is in the context at <code>key</code>). The proof is supposed to be produced by Irmin's <code>produce_proof</code>, and consumed by Irmin's <code>verify_proof</code>. The value embedded in the proof depends on <code>leaf_kind</code>. If <code>leaf_kind</code> is <code>Block_services.Raw_context</code>, the embeded value is the complete subtree in the context at <code>key</code>. If <code>leaf_kind</code> is <code>Block_services.Hole</code>, the embedded value is the hash of the subtree described above.</p></div></div><h3 id="accessing-and-updating-versions"><a href="#accessing-and-updating-versions" class="anchor"></a>Accessing and Updating Versions</h3><div class="odoc-spec"><div class="spec value anchored" id="val-exists"><a href="#val-exists" class="anchor"></a><code><span><span class="keyword">val</span> exists : <span><a href="#type-index">index</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../../../octez-libs/Tezos_crypto/Hashed/Context_hash/index.html#type-t">Tezos_base.TzPervasives.Context_hash.t</a> <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-checkout"><a href="#val-checkout" class="anchor"></a><code><span><span class="keyword">val</span> checkout : 
  <span><a href="#type-index">index</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../../octez-libs/Tezos_crypto/Hashed/Context_hash/index.html#type-t">Tezos_base.TzPervasives.Context_hash.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-context">context</a> option</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-checkout_exn"><a href="#val-checkout_exn" class="anchor"></a><code><span><span class="keyword">val</span> checkout_exn : 
  <span><a href="#type-index">index</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../../octez-libs/Tezos_crypto/Hashed/Context_hash/index.html#type-t">Tezos_base.TzPervasives.Context_hash.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-context">context</a> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-hash"><a href="#val-hash" class="anchor"></a><code><span><span class="keyword">val</span> hash : 
  <span><span class="label">time</span>:<a href="../../../../../octez-libs/Tezos_base/Time/Protocol/index.html#type-t">Tezos_base.TzPervasives.Time.Protocol.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?message</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../../../../octez-libs/Tezos_crypto/Hashed/Context_hash/index.html#type-t">Tezos_base.TzPervasives.Context_hash.t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-commit"><a href="#val-commit" class="anchor"></a><code><span><span class="keyword">val</span> commit : 
  <span><span class="label">time</span>:<a href="../../../../../octez-libs/Tezos_base/Time/Protocol/index.html#type-t">Tezos_base.TzPervasives.Time.Protocol.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?message</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-context">context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../../octez-libs/Tezos_crypto/Hashed/Context_hash/index.html#type-t">Tezos_base.TzPervasives.Context_hash.t</a> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-gc"><a href="#val-gc" class="anchor"></a><code><span><span class="keyword">val</span> gc : <span><a href="#type-index">index</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../../../octez-libs/Tezos_crypto/Hashed/Context_hash/index.html#type-t">Tezos_base.TzPervasives.Context_hash.t</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>gc index commit_hash</code> removes from disk all the data older than the <code>commit_hash</code>. Operations needing to checkout commits greater or equal to <code>commit_hash</code> will continue to work. Calling <code>checkout h'</code> on GC-ed commits will return <code>None</code>.</p><p>From the irmin point of view, a successful gc call on a <code>commit_hash</code> will result in a new prefix file containing that <code>commit_hash</code> as a root commit. This prefix file is considered as standalone as all the data referenced by that commit is contained in that file.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-wait_gc_completion"><a href="#val-wait_gc_completion" class="anchor"></a><code><span><span class="keyword">val</span> wait_gc_completion : <span><a href="#type-index">index</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>wait_gc_completion index</code> will return a blocking thread if an Irmin GC is currently ongoing.</p><p><b>Warning</b>: this currently only applies to GC started in the Irmin instance referenced as <code>index</code>; other opened instances will always return instantly.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sync"><a href="#val-sync" class="anchor"></a><code><span><span class="keyword">val</span> sync : <span><a href="#type-index">index</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p>Sync the context with disk. Only useful for read-only instances. Does not fail when the context is not in read-only mode.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_gc_allowed"><a href="#val-is_gc_allowed" class="anchor"></a><code><span><span class="keyword">val</span> is_gc_allowed : <span><a href="#type-index">index</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_gc_allowed index</code> returns whether or not it is possible to run a GC on the given context tree. If false is returned, it means that the context was run, at least once, with the indexing strategy mode &quot;always&quot;, which is not suitable for GC.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-split"><a href="#val-split" class="anchor"></a><code><span><span class="keyword">val</span> split : <span><a href="#type-index">index</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>split index</code> creates a new suffix file, also called &quot;chunk&quot;, into the irmin's file hierarchy.</p><p>To be optimal, the split function is expected to be called directly after committing, to the context, a commit (of hash <code>context_hash</code>) that will be a future candidate of a GC target. Thus, the commit <code>commit_hash</code> is the last commit stored on a given chunk. The GC called on that <code>commit_hash</code> will be able to extract that <code>commit_hash</code> into a new prefix file, and then, drop the whole chunk.</p><p>If the last commit of a chunk appears not to be the candidate of a future GC, it may result in keeping chunks containing partially needed data. This is not an issue, but it should be avoided to prevent storing unnecessary data and thus, to minimize the disk footprint.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-export_snapshot"><a href="#val-export_snapshot" class="anchor"></a><code><span><span class="keyword">val</span> export_snapshot : 
  <span><a href="#type-index">index</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../../octez-libs/Tezos_crypto/Hashed/Context_hash/index.html#type-t">Tezos_base.TzPervasives.Context_hash.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">path</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span>unit <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>export_snapshot index context_hash ~path</code> exports the context corresponding to <code>context_hash</code>, if found in <code>index</code>, into the given folder path. As the export uses the GC's behaviour to extract a single commit into a standalone fresh store, it is not possible to export a snapshot while a GC is running. This call will hang until the GC has finished.</p><p>Note: there is no associated <code>import_snapshot</code> function as the import consist in copying the exported store.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_head"><a href="#val-set_head" class="anchor"></a><code><span><span class="keyword">val</span> set_head : 
  <span><a href="#type-index">index</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../../octez-libs/Tezos_crypto/Hashed/Chain_id/index.html#type-t">Tezos_crypto.Hashed.Chain_id.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../../octez-libs/Tezos_crypto/Hashed/Context_hash/index.html#type-t">Tezos_base.TzPervasives.Context_hash.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>unit <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_master"><a href="#val-set_master" class="anchor"></a><code><span><span class="keyword">val</span> set_master : <span><a href="#type-index">index</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../../../octez-libs/Tezos_crypto/Hashed/Context_hash/index.html#type-t">Tezos_base.TzPervasives.Context_hash.t</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><h3 id="hash-version"><a href="#hash-version" class="anchor"></a>Hash version</h3><div class="odoc-spec"><div class="spec value anchored" id="val-get_hash_version"><a href="#val-get_hash_version" class="anchor"></a><code><span><span class="keyword">val</span> get_hash_version : 
  <span><a href="#type-context">context</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../../../../octez-libs/Tezos_crypto/Hashed/Context_hash/Version/index.html#type-t">Tezos_base.TzPervasives.Context_hash.Version.t</a></span></code></div><div class="spec-doc"><p>Get the hash version used for the context</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_hash_version"><a href="#val-set_hash_version" class="anchor"></a><code><span><span class="keyword">val</span> set_hash_version : 
  <span><a href="#type-context">context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../../octez-libs/Tezos_crypto/Hashed/Context_hash/Version/index.html#type-t">Tezos_base.TzPervasives.Context_hash.Version.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-context">context</a> <a href="../../../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tzresult">Tezos_base.TzPervasives.tzresult</a></span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p>Set the hash version used for the context. It may recalculate the hashes of the whole context, which can be a long process. Returns an <code>Error</code> if the hash version is unsupported.</p></div></div><h3 id="predefined-fields"><a href="#predefined-fields" class="anchor"></a>Predefined Fields</h3><div class="odoc-spec"><div class="spec value anchored" id="val-get_protocol"><a href="#val-get_protocol" class="anchor"></a><code><span><span class="keyword">val</span> get_protocol : <span><a href="#type-context">context</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../../../octez-libs/Tezos_crypto/Hashed/Protocol_hash/index.html#type-t">Tezos_base.TzPervasives.Protocol_hash.t</a> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_protocol"><a href="#val-add_protocol" class="anchor"></a><code><span><span class="keyword">val</span> add_protocol : 
  <span><a href="#type-context">context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../../octez-libs/Tezos_crypto/Hashed/Protocol_hash/index.html#type-t">Tezos_base.TzPervasives.Protocol_hash.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-context">context</a> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_test_chain"><a href="#val-get_test_chain" class="anchor"></a><code><span><span class="keyword">val</span> get_test_chain : 
  <span><a href="#type-context">context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../../octez-libs/Tezos_base/Test_chain_status/index.html#type-t">Tezos_base.TzPervasives.Test_chain_status.t</a> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_test_chain"><a href="#val-add_test_chain" class="anchor"></a><code><span><span class="keyword">val</span> add_test_chain : 
  <span><a href="#type-context">context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../../octez-libs/Tezos_base/Test_chain_status/index.html#type-t">Tezos_base.TzPervasives.Test_chain_status.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-context">context</a> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-remove_test_chain"><a href="#val-remove_test_chain" class="anchor"></a><code><span><span class="keyword">val</span> remove_test_chain : <span><a href="#type-context">context</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-context">context</a> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fork_test_chain"><a href="#val-fork_test_chain" class="anchor"></a><code><span><span class="keyword">val</span> fork_test_chain : 
  <span><a href="#type-context">context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">protocol</span>:<a href="../../../../../octez-libs/Tezos_crypto/Hashed/Protocol_hash/index.html#type-t">Tezos_base.TzPervasives.Protocol_hash.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">expiration</span>:<a href="../../../../../octez-libs/Tezos_base/Time/Protocol/index.html#type-t">Tezos_base.TzPervasives.Time.Protocol.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-context">context</a> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-clear_test_chain"><a href="#val-clear_test_chain" class="anchor"></a><code><span><span class="keyword">val</span> clear_test_chain : 
  <span><a href="#type-index">index</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../../octez-libs/Tezos_crypto/Hashed/Chain_id/index.html#type-t">Tezos_base.TzPervasives.Chain_id.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>unit <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-find_predecessor_block_metadata_hash"><a href="#val-find_predecessor_block_metadata_hash" class="anchor"></a><code><span><span class="keyword">val</span> find_predecessor_block_metadata_hash : 
  <span><a href="#type-context">context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../../../../octez-libs/Tezos_crypto/Hashed/Block_metadata_hash/index.html#type-t">Tezos_base.TzPervasives.Block_metadata_hash.t</a> option</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_predecessor_block_metadata_hash"><a href="#val-add_predecessor_block_metadata_hash" class="anchor"></a><code><span><span class="keyword">val</span> add_predecessor_block_metadata_hash : 
  <span><a href="#type-context">context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../../octez-libs/Tezos_crypto/Hashed/Block_metadata_hash/index.html#type-t">Tezos_base.TzPervasives.Block_metadata_hash.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-context">context</a> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-find_predecessor_ops_metadata_hash"><a href="#val-find_predecessor_ops_metadata_hash" class="anchor"></a><code><span><span class="keyword">val</span> find_predecessor_ops_metadata_hash : 
  <span><a href="#type-context">context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../../../../octez-libs/Tezos_crypto/Hashed/Operation_metadata_list_list_hash/index.html#type-t">Tezos_base.TzPervasives.Operation_metadata_list_list_hash.t</a> option</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_predecessor_ops_metadata_hash"><a href="#val-add_predecessor_ops_metadata_hash" class="anchor"></a><code><span><span class="keyword">val</span> add_predecessor_ops_metadata_hash : 
  <span><a href="#type-context">context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../../octez-libs/Tezos_crypto/Hashed/Operation_metadata_list_list_hash/index.html#type-t">Tezos_base.TzPervasives.Operation_metadata_list_list_hash.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-context">context</a> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div></div></body></html>
