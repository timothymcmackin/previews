<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Block_store (octez-shell-libs.Tezos_store_unix.Block_store)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">octez-shell-libs</a> &#x00BB; <a href="../index.html">Tezos_store_unix</a> &#x00BB; Block_store</nav><header class="odoc-preamble"><h1>Module <code><span>Tezos_store_unix.Block_store</span></code></h1><p>Persistent and cached generic block store</p><p>The store instantiate a cemented block store and multiple floating block stores. The floating stores serve as buffers until enough blocks have arrived. Then it performs a &quot;cementing&quot; (also called a &quot;merge&quot;). Under normal circumstances, there are two different kinds (<a href="../Floating_block_store/index.html#type-floating_kind"><code>Floating_block_store.floating_kind</code></a>) of floating stores instances: a <code>RO</code>(read-only) and a <code>RW</code>(read-write). Newly arrived blocks are <b>always</b> pushed in the <code>RW</code> instance. The block lookup is first tried in <code>RW</code>, then <code>RO</code> and finally in the cement blocks.</p><p>This store also instantiates a LRU block cache to reduce the number of I/O operations. This cache is updated whenever a block is read or stored.</p><p>When a merge occurs, the <code>RW</code> instance is promoted as another <code>RO'</code> and a new <code>RW'</code> instance replaces it. This allows retrieving the new cycle to be cemented from <code>RO</code> and <code>RO'</code> (former <code>RW</code>) <b>asynchronously</b> and thus allowing new blocks to be stored in the newly instantiated <code>RW</code> store without pausing. This asynchronous merging thread, while retrieving the cycle to cement, also combines <code>RO</code> and <code>RO'</code> into a <b>new</b> <code>RO''</code> without the cemented cycle. When the merging thread is done, the former <code>RO</code> and <code>RO'</code> instances are deleted from the disk and the new <code>RO''</code> replaces them. A merging thread has to wait for the previous one to finish.</p><p>Retrieving the new cycle from <code>RO</code> and <code>RO'</code> from blocks <code>B_start</code> and <code>B_end</code> means that we must retrieve the set of blocks between them but also trim potential branches that have roots in this set. To achieve that, we iterate over <code>RO</code> and <code>RO'</code> <b>linearly</b>. This means that <b>every block's predecessor in floating stores must be previously known</b>. Either we previously encountered it in the same floating store file, either in <code>RO</code> if the block is in <code>RO'</code> or in the cemented store (see invariants below). This invariant is required to ensure minimal memory usage. The iterations done to retrieve the cycle and merge the floating stores works similarly to a <i>stop and copy</i> GC algorithm. It works as follows:</p><ul><li>We retrieve the blocks from <code>B_end</code> to <code>B_start</code> by sequentially reading predecessors.</li></ul><ul><li>We instantiate a set of encountered block hashes with <code>B_end</code>'s hash as initial value.</li></ul><ul><li>We iterate sequentially over <code>RO</code> and <code>RO'</code> blocks and copy them only if their predecessors is present in the visited set, adding their hash in the process.</li></ul><p>The result is a correct, in order and trimmed new <code>RO</code> floating store. A visual example of merging is given below.</p><p>The merging thread will also trigger a garbage-collection of the cemented block store w.r.t. the given history mode.</p></header><nav class="odoc-toc"><ul><li><a href="#invariants">Invariants</a></li><li><a href="#merging-example">Merging example</a></li></ul></nav><div class="odoc-content"><h2 id="invariants"><a href="#invariants" class="anchor"></a>Invariants</h2><p>This store is expected to respect the following invariants:</p><ul><li>If no merging thread is pending, two floating stores are present: a <code>RO</code> and a <code>RW</code>.</li></ul><ul><li>If a merging thread is pending, there are three floating stores present: a <code>RO</code>, a <code>RO'</code> and a <code>RW</code>.</li></ul><ul><li>Blocks may be stored twice in <b>floating stores</b> but only when a merging occurs (as <code>RO''</code> is a subset of <code>RO</code>+<code>RO'</code>). However, blocks can be present in both the cemented and the floating store (after importing a storage snapshot as the floating block store consist in a checkpoint associated with its `max_op_ttl` blocks which were already cemented).</li></ul><ul><li>For every stored block in floating stores, its predecessor is either already stored in the same floating store file, in a previous floating store file or in the cemented store.</li></ul><ul><li>A merging thread does not start until the previous one has completed.</li></ul><h2 id="merging-example"><a href="#merging-example" class="anchor"></a>Merging example</h2><pre>           RO          RW

                 | C' - D' - E'   G'
              /  |               /
         A - B - | C - D - E - F - G
                 |  \
                 |    D'' - E''
                 |     \
                 |       E'''</pre><p>For instance, a merging from <code>A</code> to <code>C</code> will first retrieve blocks <code>C</code>, <code>B</code> and <code>A</code>. Then, iterate over all the blocks in both the <code>RO</code> and <code>RW</code> files: reading first in <code>RO</code>, then in <code>RW</code>. By construction, blocks are stored after their predecessors. For example, [ A ; B ; C ; C'; D'' ; D'; D ; E ; E'' ; F ; E''' ; G' ; G ] is a valid storing sequence.</p><p>The algorithm starts iterating over this sequence and will only copy blocks for which predecessors are present in the set S of hash (initially S = { hash(<code>C</code>) }). Thus, for the given sequence, <code>D''</code> will first be considered, S will be updated to { hash(<code>C</code>), hash(<code>D</code>) } and so on, until <code>RO</code> and <code>RW</code> are fully read.</p><p>The new RO will then be:</p><pre>                G'
               /
    - D - E - F - G

    - D'' - E''
       \
        E'''</pre><p>where its storing order will be correct with regards to the invariant.</p><div class="odoc-spec"><div class="spec type anchored" id="type-block_store"><a href="#type-block_store" class="anchor"></a><code><span><span class="keyword">type</span> block_store</span></code></div><div class="spec-doc"><p>The type of the block store</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = <a href="#type-block_store">block_store</a></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-key"><a href="#type-key" class="anchor"></a><code><span><span class="keyword">type</span> key</span><span> = </span></code><ol><li id="type-key.Block" class="def variant constructor anchored"><a href="#type-key.Block" class="anchor"></a><code><span>| </span><span><span class="constructor">Block</span> <span class="keyword">of</span> <a href="../../../octez-libs/Tezos_crypto/Hashed/Block_hash/index.html#type-t">Tezos_base.TzPervasives.Block_hash.t</a> * int</span></code></li></ol></div><div class="spec-doc"><p>The type of the block's key to be accessed: a hash and an offset.</p><ul><li>Block (h, 0) represents the block h itself ;</li></ul><ul><li>Block (h, n) represents the block's <code>n</code>th predecessor.</li></ul><p>A block key may represent an invalid block (wrong hash and/or offset) as it is not ensured to be valid by construction.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-merge_status"><a href="#type-merge_status" class="anchor"></a><code><span><span class="keyword">type</span> merge_status</span><span> = </span></code><ol><li id="type-merge_status.Not_running" class="def variant constructor anchored"><a href="#type-merge_status.Not_running" class="anchor"></a><code><span>| </span><span><span class="constructor">Not_running</span></span></code></li><li id="type-merge_status.Running" class="def variant constructor anchored"><a href="#type-merge_status.Running" class="anchor"></a><code><span>| </span><span><span class="constructor">Running</span></span></code></li><li id="type-merge_status.Merge_failed" class="def variant constructor anchored"><a href="#type-merge_status.Merge_failed" class="anchor"></a><code><span>| </span><span><span class="constructor">Merge_failed</span> <span class="keyword">of</span> <a href="../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tztrace">Tezos_base.TzPervasives.tztrace</a></span></code></li></ol></div><div class="spec-doc"><p>The status of the merging thread</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cemented_block_store"><a href="#val-cemented_block_store" class="anchor"></a><code><span><span class="keyword">val</span> cemented_block_store : <span><a href="#type-block_store">block_store</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Cemented_block_store/index.html#type-t">Cemented_block_store.t</a></span></code></div><div class="spec-doc"><p><code>cemented_block_store block_store</code> returns the instance of the cemented block store for <code>block_store</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-floating_block_stores"><a href="#val-floating_block_stores" class="anchor"></a><code><span><span class="keyword">val</span> floating_block_stores : <span><a href="#type-block_store">block_store</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Floating_block_store/index.html#type-t">Floating_block_store.t</a> list</span></span></code></div><div class="spec-doc"><p><code>floating_block_stores block_store</code> returns all running floating block store instances for <code>block_store</code>. It will always return two or three ordered floating stores:</p><ul><li><code> [RO] ; [RW] </code> if a merge is not occurring;</li></ul><ul><li><code> [RO] ; [RO'] ; [RW] </code> if a merge is occurring.</li></ul><p><b>Warning</b> These stores should only be accessed when the store is not active.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-savepoint"><a href="#val-savepoint" class="anchor"></a><code><span><span class="keyword">val</span> savepoint : 
  <span><a href="#type-block_store">block_store</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Tezos_store_shared/Store_types/index.html#type-block_descriptor">Tezos_store_shared.Store_types.block_descriptor</a> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-write_savepoint"><a href="#val-write_savepoint" class="anchor"></a><code><span><span class="keyword">val</span> write_savepoint : 
  <span><a href="#type-block_store">block_store</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Tezos_store_shared/Store_types/index.html#type-block_descriptor">Tezos_store_shared.Store_types.block_descriptor</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>unit <a href="../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tzresult">Tezos_base.TzPervasives.tzresult</a></span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-caboose"><a href="#val-caboose" class="anchor"></a><code><span><span class="keyword">val</span> caboose : 
  <span><a href="#type-block_store">block_store</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Tezos_store_shared/Store_types/index.html#type-block_descriptor">Tezos_store_shared.Store_types.block_descriptor</a> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-write_caboose"><a href="#val-write_caboose" class="anchor"></a><code><span><span class="keyword">val</span> write_caboose : 
  <span><a href="#type-block_store">block_store</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Tezos_store_shared/Store_types/index.html#type-block_descriptor">Tezos_store_shared.Store_types.block_descriptor</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>unit <a href="../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tzresult">Tezos_base.TzPervasives.tzresult</a></span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-status"><a href="#val-status" class="anchor"></a><code><span><span class="keyword">val</span> status : 
  <span><a href="#type-block_store">block_store</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Tezos_store_shared/Store_types/Block_store_status/index.html#type-t">Tezos_store_shared.Store_types.Block_store_status.t</a> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-genesis_block"><a href="#val-genesis_block" class="anchor"></a><code><span><span class="keyword">val</span> genesis_block : <span><a href="#type-block_store">block_store</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../Tezos_store_shared/Block_repr/index.html#type-t">Tezos_store_shared.Block_repr.t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mem"><a href="#val-mem" class="anchor"></a><code><span><span class="keyword">val</span> mem : <span><a href="#type-block_store">block_store</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span>bool <a href="../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tzresult">Tezos_base.TzPervasives.tzresult</a></span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>mem block_store key</code> tests the existence of the block <code>key</code> in <code>block_store</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_hash"><a href="#val-get_hash" class="anchor"></a><code><span><span class="keyword">val</span> get_hash : 
  <span><a href="#type-block_store">block_store</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span><a href="../../../octez-libs/Tezos_crypto/Hashed/Block_hash/index.html#type-t">Tezos_base.TzPervasives.Block_hash.t</a> option</span> <a href="../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tzresult">Tezos_base.TzPervasives.tzresult</a></span>
    <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>get_hash block_store key</code> retrieves the hash corresponding to the given <code>key</code> in <code>block_store</code>. Return <code>None</code> if the block is unknown.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-resulting_context_hash"><a href="#val-resulting_context_hash" class="anchor"></a><code><span><span class="keyword">val</span> resulting_context_hash : 
  <span><a href="#type-block_store">block_store</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">fetch_expect_predecessor_context</span>:
    <span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span><span>bool <a href="../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tzresult">Tezos_base.TzPervasives.tzresult</a></span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span><a href="../../../octez-libs/Tezos_crypto/Hashed/Context_hash/index.html#type-t">Tezos_base.TzPervasives.Context_hash.t</a> option</span>
    <a href="../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tzresult">Tezos_base.TzPervasives.tzresult</a></span>
    <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>resulting_context_hash block_store ~fetch_expect_predecessor_context key</code> retrieves the resulting context hash from the block application, corresponding to the given <code>key</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-read_block"><a href="#val-read_block" class="anchor"></a><code><span><span class="keyword">val</span> read_block : 
  <span><a href="#type-block_store">block_store</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">read_metadata</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span><a href="../../Tezos_store_shared/Block_repr/index.html#type-t">Tezos_store_shared.Block_repr.t</a> option</span> <a href="../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tzresult">Tezos_base.TzPervasives.tzresult</a></span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>read_block block_store ~read_metadata key</code> reads the block <code>key</code> in <code>block_store</code> if present. Return <code>None</code> if the block is unknown. If <code>read_metadata</code> is set to <code>true</code> it tries to retreive the metadata but do not fail if it is not available.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-read_block_metadata"><a href="#val-read_block_metadata" class="anchor"></a><code><span><span class="keyword">val</span> read_block_metadata : 
  <span><a href="#type-block_store">block_store</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span><a href="../../Tezos_store_shared/Block_repr/index.html#type-metadata">Tezos_store_shared.Block_repr.metadata</a> option</span>
    <a href="../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tzresult">Tezos_base.TzPervasives.tzresult</a></span>
    <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>read_block_metadata block_store key</code> reads the metadata for the block <code>key</code> in <code>block_store</code> if present. Return <code>None</code> if the block is unknown or if the metadata are not present.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-store_block"><a href="#val-store_block" class="anchor"></a><code><span><span class="keyword">val</span> store_block : 
  <span><a href="#type-block_store">block_store</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Tezos_store_shared/Block_repr/index.html#type-t">Tezos_store_shared.Block_repr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../octez-libs/Tezos_crypto/Hashed/Context_hash/index.html#type-t">Tezos_base.TzPervasives.Context_hash.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>unit <a href="../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tzresult">Tezos_base.TzPervasives.tzresult</a></span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>store_block block_store block resulting_context_hash</code> stores the <code>block</code> in the current <code>RW</code> floating store with its associated <code>resulting_context_hash</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cement_blocks"><a href="#val-cement_blocks" class="anchor"></a><code><span><span class="keyword">val</span> cement_blocks : 
  <span><span class="optlabel">?check_consistency</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">write_metadata</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-block_store">block_store</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Cemented_block_store/index.html#type-chunk_iterator">Cemented_block_store.chunk_iterator</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">cycle_range</span>:<span>(int32 * int32)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>unit <a href="../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tzresult">Tezos_base.TzPervasives.tzresult</a></span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>cement_blocks ?check_consistency ~write_metadata block_store
    chunk_iterator ~cycle_range</code></p><p>Wrapper of <a href="../Cemented_block_store/index.html#val-cement_blocks"><code>Cemented_block_store.cement_blocks</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-move_floating_store"><a href="#val-move_floating_store" class="anchor"></a><code><span><span class="keyword">val</span> move_floating_store : 
  <span><a href="#type-block_store">block_store</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">src</span>:<a href="../Floating_block_store/index.html#type-t">Floating_block_store.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">dst_kind</span>:<a href="../Floating_block_store/index.html#type-floating_kind">Floating_block_store.floating_kind</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>unit <a href="../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tzresult">Tezos_base.TzPervasives.tzresult</a></span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>move_floating_store block_store ~src ~dst_kind</code> closes the floating store <code>src</code>, tests the existence of a <code>dst_kind</code> store opened in <code>block_store</code> and tries to close it if it is the case. It then proceeds to replace the files from <code>src</code> to <code>dst</code>.</p><p>This function is unsafe and should only be called in very specific cases.</p><p><b>Warning</b> <code>block_store</code> remains unchanged meaning that the potential deleted floating store is referenced in the structure.</p><p>Fails if both <code>src</code> and <code>dst</code> (if it exists) have the same <a href="../Floating_block_store/index.html#type-floating_kind"><code>Floating_block_store.floating_kind</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-await_merging"><a href="#val-await_merging" class="anchor"></a><code><span><span class="keyword">val</span> await_merging : <span><a href="#type-block_store">block_store</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>await_merging block_store</code> waits for the current merging thread in <code>block_store</code> to finish if any.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-default_cycle_size_limit"><a href="#val-default_cycle_size_limit" class="anchor"></a><code><span><span class="keyword">val</span> default_cycle_size_limit : int32</span></code></div><div class="spec-doc"><p>Default cemented cycles maximum size. I.e.: <code>2^16 - 1</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-merge_stores"><a href="#val-merge_stores" class="anchor"></a><code><span><span class="keyword">val</span> merge_stores : 
  <span><span class="optlabel">?cycle_size_limit</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-block_store">block_store</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">on_error</span>:
    <span>(<span><a href="../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tztrace">Tezos_base.TzPervasives.tztrace</a> <span class="arrow">&#45;&gt;</span></span>
      <span><span>unit <a href="../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tzresult">Tezos_base.TzPervasives.tzresult</a></span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">finalizer</span>:<span>(<span>int32 <span class="arrow">&#45;&gt;</span></span> <span><span>unit <a href="../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tzresult">Tezos_base.TzPervasives.tzresult</a></span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">history_mode</span>:<a href="../../Tezos_shell_services/History_mode/index.html#type-t">Tezos_shell_services.History_mode.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">new_head</span>:<a href="../../Tezos_store_shared/Block_repr/index.html#type-t">Tezos_store_shared.Block_repr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">new_head_metadata</span>:<a href="../../Tezos_store_shared/Block_repr/index.html#type-metadata">Tezos_store_shared.Block_repr.metadata</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">cementing_highwatermark</span>:int32 <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">disable_context_pruning</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span>unit <a href="../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tzresult">Tezos_base.TzPervasives.tzresult</a></span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p>(* TODO UPDATE MERGE DOC *) <code>merge_stores block_store ?finalizer ~nb_blocks_to_preserve
    ~history_mode ~from_block ~to_block</code> triggers a merge as described in the above description. This will result, <b>asynchronously</b>, in:</p><ul><li>the cementing (if needs be) of a cycle from <code>from_block</code> to <code>to_block</code> (included)</li></ul><ul><li>trimming the floating stores and preserves <code>to_block</code> - <code>nb_blocks_to_preserve</code> blocks (iff these blocks are present or the longest suffix otherwise) along with their metadata in the floating store. It may potentially have duplicates in the cemented block store.</li></ul><p>After the cementing, <a href="../Cemented_block_store/index.html#val-trigger_gc"><code>Cemented_block_store.trigger_gc</code></a> will be called with the given <code>history_mode</code>. When the merging thread succeeds, the callback <code>finalizer</code> will be called. Note that depending on the <code>disable_context_pruning</code> flag, the context pruning may be discarded.</p><p>If a merge thread is already occurring, this function will first wait for the previous merge to be done.</p><p>The cemented cycles will have a max size of <code>cycle_size_limit</code> blocks which default to <code>default_cycle_size_limit</code>.</p><p><b>Warning</b> For a given <code>block_store</code>, the caller must wait for this function termination before calling it again or it may result in concurrent intertwining causing the cementing to be out of order.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_merge_status"><a href="#val-get_merge_status" class="anchor"></a><code><span><span class="keyword">val</span> get_merge_status : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-merge_status">merge_status</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_merge_status"><a href="#val-pp_merge_status" class="anchor"></a><code><span><span class="keyword">val</span> pp_merge_status : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-merge_status">merge_status</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-switch_history_mode"><a href="#val-switch_history_mode" class="anchor"></a><code><span><span class="keyword">val</span> switch_history_mode : 
  <span><a href="#type-block_store">block_store</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">current_head</span>:<a href="../../Tezos_store_shared/Block_repr/index.html#type-t">Tezos_store_shared.Block_repr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">previous_history_mode</span>:<a href="../../Tezos_shell_services/History_mode/index.html#type-t">Tezos_shell_services.History_mode.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">new_history_mode</span>:<a href="../../Tezos_shell_services/History_mode/index.html#type-t">Tezos_shell_services.History_mode.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>unit <a href="../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tzresult">Tezos_base.TzPervasives.tzresult</a></span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>switch_history_mode block_store ~current_head
   ~previous_history_mode ~new_history_mode</code> switches the store from the <code>previous_history_mode</code> to the given <code>new_history_mode</code>. To do so, it infers and updates both the caboose and savepoint. If needed, a garbage collection of unnecessary cycles is performed.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-create"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : 
  <span><span class="optlabel">?block_cache_limit</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>[ `Chain_dir ]</span> <a href="../../Tezos_store_shared/Naming/index.html#type-directory">Tezos_store_shared.Naming.directory</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">genesis_block</span>:<a href="../../Tezos_store_shared/Block_repr/index.html#type-t">Tezos_store_shared.Block_repr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-block_store">block_store</a> <a href="../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tzresult">Tezos_base.TzPervasives.tzresult</a></span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>create ?block_cache_limit ~chain_dir ~genesis_block</code> instantiates a fresh <code>block_store</code> in directory <code>chain_dir</code> and stores the <code>genesis_block</code> in it. It fails if the given <code>chain_dir</code> is already populated. Setting the <code>block_cache_limit</code> allows to override the default block cache size.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-load"><a href="#val-load" class="anchor"></a><code><span><span class="keyword">val</span> load : 
  <span><span class="optlabel">?block_cache_limit</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>[ `Chain_dir ]</span> <a href="../../Tezos_store_shared/Naming/index.html#type-directory">Tezos_store_shared.Naming.directory</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">genesis_block</span>:<a href="../../Tezos_store_shared/Block_repr/index.html#type-t">Tezos_store_shared.Block_repr.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">readonly</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-block_store">block_store</a> <a href="../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tzresult">Tezos_base.TzPervasives.tzresult</a></span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>load ?block_cache_limit chain_dir ~genesis_block ~readonly</code> loads an existing block_store from directory <code>chain_dir</code>. Setting <code>readonly</code> will prevent new blocks from being stored. Setting the <code>block_cache_limit</code> allows to override the default block cache size.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lock_block_store"><a href="#val-lock_block_store" class="anchor"></a><code><span><span class="keyword">val</span> lock_block_store : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unlock_block_store"><a href="#val-unlock_block_store" class="anchor"></a><code><span><span class="keyword">val</span> unlock_block_store : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="xref-unresolved">Lwt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sync"><a href="#val-sync" class="anchor"></a><code><span><span class="keyword">val</span> sync : 
  <span><span class="label">last_status</span>:<a href="../../Tezos_store_shared/Store_types/Block_store_status/index.html#type-t">Tezos_store_shared.Store_types.Block_store_status.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="#type-t">t</a>
   * <a href="../../Tezos_store_shared/Store_types/Block_store_status/index.html#type-t">Tezos_store_shared.Store_types.Block_store_status.t</a>
   * <span>(<span>unit <span class="arrow">&#45;&gt;</span></span>
   <span>unit <span class="xref-unresolved">Lwt</span>.t</span>)</span>)</span>
    <a href="../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tzresult">Tezos_base.TzPervasives.tzresult</a></span>
    <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>sync ?last_status block_store</code> updates the <code>block_store</code> internal file descriptors so that the return block store points to the latest fds. This is useful to keep track of a block store opened in readonly mode that is updated by another read/write instance. If <code>last_status</code> is provided, it gives a hint about the previous sync call and may avoid unnecessary synchronizations. As a result, a promise to cleanup resources is returned. This closure must be evaluated after switching to the synchronized block_store to close former resources and avoid leaks.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-register_gc_callback"><a href="#val-register_gc_callback" class="anchor"></a><code><span><span class="keyword">val</span> register_gc_callback : 
  <span><a href="#type-block_store">block_store</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><a href="../../../octez-libs/Tezos_crypto/Hashed/Block_hash/index.html#type-t">Tezos_base.TzPervasives.Block_hash.t</a> <span class="arrow">&#45;&gt;</span></span>
    <span><span>unit <a href="../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tzresult">Tezos_base.TzPervasives.tzresult</a></span> <span class="xref-unresolved">Lwt</span>.t</span>)</span>
    option</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>register_gc_callback block_store callback</code> installs a <code>callback</code> that may be triggered during a block store merge in order to garbage-collect old contexts.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-register_split_callback"><a href="#val-register_split_callback" class="anchor"></a><code><span><span class="keyword">val</span> register_split_callback : 
  <span><a href="#type-block_store">block_store</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span><span>unit <a href="../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tzresult">Tezos_base.TzPervasives.tzresult</a></span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> option</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>register_split_callback chain_store callback</code> installs a <code>callback</code> that may be triggered during a <code>set_head</code> in order to split the context into a new chunk.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-split_context"><a href="#val-split_context" class="anchor"></a><code><span><span class="keyword">val</span> split_context : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Int32.t <span class="arrow">&#45;&gt;</span></span>
  <span><span>unit <a href="../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tzresult">Tezos_base.TzPervasives.tzresult</a></span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>split_context block_store new_head_lpbl</code> calls the callback registered by <code>register_split_callback</code> if any.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-close"><a href="#val-close" class="anchor"></a><code><span><span class="keyword">val</span> close : <span><a href="#type-block_store">block_store</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>close block_store</code> closes the <code>block_store</code> and every underlying opened stores.</p><p><b>Warning</b> If a merging thread is occurring, it will wait up to 5s for its termination before effectively closing the store.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-may_recover_merge"><a href="#val-may_recover_merge" class="anchor"></a><code><span><span class="keyword">val</span> may_recover_merge : 
  <span><a href="#type-block_store">block_store</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>unit <a href="../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tzresult">Tezos_base.TzPervasives.tzresult</a></span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>may_recover_merge block_store</code> recovers, if needed, from a <code>block_store</code> where the merge procedure was interrupted.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-stat_metadata_cycles"><a href="#val-stat_metadata_cycles" class="anchor"></a><code><span><span class="keyword">val</span> stat_metadata_cycles : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span><span>(string * <span><a href="../../Tezos_store_shared/Store_types/index.html#type-metadata_stat">Tezos_store_shared.Store_types.metadata_stat</a> list</span>)</span> list</span>
    <a href="../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tzresult">Tezos_base.TzPervasives.tzresult</a></span>
    <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p>Utility function that aims to give an overview of the shape of the store's metadata.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-v_3_1_upgrade"><a href="#val-v_3_1_upgrade" class="anchor"></a><code><span><span class="keyword">val</span> v_3_1_upgrade : 
  <span><span><span>[ `Chain_dir ]</span> <a href="../../Tezos_store_shared/Naming/index.html#type-directory">Tezos_store_shared.Naming.directory</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>unit <a href="../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tzresult">Tezos_base.TzPervasives.tzresult</a></span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p>Upgrade the block_store_status</p></div></div></div></body></html>
