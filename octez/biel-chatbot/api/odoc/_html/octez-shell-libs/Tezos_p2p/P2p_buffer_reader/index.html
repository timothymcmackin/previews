<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>P2p_buffer_reader (octez-shell-libs.Tezos_p2p.P2p_buffer_reader)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">octez-shell-libs</a> &#x00BB; <a href="../index.html">Tezos_p2p</a> &#x00BB; P2p_buffer_reader</nav><header class="odoc-preamble"><h1>Module <code><span>Tezos_p2p.P2p_buffer_reader</span></code></h1><p>This module takes care of reading data from a <a href="#type-readable"><code>readable</code></a> into a <a href="#type-buffer"><code>buffer</code></a>.</p><p>Its purpose is to take care - via those abstract types - of the tedious tracking of byte positions and lengths when copying data around, as well as ensuring invariants for safety of call sites, e.g. &quot;do not read too much&quot; or &quot;wait if no data is readable right now&quot;.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-readable"><a href="#type-readable" class="anchor"></a><code><span><span class="keyword">type</span> readable</span></code></div><div class="spec-doc"><p>A data source. Reading functions read data <i>from</i> it.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-buffer"><a href="#type-buffer" class="anchor"></a><code><span><span class="keyword">type</span> buffer</span></code></div><div class="spec-doc"><p>A data destination. Reading functions copy data <i>into</i> it.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mk_readable"><a href="#val-mk_readable" class="anchor"></a><code><span><span class="keyword">val</span> mk_readable : 
  <span><span class="label">read_buffer</span>:<a href="../../../octez-libs/Tezos_stdlib/Circular_buffer/index.html#type-t">Tezos_stdlib.Circular_buffer.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">read_queue</span>:
    <span><span><a href="../../../octez-libs/Tezos_stdlib/Circular_buffer/index.html#type-data">Tezos_stdlib.Circular_buffer.data</a> <a href="../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tzresult">Tezos_base.TzPervasives.tzresult</a></span>
      <a href="../../../octez-libs/Tezos_stdlib/Lwt_pipe/Maybe_bounded/index.html#type-t">Tezos_stdlib.Lwt_pipe.Maybe_bounded.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-readable">readable</a></span></code></div><div class="spec-doc"><p><code>mk_readable ~read_buffer ~read_queue</code> creates a <a href="#type-readable"><code>readable</code></a> that uses <code>read_buffer</code> to store data and <code>read_queue</code> to notify asynchronously that data was written.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mk_buffer"><a href="#val-mk_buffer" class="anchor"></a><code><span><span class="keyword">val</span> mk_buffer : 
  <span><span class="optlabel">?pos</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?length_to_copy</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span>bytes <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-buffer">buffer</a> <a href="../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tzresult">Tezos_base.TzPervasives.tzresult</a></span></span></code></div><div class="spec-doc"><p><code>mk_buffer ?pos ?length_to_copy bytes</code> creates a <a href="#type-buffer"><code>buffer</code></a> for copying <code>length_to_copy</code> bytes into <code>bytes</code> starting at position <code>pos</code>.</p><ul><li><code>pos</code> defaults to <code>0</code>.</li><li><code>length_to_copy</code> defaults to <code>Bytes.length bytes - pos</code>.</li></ul><p>If you neither specify <code>pos</code> nor <code>length_to_copy</code>, prefer using <a href="#val-mk_buffer_safe"><code>mk_buffer_safe</code></a> which cannot fail.</p><p>If invalid values are passed, fails with <code>Invalid_read_request</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mk_buffer_safe"><a href="#val-mk_buffer_safe" class="anchor"></a><code><span><span class="keyword">val</span> mk_buffer_safe : <span>bytes <span class="arrow">&#45;&gt;</span></span> <a href="#type-buffer">buffer</a></span></code></div><div class="spec-doc"><p><code>mk_buffer_safe bytes</code> creates a <a href="#type-buffer"><code>buffer</code></a> that uses the entirety of <code>bytes</code>.</p><p>Simpler equivalent to <code>mk_buffer ?pos:None ?length_to_copy:None bytes</code> as the result is not wrapped in a <code>result</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-read"><a href="#val-read" class="anchor"></a><code><span><span class="keyword">val</span> read : 
  <span><span class="optlabel">?canceler</span>:<span class="xref-unresolved">Lwt_canceler</span>.t <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-readable">readable</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-buffer">buffer</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>int <a href="../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tzresult">Tezos_base.TzPervasives.tzresult</a></span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>read readable buffer</code> reads the next segment of data from <code>readable</code> and copies it into <code>buffer</code>, returning the number of read bytes.</p><ul><li>If <code>readable</code> does not currently contain any data, it waits for a segment then reads it.</li><li>If <code>readable</code> already contains data, it reads immediately.</li></ul><p>Note: Even if <code>buffer</code> size is <code>0</code>, this function still waits for data in <code>readable</code> before returning.</p><p>Invariants:</p><ul><li>The returned number of bytes is lower than or equal to the current value of <code>buffer.length_to_copy</code>.</li><li>If the next <code>readable</code> segment is smaller than the current value of <code>buffer.length_to_copy</code> then only this segment is copied into <code>buffer</code> (i.e. after <code>read</code>, <code>buffer.length_to_copy</code> may or may not be <code>0</code>)</li><li>If the next <code>readable</code> segment is bigger than the current value of <code>buffer.length_to_copy</code> then the unused data of that segment is kept for the next read (i.e. <code>readable</code> does not lose data).</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-read_full"><a href="#val-read_full" class="anchor"></a><code><span><span class="keyword">val</span> read_full : 
  <span><span class="optlabel">?canceler</span>:<span class="xref-unresolved">Lwt_canceler</span>.t <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-readable">readable</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-buffer">buffer</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>unit <a href="../../../octez-libs/Tezos_base/TzPervasives/index.html#type-tzresult">Tezos_base.TzPervasives.tzresult</a></span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>read_full readable buffer</code> reads from <code>readable</code> and copies into <code>buffer</code> until <code>buffer</code> is full.</p><ul><li>If <code>readable</code> does not currently contain enough data to fill <code>buffer</code>, it waits for additional segments and reads them.</li><li>If <code>readable</code> already contains data, it reads immediately.</li></ul><p>Invariants:</p><ul><li><code>buffer.length_to_copy</code> after <code>read_full</code> is guaranteed to be <code>0</code> (i.e. it is useless to read into <code>buffer</code> afterwards).</li><li>If the last read segment of <code>readable</code> is bigger than the remaining length of <code>buffer</code> then the unused data of that segment is kept for the next read (i.e. <code>readable</code> does not lose data).</li></ul></div></div></div></body></html>
