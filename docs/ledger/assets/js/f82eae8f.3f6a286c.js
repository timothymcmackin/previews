"use strict";(self.webpackChunktezos_developer_docs=self.webpackChunktezos_developer_docs||[]).push([[1746],{72006:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>s,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"tutorials/security/part-2","title":"Part 2: Leaks","description":"Note: clone this project for compiling and testing this tutorial.","source":"@site/docs/tutorials/security/part-2.md","sourceDirName":"tutorials/security","slug":"/tutorials/security/part-2","permalink":"/previews/docs/ledger/tutorials/security/part-2","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1704949200000,"frontMatter":{"title":"Part 2: Leaks","authors":"Benjamin Fuentes","last_update":{"date":"11 January 2024"}},"sidebar":"tutorialsSidebar","previous":{"title":"Part 1: Programming errors","permalink":"/previews/docs/ledger/tutorials/security/part-1"},"next":{"title":"Part 3: User trust & management","permalink":"/previews/docs/ledger/tutorials/security/part-3"}}');var r=n(74848),o=n(28453);const s={title:"Part 2: Leaks",authors:"Benjamin Fuentes",last_update:{date:"11 January 2024"}},i=void 0,c={},l=[{value:"Replay attack",id:"replay-attack",level:2},{value:"Memory overflow",id:"memory-overflow",level:2},{value:"Re-entrancy",id:"re-entrancy",level:2},{value:"Overflow",id:"overflow",level:2}];function h(e){const t={a:"a",blockquote:"blockquote",code:"code",h2:"h2",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.blockquote,{children:["\n",(0,r.jsxs)(t.p,{children:["Note: clone this ",(0,r.jsx)(t.a,{href:"https://github.com/marigold-dev/training-security-2.git",children:"project"})," for compiling and testing this tutorial."]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"replay-attack",children:"Replay attack"}),"\n",(0,r.jsx)(t.p,{children:"A replay attack on a smart contract is a type of security vulnerability that allows an attacker to reuse a signed valid transaction multiple times. We saw in the previous part how to do off-chain replay attacks, but it is also possible to do on-chain replay attacks.\nEven though Tezos prevents this kind of attack, you can try it by sending the same operation several times."}),"\n",(0,r.jsx)(t.p,{children:"Compile and simulate the replay attack:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:"taq init\ntaq compile 1-replay.jsligo\ntaq simulate 1-replay.tz --param=1-replay.parameter.parameter.tz\n"})}),"\n",(0,r.jsx)(t.p,{children:"The simulation will tell you that several internal transactions will be executed.\nBut if you deploy the code and try to execute it, it throws an error:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:"taq deploy 1-replay.tz --mutez 1000 -e testing\n\ntaq transfer KT1VMt7t4CboRP6jYBUdBQowHb4NR1UtmDrz -e testing\n"})}),"\n",(0,r.jsx)(t.p,{children:"Tezos detect the flaw and returns this error:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-logs",children:'  "message": "(transaction) proto.017-PtNairob.internal_operation_replay"\n'})}),"\n",(0,r.jsx)(t.h2,{id:"memory-overflow",children:"Memory overflow"}),"\n",(0,r.jsx)(t.p,{children:"Memory overflow is a kind of attack that overloads the memory of a smart contract resulting in making this contract unusable. Even simply loading the data into memory and deserializing it at the beginning of the call could use so much gas that any call to the contract would fail. All the funds would be forever locked into the contract."}),"\n",(0,r.jsx)(t.p,{children:"Here is the list of dangerous types to use carefully:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Integers and nats: they can be increased to an arbitrarily large value"}),"\n",(0,r.jsx)(t.li,{children:"Strings: they have no limit on their lengths"}),"\n",(0,r.jsx)(t.li,{children:"Lists, sets, maps: they can contain an arbitrary number of items"}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["\u2192 ",(0,r.jsx)(t.strong,{children:"SOLUTION"}),":"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Ask the user to pay a minimum tez for each call"}),"\n",(0,r.jsx)(t.li,{children:"Set a threshold limit"}),"\n",(0,r.jsx)(t.li,{children:"Store data in a big_map"}),"\n",(0,r.jsx)(t.li,{children:"Avoid unnecessary on-chain computation that can be done off-chain. For example, do not loop on-chain; instead, update a part of a map"}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["Example with the current FA1.2 implementation: ",(0,r.jsx)(t.a,{href:"https://inference.ag/blog/2023-10-09-FA12_spenders/",children:"https://inference.ag/blog/2023-10-09-FA12_spenders/"})]}),"\n",(0,r.jsxs)(t.p,{children:["You can have a look at the LIGO implementation of FA1.2 on the LIGO registry ",(0,r.jsx)(t.a,{href:"https://packages.ligolang.org/package/ligo_fa1.2",children:"here"})]}),"\n",(0,r.jsxs)(t.p,{children:["The code follows the standard but you can see that the ",(0,r.jsx)(t.a,{href:"https://github.com/frankhillard/ligoFA12/blob/main/lib/asset/allowance.mligo#L3C8-L3C8",children:"Allowance type is a map"}),". It would have been better to change the standard and use a ",(0,r.jsx)(t.code,{children:"big_map"})," instead of a ",(0,r.jsx)(t.code,{children:"map"}),". If you implement the standard differently, then your smart contract storage definition and entrypoint signatures will not match anymore and will not be supported by other platforms."]}),"\n",(0,r.jsx)(t.h2,{id:"re-entrancy",children:"Re-entrancy"}),"\n",(0,r.jsx)(t.p,{children:"These attacks allow an attacker to repeatedly call a contract function in a way that drains the contract\u2019s resources, leading to a denial of service (DoS) attack."}),"\n",(0,r.jsx)(t.p,{children:"One of the most well-known examples of a re-entrancy attack occurred in 2016 when an attacker exploited a vulnerability in the DAO (Decentralized Autonomous Organization) contract on the Ethereum blockchain. But this popular hack is still actively used:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Uniswap/Lendf.Me hacks (April 2020) \u2013 $25 mln, attacked by a hacker using a re-entrancy."}),"\n",(0,r.jsx)(t.li,{children:"The BurgerSwap hack (May 2021) \u2013 $7.2 mln, because of a fake token contract and a re-entrancy exploit."}),"\n",(0,r.jsx)(t.li,{children:"The SURGEBNB hack (August 2021) \u2013 $4 mln, seems to be a re-entrancy-based price manipulation attack."}),"\n",(0,r.jsx)(t.li,{children:"CREAM FINANCE hack (August 2021) \u2013 $18.8 mln, re-entrancy vulnerability allowed the exploiter for the second borrow."}),"\n",(0,r.jsx)(t.li,{children:"Siren protocol hack (September 2021) \u2013 $3.5 mln, AMM pools were exploited through re-entrancy attack."}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"This kind of attack is quite simple to put in place with Solidity because of the way it works."}),"\n",(0,r.jsx)(t.p,{children:"Consider this scenario:"}),"\n",(0,r.jsx)(t.mermaid,{value:"sequenceDiagram\n  User->>MaliciousContract: deposit funds\n  MaliciousContract->>LedgerContract: deposit funds\n  User->>MaliciousContract: call withdraw\n  MaliciousContract->>LedgerContract: call withdraw\n  Note right of LedgerContract: checkBalance\n  Note right of LedgerContract: sendFunds\n  LedgerContract->>MaliciousContract: sendFunds operation\n  Note right of MaliciousContract: loop calling withdraw ... x times\n  MaliciousContract->>LedgerContract: call withdraw\n  LedgerContract->>MaliciousContract: sendFunds operation  ... x times\n  Note right of LedgerContract: ... Once finish ... UpdateBalance"}),"\n",(0,r.jsx)(t.p,{children:"Why is this scenario possible on Solidity?\nIn Solidity, when a smart contract calls another smart contract, that operation runs immediately and synchronously.\nThe original smart contract pauses, the other smart contract runs, and then the original smart contract resumes.\nIf someone calls the original smart contract multiple times very quickly, they can generate multiple operations before the original smart contract updates its state.\nIn the example in the previous diagram, a user may be able to run many withdraw operations and drain more than the developer expected."}),"\n",(0,r.jsx)(t.p,{children:"Why is this scenario not possible on Tezos?\nThe transaction mempool queue is processed in sequence.\nWhen a transaction is processed and involves another smart contract call, the new operation is pushed on the queue and is executed after the current operation ends and updates its state."}),"\n",(0,r.jsxs)(t.p,{children:["Let's implement a more complex scenario where the OfferContract and LedgerContract are separated. The OfferContract will naively send the money back to MaliciousContract because it relies on the ",(0,r.jsx)(t.strong,{children:"not yet modified"})," state of the LedgerContract. There are two operations and the modification of the state will come in second position."]}),"\n",(0,r.jsx)(t.mermaid,{value:"sequenceDiagram\n  User->>MaliciousContract: deposit cookies\n  MaliciousContract->>LedgerContract: deposit cookies\n  User->>MaliciousContract: sell cookies\n  MaliciousContract->>OfferContract: sell cookies\n  Note right of OfferContract: checkBalance\n  OfferContract->>LedgerContract: call hasCookies view\n  Note right of OfferContract: prepare post operations (sendFund + changeOwner)\n  OfferContract->>MaliciousContract: sendFund\n  Note right of MaliciousContract: while receiving fund on default entrypoint will loop on selling cookies\n  MaliciousContract->>OfferContract: sell cookies\n  Note right of OfferContract: checkBalance\n  OfferContract->>LedgerContract: call hasCookies view\n  Note right of OfferContract: prepare post operations (sendFund + changeOwner)\n  OfferContract->>MaliciousContract: sendFund\n  MaliciousContract->>OfferContract: sell cookies\n  Note right of OfferContract: checkBalance\n  OfferContract->>LedgerContract: call hasCookies view\n  Note right of OfferContract: prepare post operations (sendFund + changeOwner)\n  OfferContract->>MaliciousContract: sendFund\n  OfferContract->>LedgerContract: call changeOwner"}),"\n",(0,r.jsx)(t.p,{children:"The issue here is clearly that we send money without updating the state first."}),"\n",(0,r.jsxs)(t.p,{children:["\u2192 ",(0,r.jsx)(t.strong,{children:"SOLUTION"}),":"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:["Mutex safeguard: To prevent the contract from generating multiple internal operations, we can add a Mutual Exclusive semaphore Boolean named ",(0,r.jsx)(t.code,{children:"isRunning"})," that is true when an operation is running. This variable locks the contract while the full transaction flow runs."]}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsx)(t.li,{children:"Check the isRunning is false"}),"\n",(0,r.jsx)(t.li,{children:"Set isRunning to true"}),"\n",(0,r.jsx)(t.li,{children:"Do logic code ..."}),"\n",(0,r.jsx)(t.li,{children:"Create a last operation transaction to reset the boolean to false"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"Check-and-send pattern: Principle of separating state changes from external contract interactions. First, update the contract\u2019s state, then interact with other contracts."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Compile and run the hack test first:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:"taq test 3-reentrancyTest.jsligo\n"})}),"\n",(0,r.jsx)(t.p,{children:"The logs seem to be fine, but it is hard to guess the internal transactions and to separate the fees from the hack on the attacker's balance."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-logs",children:'\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Contract                \u2502 Test Results                                \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 3-reentrancyTest.jsligo \u2502 "ledgerContract"                            \u2502\n\u2502                         \u2502 KT1LQyTHEZeaecRj7hWgkzPEBD6vMEKXYzoo(None)  \u2502\n\u2502                         \u2502 "offerContract"                             \u2502\n\u2502                         \u2502 KT1M4nPCej4va4Q2iMPX2FKt8xLw5cfGjBv9(None)  \u2502\n\u2502                         \u2502 "maliciousContract"                         \u2502\n\u2502                         \u2502 KT1B7RgF6j7UpAybpdfxhLCp7hf41pNFcxyS(None)  \u2502\n\u2502                         \u2502 "admin initialize cookies to malicious KT1" \u2502\n\u2502                         \u2502 Success (1299n)                             \u2502\n\u2502                         \u2502 "COOKIES OWNERS"                            \u2502\n\u2502                         \u2502 {KT1B7RgF6j7UpAybpdfxhLCp7hf41pNFcxyS}      \u2502\n\u2502                         \u2502 "BALANCE OF SENDER"                         \u2502\n\u2502                         \u2502 3799985579750mutez                          \u2502\n\u2502                         \u2502 Success (1798n)                             \u2502\n\u2502                         \u2502 "AFTER RUN - BALANCE OF SENDER"             \u2502\n\u2502                         \u2502 3799984579749mutez                          \u2502\n\u2502                         \u2502 {KT1LQyTHEZeaecRj7hWgkzPEBD6vMEKXYzoo}      \u2502\n\u2502                         \u2502 "END RUN - BALANCE OF SENDER"               \u2502\n\u2502                         \u2502 3799984579749mutez                          \u2502\n\u2502                         \u2502 {KT1LQyTHEZeaecRj7hWgkzPEBD6vMEKXYzoo}      \u2502\n\u2502                         \u2502 Everything at the top-level was executed.   \u2502\n\u2502                         \u2502 - testReentrancy exited with value true.    \u2502\n\u2502                         \u2502                                             \u2502\n\u2502                         \u2502 \ud83c\udf89 All tests passed \ud83c\udf89                      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n'})}),"\n",(0,r.jsx)(t.p,{children:"To have a better visualization of the hack, the contract should be deployed."}),"\n",(0,r.jsx)(t.p,{children:"Compile the first contract, the Ledger contract, and deploy it:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:"taq compile 3-reentrancyLedgerContract.jsligo\ntaq deploy 3-reentrancyLedgerContract.tz -e testing\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Copy the contract address, in my case ",(0,r.jsx)(t.code,{children:"KT1BJZfhC459WqCVJzPmu3vJSWFFkvyi9k1u"}),", and paste it in the file ",(0,r.jsx)(t.code,{children:"3-reentrancyOfferContract.storageList.jsligo"}),"."]}),"\n",(0,r.jsx)(t.p,{children:"Compile and deploy the second contract, the Offer contract, putting some money on the contract for the thieves:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:"taq compile 3-reentrancyOfferContract.jsligo\ntaq deploy 3-reentrancyOfferContract.tz -e testing --mutez 10000000\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Copy the contract address, in my case ",(0,r.jsx)(t.code,{children:"KT1CHJgXEdBPktNNPGTDaL8XEAzJV9fjSkrZ"}),", and paste it in the file ",(0,r.jsx)(t.code,{children:"3-reentrancyMaliciousContract.storageList.jsligo"}),"."]}),"\n",(0,r.jsx)(t.p,{children:"Compile and deploy the last contract, the Malicious contract which will loop and steal the funds of the Offer contract:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:"taq compile 3-reentrancyMaliciousContract.jsligo\ntaq deploy 3-reentrancyMaliciousContract.tz -e testing\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Copy the contract address, in my case ",(0,r.jsx)(t.code,{children:"KT1NKLZE9HkGJxjopowLqxA4pswutgMrrXyE"}),", and initialize the Ledger contract as the Malicious contract as some cookies on its storage. Paste the value in the file ",(0,r.jsx)(t.code,{children:"3-reentrancyLedgerContract.parameterList.jsligo"}),"."]}),"\n",(0,r.jsx)(t.p,{children:"When you are done, compile the Ledger contracts and call them with this parameter:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:"taq compile 3-reentrancyLedgerContract.jsligo\ntaq call 3-reentrancyLedgerContract --param 3-reentrancyLedgerContract.parameter.default_parameter.tz -e testing\n"})}),"\n",(0,r.jsx)(t.p,{children:"Context is ready:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"The Malicious contract has cookies on the Ledger contract"}),"\n",(0,r.jsx)(t.li,{children:"All deployed contract points to the correct addresses"}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Now the Malicious contract will try to steal funds from the Offer contract. Run the command to start the attack on the transaction flow:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:"octez-client transfer 0 from alice to KT1NKLZE9HkGJxjopowLqxA4pswutgMrrXyE --entrypoint attack --arg 'Unit' --burn-cap 1\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Here you can see the result on the Ghostnet: ",(0,r.jsx)(t.a,{href:"https://ghostnet.tzkt.io/KT1NKLZE9HkGJxjopowLqxA4pswutgMrrXyE/operations/",children:"https://ghostnet.tzkt.io/KT1NKLZE9HkGJxjopowLqxA4pswutgMrrXyE/operations/"})]}),"\n",(0,r.jsx)(t.p,{children:"3 refunds will be emitted instead of one."}),"\n",(0,r.jsxs)(t.p,{children:["\u2192 ",(0,r.jsx)(t.strong,{children:"SOLUTION"}),": On the ",(0,r.jsx)(t.code,{children:"3-reentrancyOfferContract.jsligo"})," file, line 34, swap the order of operation execution from this:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-jsligo",children:"return [list([opTx, opChangeOwner]), s];\n"})}),"\n",(0,r.jsx)(t.p,{children:"to this:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-jsligo",children:"return [list([opChangeOwner,opTx]), s];\n"})}),"\n",(0,r.jsx)(t.p,{children:"Then rerun the scenario from scratch redeploying the contracts. It should be impossible to run the attack, because the transaction will fail with this message:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-logs",children:'"message":"user do not have cookies"\n'})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"Authorize withdraw transfer only to a user account: Because the user wallet cannot do callback loops, it solves the issue but this solution is not always feasible and limiting. To check if an address is a user account, verify that the sender and source are equal."}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"Audit External Contract calls: This is very hard to check, for example on withdrawal for a token transfer, any contract can receive funds."}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"Call third-party security experts or employ automated security tools: If you are not sure about your code, they will identify weaknesses and validate the contract\u2019s security measures."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"overflow",children:"Overflow"}),"\n",(0,r.jsx)(t.p,{children:"Manipulating arithmetic operations can lead to overflows and underflows."}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:"On Solidity: SafeMath is a library in Solidity that was designed to provide safe mathematical operations. It prevents overflow and underflow errors when working with unsigned integers (uint), which can lead to unexpected behavior in smart contracts. However, since Solidity v0.8.0, this library has been made obsolete as the language itself starts to include internal checking."}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:["On LIGO: For the nat, int, and timestamp types, the Michelson interpreter uses arbitrary-precision arithmetic provided by the ",(0,r.jsx)(t.a,{href:"https://github.com/ocaml/Zarith",children:"OCaml Zarith library"}),". This means that their size is only limited by gas or storage limits. You can store huge numbers in a contract without reaching the limit. However, in LIGO, an overflow will cause the contract to fail."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["\u2192 ",(0,r.jsx)(t.strong,{children:"SOLUTION"}),":"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"For large tez values, do operations with int or nat types, which have larger memory values."}),"\n",(0,r.jsx)(t.li,{children:"There is no other solution than using types with larger values because the default behavior is to reject the transaction in case of overflow."}),"\n"]}),"\n",(0,r.jsxs)(t.blockquote,{children:["\n",(0,r.jsxs)(t.p,{children:["Do not confuse the OCaml Zarith library with the ",(0,r.jsx)(t.a,{href:"https://packages.ligolang.org/package/@ligo/math-lib",children:"Ligo MathLib library"}),", which provides manipulation of floats and rationals instead of using basic types."]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["Go to ",(0,r.jsx)(t.a,{href:"/tutorials/security/part-3",children:"Part 3: User trust & management"}),"."]})]})}function d(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>i});var a=n(96540);const r={},o=a.createContext(r);function s(e){const t=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),a.createElement(o.Provider,{value:t},e.children)}}}]);