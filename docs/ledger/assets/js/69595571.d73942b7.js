"use strict";(self.webpackChunktezos_developer_docs=self.webpackChunktezos_developer_docs||[]).push([[4468],{49955:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>t,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"smart-contracts/logic/comparing","title":"Comparing values","description":"The ways that you can compare values depends on the types of those values.","source":"@site/docs/smart-contracts/logic/comparing.md","sourceDirName":"smart-contracts/logic","slug":"/smart-contracts/logic/comparing","permalink":"/previews/docs/ledger/smart-contracts/logic/comparing","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1696392000000,"frontMatter":{"title":"Comparing values","authors":"Mathias Hiron (Nomadic Labs), Sasha Aldrick (TriliTech), Tim McMackin (TriliTech)","last_update":{"date":"4 October 2023"}},"sidebar":"documentationSidebar","previous":{"title":"Cryptographic data types","permalink":"/previews/docs/ledger/smart-contracts/data-types/crypto-data-types"},"next":{"title":"Loops and iterations","permalink":"/previews/docs/ledger/smart-contracts/logic/loops"}}');var a=n(74848),o=n(28453);const i={title:"Comparing values",authors:"Mathias Hiron (Nomadic Labs), Sasha Aldrick (TriliTech), Tim McMackin (TriliTech)",last_update:{date:"4 October 2023"}},t=void 0,c={},l=[{value:"Implementation details",id:"implementation-details",level:3}];function d(e){const s={a:"a",code:"code",h3:"h3",li:"li",ol:"ol",p:"p",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(s.p,{children:"The ways that you can compare values depends on the types of those values."}),"\n",(0,a.jsxs)(s.p,{children:["Many types allow the usual comparison operators: ",(0,a.jsx)(s.code,{children:"="}),", ",(0,a.jsx)(s.code,{children:"!="}),", ",(0,a.jsx)(s.code,{children:"<"}),", ",(0,a.jsx)(s.code,{children:">"}),", ",(0,a.jsx)(s.code,{children:"\u2264"})," and ",(0,a.jsx)(s.code,{children:"\u2265"}),".\nThe syntax depends on the language.\nComparing values in this way produces a Boolean type that you can use in conditional instructions or to continue or terminate loops."]}),"\n",(0,a.jsx)(s.p,{children:"How values are compared depends on the type of the values:"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"nat"}),", ",(0,a.jsx)(s.code,{children:"int"}),", ",(0,a.jsx)(s.code,{children:"mutez"})," and timestamp values are compared numerically."]}),"\n",(0,a.jsxs)(s.li,{children:["Strings, ",(0,a.jsx)(s.code,{children:"bytes"}),", ",(0,a.jsx)(s.code,{children:"key_hash"}),", ",(0,a.jsx)(s.code,{children:"key"}),", ",(0,a.jsx)(s.code,{children:"signature"})," and ",(0,a.jsx)(s.code,{children:"chain_id"})," values are compared lexicographically."]}),"\n",(0,a.jsx)(s.li,{children:"Boolean values are compared so that false is strictly less than true."}),"\n",(0,a.jsxs)(s.li,{children:["Address are compared as follows:","\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"Addresses of user accounts are strictly less than addresses of smart contracts."}),"\n",(0,a.jsx)(s.li,{children:"Addresses of the same type are compared lexicographically."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(s.li,{children:"Pair values (and therefore records) are compared component by component, starting with the first component."}),"\n",(0,a.jsxs)(s.li,{children:["Options are compared as follows:","\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"None"})," is strictly less than any ",(0,a.jsx)(s.code,{children:"Some"}),"."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"Some x"})," and ",(0,a.jsx)(s.code,{children:"Some y"})," are compared as ",(0,a.jsx)(s.code,{children:"x"})," and ",(0,a.jsx)(s.code,{children:"y"}),"."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:["Values of ",(0,a.jsx)(s.code,{children:"union"})," types built with ",(0,a.jsx)(s.code,{children:"or"})," are compared as follows:","\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:["any ",(0,a.jsx)(s.code,{children:"Left x"})," is smaller than any ",(0,a.jsx)(s.code,{children:"Right y"}),","]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"Left x"})," and ",(0,a.jsx)(s.code,{children:"Left y"})," are compared as ",(0,a.jsx)(s.code,{children:"x"})," and ",(0,a.jsx)(s.code,{children:"y"}),","]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"Right x"})," and ",(0,a.jsx)(s.code,{children:"Right y"})," are compared as ",(0,a.jsx)(s.code,{children:"x"})," and ",(0,a.jsx)(s.code,{children:"y"}),"."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:["Values of type ",(0,a.jsx)(s.code,{children:"Unit"})," are all equal."]}),"\n"]}),"\n",(0,a.jsx)(s.p,{children:"In Michelson, comparisons are done in two steps:"}),"\n",(0,a.jsxs)(s.ol,{children:["\n",(0,a.jsxs)(s.li,{children:["A ",(0,a.jsx)(s.code,{children:"COMPARE"})," instruction consumes the values and produces a value that is 0 if the two elements are equal, negative if the first element in the stack is less than the second, and positive otherwise."]}),"\n",(0,a.jsxs)(s.li,{children:["The instructions ",(0,a.jsx)(s.code,{children:"EQ"})," (equal), ",(0,a.jsx)(s.code,{children:"NEQ"})," (not equal), ",(0,a.jsx)(s.code,{children:"LT"})," (lower than), ",(0,a.jsx)(s.code,{children:"GT"})," (greater than), ",(0,a.jsx)(s.code,{children:"LE"})," (lower or equal) and ",(0,a.jsx)(s.code,{children:"GE"})," (greater or equal) consume this value and return the corresponding Boolean value."]}),"\n"]}),"\n",(0,a.jsx)(s.h3,{id:"implementation-details",children:"Implementation details"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:["Michelson: ",(0,a.jsx)(s.a,{href:"https://tezos.gitlab.io/active/michelson.html#generic-comparison",children:"Generic comparison"})]}),"\n",(0,a.jsxs)(s.li,{children:["Archetype: ",(0,a.jsx)(s.a,{href:"https://archetype-lang.org/docs/reference/expressions/operators/arithmetic#a--b-7",children:"Comparison operators"})]}),"\n",(0,a.jsxs)(s.li,{children:["SmartPy: ",(0,a.jsx)(s.a,{href:"https://smartpy.io/manual/syntax/integers-and-mutez#comparison",children:"Comparing sp.int and sp.nat"})]}),"\n",(0,a.jsxs)(s.li,{children:["LIGO: ",(0,a.jsx)(s.a,{href:"https://ligolang.org/docs/language-basics/boolean-if-else#comparing-values",children:"Comparing values"})]}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,o.R)(),...e.components};return s?(0,a.jsx)(s,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453:(e,s,n)=>{n.d(s,{R:()=>i,x:()=>t});var r=n(96540);const a={},o=r.createContext(a);function i(e){const s=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function t(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),r.createElement(o.Provider,{value:s},e.children)}}}]);