"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9444],{7721:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"tutorials/smart-rollup","title":"Deploy a Smart Rollup","description":"This tutorial covers how to deploy a Smart Rollup in a Tezos sandbox.","source":"@site/docs/tutorials/smart-rollup.md","sourceDirName":"tutorials","slug":"/tutorials/smart-rollup","permalink":"/previews/docs/biel-ai-search/tutorials/smart-rollup","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1696996800000,"frontMatter":{"title":"Deploy a Smart Rollup","last_update":{"date":"11 October 2023"},"dependencies":{"tezos-smart-rollup":"0.2.1","rust":1.73,"octez":19}},"sidebar":"tutorialsSidebar","previous":{"title":"Running a baker signing using a Ledger baking key","permalink":"/previews/docs/biel-ai-search/tutorials/bake-with-ledger/run-baker"},"next":{"title":"Part 1: Setting up the application","permalink":"/previews/docs/biel-ai-search/tutorials/smart-rollup/set-up"}}');var a=n(74848),r=n(28453);const o={title:"Deploy a Smart Rollup",last_update:{date:"11 October 2023"},dependencies:{"tezos-smart-rollup":"0.2.1",rust:1.73,octez:19}},i=void 0,l={},c=[{value:"What is a Smart Rollup?",id:"what-is-a-smart-rollup",level:2},{value:"Smart Rollup analogy",id:"smart-rollup-analogy",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Tutorial application",id:"tutorial-application",level:2}];function h(e){const s={a:"a",code:"code",em:"em",h2:"h2",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(s.p,{children:"This tutorial covers how to deploy a Smart Rollup in a Tezos sandbox.\nTo run this tutorial, you should have a basic understanding of how Tezos works and the ability to use the command-line terminal on your computer."}),"\n",(0,a.jsx)(s.p,{children:"In this tutorial, you will learn:"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"What a Smart Rollup is and how they help scale Tezos"}),"\n",(0,a.jsx)(s.li,{children:"How information passes between Tezos and Smart Rollups"}),"\n",(0,a.jsx)(s.li,{children:"How to respond to messages from Tezos in a Smart Rollup"}),"\n"]}),"\n",(0,a.jsx)(s.h2,{id:"what-is-a-smart-rollup",children:"What is a Smart Rollup?"}),"\n",(0,a.jsx)(s.p,{children:"Smart Rollups are processing units that run outside the Tezos network but communicate with Tezos on a regular basis.\nThese processing units can run arbitrarily large amounts of code without waiting for Tezos baking nodes to run and verify that code.\nSmart Rollups use Tezos for information and transactions but can run large applications at their own speed, independently of the Tezos baking system."}),"\n",(0,a.jsxs)(s.p,{children:["In this way, Smart Rollups allow Tezos to scale to support large, complex applications without slowing Tezos itself or incurring large transaction and storage fees.\nThe processing that runs on Tezos itself via smart contracts is referred to as ",(0,a.jsx)(s.em,{children:"layer 1"})," and the processing that Smart Rollups run is referred to as ",(0,a.jsx)(s.em,{children:"layer 2"}),".\nTo learn about running code in smart contracts, see the tutorial ",(0,a.jsx)(s.a,{href:"/tutorials/smart-contract",children:"Deploy a smart contract"}),"."]}),"\n",(0,a.jsx)(s.p,{children:"Rollups also have an outbox, which consists of calls to smart contracts on layer 1.\nThese calls are how rollups send messages back to layer 1."}),"\n",(0,a.jsx)(s.p,{children:"Smart Rollups can run any kind of applications that they want, such as:"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"Financial applications that use information and transactions from Tezos"}),"\n",(0,a.jsx)(s.li,{children:"Gaming applications that manipulate assets and keep them in sync with Tezos"}),"\n",(0,a.jsx)(s.li,{children:"Applications that run complex logic on NFTs or other types of tokens"}),"\n",(0,a.jsx)(s.li,{children:"Applications that communicate with other blockchains"}),"\n"]}),"\n",(0,a.jsxs)(s.p,{children:["Rollups maintain consensus by publishing the hash of their state to Tezos, which other nodes can use to verify the rollup's behavior.\nThe specific way that rollups publish their states and maintain consensus is beyond the scope of this tutorial.\nFor more information about rollups and their consensus mechanism, see ",(0,a.jsx)(s.a,{href:"/architecture/smart-rollups",children:"Smart Optimistic Rollups"}),"."]}),"\n",(0,a.jsx)(s.p,{children:"This diagram shows a Smart Rollup interacting with layer 1 by receiving a message, running processing based on that message, and sending a transaction to layer 1:"}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.img,{alt:"Diagram that shows the flow of messages in Smart Rollups",src:n(80011).A+"",width:"1759",height:"880"})}),"\n",(0,a.jsx)(s.p,{children:"Smart Rollups stay in sync with Tezos by passing messages to Tezos and receiving messages from Tezos and other rollups.\nEach Tezos block contains a global rollups inbox that contains messages from Tezos layer 1 to all rollups.\nAnyone can add a message to this inbox and all messages are visible to all rollups.\nRollups receive this inbox, filter it to the messages that they are interested in, and act on them accordingly."}),"\n",(0,a.jsx)(s.h2,{id:"smart-rollup-analogy",children:"Smart Rollup analogy"}),"\n",(0,a.jsxs)(s.p,{children:["Businesses talk about ",(0,a.jsx)(s.em,{children:"horizontal scaling"})," versus ",(0,a.jsx)(s.em,{children:"vertical scaling"}),".\nIf a business is growing and its employees are being overworked, the business could use vertical scaling to hire more employees or use better tools to improve the productivity of each employee.\nScaling Tezos in this way would mean using more processing power to process each new block, which would increase the cost to run baking nodes.\nAlso, if the business hires more employees, the amount of communication between employees increases because, for example, they have to make sure that they are working in the same way and not doing duplicate jobs."]}),"\n",(0,a.jsx)(s.p,{children:"By contrast, Smart Rollups behave like horizontal scaling.\nIn horizontal scaling, businesses create specialized teams that work on different portions of the workload.\nThese teams can work independently of other teams and take advantage of efficiencies of being focused on a specific task.\nThey also need to communicate less with other teams, which speeds up their work.\nSmart Rollups are like separate horizontally scaled teams, with Tezos layer 1 as the source of communication between teams."}),"\n",(0,a.jsx)(s.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,a.jsx)(s.p,{children:"To run this tutorial, make sure that the following tools are installed:"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.a,{href:"https://www.docker.com/",children:"Docker"})}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsx)(s.p,{children:"Rust"}),"\n",(0,a.jsx)(s.p,{children:"The application in this tutorial uses Rust because of its support for WebAssembly (WASM), the language that Smart Rollups use to communicate.\nRollups can use any language that has WASM compilation support."}),"\n",(0,a.jsxs)(s.p,{children:["To install Rust via the ",(0,a.jsx)(s.code,{children:"rustup"})," command, run this command:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-bash",children:"curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n"})}),"\n",(0,a.jsxs)(s.p,{children:["You can see other ways of installing Rust at ",(0,a.jsx)(s.a,{href:"https://www.rust-lang.org",children:"https://www.rust-lang.org"}),"."]}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsx)(s.p,{children:"Clang and LLVM"}),"\n",(0,a.jsx)(s.p,{children:"Clang and LLVM are required for compilation to WebAssembly.\nVersion 11 or later of Clang is required.\nHere are instructions for installing the appropriate tools on different operating systems:"}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"MacOS"})}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-bash",children:'brew install llvm\nexport CC="$(brew --prefix llvm)/bin/clang"\n'})}),"\n",(0,a.jsxs)(s.p,{children:["In some cases for MacOS you may need to update your ",(0,a.jsx)(s.code,{children:"PATH"})," environment variable to include LLVM by running this command:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-bash",children:"echo 'export PATH=\"/opt/homebrew/opt/llvm/bin:$PATH\"' >> ~/.zshrc\n"})}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Ubuntu"})}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-bash",children:"sudo apt-get install clang-11\nexport CC=clang-11\n"})}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Fedora"})}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-bash",children:"dnf install clang\nexport CC=clang\n"})}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Arch Linux"})}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-bash",children:"pacman -S clang\nexport CC=clang\n"})}),"\n",(0,a.jsxs)(s.p,{children:["The ",(0,a.jsx)(s.code,{children:"export CC"})," command sets Clang as the default C/C++ compiler."]}),"\n",(0,a.jsxs)(s.p,{children:["After you run these commands, run ",(0,a.jsx)(s.code,{children:"$CC --version"})," to verify that you have version 11 or greater installed."]}),"\n",(0,a.jsxs)(s.p,{children:["Also, ensure that your version of Clang ",(0,a.jsx)(s.code,{children:"wasm32"})," target with by running the command ",(0,a.jsx)(s.code,{children:"$CC -print-targets | grep wasm32"})," and verifying that the results include ",(0,a.jsx)(s.code,{children:"wasm32"}),"."]}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsx)(s.p,{children:"AR (macOS only)"}),"\n",(0,a.jsx)(s.p,{children:"To compile to WebAssembly on macOS, you need to use the LLVM archiver.\nIf you used Homebrew to install LLVM, you can configure it to use the archiver by running this command:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-bash",children:'export AR="$(brew --prefix llvm)/bin/llvm-ar"\n'})}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsx)(s.p,{children:"WebAssembly Toolkit"}),"\n",(0,a.jsxs)(s.p,{children:["The ",(0,a.jsxs)(s.a,{href:"https://github.com/WebAssembly/wabt",children:["WebAssembly Toolkit (",(0,a.jsx)(s.code,{children:"wabt"}),")"]})," provides tooling for reducing (or ",(0,a.jsx)(s.em,{children:"stripping"}),") the size of WebAssembly binaries (with the ",(0,a.jsx)(s.code,{children:"wasm-strip"})," command) and conversion utilities between the textual and binary representations of WebAssembly (including the ",(0,a.jsx)(s.code,{children:"wat2wasm"})," and ",(0,a.jsx)(s.code,{children:"wasm2wat"})," commands)."]}),"\n",(0,a.jsxs)(s.p,{children:["Most distributions ship a ",(0,a.jsx)(s.code,{children:"wabt"})," package, which you can install with the appropriate command for your operating system:"]}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"MacOS"})}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-bash",children:"brew install wabt\n"})}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Ubuntu"})}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-bash",children:"sudo apt install wabt\n"})}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Fedora"})}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-bash",children:"dnf install wabt\n"})}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Arch Linux"})}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-bash",children:"pacman -S wabt\n"})}),"\n",(0,a.jsxs)(s.p,{children:["To verify that ",(0,a.jsx)(s.code,{children:"wabt"})," is installed, run the command ",(0,a.jsx)(s.code,{children:"wasm-strip --version"})," and verify that the version is at least 1.0.31.\nIf not, you can download this version directly and extract its files: ",(0,a.jsx)(s.a,{href:"https://github.com/WebAssembly/wabt/releases/tag/1.0.31",children:"https://github.com/WebAssembly/wabt/releases/tag/1.0.31"}),".\nThen, whenever you have to use ",(0,a.jsx)(s.code,{children:"wasm-strip"}),", you can use ",(0,a.jsx)(s.code,{children:"<path_to_wabt_1.0.31>/bin/wasm-strip"})," instead."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(s.h2,{id:"tutorial-application",children:"Tutorial application"}),"\n",(0,a.jsxs)(s.p,{children:["Despite the number of command-line tools needed, the code for the core of the rollup itself is relatively simple.\nThis core is called the ",(0,a.jsx)(s.em,{children:"kernel"})," and is responsible for accepting messages from layer 1 and sending messages to layer 1."]}),"\n",(0,a.jsxs)(s.p,{children:["The code for the tutorial application is here: ",(0,a.jsx)(s.a,{href:"https://gitlab.com/trili/hello-world-kernel",children:"https://gitlab.com/trili/hello-world-kernel"}),"."]}),"\n",(0,a.jsxs)(s.p,{children:["The code for the kernel is in the ",(0,a.jsx)(s.code,{children:"src/lib.rs"})," file.\nIt is written in the Rust programming language and looks like this:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-rust",children:'use tezos_smart_rollup::inbox::InboxMessage;\nuse tezos_smart_rollup::kernel_entry;\nuse tezos_smart_rollup::michelson::MichelsonBytes;\nuse tezos_smart_rollup::prelude::*;\n\nkernel_entry!(hello_kernel);\n\nfn handle_message(host: &mut impl Runtime, msg: impl AsRef<[u8]>) {\n    if let Some((_, msg)) = InboxMessage::<MichelsonBytes>::parse(msg.as_ref()).ok() {\n        debug_msg!(host, "Got message: {:?}\\n", msg);\n    }\n}\n\npub fn hello_kernel(host: &mut impl Runtime) {\n    debug_msg!(host, "Hello, kernel!\\n");\n\n    while let Some(msg) = host.read_input().unwrap() {\n        handle_message(host, msg);\n    }\n}\n'})}),"\n",(0,a.jsx)(s.p,{children:"This example kernel has these major parts:"}),"\n",(0,a.jsxs)(s.ol,{children:["\n",(0,a.jsx)(s.li,{children:"It imports resources that allow it to access and decode messages from layer 1."}),"\n",(0,a.jsxs)(s.li,{children:["It runs the Rust macro ",(0,a.jsx)(s.code,{children:"kernel_entry!"})," to set the main function for the kernel."]}),"\n",(0,a.jsxs)(s.li,{children:["It declares the ",(0,a.jsx)(s.code,{children:"handle_message"})," function, which accepts, decodes, and processes messages from layer 1.\nIn this case, the function decodes the message (which is sent as a sequence of bytes) and prints it to the log.\nThe function could call any other logic that the application needs to run."]}),"\n",(0,a.jsxs)(s.li,{children:["It declares the ",(0,a.jsx)(s.code,{children:"hello_kernel"})," function, which is the main function for the kernel.\nIt runs each time the kernel receives messages from layer 1, prints a logging message each time it is called, and runs the ",(0,a.jsx)(s.code,{children:"handle_message"})," function on each message."]}),"\n"]}),"\n",(0,a.jsx)(s.p,{children:"You don't need to access the other files in the application directly, but here are descriptions of them:"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"src/lib.rs"}),": The Rust code for the kernel"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"Cargo.toml"}),": The dependencies for the build process"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"rustup-toolchain.toml"}),": The required Rust version"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"sandbox_node.sh"}),": A script that sets up a Tezos sandbox for testing the rollup"]}),"\n"]}),"\n",(0,a.jsx)(s.p,{children:"The tutorial repository also includes two files that represent example message inboxes in layer 1 blocks:"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"empty_input.json"}),": An empty rollup message inbox"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"two_inputs.json"}),": A rollup message inbox with two messages"]}),"\n"]}),"\n",(0,a.jsx)(s.p,{children:"When you're ready, move to the next section to begin setting up the application."})]})}function d(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,a.jsx)(s,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},80011:(e,s,n)=>{n.d(s,{A:()=>t});const t=n.p+"assets/images/smart-rollup-overview-6f9951f465a897ae88fd8bc172c96982.png"},28453:(e,s,n)=>{n.d(s,{R:()=>o,x:()=>i});var t=n(96540);const a={},r=t.createContext(a);function o(e){const s=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function i(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),t.createElement(r.Provider,{value:s},e.children)}}}]);