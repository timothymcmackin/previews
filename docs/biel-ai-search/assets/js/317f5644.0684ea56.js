"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5165],{80008:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>o,default:()=>c,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"tutorials/build-files-archive-with-dal/using-full-slot","title":"Part 5: Using the entire slot","description":"In some cases, you may want to retrieve the entire contents of a slot.","source":"@site/docs/tutorials/build-files-archive-with-dal/using-full-slot.md","sourceDirName":"tutorials/build-files-archive-with-dal","slug":"/tutorials/build-files-archive-with-dal/using-full-slot","permalink":"/previews/docs/biel-ai-search/tutorials/build-files-archive-with-dal/using-full-slot","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1722312000000,"frontMatter":{"title":"Part 5: Using the entire slot","authors":"Tezos core developers, Tim McMackin","last_update":{"date":"30 July 2024"}},"sidebar":"tutorialsSidebar","previous":{"title":"Part 4: Publishing on the DAL","permalink":"/previews/docs/biel-ai-search/tutorials/build-files-archive-with-dal/publishing-on-the-dal"}}');var i=n(74848),l=n(28453);const a={title:"Part 5: Using the entire slot",authors:"Tezos core developers, Tim McMackin",last_update:{date:"30 July 2024"}},o=void 0,r={},d=[{value:"Fetching and storing the full slot",id:"fetching-and-storing-the-full-slot",level:2},{value:"Next steps",id:"next-steps",level:2}];function h(e){const t={admonition:"admonition",code:"code",h2:"h2",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,l.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"In some cases, you may want to retrieve the entire contents of a slot.\nFor example, it can be convenient to get the entire slot because it has a fixed size, while the data in the slot may be smaller and padded to fit the slot."}),"\n",(0,i.jsx)(t.h2,{id:"fetching-and-storing-the-full-slot",children:"Fetching and storing the full slot"}),"\n",(0,i.jsx)(t.p,{children:"Retrieving the full slot is similar to retrieving any data from the slot.\nIn this case, you change the kernel to retrieve data of the exact size of the slot."}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["Update the ",(0,i.jsx)(t.code,{children:"run"})," function in the ",(0,i.jsx)(t.code,{children:"lib/rs"})," file to this code, without changing the rest of the file:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:'pub fn run<R: Runtime>(\n    host: &mut R,\n    param: &RollupDalParameters,\n    slot_index: u8,\n) -> Result<(), RuntimeError> {\n    // Reading one message from the shared inbox is always safe,\n    // because the shared inbox contains at least 3 messages per\n    // Tezos block.\n    let sol = host.read_input()?.unwrap();\n\n    let target_level = sol.level as usize - param.attestation_lag as usize;\n\n    let mut buffer = vec![0u8; param.slot_size as usize];\n\n    let bytes_read = host.reveal_dal_page(target_level as i32, slot_index, 0, &mut buffer)?;\n\n    if bytes_read == 0 {\n        debug_msg!(\n            host,\n            "No attested slot at index {} for level {}\\n",\n            slot_index,\n            target_level\n        );\n\n        return Ok(());\n    }\n\n    debug_msg!(\n        host,\n        "Attested slot at index {} for level {}\\n",\n        slot_index,\n        target_level\n    );\n\n    let num_pages = param.slot_size / param.page_size;\n\n    for page_index in 1..num_pages {\n        let _result = host.reveal_dal_page(\n            target_level as i32,\n            slot_index,\n            page_index.try_into().unwrap(),\n            &mut buffer[page_index as usize * (param.page_size as usize)\n                ..(page_index as usize + 1) * (param.page_size as usize)],\n        );\n    }\n\n    let hash = blake2b::digest(&buffer, 32).unwrap();\n    let key = hex::encode(hash);\n    let path = OwnedPath::try_from(format!("/{}", key)).unwrap();\n\n    debug_msg!(host, "Saving slot under `{}\'\\n", path);\n\n    let () = host.store_write_all(&path, &buffer)?;\n\n    Ok(())\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Now the ",(0,i.jsx)(t.code,{children:"run"})," function works like this:"]}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"It allocates a buffer of the size of a slot, not a size of a page."}),"\n",(0,i.jsxs)(t.li,{children:["It tries to fetch the contents of the first page.\nIf 0 bytes are written by ",(0,i.jsx)(t.code,{children:"reveal_dal_page"}),", the targeted slot has not been\nattested for this block."]}),"\n",(0,i.jsx)(t.li,{children:"If the targeted slot has been attested, the function reads as many pages as necessary to get the full slot data."}),"\n",(0,i.jsx)(t.li,{children:"It stores the data in the durable storage, using the Blake2B hash (encoded in hexadecimal) as its key."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["Add these ",(0,i.jsx)(t.code,{children:"use"})," statements to the beginning of the file:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:"use tezos_crypto_rs::blake2b;\nuse tezos_smart_rollup::storage::path::OwnedPath;\n"})}),"\n",(0,i.jsxs)(t.p,{children:["These dependencies use ",(0,i.jsx)(t.code,{children:"tezos_crypto_rs"})," for hashing, and ",(0,i.jsx)(t.code,{children:"hex"})," for encoding."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["Add the matching dependencies to the end of the ",(0,i.jsx)(t.code,{children:"Cargo.toml"})," file:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-toml",children:'tezos_crypto_rs = { version = "0.5.2", default-features = false }\nhex = "0.4.3"\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Adding ",(0,i.jsx)(t.code,{children:"default-features = false"})," for ",(0,i.jsx)(t.code,{children:"tezos_crypto_rs"})," is necessary for the crate to be compatible with Smart Rollups."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Deploy the Smart Rollup again, publish a file as you did in the previous section, and wait for enough levels to pass.\nThe Smart Rollup log shows the hash of the data, as in this example:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"RollupDalParameters { number_of_slots: 32, attestation_lag: 8, slot_size: 126944, page_size: 3967 }\nAttested slot at index 10 for level 7325751\nSaving slot under `/6a578d1e6746d29243ff81923bcea6375e9344d719ca118e14cd9f3d3b00cd96'\nSee you in the next level\n"})}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Get the data from the slot by passing the hash, as in this example:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-bash",children:"hash=6a578d1e6746d29243ff81923bcea6375e9344d719ca118e14cd9f3d3b00cd96\ncurl \"http://localhost:8932/global/block/head/durable/wasm_2_0_0/value?key=/${hash}\" \\\n    -H 'Content-Type: application/octet-stream' \\\n    -o slot.bin\n"})}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Convert the contents of the slot to text by running this command:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-bash",children:"xxd -r -p slot.bin\n"})}),"\n",(0,i.jsx)(t.p,{children:'The console shows your message in text, such as "Hi! This is a message to go on the DAL."'}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.admonition,{type:"note",children:[(0,i.jsxs)(t.mdxAdmonitionTitle,{children:["Why ",(0,i.jsx)(t.code,{children:"diff"})," won't work"]}),(0,i.jsxs)(t.p,{children:["You cannot use ",(0,i.jsx)(t.code,{children:"diff"})," to ensure that the file you originally published and the one that you downloaded from the rollup node are equal.\nIndeed, they are not: because the size of a slot is fixed, the DAL node pads the value it receives from ",(0,i.jsx)(t.code,{children:"POST /slots"})," in order to ensure that it has the correct slot size."]})]}),"\n",(0,i.jsx)(t.h2,{id:"next-steps",children:"Next steps"}),"\n",(0,i.jsx)(t.p,{children:"Now you know how to send files to the DAL and use a Smart Rollup to store the data."}),"\n",(0,i.jsx)(t.p,{children:"From there, the sky's the limit.\nYou can implement many other features, such as:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Handling more than one file per level"}),"\n",(0,i.jsx)(t.li,{children:"Having file publishers pay for the storage that they are using in layer 2 by allowing them to deposit tez to the Smart Rollup and sign the files they publish"}),"\n",(0,i.jsx)(t.li,{children:"Building a frontend to visualize the files in the archive"}),"\n",(0,i.jsx)(t.li,{children:"Providing the original size of the file by modifying the script to prefix the file with its size"}),"\n"]})]})}function c(e={}){const{wrapper:t}={...(0,l.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var s=n(96540);const i={},l=s.createContext(i);function a(e){const t=s.useContext(l);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(l.Provider,{value:t},e.children)}}}]);