# Tezos tutorials

# Tutorials

These tutorials can help you get started developing different kinds of applications on Tezos in as little as 15 minutes.

import TutorialCard from '@site/src/components/TutorialCard';
import TutorialCardContainer from '@site/src/components/TutorialCardContainer';

## Beginner

These tutorials are intended for developers who are starting work with Tezos:

<TutorialCardContainer>

<TutorialCard
title="Create a minimum dApp"
emoji="🏆"
href="/tutorials/dapp"
description="Create your minimum dApp from the smart contract to the frontend, using Typescript React and Typescript-like JsLIGO language"
link="Start tutorial"
/>

<TutorialCard
title="Deploy a smart contract"
emoji="🚀"
href="/tutorials/smart-contract"
description="In 15 minutes, go from zero to hero and deploy your first smart contract with your choice of JavaScript, OCaml, or Python-like languages"
link="Start tutorial"
/>

</TutorialCardContainer>

## Intermediate

These tutorials contain multiple parts and are intended for developers with some application development experience:

<TutorialCardContainer>

<TutorialCard
title="Learn about tickets"
emoji="🎫"
href="/tutorials/dapp/part-3"
description="Learn about a Tezos unique feature named Tickets, using Typescript React and Typescript-like JsLIGO language"
link="Start tutorial"
/>

<TutorialCard
title="Build a simple web application"
emoji="💡"
href="/tutorials/build-your-first-app/"
description="Learn how to set up and create a decentralized web application on Tezos using TypeScript, Taquito, and Svelte"
link="Start tutorial"
/>

<TutorialCard
title="Create a fungible token with the SmartPy FA2 library"
emoji="🏭"
href="/tutorials/smartpy-fa2-fungible"
description="Create standards-compliant tokens with the SmartPy language and its FA2 library and work with them in your wallet"
link="Start tutorial"
/>

<TutorialCard
title="Create NFTs from a web application"
emoji="🚀"
href="/tutorials/create-nfts"
description="Learn how to create a web application and smart contract so you can create your own NFTs"
link="Start tutorial"
/>

<TutorialCard
title="Run a tezos node in 5 steps"
emoji="🍞"
href="/tutorials/join-dal-baker"
description="See a complete walkthrough of becoming a baker by setting up a Tezos node, DAL node, and baker"
link="Start tutorial"
/>

<TutorialCard
title="Bake using a Ledger device"
emoji="🥖"
href="/tutorials/bake-with-ledger"
description="Set up a Ledger device to protect your private keys and start baking"
link="Start tutorial"
/>

</TutorialCardContainer>

## Advanced

These tutorials are intended for developers who are familiar with Tezos and want to get into more powerful applications:

<TutorialCardContainer>

<TutorialCard
title="Upgrade your smart contract"
emoji="⬆️"
href="/tutorials/dapp/part-4"
description="Learn the different ways of upgrading your smart contract, using Typescript React and Typescript-like JsLIGO language"
link="Start tutorial"
/>

<TutorialCard
title="Build an NFT marketplace"
emoji="🛒"
href="/tutorials/build-an-nft-marketplace"
description="Learn how to build a marketplace to buy and sell different kinds of tokens with LIGO smart contract templates"
link="Start tutorial"
/>

<TutorialCard
title="Deploy a smart rollup"
emoji="🏎"
href="/tutorials/smart-rollup"
description="Learn how to deploy a smart rollup to handle large amounts of processing off the main chain"
link="Start tutorial"
/>

<TutorialCard
title="Learn and play with security"
emoji="🛡️"
href="/tutorials/security"
description="Learn and try to hack web3 applications"
link="Start tutorial"
/>

<TutorialCard
title="Create a mobile game on Tezos"
emoji="📱"
href="/tutorials/mobile"
description="Learn how to create a decentralized game on Tezos to run on Android or iOS"
link="Start tutorial"
/>

<TutorialCard
title="Implement a file archive with the DAL"
emoji="🗃️"
href="/tutorials/build-files-archive-with-dal"
description="Learn how to build a file archive with a Smart Rollup and the Data Availability Layer"
link="Start tutorial"
/>

</TutorialCardContainer>


# Deploy a smart contract

This tutorial covers deploying a smart contract to Tezos.
It covers how to:

* Connect to a testnet
* Create a wallet
* Get tokens from a faucet
* Code a contract, including:
  * Defining the storage for the contract
  * Defining entrypoints in the contract
  * Writing code to run when the entrypoints are called
* Deploy (or originate) the contract to Tezos and set its starting storage value
* Look up the current state of the contract
* Call the contract

This tutorial has different versions for different programming languages.
You can run the tutorial with the version of the language you are most familiar with or want to learn.
You do not need an experience in these languages to run the tutorial.

* To use SmartPy, a language similar to Python, see [Deploy a smart contract with SmartPy](/tutorials/smart-contract/smartpy)
* To use JsLIGO, a language similar to JavaScript and TypeScript, see [Deploy a smart contract with JsLIGO](/tutorials/smart-contract/jsligo)
* To use CameLIGO, a language similar to OCaml, see [Deploy a smart contract with CameLIGO](/tutorials/smart-contract/cameligo)
* To learn the Archetype language, try [Deploy a smart contract with Archetype](/tutorials/smart-contract/archetype).


# Deploy a smart contract with JsLIGO

This tutorial covers writing and deploying a simple smart contract with the LIGO programming language.
Specifically, this tutorial uses the JsLIGO version of LIGO, which has syntax similar to JavaScript, but you don't need any experience with JavaScript or LIGO to do this tutorial.

* If you are more familiar with Python, try [Deploy a smart contract with SmartPy](/tutorials/smart-contract/smartpy).
* If you are more familiar with OCaml, try [Deploy a smart contract with CameLIGO](/tutorials/smart-contract/cameligo).
* To learn the Archetype language, try [Deploy a smart contract with Archetype](/tutorials/smart-contract/archetype).

LIGO is a high-level programming language that you can use to write smart contracts for the Tezos blockchain.
It abstracts away the complexity of using Michelson (the smart contract language directly available on-chain) to make it easier to write smart contracts on Tezos.

In this tutorial, you will learn how to:

* Create a wallet to store cryptocurrency tokens
* Get free tez tokens (the native cryptocurrency token on Tezos) from a faucet
* Code a contract in LIGO, including:
  * Defining the storage for the contract
  * Defining entrypoints in the contract
  * Writing code to run when the entrypoints are called
* Deploy (or originate) the contract to Tezos and set its starting storage value
* Look up the current state of the contract
* Call the contract

## What is a smart contract?

A smart contract is a computer program that is stored on a blockchain and runs on a blockchain.
Because the blockchain is spread across many computer nodes, you don't have to think about where to host the program or worry whether a computer will run it or not.
Responsibility for running the contract is distributed across all of the nodes in the Tezos system, so when you deploy a smart contract, you can be confident that it will be available and unmodified when someone wants to run it.

A smart contract has these parts:

* Persistent storage, data that the contract can read and write
* One or more entrypoints, which are a kind of function that clients can call, like endpoints in an API or functions or methods in many programming languages
* A Tezos account that can store tokens (technically, the contract is itself a type of Tezos account, but you can think of it as a program with a Tezos account)

## Tutorial contract

The contract that you deploy in this tutorial stores a single integer.
It provides entrypoints that clients can call to change the value of that integer:

* The `increment` entrypoint accepts an integer as a parameter and adds that integer to the value in storage
* The `decrement` entrypoint accepts an integer as a parameter and subtracts that integer from the value in storage
* The `reset` entrypoint takes no parameters and resets the value in storage to 0

After you deploy the contract, you or any other user can call it from various sources, including web applications, other contracts, and the Octez command-line client.
However, no one can prevent it from running or tamper with its code or its storage.

## Creating and funding a wallet

To deploy and work with the contract, you need a wallet and some tez tokens.
You can get test tokens for free on the Ghostnet test network:

1. Install a Tezos-compatible wallet.
   Which wallet you install is up to you and whether you want to install a wallet on your computer, in a browser extension, or as a mobile app.

   If you don't know which one to choose, try the [Temple](https://templewallet.com/) browser extension.

   Desktop wallets for Tezos include the [Temple](https://templewallet.com/) browser extension, [Kukai](https://wallet.kukai.app/), and [Umami](https://umamiwallet.com/).

   Mobile apps include [Temple](https://templewallet.com/), [Kukai](https://wallet.kukai.app/), and [Umami](https://umamiwallet.com/).

2. Switch the wallet to use the Ghostnet testnet instead of Tezos Mainnet.
   Ghostnet is a network for testing Tezos applications where tokens are free so you don't have to spend real currency to work with your applications.

   For example, for the Temple browser wallet, click **Tezos Mainnet** at the top and then click **Ghostnet Testnet**, as in this picture:

   ![Selecting the Ghostnet testnet in the Temple wallet](/img/tutorials/temple-switch-network.png)

3. From your wallet, get the address of your account, which starts with `tz1`.
   This is the address that applications use to work with your wallet.

4. Go to the Ghostnet faucet page at https://faucet.ghostnet.teztnets.com.

5. On the faucet page, paste your wallet address into the input field labeled "Or fund any address" and click the button for the amount of tez to add to your wallet.
   20 tez is enough to work with the tutorial contract, and you can return to the faucet later if you need more tez.

   It may take a few minutes for the faucet to send the tokens and for those tokens to appear in your wallet.

   You can use the faucet as much as you need to get tokens on the testnet, but those tokens are worthless and cannot be used on Mainnet.

   ![Fund your wallet using the Ghostnet Faucet](/img/tutorials/wallet-funding.png)

Now you have an account and funds that you can use to work with Tezos.

## Creating the contract

The contract that you will create has these basic parts:

* A type that describes the contract's storage, in this case an integer.
  The storage can be a primitive type such as an integer, string, or timestamp, or a complex data type that contains multiple values.
  For more information on contract data types, see [Data types](/smart-contracts/data-types).

* Functions called entrypoints that run code when clients call the contract.

* A type that describes the return value of the entrypoints.

Follow these steps to create the code for the contract:

1. Open the LIGO online IDE at https://ide.ligolang.org/.
   You can work with LIGO code in any IDE, but this online IDE keeps you from having to install software on your computer, and it also simplifies the process of deploying contracts.

2. At the top right of the page, in the **Network** menu, select Ghostnet, as shown in this picture:

   ![Selecting Ghostnet in the list of networks](/img/tutorials/ligo-online-ide-select-ghostnet.png)

3. Connect a wallet to the IDE:

   1. At the top right of the page, click the **Keypair Manager** <img src="/img/tutorials/ligo-online-ide-keypair-manager.png" alt="" style={{width: 24}} /> button.

   2. In the Keypair Manager window, import the account that you created earlier or create and fund a new account to use with the IDE.

      * To import the account that you created earlier, export the private key from your wallet app, click **Import** in the Keypair Manager window, and paste the private key.
        Now you can use your account in the IDE.

      * To create an account to use with the IDE, click **Create** in the Keypair Manager window, give the new keypair a name, and click **Create**.
        Then, copy the address of the keypair and get tez from the faucet as you did in [Creating and funding a wallet](#creating-and-funding-a-wallet).

4. In the IDE, create a project from the empty template and select the JsLIGO syntax, as shown in this picture:

   <img src="/img/tutorials/ligo-online-ide-new-project-js.png" alt="Creating a project" style={{width: 500}} />

   The IDE creates a project and a contract file named `Contract.jsligo`.

5. In the contract file, create a namespace named `Counter` to hold the code for the contract:

   ```jsligo
   namespace Counter {

   }
   ```

6. Inside the namespace, create a TypeScript type to set the storage type to an integer:

   ```jsligo
   type storage = int;
   ```

7. Add this code to define the return type for the entrypoints.
   Tezos entrypoints return two values: a list of other operations to call and the new value of the contract's storage.

   ```jsligo
   type returnValue = [list<operation>, storage];
   ```

8. Add the code for the increment and decrement entrypoints:

   ```jsligo
   // Increment entrypoint
   @entry
   const increment = (delta : int, store : storage) : returnValue =>
     [list([]), store + delta];

   // Decrement entrypoint
   @entry
   const decrement = (delta : int, store : storage) : returnValue =>
     [list([]), store - delta];
   ```

   These functions begin with the `@entry` annotation to indicate that they are entrypoints.
   They accept two parameters: the change in the storage value (an integer) and the current value of the storage (in the `storage` type that you created earlier in the code).
   They return a value of the type `returnValue` that you created in the previous step.

   Each function returns an empty list of other operations to call and the new value of the storage.

9. Add this code for the reset entrypoint:

   ```jsligo
   // Reset entrypoint
   @entry
   const reset = (_p : unit, _s : storage) : returnValue =>
     [list([]), 0];
   ```

   This function is similar to the others, but it does not take the current value of the storage into account.
   It always returns an empty list of operations and 0.

The complete contract code looks like this:

```jsligo
namespace Counter {
  type storage = int;
  type returnValue = [list<operation>, storage];

  // Increment entrypoint
  @entry
  const increment = (delta : int, store : storage) : returnValue =>
    [list([]), store + delta];

  // Decrement entrypoint
  @entry
  const decrement = (delta : int, store : storage) : returnValue =>
    [list([]), store - delta];

  // Reset entrypoint
  @entry
  const reset = (_p : unit, _s : storage) : returnValue =>
    [list([]), 0];
}
```

## Testing and compiling the contract

Before you can deploy the contract to Tezos, you must compile it to Michelson, the base language of Tezos contracts.

1. Set the compiler to target the namespace to compile in your code:

   1. On the left side of the page, under **Actions**, click **Project Settings**.
   2. On the Project Settings tab, in the **Module name** field, set the module name to `Counter`.
   3. Close the Project Settings tab.

2. Test the contract by passing parameters and the storage value to the LIGO `dry-run` command:

   1. On the left side of the page, under **Actions**, click **Dry Run**.

   2. In the Dry Run window, select the `Increment` entrypoint, set the input parameter to `32` and the storage to `10`.
      The Dry Run window looks like this:

      <img src="/img/tutorials/ligo-online-ide-dry-run-window-js.png" alt="The Dry Run window, showing the entrypoint to run, the parameter to pass, and the value of the storage" style={{width: 500}} />

   3. Click **Run**.

      At the bottom of the window, the Result field shows the response `(LIST_EMPTY(), 42)`.
      This response means that the contract did not call any other contracts, so the list of operations is empty.
      Then it shows the new value of the storage.
      You can test the decrement function in the same way.
      If you see any errors, make sure that the code of your contract matches the code in the previous section.

   4. Test the `Reset` entrypoint in the same way, but pass `unit` as the input parameter and any integer in the storage field.
      The `Reset` entrypoint takes no parameters, but technically it accepts the value `unit`, which means no parameter.

      The Result field shows the response `(LIST_EMPTY(), 0)`, which means that the storage value is now 0.

3. On the left side of the page, under **Actions**, click **Compile**, and in the Compile window, click **Compile** again.

If the compilation succeeds, the IDE prints the compiled code to the terminal and saves it to the file `build/contracts/Contract.tz`.
You can see the code by expanding your project on the left side of the page, under `.workspaces`, and double-clicking `Contract.tz`.
If you see error messages, verify that your contract code matches the code in the previous section.

Now you can deploy the contract.

## Deploying (originating) to the testnet

Deploying a contract to the network is called "originating."
Originating the contract requires a small amount of Tezos tokens as a fee.

1. On the left side of the page, under **Actions**, click **Deploy**.
   You may see a warning that the initial storage is not set.
   You can ignore this warning because you can set the initial storage now.

2. In the Deploy contract window, in the **Init storage** field, set the initial value for the contract's storage to an integer.

3. In the **Signer** field, make sure your account is selected.

4. Click **Estimate**.

   The window shows the estimated fees to deploy the contract, as in this picture:

   <img src="/img/tutorials/ligo-online-ide-deploy-estimate-js.png" alt="The estimate of the fees to deploy the contract" style={{width: 500}} />

5. Click **Deploy**.

   The deployment process can take a few minutes.
   When the contract is deployed, the Deploy contract window shows the address at the bottom of the window.

6. Copy the address of the deployed contract, which starts with `KT1`.

:::warning
Copy the contract address now, because it will not be shown again.
:::

Now you can call the contract from any Tezos client, including web applications and command-line applications like [The Octez client](/developing/octez-client).

## Calling the contract

These steps show you how to inspect the contract with a block explorer, which is a web application that shows information about Tezos.
It also allows you to call the contract.

1. Open the block explorer Better Call Dev at this link: https://better-call.dev/

2. Paste the address of the contract in the search field and press Enter.

   The block explorer shows information about the contract, including recent transactions and the current state of its storage.

   <img src="/img/tutorials/bcd-originated-contract.png" alt="The block explorer, showing information about the contract" style={{width: 500}} />

3. Try calling one of the entrypoints:

   1. Go to the **Storage** tab and check the current state of the storage, which should be the integer that you put in the Deploy window.

   2. Go to the **Interact** tab.
      This tab shows the entrypoints in the contract and lets you use them.

   3. For the `increment` entrypoint, in the **Parameters** section, put an integer in the field, as shown in this image:

      <img src="/img/tutorials/bcd-interact-parameters-increment.png" alt="Putting in a value for an entrypoint parameter" style={{width: 500}} />

   4. Click **Execute** and then click **Wallet**.

   5. Select your wallet and connect it to the application.

   6. Confirm the transaction in your wallet.

   7. Wait for a success message that says "The transaction has successfully been broadcasted to the network."

   8. Go back to the **Storage** tab and see the new value of the storage, as in this picture:

      <img src="/img/tutorials/bcd-updated-storage-counter.png" alt="Updated storage value" style={{width: 500}} />

## Summary

Now the contract is running on the Tezos blockchain.
You or any other user can call it from any source that can send transactions to Tezos, including Octez, dApps, and other contracts.

If you want to continue working with this contract, here are some ideas:

* Change permissions for the contract so only your account can call its entrypoints
* Add your own entrypoints and originate a new contract; note that you cannot update the existing contract after it is deployed
* Create a dApp to call the contract from a web application, similar to the dApp that you create in the tutorial [Build a simple web application](/tutorials/build-your-first-app/)


# Deploy a smart contract with CameLIGO

This tutorial covers writing and deploying a simple smart contract with the LIGO programming language.
Specifically, this tutorial uses the CameLIGO version of LIGO, which has syntax similar to OCaml, but you don't need any experience with OCaml or LIGO to do this tutorial.

* If you are more familiar with JavaScript, try [Deploy a smart contract with JsLIGO](/tutorials/smart-contract/jsligo).
* If you are more familiar with Python, try [Deploy a smart contract with SmartPy](/tutorials/smart-contract/smartpy).
* To learn the Archetype language, try [Deploy a smart contract with Archetype](/tutorials/smart-contract/archetype).

LIGO is a high-level programming language that you can use to write smart contracts for the Tezos blockchain.
It abstracts away the complexity of using Michelson (the smart contract language directly available on-chain) to make it easier to write smart contracts on Tezos.

In this tutorial, you will learn how to:

* Create a wallet to store cryptocurrency tokens
* Get free tez tokens (the native cryptocurrency token on Tezos) from a faucet
* Code a contract in LIGO, including:
  * Defining the storage for the contract
  * Defining entrypoints in the contract
  * Writing code to run when the entrypoints are called
* Deploy (or originate) the contract to Tezos and set its starting storage value
* Look up the current state of the contract
* Call the contract

## What is a smart contract?

A smart contract is a computer program that is stored on a blockchain and runs on a blockchain.
Because the blockchain is spread across many computer nodes, you don't have to think about where to host the program or worry whether a computer will run it or not.
Responsibility for running the contract is distributed across all of the nodes in the Tezos system, so when you deploy a smart contract, you can be confident that it will be available and unmodified when someone wants to run it.

A smart contract has these parts:

* Persistent storage, data that the contract can read and write
* One or more entrypoints, which are a kind of function that clients can call, like endpoints in an API or functions or methods in many programming languages
* A Tezos account that can store tokens (technically, the contract is itself a type of Tezos account, but you can think of it as a program with a Tezos account)

## Tutorial contract

The contract that you deploy in this tutorial stores a single integer.
It provides entrypoints that clients can call to change the value of that integer:

* The `increment` entrypoint accepts an integer as a parameter and adds that integer to the value in storage
* The `decrement` entrypoint accepts an integer as a parameter and subtracts that integer from the value in storage
* The `reset` entrypoint takes no parameters and resets the value in storage to 0

After you deploy the contract, you or any other user can call it from various sources, including web applications, other contracts, and the Octez command-line client.
However, no one can prevent it from running or tamper with its code or its storage.

## Creating and funding a wallet

To deploy and work with the contract, you need a wallet and some tez tokens.
You can get test tokens for free on the Ghostnet test network:

1. Install a Tezos-compatible wallet.
   Which wallet you install is up to you and whether you want to install a wallet on your computer, in a browser extension, or as a mobile app.

   If you don't know which one to choose, try the [Temple](https://templewallet.com/) browser extension.

   Desktop wallets for Tezos include the [Temple](https://templewallet.com/) browser extension, [Kukai](https://wallet.kukai.app/), and [Umami](https://umamiwallet.com/).

   Mobile apps include [Temple](https://templewallet.com/), [Kukai](https://wallet.kukai.app/), and [Umami](https://umamiwallet.com/).

2. Switch the wallet to use the Ghostnet testnet instead of Tezos Mainnet.
   Ghostnet is a network for testing Tezos applications where tokens are free so you don't have to spend real currency to work with your applications.

   For example, for the Temple browser wallet, click **Tezos Mainnet** at the top and then click **Ghostnet Testnet**, as in this picture:

   ![Selecting the Ghostnet testnet in the Temple wallet](/img/tutorials/temple-switch-network.png)

3. From your wallet, get the address of your account, which starts with `tz1`.
   This is the address that applications use to work with your wallet.

4. Go to the Ghostnet faucet page at https://faucet.ghostnet.teztnets.com.

5. On the faucet page, paste your wallet address into the input field labeled "Or fund any address" and click the button for the amount of tez to add to your wallet.
   20 tez is enough to work with the tutorial contract, and you can return to the faucet later if you need more tez.

   It may take a few minutes for the faucet to send the tokens and for those tokens to appear in your wallet.

   You can use the faucet as much as you need to get tokens on the testnet, but those tokens are worthless and cannot be used on Mainnet.

   ![Fund your wallet using the Ghostnet Faucet](/img/tutorials/wallet-funding.png)

Now you have an account and funds that you can use to work with Tezos.

## Creating the contract

The contract that you will create has these basic parts:

* A type that describes the contract's storage, in this case an integer.
  The storage can be a primitive type such as an integer, string, or timestamp, or a complex data type that contains multiple values.
  For more information on contract data types, see [Data types](/smart-contracts/data-types).

* Functions called entrypoints that run code when clients call the contract.

* A type that describes the return value of the entrypoints.

Follow these steps to create the code for the contract:

1. Open the LIGO online IDE at https://ide.ligolang.org/.
   You can work with LIGO code in any IDE, but this online IDE keeps you from having to install software on your computer, and it also simplifies the process of deploying contracts.

2. At the top right of the page, in the **Network** menu, select Ghostnet, as shown in this picture:

   ![Selecting Ghostnet in the list of networks](/img/tutorials/ligo-online-ide-select-ghostnet.png)

3. Connect a wallet to the IDE:

   1. At the top right of the page, click the **Keypair Manager** <img src="/img/tutorials/ligo-online-ide-keypair-manager.png" alt="" style={{width: 24}} /> button.

   2. In the Keypair Manager window, import the account that you created earlier or create and fund a new account to use with the IDE.

      * To import the account that you created earlier, export the private key from your wallet app, click **Import** in the Keypair Manager window, and paste the private key.
        Now you can use your account in the IDE.

      * To create an account to use with the IDE, click **Create** in the Keypair Manager window, give the new keypair a name, and click **Create**.
        Then, copy the address of the keypair and get tez from the faucet as you did in [Creating and funding a wallet](#creating-and-funding-a-wallet).

4. In the IDE, create a project from the empty template and select the CameLIGO syntax, as shown in this picture:

   <img src="/img/tutorials/ligo-online-ide-new-project-camel.png" alt="Creating a project" style={{width: 500}} />

   The IDE creates a project and a contract file named `Contract.mligo`.

5. In the contract file, create a type to set the storage type to an integer:

   ```cameligo
   type storage = int
   ```

6. Add this code to define the return type for the entrypoints.
   Tezos entrypoints return two values: a list of other operations to call and the new value of the contract's storage.

   ```cameligo
   type returnValue = operation list * storage
   ```

7. Add the code for the increment and decrement entrypoints:

   ```cameligo
   // Increment entrypoint
   [@entry] let increment (delta : int) (store : storage) : returnValue =
     [], store + delta

   // Decrement entrypoint
   [@entry] let decrement (delta : int) (store : storage) : returnValue =
     [], store - delta
   ```

   These functions begin with the `@entry` annotation to indicate that they are entrypoints.
   They accept two parameters: the change in the storage value (an integer) and the current value of the storage (in the `storage` type that you created earlier in the code).
   They return a value of the type `returnValue` that you created in the previous step.

   Each function returns an empty list of other operations to call and the new value of the storage.

8. Add this code for the reset entrypoint:

   ```cameligo
   // Reset entrypoint
   [@entry] let reset (() : unit) (_ : storage) : returnValue =
     [], 0
   ```

   This function is similar to the others, but it does not take the current value of the storage into account.
   It always returns an empty list of operations and 0.

The complete contract code looks like this:

```cameligo
type storage = int

type returnValue = operation list * storage

// Increment entrypoint
[@entry] let increment (delta : int) (store : storage) : returnValue =
  [], store + delta

// Decrement entrypoint
[@entry] let decrement (delta : int) (store : storage) : returnValue =
  [], store - delta

// Reset entrypoint
[@entry] let reset (() : unit) (_ : storage) : returnValue =
  [], 0
```

## Testing and compiling the contract

Before you can deploy the contract to Tezos, you must compile it to Michelson, the base language of Tezos contracts.

1. Set the compiler to target the module to compile in your code:

   1. On the left side of the page, under **Actions**, click **Project Settings**.
   2. On the Project Settings tab, in the **Module name** field, set the module name to `Counter`.
   3. Close the Project Settings tab.

2. Test the contract by passing parameters and the storage value to the LIGO `dry-run` command:

   1. On the left side of the page, under **Actions**, click **Dry Run**.

   2. In the Dry Run window, select the `Increment` entrypoint, set the input parameter to `32` and the storage to `10`.
      The Dry Run window looks like this:

      <img src="/img/tutorials/ligo-online-ide-dry-run-window-camel.png" alt="The Dry Run window, showing the entrypoint to run, the parameter to pass, and the value of the storage" style={{width: 500}} />

   3. Click **Run**.

      At the bottom of the window, the Result field shows the response `(LIST_EMPTY(), 42)`.
      This response means that the contract did not call any other contracts, so the list of operations is empty.
      Then it shows the new value of the storage.
      You can test the decrement function in the same way.
      If you see any errors, make sure that the code of your contract matches the code in the previous section.

   4. Test the `Reset` entrypoint in the same way, but pass `unit` as the input parameter and any integer in the storage field.
      The `Reset` entrypoint takes no parameters, but technically it accepts the value `unit`, which means no parameter.

      The Result field shows the response `(LIST_EMPTY(), 0)`, which means that the storage value is now 0.

3. On the left side of the page, under **Actions**, click **Compile**, and in the Compile window, click **Compile** again.

If the compilation succeeds, the IDE prints the compiled code to the terminal and saves it to the file `build/contracts/Contract.tz`.
You can see the code by expanding your project on the left side of the page, under `.workspaces`, and double-clicking `Contract.tz`.
If you see error messages, verify that your contract code matches the code in the previous section.

Now you can deploy the contract.

## Deploying (originating) to the testnet

Deploying a contract to the network is called "originating."
Originating the contract requires a small amount of Tezos tokens as a fee.

1. On the left side of the page, under **Actions**, click **Deploy**.
   You may see a warning that the initial storage is not set.
   You can ignore this warning because you can set the initial storage now.

2. In the Deploy contract window, in the **Init storage** field, set the initial value for the contract's storage to an integer.

3. In the **Signer** field, make sure your account is selected.

4. Click **Estimate**.

   The window shows the estimated fees to deploy the contract, as in this picture:

   <img src="/img/tutorials/ligo-online-ide-deploy-estimate-camel.png" alt="The estimate of the fees to deploy the contract" style={{width: 500}} />

5. Click **Deploy**.

   The deployment process can take a few minutes.
   When the contract is deployed, the Deploy contract window shows the address at the bottom of the window.

6. Copy the address of the deployed contract, which starts with `KT1`.

:::warning
Copy the contract address now, because it will not be shown again.
:::

Now you can call the contract from any Tezos client, including web applications and command-line applications like [The Octez client](/developing/octez-client).

## Calling the contract

These steps show you how to inspect the contract with a block explorer, which is a web application that shows information about Tezos.
It also allows you to call the contract.

1. Open the block explorer Better Call Dev at this link: https://better-call.dev/

2. Paste the address of the contract in the search field and press Enter.

   The block explorer shows information about the contract, including recent transactions and the current state of its storage.

   <img src="/img/tutorials/bcd-originated-contract.png" alt="The block explorer, showing information about the contract" style={{width: 500}} />

3. Try calling one of the entrypoints:

   1. Go to the **Storage** tab and check the current state of the storage, which should be the integer that you put in the Deploy window.

   2. Go to the **Interact** tab.
      This tab shows the entrypoints in the contract and lets you use them.

   3. For the `increment` entrypoint, in the **Parameters** section, put an integer in the field, as shown in this image:

      <img src="/img/tutorials/bcd-interact-parameters-increment.png" alt="Putting in a value for an entrypoint parameter" style={{width: 500}} />

   4. Click **Execute** and then click **Wallet**.

   5. Select your wallet and connect it to the application.

   6. Confirm the transaction in your wallet.

   7. Wait for a success message that says "The transaction has successfully been broadcasted to the network."

   8. Go back to the **Storage** tab and see the new value of the storage, as in this picture:

      <img src="/img/tutorials/bcd-updated-storage-counter.png" alt="Updated storage value" style={{width: 500}} />

## Summary

Now the contract is running on the Tezos blockchain.
You or any other user can call it from any source that can send transactions to Tezos, including Octez, dApps, and other contracts.

If you want to continue working with this contract, here are some ideas:

* Change permissions for the contract so only your account can call its entrypoints
* Add your own entrypoints and originate a new contract; note that you cannot update the existing contract after it is deployed
* Create a dApp to call the contract from a web application, similar to the dApp that you create in the tutorial [Build a simple web application](/tutorials/build-your-first-app/)


# Deploy a smart contract with SmartPy

This tutorial covers writing and deploying a simple smart contract with the SmartPy programming language.
SmartPy has syntax similar to Python, but you don't need any experience with Python or SmartPy to do this tutorial.

* If you are more familiar with OCaml, try [Deploy a smart contract with CameLIGO](/tutorials/smart-contract/cameligo).
* If you are more familiar with JavaScript, try [Deploy a smart contract with JsLIGO](/tutorials/smart-contract/jsligo).
* To learn the Archetype language, try [Deploy a smart contract with Archetype](/tutorials/smart-contract/archetype).

SmartPy is a high-level programming language that you can use to write smart contracts for the Tezos blockchain.
It abstracts away the complexity of using Michelson (the smart contract language directly available on-chain) to make it easier to write smart contracts on Tezos.

In this tutorial, you will learn how to:

* Create a wallet to store cryptocurrency tokens
* Get free tez tokens (the native cryptocurrency token on Tezos) from a faucet
* Code a contract in SmartPy, including:
  * Creating a contract in the online IDE
  * Defining the storage for the contract
  * Defining entrypoints in the contract
  * Writing code to run when the entrypoints are called
* Deploy (or originate) the contract to Tezos and set its starting storage value
* Look up the current state of the contract
* Call the contract

## What is a smart contract?

A smart contract is a computer program that is stored on a blockchain and runs on a blockchain.
Because the blockchain is spread across many computer nodes, you don't have to think about where to host the program or worry whether a computer will run it or not.
Responsibility for running the contract is distributed across all of the nodes in the Tezos system, so when you deploy a smart contract, you can be confident that it will be available and unmodified when someone wants to run it.

A smart contract has these parts:

* Persistent storage, data that the contract can read and write
* One or more entrypoints, which are a kind of function that clients can call, like endpoints in an API or functions or methods in many programming languages
* A Tezos account that can store tokens (technically, the contract is itself a type of Tezos account, but you can think of it as a program with a Tezos account)

## Tutorial contract

The contract that you deploy in this tutorial stores a string value.
It provides entrypoints that clients can call to change the value of that string:

* The `replace` entrypoint accepts a new string as a parameter and stores that string, replacing the existing string.
* The `append` entrypoint accepts a new string as a parameter and appends it to the existing string.

After you deploy the contract, you or any other user can call it from various sources, including web applications, other contracts, and the Octez command-line client.
However, no one can prevent it from running or tamper with its code or its storage.

## Creating and funding a wallet

To deploy and work with the contract, you need a wallet and some tez tokens.

1. Install a Tezos-compatible wallet.
   Which wallet you install is up to you and whether you want to install a wallet on your computer, in a browser extension, or as a mobile app.

   If you don't know which one to choose, try the [Temple](https://templewallet.com/) browser extension.

   Desktop wallets for Tezos include the [Temple](https://templewallet.com/) browser extension, [Kukai](https://wallet.kukai.app/), and [Umami](https://umamiwallet.com/).

   Mobile apps include [Temple](https://templewallet.com/), [Kukai](https://wallet.kukai.app/), and [Umami](https://umamiwallet.com/).

2. Switch the wallet to use the Ghostnet testnet instead of Tezos Mainnet.
   Ghostnet is a network for testing Tezos applications where tokens are free so you don't have to spend real currency to work with your applications.

   For example, for the Temple browser wallet, click **Tezos Mainnet** at the top and then click **Ghostnet Testnet**, as in this picture:

   ![Selecting the Ghostnet testnet in the Temple wallet](/img/tutorials/temple-switch-network.png)

3. From your wallet, get the address of your account, which starts with `tz1`.
   This is the address that applications use to work with your wallet.

4. Go to the Ghostnet faucet page at https://faucet.ghostnet.teztnets.com.

5. On the faucet page, paste your wallet address into the input field labeled "Or fund any address" and click the button for the amount of tez to add to your wallet.
   20 tez is enough to work with the tutorial contract, and you can return to the faucet later if you need more tez.

   It may take a few minutes for the faucet to send the tokens and for those tokens to appear in your wallet.

   You can use the faucet as much as you need to get tokens on the testnet, but those tokens are worthless and cannot be used on Mainnet.

   ![Fund your wallet using the Ghostnet Faucet](/img/tutorials/wallet-funding.png)

Now you have an account and funds that you can use to work with Tezos.

## Creating the contract

The contract that you will create has these basic parts:

* A function that initializes the contract and sets the starting value for its storage.

* Internal functions called entrypoints that run code when clients call the contract.

* Automated tests that verify that the contract works as expected.

Follow these steps to create the code for the contract:

1. Open the SmartPy online IDE at https://smartpy.io/ide.
   You can work with SmartPy code in any IDE, but this online IDE keeps you from having to install software on your computer, and it also simplifies the process of deploying contracts.

2. In the code editor, add this line of code to import SmartPy:

   ```python
   import smartpy as sp
   ```

3. Add this code that creates the entrypoints:

   ```python
   @sp.module
   def main():
       class StoreGreeting(sp.Contract):
           def __init__(self, greeting):  # Note the indentation
               # Initialize the storage with a string passed at deployment time
               # Cast the greeting parameter to a string
               sp.cast(greeting, sp.string)
               self.data.greeting = greeting

           @sp.entrypoint  # Note the indentation
           def replace(self, params):
               self.data.greeting = params.text

           @sp.entrypoint  # Note the indentation
           def append(self, params):
               self.data.greeting += params.text
   ```

   Indentation is significant in Python, so make sure that your indentation matches this code.

   The first two lines create a SmartPy module, which indicates that the code is SmartPy instead of ordinary Python.

   Then the code creates a class named StoreGreeting, which represents the smart contract.
   The contract has an `__init__` function, which runs when the contract is deployed.
   In this case, the function sets the initial value of the storage to a parameter that you pass when you deploy the contract.
   This storage value is a string, but the storage can be another primitive type such as an integer or timestamp, or a complex data type that contains multiple values.
   For more information on contract data types, see [Data types](/smart-contracts/data-types).

4. Add this code, which creates automated tests:

   ```python
   # Automated tests that run on simulation
   @sp.add_test()
   def test():
       # Initialize the test scenario
       scenario = sp.test_scenario("StoreGreeting", main)
       scenario.h1("StoreGreeting")

       # Initialize the contract and pass the starting value
       contract = main.StoreGreeting("Hello")
       scenario += contract

       # Verify that the value in storage was set correctly
       scenario.verify(contract.data.greeting == "Hello")

       # Test the entrypoints and check the new storage value
       contract.replace(text = "Hi")
       contract.append(text = ", there!")
       scenario.verify(contract.data.greeting == "Hi, there!")
   ```

   When you run the SmartPy file, SmartPy runs a simulation in which it tests and compiles the contract.
   In this case, the tests verify that the replace and append endpoints work.
   For more information about SmartPy and tests, see the [SmartPy documentation](https://smartpy.io/).

The SmartPy online IDE looks like this:

![The SmartPy online IDE, including the code for the contract](/img/tutorials/smartpy-ide-contract.png)

The complete contract looks like this:

```python
import smartpy as sp

@sp.module
def main():
    class StoreGreeting(sp.Contract):
        def __init__(self, greeting):  # Note the indentation
            # Initialize the storage with a string passed at deployment time
            # Cast the greeting parameter to a string
            sp.cast(greeting, sp.string)
            self.data.greeting = greeting

        @sp.entrypoint  # Note the indentation
        def replace(self, params):
            self.data.greeting = params.text

        @sp.entrypoint  # Note the indentation
        def append(self, params):
            self.data.greeting += params.text

# Automated tests that run on simulation
@sp.add_test()
def test():
    # Initialize the test scenario
    scenario = sp.test_scenario("Test scenario", main)
    scenario.h1("StoreGreeting")

    # Initialize the contract and pass the starting value
    contract = main.StoreGreeting("Hello")
    scenario += contract

    # Verify that the value in storage was set correctly
    scenario.verify(contract.data.greeting == "Hello")

    # Test the entrypoints and check the new storage value
    contract.replace(text = "Hi")
    contract.append(text = ", there!")
    scenario.verify(contract.data.greeting == "Hi, there!")
```

## Testing and compiling the contract

Before you can deploy the contract to Tezos, you must compile it to Michelson, the base language of Tezos contracts.
The compilation process automatically runs the tests.

1. Compile the contract and run the tests by clicking the **Run Code** button:

   ![](/img/tutorials/smartpy-ide-run.png)

   The right-hand pane of the online IDE shows the results of the simulation, compilation, and testing process.
   The first step is simulating the deployment (origination) of the contract.
   The simulation assigns the contract a temporary address and shows the initial state of its storage:

   <img src="/img/tutorials/smartpy-ide-origination.png" alt="The originated contract and the initial storage in the SmartPy IDE" style={{width: 300}} />

   Then, the simulation runs the test cases and shows the results of each call to an entrypoint:

   <img src="/img/tutorials/smartpy-ide-test-entrypoints.png" alt="The results of the entrypoint calls" style={{width: 300}} />

## Deploying (originating) to the testnet

Deploying a contract to the network is called "originating."
Originating the contract requires a small amount of Tezos tokens as a fee.

1. Under the origination step, click **Show Michelson**.

   <img src="/img/tutorials/smartpy-ide-origination-annotated.png" alt="The originated contract, with the Show Michelson button highlighted" style={{width: 300}} />

   The IDE shows the compiled Michelson code of the contract, which is the language that smart contracts use on Tezos.

2. Below the Michelson code, click **Deploy Contract**.

3. In the new window, under "Node and Network," select the Ghostnet testnet and accept the default RPC node, as in this picture:

   <img src="/img/tutorials/smartpy-ide-network.png" alt="Selecting the Ghostnet network and default RPC node" style={{width: 600}} />

4. Under "Wallet," click **Select Account**.

5. In the pop-up window, connect your wallet.
   For Temple wallets, use the Temple tab, and for most other wallets, use the Beacon tab.

6. When your wallet is connected, click **Validate**.

   The Origination page shows your wallet information:

   <img src="/img/tutorials/smartpy-ide-connected-wallet.png" alt="The successful connection to your wallet on the origination page" style={{width: 500}} />

7. At the bottom of the page, click **Deploy Contract**.

8. In the pop-up window, click **Accept**.

9. Approve the transaction in your wallet app.

   The "Origination Result" section shows information about the deployed contract, including its address:

   <img src="/img/tutorials/smartpy-ide-originated-contract.png" alt="Information about the originated contract" style={{width: 500}} />

10. Under the contract address, click **Save Contract**.

11. In the popup window, give the contract a name and click **Add Contract**.
    Saving the contract address like this is important because the address is not shown again.

12. Open the contract in the block explorer Better Call Dev:

    1. In a new browser tab, go to https://better-call.dev/.

    2. Paste the contract address in the search box and press Enter.

    The block explorer shows information about the contract, including recent transactions and the current state of its storage.

    <img src="/img/tutorials/bcd-originated-contract.png" alt="The block explorer, showing information about the contract" style={{width: 500}} />

13. Try calling one of the entrypoints:

    1. Go to the **Storage** tab and check the current state of the storage.
       If you just originated  the contract, the storage is "Hello" because that's the value set in the smart contract code.

    2. Go to the **Interact** tab.
       This tab shows the entrypoints in the contract and lets you use them.

    3. For the `append` entrypoint, in the **Parameters** section, put some text in the field, as shown in this image:

       <img src="/img/tutorials/bcd-interact-parameters.png" alt="Putting in a value for an entrypoint parameter" style={{width: 500}} />

    4. Click **Execute** and then click **Wallet**.

    5. Select your wallet and connect it to the application.

    6. Confirm the transaction in your wallet.

    7. Wait for a success message that says "The transaction has successfully been broadcasted to the network."

    8. Go back to the **Storage** tab and see that the text that you put in the parameter has been added to the contract storage, as in this picture:

       <img src="/img/tutorials/bcd-updated-storage.png" alt="Updated storage value" style={{width: 500}} />

## Summary

Now the contract is running on the Tezos blockchain.
You or any other user can call it from any source that can send transactions to Tezos, including Octez, dApps, and other contracts.

If you want to continue working with this contract, here are some ideas:

* Change permissions for the contract so only your account can call its entrypoints
* Add your own entrypoints and originate a new contract; note that you cannot update the existing contract after it is deployed
* Create a dApp to call the contract from a web application, similar to the dApp that you create in the tutorial [Build a simple web application](/tutorials/build-your-first-app/)


# Deploy a smart contract with Archetype

This tutorial covers writing a smart contract and deploying it to Tezos in the Archetype programming language.
It uses the completium-cli command-line tool, which lets you work with Archetype contracts and Tezos from the command line.

* If you are more familiar with Python, try [Deploy a smart contract with SmartPy](/tutorials/smart-contract/smartpy).
* If you are more familiar with OCaml, try [Deploy a smart contract with CameLIGO](/tutorials/smart-contract/cameligo).
* If you are more familiar with JavaScript, try [Deploy a smart contract with JsLIGO](/tutorials/smart-contract/jsligo).

In this tutorial, you will learn how to:

* Create a wallet to store cryptocurrency tokens
* Get free tez tokens (the native cryptocurrency token on Tezos) from a faucet
* Code a contract in Archetype, including:
  * Defining the storage for the contract and its initial value
  * Defining entrypoints in the contract
  * Writing code to run when the entrypoints are called
* Deploy (or originate) the contract to Tezos
* Look up the current state of the contract
* Call the contract from the command line

## What is a smart contract?

A smart contract is a computer program that is stored on a blockchain and runs on a blockchain.
Because the blockchain is spread across many computer nodes, you don't have to think about where to host the program or worry whether a computer will run it or not.
Responsibility for running the contract is distributed across all of the nodes in the Tezos system, so when you deploy a smart contract, you can be confident that it will be available and unmodified when someone wants to run it.

A smart contract has these parts:

* Persistent storage, data that the contract can read and write
* One or more entrypoints, which are a kind of function that clients can call, like endpoints in an API or functions or methods in many programming languages
* A Tezos account that can store tokens (technically, the contract is itself a type of Tezos account, but you can think of it as a program with a Tezos account)

## The Archetype language

Archetype is a high-level language designed specifically for writing Tezos smart contracts.
It has features that help you write smart contracts, including:

* Clear syntax that maps closely with how smart contracts work
* Enhancements that simplify working with storage
* Tools that help you verify conditions before running code, such as ensuring that the caller is authorized to run the entrypoint
* The ability to set up a contract as a state machine, which gives the contract a state and manages transitions between states
* The ability to verify that the contract does what it says it does through the process of formal verification

Like the other languages that Tezos accepts, Archetype code is compiled to Michelson to run on the blockchain.

For more information about Archetype, see https://archetype-lang.org/.

## Tutorial contract

The contract that you deploy in this tutorial stores a single integer.
It provides entrypoints that clients can call to change the value of that integer:

* The `increment` entrypoint accepts an integer as a parameter and adds that integer to the value in storage
* The `decrement` entrypoint accepts an integer as a parameter and subtracts that integer from the value in storage
* The `reset` entrypoint takes no parameters and resets the value in storage to 0

After you deploy the contract, you or any other user can call it from various sources, including web applications, other contracts, and the Octez command-line client.
However, no one can prevent it from running or tamper with its code or its storage.

## Prerequisites

To run this tutorial, you need the completium-cli program:

1. Make sure that NPM is installed by running this command in your command-line terminal:

   ```bash
   npm --version
   ```

   If NPM is not installed, install Node.JS on your computer, which includes NPM, from this link: https://nodejs.org/en.

2. Install completium-cli by running this command:

   ```bash
   npm install -g @completium/completium-cli
   ```

   You can verify that completium-cli installed by running this command:

   ```bash
   completium-cli version
   ```

   If you see a message with the version of completium-cli, it is installed correctly.

3. Initialize completium-cli by running this command:

   ```bash
   completium-cli init
   ```

## Using a testnet

Before you deploy your contract to the main Tezos network (referred to as *Mainnet*), you can deploy it to a testnet.
Testnets are useful for testing Tezos operations because testnets provide tokens for free so you can work with them without spending real tokens.

Tezos testnets are listed on this site: https://teztnets.com/.

The [Ghostnet](https://teztnets.com/ghostnet-about) testnet is a good choice for testing because it is intended to be long-lived, as opposed to shorter-term testnets that allow people to test new Tezos features.

By default, completium-cli uses Ghostnet, but these steps verify the network:

1. Verify that completium-cli is set to use Ghostnet by running this command:

   ```bash
   completium-cli show endpoint
   ```

   The response shows the RPC endpoint that completium-cli is using, which is its access point to the Tezos network.
   If the response shows `Current network: ghost`, it is using Ghostnet.

2. If completium-cli is not using Ghostnet, switch to Ghostnet by running this command, selecting any endpoint labeled "ghost," and pressing Enter:

   ```bash
   completium-cli switch endpoint
   ```

## Creating a local wallet

Deploying and using a smart contract costs fees, so you need a local wallet and XTZ tokens.
You could use the default accounts that are included in completium-cli, but follow these steps to create your own local wallet on a test network:

1. Run the following command to generate a local wallet, replacing `local_wallet` with a name for your wallet:

   ```bash
   completium-cli generate account as local_wallet
   ```

2. Switch to the account that you created by running this command, selecting the new account, and pressing Enter:

   ```bash
   completium-cli switch account
   ```

3. Get the address for the wallet by running this command:

   ```bash
   completium-cli show account
   ```

   The result shows the address of the account, which begins with "tz1".

   You need the wallet address to send funds to the wallet, to deploy the contract, and to send transactions to the contract.

4. Copy the address for the account, which is labeled as the "public key hash" in the response to the previous command.
   The address starts with "tz1".

5. On the testnets page at https://teztnets.com/, click the faucet link for the Ghostnet testnet, which is at https://faucet.ghostnet.teztnets.com.

6. On the faucet page, paste your wallet address into the input field labeled "Or fund any address" and click the button for the amount of XTZ to add to your wallet.
   1 XTZ is enough for the tutorial.
   It may take a few minutes for the faucet to send the tokens and for those tokens to appear in your wallet.

   You can use the faucet as much as you need to get tokens on the testnet, but those tokens are worthless and cannot be used on Mainnet.

   ![Fund your wallet using the Ghostnet Faucet](/img/tutorials/wallet-funding.png)

7. Run this command to check the balance of your wallet:

   ```bash
   completium-cli show account
   ```

If your wallet is set up correctly and the faucet has sent tokens to it, the response includes the balance of your wallet.

## Create the contract

The contract that you will create has these basic parts:

* A variable that represents the contract's storage, in this case an integer.
  Contracts can have storage in the form of primitive types such as an integer, string, or timestamp, or a complex data type that contains multiple values.
  For more information on contract data types, see [Data types](/smart-contracts/data-types).

* Internal functions called entrypoints that run code when clients call the contract.

Follow these steps to create the code for the contract:

1. Run this command to create the contract file:

   ```bash
   touch counter.arl
   ```

2. Open the `counter.arl` file in any text editor.

3. At the top of the file, name the contract by putting the name after the `archetype` keyword:

   ```archetype
   archetype Counter
   ```

4. Define the storage for the contract by adding this line:

   ```archetype
   variable value : int = 10
   ```

   This line creates a variable in the contract's storage with the name "value."
   It is an integer type and has the initial value of 10.

   Any variables that you create with the `variable` keyword at the top level of the contract become part of its persistent storage.

5. Add the code for the increment and decrement entrypoints:

   ```archetype
   // Increment entrypoint
   entry increment(delta : int) {
     value += delta
   }

   // Decrement entrypoint
   entry decrement(delta : int) {
     value -= delta
   }
   ```

   These functions begin with the `entry` keyword to indicate that they are entrypoints.
   They accept one parameter: the change in the storage value, which is an integer named `delta`.
   One function adds the parameter to the value of the `value` variable and the other subtracts it.

6. Add this code for the reset entrypoint:

   ```archetype
   // Reset entrypoint
   entry reset() {
     value := 0
   }
   ```

   This function is similar to the others, but it does not take a parameter.
   It always sets the `value` variable to 0.

The complete contract code looks like this:

```archetype
archetype Counter

variable value : int = 0

// Increment entrypoint
entry increment(delta : int) {
  value += delta
}

// Decrement entrypoint
entry decrement(delta : int) {
  value -= delta
}

// Reset entrypoint
entry reset() {
  value := 0
}
```

## Deploying (originating) to the testnet

Deploying a contract to the network is called "originating."
Originating the contract requires a small amount of Tezos tokens as a fee.

1. Run the following command to originate the smart contract:

   ```bash
   completium-cli deploy Counter.arl
   ```

   The command line shows information about the transaction, including the name of the originating account, the target network, and the cost to deploy it.
   By default, it uses the local alias "Counter" to refer to the contract.

2. Press Y to confirm and deploy the contract.

   If you see an error that includes the message `contract.counter_in_the_past`, you waited too long before pressing Y.
   Run the `deploy` command again and promptly press Y to confirm it.

3. Print information about the contract by running this command:

   ```bash
   completium-cli show contract Counter
   ```

   The response shows information about the contract, including its address on Ghostnet, which starts with "KT1".
   You can use this information to look up the contract on a block explorer.

4. Verify that the contract deployed successfully by finding it on a block explorer:

   1. Open a Tezos block explorer such as [TzKT](https://tzkt.io) or [Better Call Dev](https://better-call.dev/).

   2. Set the explorer to Ghostnet instead of Mainnet.

   3. Paste the contract address, which starts with `KT1`, into the search field and press Enter.

   4. Go to the Storage tab to see that the initial value of the storage is 10.

5. Run this command to see the current value of the contract storage:

   ```bash
   completium-cli show storage Counter
   ```

## Calling the contract

Now you can call the contract from any Tezos client, including completium-cli.

To increment the current storage by a certain value, call the `increment` entrypoint, as in this example:

```bash
completium-cli call Counter --entry increment --arg '{ "int": 5 }'
```

To decrement the storage, call the `decrement` entrypoint, as in this example:

```bash
completium-cli call Counter --entry decrement --arg '{ "int": 2 }'
```

Finally, to reset the current storage to zero, call the `reset` entrypoint, as in this example:

```bash
completium-cli call Counter --entry reset
```

Then, you can verify the updated storage on the block explorer or by running the `completium-cli show storage Counter` command.

## Summary

Now the contract is running on the Tezos blockchain.
You or any other user can call it from any source that can send transactions to Tezos, including command-line clients, dApps, and other contracts.

If you want to continue working with this contract, here are some ideas:

* Change permissions for the contract so only your account can call its entrypoints
* Add your own entrypoints and originate a new contract; note that you cannot update the existing contract after it is deployed
* Create a dApp to call the contract from a web application, similar to the dApp that you create in the tutorial [Build a simple web application](/tutorials/build-your-first-app/)


# Create your minimum dapp on Tezos

> dApp : A decentralized application is a type of distributed open source software application that runs on a peer-to-peer (P2P) blockchain network rather than on a single computer. DApps are visibly similar to other software applications that are supported on a website or mobile device.

This tutorial shows you how to create a poke game on smart contract.
The game consists on poking the owner of a smart contract. The smart contract keeps a track of user interactions and stores a trace.

Poke sequence diagram.

```mermaid
sequenceDiagram
  Note left of User: Prepare poke transaction
  User->>Smartcontract: poke()
  Note right of Smartcontract: store(pokeTrace)
```

You will learn :

* How to create a Tezos project with Taqueria.
* How to create a smart contract in JsLIGO.
* How to deploy the smart contract a real testnet named Ghostnet.
* How to create a frontend dApp using Taquito library and interact with a Tezos browser wallet.
* How to use an indexer like TZKT.

## Prerequisites

This tutorial uses Typescript, so it will be easier if you are familiar with JavaScript.

1. Make sure that you have installed these tools:

   * [Node.JS and NPM](https://nodejs.org/en/download/): NPM is required to install the web application's dependencies.
   * [Taqueria](https://taqueria.io/), version 0.45.0 or later: Taqueria is a platform that makes it easier to develop and test dApps.
   * [Docker](https://docs.docker.com/engine/install/): Docker is required to run Taqueria.
   * [jq](https://stedolan.github.io/jq/download/): Some commands use the `jq` program to extract JSON data.
   * [`yarn`](https://yarnpkg.com/): The frontend application uses yarn to build and run (see this article for details about [differences between `npm` and `yarn`](https://www.geeksforgeeks.org/difference-between-npm-and-yarn/)).
   * Any Tezos-compatible wallet that supports Ghostnet, such as [Temple wallet](https://templewallet.com/).

2. Optionally, you can install [`VS Code`](https://code.visualstudio.com/download) to edit your application code in and the [LIGO VS Code extension](https://marketplace.visualstudio.com/items?itemName=ligolang-publish.ligo-vscode) for LIGO editing features such as code highlighting and completion.
   Taqueria also provides a [Taqueria VS Code extension](https://marketplace.visualstudio.com/items?itemName=ecadlabs.taqueria-vscode) that helps visualize your project and run tasks.

## The tutorial application

In this tutorial, you create a simple game where the user is poking though a dApp. The user interacts with the smart contract through a web interface, where they can see the current state of the contract and send poke commands to it. The contract responds by updating its storage with the user's address. Alternately, a user can also poke the contract deployed by other users.

The application looks like this:

![Example of the table of addresses and which addresses poked them](/img/tutorials/dapp-table.png)

The code for the completed application is in this GitHub repository: [solution](https://github.com/marigold-dev/training-dapp-1/tree/main/solution)

When you're ready, move to the next section [Create your minimum dApp on Tezos](/tutorials/dapp/part-1) to begin setting up the application.


# Part 1: Create your minimum dApp on Tezos

To start working with the application, you create a Taqueria project and use it to deploy the Poke contract.
Then you set up a web application to connect with a wallet, and then interact with your smart contract.

Before you begin, make sure that you have installed the tools in the [Prerequisites](/tutorials/dapp#prerequisites) section.

## Creating a Taqueria project

Taqueria manages the project structure and keeps it up to date.
For example, when you deploy a new smart contract, Taqueria automatically updates the web app to send transactions to that new smart contract.
Follow these steps to set up a Taqueria project:

On the command-line terminal, run these commands to set up a Taqueria project and install the LIGO and Taquito plugins:

```bash
taq init training
cd training
taq install @taqueria/plugin-ligo
taq install @taqueria/plugin-taquito
taq create contract pokeGame.jsligo
```

## Write the smart contract

1. Edit the **pokeGame.jsligo** file. Remove the default code and paste this code instead.

   ```jsligo
   export type storage = unit;

   type return_ = [list<operation>, storage];

   @entry
   const poke = (_: unit, store: storage): return_ => {
     return [list([]), store];
   };
   ```

   Every contract has to follow these rules :

   * At least one entrypoint, annotated with **@entry** , with a mandatory signature taking 2 arguments ***(parameter, storage)** and a return type. An entrypoint is a function that is exposed as an external API.
     * **parameter**: the entrypoint parameter. Mandatory and can be of any type. For example: an (ignored) variable starting with`_` here, and of type `unit` (the type void on LIGO).
     * **storage**: the on-chain storage. Mandatory and can be of any type. For example, here we use the type `unit`. It is recommended to add an `export` keyword before the type definition as it is a good practice to export it when you are required to write unit tests from another LIGO file.
     * **return_**: a mandatory pair of list of `operation` and the storage type (defined earlier). Return type naming is free but don't use an existing keyword like **return**.

   [Have a look at the Entrypoints contracts documentation](/smart-contracts/entrypoints)>

   > Note: Previous versions of LIGO used a single main function instead of a function for each entrypoint. This syntax is still valid, but it is harder to read and deprecated in LIGO V1.
   >
   > A `Poke` variant parameter is generated from the `poke` entrypoint function under the hood. A variant is more or less equivalent of the Enum type in Javascript. A default main function is generated and act like as a dispatcher for each of your entrypoints. It means that this painful boilerplate is no more needed on the new syntax.

   [Have a look at the Variant type documentation](/smart-contracts/data-types/complex-data-types#variants)

2. Write the poke function.
   The objective is to store every user/caller addresses poking the contract.
   Rewrite the storage, and add the caller address to the set of traces.

   At line 1, replace the line with:

   ```jsligo
   export type storage = set<address>;
   ```

3. Replace the `poke` function with:

   ```jsligo
   @entry
   const poke = (_: unit, store: storage): return_ => {
     return [list([]), Set.add(Tezos.get_source(), store)]
   };
   ```

   Explanation:

   * The LIGO Set library has a function **add** to add one element to the Set of items. There is no concept of Class in LIGO, you use a library to apply functions on objects.
   * A list of operations is required to return. An empty list is returned here as there is no other contract to call.

   [Have a look at the Set library documentation](https://ligolang.org/docs/data-types/sets)

   [Have a look at the List library documentation](https://ligolang.org/docs/data-types/lists)

   Here, get the caller address using `Tezos.get_source()`. Tezos library provides useful functions for manipulating blockchain objects.

   [Have a look at the Tezos library documentation](https://ligolang.org/docs/reference/tezos-reference?lang=jsligo)

## Simulate a call on your smart contract

The LIGO command-line provides sub-commands to test your LIGO code.

[Have a look at the Testing Framework documentation](https://ligolang.org/docs/testing)

1. Compile the contract with Taqueria (Force to use a specific LIGO version with `TAQ_LIGO_IMAGE` Taqueria environment variable).

   ```bash
   TAQ_LIGO_IMAGE=ligolang/ligo:1.6.0 taq compile pokeGame.jsligo
   ```

   Taqueria is generating the `.tz` Michelson file in the `artifacts` folder. The Michelson language is the default stack language used by the Michelson VM to run your code on a node. It is something similar to WASM.

   [Have a look on the Michelson documentation](https://octez.tezos.com/docs/active/michelson.html)

2. Taqueria is generating two additional files, edit the first file `pokeGame.storageList.jsligo` replacing the current code with:

   ```jsligo
   #import "pokeGame.jsligo" "Contract"

   const default_storage = Set.empty as set<address>;
   ```

   When you deploy a contract, you are required to initialize the default state of your smart contract. Taqueria allows you to declare different variables on this file, it is useful to use different initialized states per environment.

   [Have a look at the Taqueria documentation](https://taqueria.io/docs/plugins/plugin-ligo/#the-taq-compile-task)

3. Compile all (contract + initial storage)

   ```bash
   TAQ_LIGO_IMAGE=ligolang/ligo:1.6.0 taq compile pokeGame.jsligo
   ```

   It compiles both source code and storage.

   Before deployment, to simulate a call to our entrypoint **poke**, Taq has a **taq simulate** command.
   The contract parameter `Poke()` and the initial storage with the default empty set are passed to the execution.

4. Edit the second file **pokeGame.parameterList.jsligo**

   ```jsligo
   #import "pokeGame.jsligo" "Contract"
   const default_parameter: parameter_of Contract = Poke();
   ```

5. Run the simulation. First, install the Tezos client plugin, recompile it all, and then run the simulation.

   ```bash
   taq install @taqueria/plugin-octez-client
   TAQ_LIGO_IMAGE=ligolang/ligo:1.6.0 taq compile pokeGame.jsligo
   taq simulate pokeGame.tz --param pokeGame.parameter.default_parameter.tz
   ```

   Output logs:

   ```logs
   ┌─────────────┬──────────────────────────────────────────────┐
   │ Contract    │ Result                                       │
   ├─────────────┼──────────────────────────────────────────────┤
   │ pokeGame.tz │ storage                                      │
   │             │   { "tz1Ke2h7sDdakHJQh8WX4Z372du1KChsksyU" } │
   │             │ emitted operations                           │
   │             │                                              │
   │             │ big_map diff                                 │
   │             │                                              │
   │             │                                              │
   └─────────────┴──────────────────────────────────────────────┘
   ```

   You can notice that the instruction is storing the address of the caller in the storage set.

### Configure your wallet and deploy

The default Tezos testing testnet is called **Ghostnet**.

> :warning: You need an account to deploy a contract with some `tez` (the Tezos native currency). The first time you deploy a contract with Taqueria, it is generating a new user account with `0 tez`.

1. Deploy your contract to the `testing` environment. Ut forces Taqueria to generate a default account on a testing config file.

   ```bash
   taq deploy pokeGame.tz -e "testing"
   ```

   You should get this kind of log.

   ```log
   Warning: the faucet field in network configs has been deprecated and will be ignored.
   A keypair with public key hash tz1XXXXXXXXXXXXXXXXXXXXXX was generated for you.
   To fund this account:
   1. Go to https://teztnets.com and click "Faucet" of the target testnet.
   2. Copy and paste the above key into the 'wallet address field.
   3. Request some Tez (Note that you might need to wait for a few seconds for the network to register the funds).
   No operations performed.
   ```

   * Choice N°1 (Recommended): Use Alice wallet instead of the generated account. A common usage is to use **alice** account as Taqueria operator. **alice** is a commonly known address used on Tezos and she has always some **tez**. Replace the Taqueria config file for **testing** env **.taq/config.local.testing.json** with **alice** settings:

     ```json
     {
       "networkName": "ghostnet",
       "accounts": {
         "taqOperatorAccount": {
           "publicKey": "edpkvGfYw3LyB1UcCahKQk4rF2tvbMUk8GFiTuMjL75uGXrpvKXhjn",
           "publicKeyHash": "tz1VSUr8wwNhLAzempoch5d6hLRiTh8Cjcjb",
           "privateKey": "edsk3QoqBuvdamxouPhin7swCvkQNgq4jP5KZPbwWNnwdZpSpJiEbq"
         }
       }
     }
     ```

   * Choice N°2: use the Taqueria-generated account. Copy the account **privateKey** from the **.taq/config.local.testing.json** config file. Open your Temple browser extension on your computer or on your mobile phone and do the [initial setup](https://www.youtube.com/watch?v=S8_tL8PfCts). Once you are done, go to Settings (click on the avatar icon, or display Temple in full page) and click on **Import account > Private key** tab. Paste the **privateKey** to Temple text input and confirm. Send free Tez to your new account via this web faucet [here](https://teztnets.com/). Connect your wallet on **Ghostnet** and ask for free tez.

   Now you have some money to play with.

2. Deploy to Ghostnet testnet.

   ```bash
   taq deploy pokeGame.tz -e "testing"
   ```

   Your smart contract is deployed on the Ghostnet.

   ```logs
   ┌─────────────┬──────────────────────────────────────┬──────────┬──────────────────┬────────────────────────────────┐
   │ Contract    │ Address                              │ Alias    │ Balance In Mutez │ Destination                    │
   ├─────────────┼──────────────────────────────────────┼──────────┼──────────────────┼────────────────────────────────┤
   │ pokeGame.tz │ KT1G8tx4qSeJmKRY1p2oxA6eYoCGc9Qi3Fky │ pokeGame │ 0                │ https://ghostnet.ecadinfra.com │
   └─────────────┴──────────────────────────────────────┴──────────┴──────────────────┴────────────────────────────────┘
   ```

## Create the frontend

### Create a React app

```bash
yarn create vite
```

Then follow the prompts. Choose React and then Typescript+SWC:

```shell
? Project name: › app #Enter your project name

? Select a framework: › - Use arrow-keys. Return to submit. # Select React as framework
    Vanilla
    Vue
❯   React
    Preact
    Lit
    Svelte
    Others

? Select a variant: › - Use arrow-keys. Return to submit. #Both TypeScript variants are fine. Select TypeScript only.
    TypeScript
❯   TypeScript + SWC
    JavaScript
    JavaScript + SWC
```

[More information about SWC here](https://swc.rs/).

1. Add taquito and tzkt indexer libraries.

   ```bash
   cd app
   yarn add @taquito/taquito @taquito/beacon-wallet @airgap/beacon-sdk  @tzkt/sdk-api
   yarn add -D @airgap/beacon-types
   ```

   > :warning: Before starting, add the following dependencies in order to resolve polyfill issues. Some dependencies are from NodeJs, thus not included in browsers.

2. For example, in my case, I installed this:

   ```bash
   yarn add --dev process buffer crypto-browserify stream-browserify assert stream-http https-browserify os-browserify url path-browserify
   ```

3. Create a new file `nodeSpecific.ts` in the src folder of your project and edit with this content:

   ```bash
   touch src/nodeSpecific.ts
   ```

   ```js
   import { Buffer } from 'buffer';

   globalThis.Buffer = Buffer;
   ```

4. Open the `index.html` file and replace the `body` with this one:

   ```html
   <body>
     <div id="root"></div>
     <script type="module" src="/src/nodeSpecific.ts"></script>
     <script type="module" src="/src/main.tsx"></script>
   </body>
   ```

5. Open the `vite.config.ts` file and replace it with:

   ```js
   import react from '@vitejs/plugin-react-swc';
   import path from 'path';
   import { defineConfig } from 'vite';
   // https://vitejs.dev/config/
   export default ({ command }) => {
     const isBuild = command === 'build';

     return defineConfig({
       define: {},
       plugins: [react()],
       build: {
         commonjsOptions: {
           transformMixedEsModules: true,
         },
       },
       resolve: {
         alias: {
           // dedupe @airgap/beacon-sdk
           // I almost have no idea why it needs `cjs` on dev and `esm` on build, but this is how it works 🤷‍♂️
           '@airgap/beacon-sdk': path.resolve(
             path.resolve(),
             `./node_modules/@airgap/beacon-sdk/dist/${
               isBuild ? 'esm' : 'cjs'
             }/index.js`
           ),
           stream: 'stream-browserify',
           os: 'os-browserify/browser',
           util: 'util',
           process: 'process/browser',
           buffer: 'buffer',
           crypto: 'crypto-browserify',
           assert: 'assert',
           http: 'stream-http',
           https: 'https-browserify',
           url: 'url',
           path: 'path-browserify',
         },
       },
     });
   };
   ```

### Generate the Typescript classes from Michelson code and run the server

Taqueria is able to generate Typescript classes for any frontend application. It takes the definition of your smart contract and generates the contract entrypoint functions, type definitions, etc ...

To get typescript classes from Taqueria plugin, on your project root folder run:

```bash
taq install @taqueria/plugin-contract-types
taq generate types ./app/src
```

1. Go back to your frontend app and run the dev server.

   ```bash
   cd app
   yarn dev
   ```

2. Open your browser at: http://localhost:5173/
   Your app should be running.

### Connect / disconnect the wallet

Declare two React Button components and display the user's address and balance.

1. Edit **src/App.tsx** file:

   ```typescript
   import { NetworkType } from '@airgap/beacon-types';
   import { BeaconWallet } from '@taquito/beacon-wallet';
   import { TezosToolkit } from '@taquito/taquito';
   import * as api from '@tzkt/sdk-api';
   import { useEffect, useState } from 'react';
   import './App.css';
   import ConnectButton from './ConnectWallet';
   import DisconnectButton from './DisconnectWallet';

   function App() {
     api.defaults.baseUrl = 'https://api.ghostnet.tzkt.io';

     const [Tezos, setTezos] = useState<TezosToolkit>(
       new TezosToolkit('https://ghostnet.ecadinfra.com')
     );
     const [wallet, setWallet] = useState<BeaconWallet>(
       new BeaconWallet({
         name: 'Training',
         preferredNetwork: NetworkType.GHOSTNET,
       })
     );

     useEffect(() => {
       (async () => {
         const activeAccount = await wallet.client.getActiveAccount();
         if (activeAccount) {
           setUserAddress(activeAccount.address);
           const balance = await Tezos.tz.getBalance(activeAccount.address);
           setUserBalance(balance.toNumber());
         }
       })();
     }, []);

     const [userAddress, setUserAddress] = useState<string>('');
     const [userBalance, setUserBalance] = useState<number>(0);

     return (
       <div className="App">
         <header className="App-header">
           <ConnectButton
             Tezos={Tezos}
             setTezos={setTezos}
             setUserAddress={setUserAddress}
             setUserBalance={setUserBalance}
             wallet={wallet}
           />

           <DisconnectButton
             wallet={wallet}
             setUserAddress={setUserAddress}
             setUserBalance={setUserBalance}
           />

           <div>
             I am {userAddress} with {userBalance} mutez
           </div>
         </header>
       </div>
     );
   }

   export default App;
   ```

2. Let's create the 2 missing src component files:

   ```bash
   touch src/ConnectWallet.tsx
   touch src/DisconnectWallet.tsx
   ```

   ConnectWallet button creates an instance wallet, gets user permissions via a popup, and then retrieves the current account information.

3. Edit **ConnectWallet.tsx**

   ```typescript
   import { NetworkType } from '@airgap/beacon-sdk';
   import { BeaconWallet } from '@taquito/beacon-wallet';
   import { TezosToolkit } from '@taquito/taquito';
   import { Dispatch, SetStateAction } from 'react';
   type ButtonProps = {
     Tezos: TezosToolkit;
     setUserAddress: Dispatch<SetStateAction<string>>;
     setUserBalance: Dispatch<SetStateAction<number>>;
     wallet: BeaconWallet;
     setTezos: Dispatch<SetStateAction<TezosToolkit>>;
   };
   const ConnectButton = ({
     Tezos,
     setTezos,
     setUserAddress,
     setUserBalance,
     wallet,
   }: ButtonProps): JSX.Element => {
     const connectWallet = async (): Promise<void> => {
       try {
         await wallet.requestPermissions({
           network: {
             type: NetworkType.GHOSTNET,
             rpcUrl: 'https://ghostnet.ecadinfra.com',
           },
         });
         // gets user's address
         const userAddress = await wallet.getPKH();
         const balance = await Tezos.tz.getBalance(userAddress);
         setUserBalance(balance.toNumber());
         setUserAddress(userAddress);

         Tezos.setWalletProvider(wallet);
         setTezos(Tezos);
       } catch (error) {
         console.log(error);
       }
     };
     return (
       <div className="buttons">
         <button className="button" onClick={connectWallet}>
           <span>
             <i className="fas fa-wallet"></i>&nbsp; Connect with wallet
           </span>
         </button>
       </div>
     );
   };
   export default ConnectButton;
   ```

4. Edit **DisconnectWallet.tsx**

   The button cleans the wallet instance and all linked objects.

   ```typescript
   import { BeaconWallet } from '@taquito/beacon-wallet';
   import { Dispatch, SetStateAction } from 'react';

   interface ButtonProps {
     wallet: BeaconWallet;
     setUserAddress: Dispatch<SetStateAction<string>>;
     setUserBalance: Dispatch<SetStateAction<number>>;
   }

   const DisconnectButton = ({
     wallet,
     setUserAddress,
     setUserBalance,
   }: ButtonProps): JSX.Element => {
     const disconnectWallet = async (): Promise<void> => {
       setUserAddress('');
       setUserBalance(0);
       console.log('disconnecting wallet');
       await wallet.clearActiveAccount();
     };

     return (
       <div className="buttons">
         <button className="button" onClick={disconnectWallet}>
           <i className="fas fa-times"></i>&nbsp; Disconnect wallet
         </button>
       </div>
     );
   };

   export default DisconnectButton;
   ```

5. Save both files, the dev server should refresh the page.

   As Temple is configured, click on Connect button.

   On the popup, select your Temple wallet, then your account, and connect.

   ![The app after you have connected, showing your address and tex balance](/img/tutorials/dapp-logged.png)

   Your are *logged*.

6. Click on the Disconnect button to test the disconnection, and then reconnect.

### List other poke contracts via an indexer

Instead of querying heavily the RPC node to search where are located all other similar contracts and retrieve each address, use an indexer. an indexer is a kind of enriched cache API on top of an RPC node. In this example, the TZKT indexer is used to find other similar contracts.

1. You need to install jq to parse the Taqueria JSON configuration file.
   [Install jq](https://github.com/stedolan/jq)

2. On `package.json`, change the `dev` command on `scripts` configuration. Prefix it with a `jq` command to create an new environment variable pointing to your last smart contract address on testing env:

   ```bash
       "dev": "jq -r '\"VITE_CONTRACT_ADDRESS=\" + last(.tasks[]).output[0].address' ../.taq/testing-state.json > .env && vite",
   ```

   The last deployed contract address on Ghostnet is set now on our frontend.

3. Add a button to fetch all similar contracts like yours, then display the list.
   Edit **App.tsx** and before the `return` of App function, add this section for the fetch function.

   ```typescript
   const [contracts, setContracts] = useState<Array<api.Contract>>([]);

   const fetchContracts = () => {
     (async () => {
       setContracts(
         await api.contractsGetSimilar(import.meta.env.VITE_CONTRACT_ADDRESS, {
           includeStorage: true,
           sort: { desc: 'id' },
         })
       );
     })();
   };
   ```

4. On the returned **html template** section, after the display of the user balance div `I am {userAddress} with {userBalance} mutez`, append this:

   ```tsx
   <br />
   <div>
     <button onClick={fetchContracts}>Fetch contracts</button>
     {contracts.map((contract) =>
     <div>{contract.address}</div>
     )}
   </div>
   ```

5. Save your file and restart your server.
   Now, the start script generates the .env file containing the last deployed contract address.

   ```bash
   yarn dev
   ```

6. Go to your web browser and click on **Fetch contracts** button.

   ![](/img/tutorials/dapp-deployedcontracts.png)

   Congratulations, you are able to list all similar deployed contracts.

### Poke your contract

1. Import the Taqueria-generated types on **app/src/App.tsx**.

   ```typescript
   import { PokeGameWalletType } from './pokeGame.types';
   ```

2. Add this new function after the previous fetch function, it calls the entrypoint for poking.

   ```typescript
   const poke = async (contract: api.Contract) => {
     let c: PokeGameWalletType = await Tezos.wallet.at<PokeGameWalletType>(
       '' + contract.address
     );
     try {
       const op = await c.methodsObject.default().send();
       await op.confirmation();
       alert('Tx done');
     } catch (error: any) {
       console.table(`Error: ${JSON.stringify(error, null, 2)}`);
     }
   };
   ```

   > :warning: Normally, a call to `c.methods.poke()` function is expected by convention, but with an unique entrypoint, Michelson generates a unique `default` entrypoint name instead of having the name of the entrypoint function. Also, be careful because all entrypoints function names are in lowercase, and all parameter types are in uppercase.

3. Replace the line displaying the contract address `{contracts.map((contract) => <div>{contract.address}</div>)}` with the one below, it adds a Poke button.

   ```html
       {contracts.map((contract) => <div>{contract.address} <button onClick={() =>poke(contract)}>Poke</button></div>)}
   ```

4. Save and see the page refreshed, then click on the Poke button.

   ![](/img/tutorials/dapp-pokecontracts.png)

   It calls the contract and adds your public address tz1... to the set of traces.

5. Display poke guys

To verify that on the page, we can display the list of poke people directly on the page

Replace again the html previous line `{contracts ...}` with this one

```html
<table><thead><tr><th>address</th><th>people</th><th>action</th></tr></thead><tbody>
    {contracts.map((contract) => <tr><td style={{borderStyle: "dotted"}}>{contract.address}</td><td style={{borderStyle: "dotted"}}>{contract.storage.join(", ")}</td><td style={{borderStyle: "dotted"}}><button onClick={() =>poke(contract)}>Poke</button></td></tr>)}
    </tbody></table>
```

Contracts are displaying their people now

![](/img/tutorials/dapp-table.png)

> :information_source: Wait around few second for blockchain confirmation and click on `fetch contracts` to refresh the list

:confetti_ball: Congratulations, you have completed this first dapp training

## Summary

Now, you can create any smart contract using LIGO and create a complete Dapp via Taqueria/Taquito.

In the next section, you will learn how to call a Smart contract from a smart contract using callbacks and also write unit and mutation tests.

When you are ready, continue to [Part 2: Inter-contract calls and testing](/tutorials/dapp/part-2).


# Part 2: Inter-contract calls and testing

Previously, you learned how to create your first dApp.
In this second session, you will enhance your skills on:

* How to do inter-contract calls.
* How to use views.
* How to do unit & mutation tests.

On the first version of the Poke game, you were able to poke any deployed contract. Now, you will add a new function to store on the trace an additional feedback message coming from another contract.

## Poke and Get Feedback sequence diagram

```mermaid
sequenceDiagram
  Note left of User: Prepare to poke Smartcontract2 though Smartcontract1
  User->>Smartcontract1: pokeAndGetFeedback(Smartcontract2)
  Smartcontract1->>Smartcontract2 : getFeedback()
  Smartcontract2->>Smartcontract1 : pokeAndGetFeedbackCallback([Tezos.get_self_address(),store.feedback])
  Note left of Smartcontract1: store Smartcontract2 address + feedback from Smartcontract2
```

## Get the code

Get the code from the first session: https://github.com/marigold-dev/training-dapp-1/blob/main/solution

```bash
git clone https://github.com/marigold-dev/training-dapp-1.git
```

Reuse the code from the previous smart contract: https://github.com/marigold-dev/training-dapp-1/blob/main/solution/contracts/pokeGame.jsligo

Install all libraries locally:

```bash
cd solution && npm i && cd app && yarn install && cd ..
```

## Modify the poke function

Change the storage to reflect the changes:

* If you poke directly, you must register the contract's owner's address and no feedback.
* If you poke and ask to get feedback from another contract, then you register the other contract address and an additional feedback message.
  Here is the new sequence diagram of the poke function.

```mermaid
sequenceDiagram
  Note left of User: Prepare to poke Smartcontract1
  User->>Smartcontract1: poke()
  Note left of Smartcontract1: store User address + no feedback
```

1. Edit `./contracts/pokeGame.jsligo` and replace the storage definition with this one:

   ```jsligo
   export type pokeMessage = {
       receiver : address,
       feedback : string
   };

   export type storage = {
       pokeTraces : map<address, pokeMessage>,
       feedback : string
   };
   ```

2. Replace your poke function with these lines:

   ```jsligo
   @entry
   const poke = (_ : unit, store : storage) : return_ => {
       let feedbackMessage = {receiver : Tezos.get_self_address() ,feedback: ""};
       return [  list([]) as list<operation>, {...store,
           pokeTraces : Map.add(Tezos.get_source(), feedbackMessage, store.pokeTraces) }];
   };
   ```

   Explanation:

   * `...store` do a copy by value of your object. [Have a look on the Functional updates documentation](https://ligolang.org/docs/language-basics/maps-records/#functional-updates). Note: you cannot do an assignment like this `store.pokeTraces=...` in jsLIGO, there are no concepts of Classes, use `Functional updates` instead.
   * `Map.add(...`: Add a key, value entry to a map. For more information about [Map](https://ligolang.org/docs/language-basics/maps-records/#maps).
   * `export type storage = {...};` a `Record` type is declared, it is an [object structure](https://ligolang.org/docs/language-basics/maps-records#records).
   * `Tezos.get_self_address()` is a native function that returns the current contract address running this code. Have a look at [Tezos native functions](https://ligolang.org/docs/reference/current-reference).
   * `feedback: ""`: poking directly does not store feedback.

3. Edit `pokeGame.storageList.jsligo` to change the storage initialization.

   ```jsligo
   #import "pokeGame.jsligo" "Contract"

   const default_storage: Contract.storage = {
       pokeTraces: Map.empty as map<address, Contract.pokeMessage>,
       feedback: "kiss"
   };
   ```

4. Compile your contract.

   ```bash
   TAQ_LIGO_IMAGE=ligolang/ligo:1.6.0 taq compile pokeGame.jsligo
   ```

   Write a second function `pokeAndGetFeedback` involving the call to another contract a bit later, let's do unit testing first!

## Write unit tests

1. Add a new unit test smart-contract file `unit_pokeGame.jsligo`.

   ```bash
   taq create contract unit_pokeGame.jsligo
   ```

   > :information_source: Testing documentation can be found [here](https://ligolang.org/docs/next/testing/?lang=cameligo)

2. Edit the file.

   ```jsligo
   #import "./pokeGame.jsligo" "PokeGame"

   export type main_fn = module_contract<parameter_of PokeGame, PokeGame.storage>;

   // reset state

   const _ = Test.reset_state(2 as nat, list([]) as list<tez>);

   const faucet = Test.nth_bootstrap_account(0);

   const sender1: address = Test.nth_bootstrap_account(1);

   const _2 = Test.log("Sender 1 has balance : ");

   const _3 = Test.log(Test.get_balance_of_address(sender1));

   const _4 = Test.set_baker(faucet);

   const _5 = Test.set_source(faucet);

   export const initial_storage = {
     pokeTraces: Map.empty as map<address, PokeGame.pokeMessage>,
     feedback: "kiss"
   };

   export const initial_tez = 0mutez;

   //functions

   export const _testPoke = (
     taddr: typed_address<parameter_of PokeGame, PokeGame.storage>,
     s: address
   ): unit => {
     const contr = Test.to_contract(taddr);
     const contrAddress = Tezos.address(contr);
     Test.log("contract deployed with values : ");
     Test.log(contr);
     Test.set_source(s);
     const status = Test.transfer_to_contract(contr, Poke(), 0 as tez);
     Test.log(status);
     const store: PokeGame.storage = Test.get_storage(taddr);
     Test.log(store);
     //check poke is registered

     match(Map.find_opt(s, store.pokeTraces)) {
       when (Some(pokeMessage)):
         do {
           assert_with_error(
             pokeMessage.feedback == "",
             "feedback " + pokeMessage.feedback + " is not equal to expected "
             + "(empty)"
           );
           assert_with_error(
             pokeMessage.receiver == contrAddress,
             "receiver is not equal"
           );
         }
       when (None()):
         assert_with_error(false, "don't find traces")
     };
   };

   // TESTS //

   const testSender1Poke =
     (
       (): unit => {
         const orig =
           Test.originate(contract_of(PokeGame), initial_storage, initial_tez);
         _testPoke(orig.addr, sender1);
       }
     )();
   ```

   Explanations:

   * `#import "./pokeGame.jsligo" "PokeGame"` to import the source file as a module to call functions and use object definitions.
   * `export type main_fn` it will be useful later for the mutation tests to point to the main function to call/mutate.
   * `Test.reset_state ( 2...` this creates two implicit accounts on the test environment.
   * `Test.nth_bootstrap_account` This returns the nth account from the environment.
   * `Test.to_contract(taddr)` and `Tezos.address(contr)` are util functions to convert typed addresses, contract, and contract addresses.
   * `let _testPoke = (s : address) : unit => {...}` declaring function starting with `_` is escaping the test for execution. Use this to factorize tests changing only the parameters of the function for different scenarios.
   * `Test.set_source` do not forget to set this value for the transaction signer.
   * `Test.transfer_to_contract(CONTRACT, PARAMS, TEZ_COST)` A transaction to send, it returns an operation.
   * `Test.get_storage` This is how to retrieve the contract's storage.
   * `assert_with_error(CONDITION,MESSAGE)` Use assertion for unit testing.
   * `const testSender1Poke = ...` This test function will be part of the execution report.
   * `Test.originate_module(MODULE_CONVERTED_TO_CONTRACT,INIT_STORAGE, INIT_BALANCE)` It originates a smart contract into the Test environment. A module is converted to a smart contract.

3. Run the test

   ```bash
   TAQ_LIGO_IMAGE=ligolang/ligo:1.6.0 taq test unit_pokeGame.jsligo
   ```

   The output should give you intermediary logs and finally the test results.

   ```logs
   ┌──────────────────────┬────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
   │ Contract             │ Test Results                                                                                                                                   │
   ├──────────────────────┼────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
   │ unit_pokeGame.jsligo │ "Sender 1 has balance : "                                                                                                                      │
   │                      │ 3800000000000mutez                                                                                                                             │
   │                      │ "contract deployed with values : "                                                                                                             │
   │                      │ KT1KwMWUjU6jYyLCTWpZAtT634Vai7paUnRN(None)                                                                                                     │
   │                      │ Success (2130n)                                                                                                                                │
   │                      │ {feedback = "kiss" ; pokeTraces = [tz1TDZG4vFoA2xutZMYauUnS4HVucnAGQSpZ -> {feedback = "" ; receiver = KT1KwMWUjU6jYyLCTWpZAtT634Vai7paUnRN}]} │
   │                      │ Everything at the top-level was executed.                                                                                                      │
   │                      │ - testSender1Poke exited with value ().                                                                                                        │
   │                      │                                                                                                                                                │
   │                      │ 🎉 All tests passed 🎉                                                                                                                         │
   └──────────────────────┴────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
   ```

## Do an inter-contract call

To keep things simple, 2 versions of the same smart contract are deployed to simulate inter-contract calls and get the feedback message (cf. [sequence diagram](#poke-and-get-feedback-sequence-diagram)).

Create a new poke function `PokeAndGetFeedback: (other : address)` with a second part function `PokeAndGetFeedbackCallback: (feedback : returned_feedback)` as a callback. Calling a contract is asynchronous, this is the reason it is done two times.

The function to call on the second contract is `GetFeedback: (contract_callback: oracle_param)` and returns a feedback message.

> Very often, this kind of contract is named an `Oracle`, because generally its storage is updated by an offchain scheduler and it exposes data to any onchain smart contracts.

1. Edit the file `pokeGame.jsligo`, to define new types:

   ```jsligo
   type returned_feedback = [address, string]; //address that gives feedback and a string message

   type oracle_param = contract<returned_feedback>;
   ```

   Explanations :

   * `type returned_feedback = [address, string]` the parameters of an oracle function always start with the address of the contract caller and followed by the return objects.
   * `type oracle_param = contract<returned_feedback>` the oracle parameters need to be wrapped inside a typed contract.

2. Write the missing functions, starting with `getFeedback`. Add this new function at the end of the file.

   ```jsligo
   @entry
   const getFeedback = (contract_callback : contract<returned_feedback>, store : storage): return_ => {
       let op : operation = Tezos.transaction(
               [Tezos.get_self_address(),store.feedback],
               (0 as mutez),
               contract_callback);
       return [list([op]) ,store];
   };
   ```

   * `Tezos.transaction(RETURNED_PARAMS,TEZ_COST,CALLBACK_CONTRACT)` the oracle function requires to return the value back to the contract caller that is passed already as first parameter.
   * `return [list([op]) ,store]` this time, you return a list of operations to execute, there is no need to update the contract storage (but it is a mandatory return object).

3. Add now, the first part of the function `pokeAndGetFeedback`.

   ```jsligo
   @entry
   const pokeAndGetFeedback = (oracleAddress: address, store: storage): return_ => {
     //Prepares call to oracle

     let call_to_oracle = (): contract<oracle_param> => {
       return match(
         Tezos.get_entrypoint_opt("%getFeedback", oracleAddress) as
           option<contract<oracle_param>>
       ) {
         when (None()):
           failwith("NO_ORACLE_FOUND")
         when (Some(contract)):
           contract
       };
     };
     // Builds transaction

     let op: operation =
       Tezos.transaction(
         (
           (
             Tezos.self("%pokeAndGetFeedbackCallback") as
               contract<returned_feedback>
           )
         ),
         (0 as mutez),
         call_to_oracle()
       );
     return [list([op]), store];
   };
   ```

   * `Tezos.get_entrypoint_opt("%getFeedback",oracleAddress)` you require to get the oracle contract address. Then you want to call a specific entrypoint of this contract. The function name is always starting with `%` with always the first letter in lowercase (even if the code is different).
   * `Tezos.transaction(((Tezos.self("%pokeAndGetFeedbackCallback") as contract<returned_feedback>)),TEZ_COST,call_to_oracle())` The transaction takes as first param the entrypoint of for the callback that the oracle uses to answer the feedback, the tez cost and the oracle contract you got just above as transaction destination.

4. Write the last missing function `pokeAndGetFeedbackCallback`, receive the feedback and finally store it.

   ```jsligo
   @entry
   const pokeAndGetFeedbackCallback = (feedback : returned_feedback, store : storage) : return_ => {
       let feedbackMessage = {receiver : feedback[0] ,feedback: feedback[1]};
       return [  list([]) as list<operation>, {...store,
           pokeTraces : Map.add(Tezos.get_source(), feedbackMessage , store.pokeTraces) }];
   };
   ```

   * `let feedbackMessage = {receiver : feedback[0] ,feedback: feedback[1]}` prepares the trace including the feedback message and the feedback contract creator.
   * `{...store,pokeTraces : Map.add(Tezos.get_source(), feedbackMessage , store.pokeTraces) }` add the new trace to the global trace map.

5. Compile the contract.

   ```bash
   TAQ_LIGO_IMAGE=ligolang/ligo:1.6.0 taq compile pokeGame.jsligo
   ```

6. (Optional) Write a unit test for this new function `pokeAndGetFeedback`.

## Use views instead of inter-contract call

As you saw in the previous step, inter-contract calls make the business logic more complex but not only that, [thinking about the cost is even worse](https://ligolang.org/docs/tutorials/inter-contract-calls/?lang=jsligo#a-note-on-complexity).

In this training, the oracle is providing a read-only storage that can be replaced by a `view` instead of a complex and costly callback.

[See the documentation here about onchain views](https://ligolang.org/docs/protocol/hangzhou#on-chain-views).

```mermaid
sequenceDiagram
  Note left of User: Prepare to poke on Smartcontract1 and get feedback from Smartcontract2
  User->>Smartcontract1: pokeAndGetFeedback(Smartcontract2)
  Smartcontract1-->>Smartcontract2 : feedback()
  Smartcontract2-->>Smartcontract1 : [Smartcontract2,feedback]
  Note left of Smartcontract1:  store Smartcontract2 address + feedback from Smartcontract2
```

:warning: **Comment below functions (with `/* */` syntax or // syntax) or just remove it, it is no more useful** :warning:

* `pokeAndGetFeedbackCallback`
* `getFeedback`

1. Edit function `pokeAndGetFeedback` to call view instead of a transaction.

   ```jsligo
   @entry
   const pokeAndGetFeedback = (oracleAddress: address, store: storage): return_ => {
     //Read the feedback view

     let feedbackOpt: option<string> =
       Tezos.call_view("feedback", unit, oracleAddress);
     match(feedbackOpt) {
       when (Some(feedback)):
         do {
           let feedbackMessage = { receiver: oracleAddress, feedback: feedback };
           return [
             list([]) as list<operation>,
             {
               ...store,
               pokeTraces: Map.add(
                 Tezos.get_source(),
                 feedbackMessage,
                 store.pokeTraces
               )
             }
           ];
         }
       when (None()):
         failwith("Cannot find view feedback on given oracle address")
     };
   };
   ```

2. Declare the view at the end of the file. Do not forget the annotation `@view` !

   ```jsligo
   @view
   export const feedback = (_: unit, store: storage): string => { return store.feedback };
   ```

3. Compile the contract.

   ```bash
   TAQ_LIGO_IMAGE=ligolang/ligo:1.6.0 taq compile pokeGame.jsligo
   ```

4. (Optional) Write a unit test for the updated function `pokeAndGetFeedback`.

## Write mutation tests

LIGO provides mutation testing through the Test library. Mutation tests are like `testing your tests` to see if your unit test coverage is strong enough. Bugs, or mutants, are automatically inserted into your code. Your tests are run on each mutant.

If your tests fail then the mutant is killed. If your tests passed, the mutant survived.
The higher the percentage of mutants killed, the more effective your tests are.

[Example of mutation features for other languages](https://stryker-mutator.io/docs/mutation-testing-elements/supported-mutators)

1. Create a file `mutation_pokeGame.jsligo`.

   ```bash
   taq create contract mutation_pokeGame.jsligo
   ```

2. Edit the file.

   ```jsligo
   #import "./pokeGame.jsligo" "PokeGame"

   #import "./unit_pokeGame.jsligo" "PokeGameTest"

   // reset state

   const _ = Test.reset_state(2 as nat, list([]) as list<tez>);

   const faucet = Test.nth_bootstrap_account(0);

   const sender1: address = Test.nth_bootstrap_account(1);

   const _1 = Test.log("Sender 1 has balance : ");

   const _2 = Test.log(Test.get_balance_of_address(sender1));

   const _3 = Test.set_baker(faucet);

   const _4 = Test.set_source(faucet);

   const _tests = (
     ta: typed_address<parameter_of PokeGame, PokeGame.storage>,
     _: michelson_contract<parameter_of PokeGame, PokeGame.storage>,
     _2: int
   ): unit => { return PokeGameTest._testPoke(ta, sender1); };

   const test_mutation =
     (
       (): unit => {
         const mutationErrorList =
           Test.originate_and_mutate_all(
             contract_of(PokeGame),
             PokeGameTest.initial_storage,
             PokeGameTest.initial_tez,
             _tests
           );
         match(mutationErrorList) {
           when ([]):
             unit
           when ([head, ..._tail]):
             do {
               Test.log(head);
               Test.assert_with_error(false, Test.to_string(head[1]))
             }
         };
       }
     )();
   ```

   Explanation:

   * `#import <SRC_FILE> <NAMESPACE>`: import your source code that will be mutated and your unit tests. For more information [module doc](https://ligolang.org/docs/language-basics/modules).
   * `const _tests = (ta: typed_address<parameter_of PokeGame, PokeGame.storage>, _: michelson_contract, _: int) : unit => {...`: you need to provide the test suite that will be run by the framework. Just point to the unit test you want to run.
   * `const test_mutation = (() : unit => {`: this is the definition of the mutations tests.
   * `Test.originate_module_and_mutate_all(CONTRACT_TO_MUTATE, INIT_STORAGE, INIT_TEZ_COST, UNIT_TEST_TO_RUN)`: This will take the first argument as the source code to mutate and the last argument as unit test suite function to run over. It returns a list of mutations that succeed (if size > 0 then bad test coverage) or an empty list (good, even mutants did not harm your code).

3. Run the test.

   ```bash
   TAQ_LIGO_IMAGE=ligolang/ligo:1.6.0 taq test mutation_pokeGame.jsligo
   ```

   Output:

   ```logs
   === Error messages for mutation_pokeGame.jsligo ===
   File "contracts/mutation_pokeGame.jsligo", line 43, characters 12-66:
   42 |             Test.log(head);
   43 |             Test.assert_with_error(false, Test.to_string(head[1]))
   44 |           }

   Test failed with "Mutation at: File "contracts/pokeGame.jsligo", line 52, characters 15-66:
   51 |     when (None()):
   52 |       failwith("Cannot find view feedback on given oracle address")
   53 |   };

   Replacing by: "Cannot find view feedback on given oracle addressCannot find view feedback on given oracle address".
   "
   Trace:
   File "contracts/mutation_pokeGame.jsligo", line 43, characters 12-66 ,
   File "contracts/mutation_pokeGame.jsligo", line 43, characters 12-66 ,
   File "contracts/mutation_pokeGame.jsligo", line 28, character 2 to line 47, character 5


   ===
   ┌──────────────────────────┬──────────────────────┐
   │ Contract                 │ Test Results         │
   ├──────────────────────────┼──────────────────────┤
   │ mutation_pokeGame.jsligo │ Some tests failed :( │
   └──────────────────────────┴──────────────────────┘
   ```

   Invaders are here.

   What happened?

   The mutation has altered a part of the code that is not tested, it was not covered, so the unit test passed.

   For a short fix, tell the Library to ignore this function for mutants.

4. Go to your source file pokeGame.jsligo, and annotate the function `pokeAndGetFeedback` with `@no_mutation`.

   ```jsligo
   @no_mutation
   @entry
   const pokeAndGetFeedback ...
   ```

5. Run again the mutation tests.

   ```bash
   TAQ_LIGO_IMAGE=ligolang/ligo:1.6.0 taq test mutation_pokeGame.jsligo
   ```

   Output

   ```logs
   ┌──────────────────────────┬────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
   │ Contract                 │ Test Results                                                                                                                                   │
   ├──────────────────────────┼────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
   │ mutation_pokeGame.jsligo │ "Sender 1 has balance : "                                                                                                                      │
   │                          │ 3800000000000mutez                                                                                                                             │
   │                          │ "contract deployed with values : "                                                                                                             │
   │                          │ KT1L8mCbuTJXKq3CDoHDxqfH5aj5sEgAdx9C(None)                                                                                                     │
   │                          │ Success (1330n)                                                                                                                                │
   │                          │ {feedback = "kiss" ; pokeTraces = [tz1hkMbkLPkvhxyqsQoBoLPqb1mruSzZx3zy -> {feedback = "" ; receiver = KT1L8mCbuTJXKq3CDoHDxqfH5aj5sEgAdx9C}]} │
   │                          │ "Sender 1 has balance : "                                                                                                                      │
   │                          │ 3800000000000mutez                                                                                                                             │
   │                          │ Everything at the top-level was executed.                                                                                                      │
   │                          │ - test_mutation exited with value ().                                                                                                          │
   │                          │                                                                                                                                                │
   │                          │ 🎉 All tests passed 🎉                                                                                                                         │
   └──────────────────────────┴────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
   ```

## Update the frontend

1. Reuse the dApp files from [the previous session](https://github.com/marigold-dev/training-dapp-1/tree/main/solution/app).

2. Redeploy a new version of the smart contract.

   > Note: You can set `feedback` value to any action other than default `kiss` string (it is more fun for other to discover it).

   ```bash
   TAQ_LIGO_IMAGE=ligolang/ligo:1.6.0 taq compile pokeGame.jsligo
   taq generate types ./app/src
   taq deploy pokeGame.tz -e "testing"
   ```

3. Adapt the frontend application code. Edit `App.tsx`, and add new import.

   ```typescript
   import { address } from './type-aliases';
   ```

4. Add a new React variable after `userBalance` definition.

   ```typescript
   const [contractToPoke, setContractToPoke] = useState<string>('');
   ```

5. Change the poke function to set entrypoint to `pokeAndGetFeedback`.

   ```typescript
   //poke
   const poke = async (
     e: React.FormEvent<HTMLFormElement>,
     contract: api.Contract
   ) => {
     e.preventDefault();
     let c: PokeGameWalletType = await Tezos.wallet.at('' + contract.address);
     try {
       const op = await c.methodsObject
         .pokeAndGetFeedback(contractToPoke as address)
         .send();
       await op.confirmation();
       alert('Tx done');
     } catch (error: any) {
       console.log(error);
       console.table(`Error: ${JSON.stringify(error, null, 2)}`);
     }
   };
   ```

6. Change the display to a table changing `contracts.map...` by:

   ```html
   <table><thead><tr><th>address</th><th>trace "contract - feedback - user"</th><th>action</th></tr></thead><tbody>
       {contracts.map((contract) => <tr><td style={{borderStyle: "dotted"}}>{contract.address}</td><td style={{borderStyle: "dotted"}}>{(contract.storage !== null && contract.storage.pokeTraces !== null && Object.entries(contract.storage.pokeTraces).length > 0)?Object.keys(contract.storage.pokeTraces).map((k : string)=>contract.storage.pokeTraces[k].receiver+" "+contract.storage.pokeTraces[k].feedback+" "+k+", "):""}</td><td style={{borderStyle: "dotted"}}><form onSubmit={(e) =>poke(e,contract)}><input type="text" onChange={e=>setContractToPoke(e.currentTarget.value)} placeholder='enter contract address here' /><button  type='submit'>Poke</button></form></td></tr>)}
       </tbody></table>
   ```

7. Relaunch the app.

   ```bash
   cd app
   yarn install
   yarn dev
   ```

   On the listed contract, choose your line and input the address of the contract you will receive feedback. Click on `poke`.

   ![The dApp page showing the result of the poke action](/img/tutorials/dapp-result.png).

   This time, the logged user will receive feedback from a targeted contract (as input of the form) via any listed contract (the first column of the table).
   Refresh manually by clicking on `Fetch` contracts\` button.

   Poke other developers' contracts to discover their contract hidden feedback when you poke them.

## Summary

Now, you can call other contracts, use views, and test your smart contract before deploying it.
In the next training, you will learn how to use tickets.

When you are ready, continue to [Part 3: Tickets](/tutorials/dapp/part-3).


# Part 3: Tickets

Previously, you learned how to do inter-contract calls, use views, and do unit testing.
In this third session, you will enhance your skills on:

* Using tickets.
* Don't mess up with `DUP` errors while manipulating tickets.

On the second version of the poke game, you were able to poke any contract without constraint. A right to poke via tickets is now mandatory. Tickets are a kind of object that cannot be copied and can hold some trustable information.

## new Poke sequence diagram

```mermaid
sequenceDiagram
  Admin->>Smartcontract : Init(User,1)
  Note right of Smartcontract : Mint 1 ticket for User
  Note left of User : Prepare to poke
  User->>Smartcontract : Poke
  Note right of Smartcontract : Check available tickets for User
  Note right of Smartcontract : Store trace and burn 1 ticket
  Smartcontract-->>User : success
  User->>Smartcontract : Poke
  Note right of Smartcontract : Check available tickets for User
  Smartcontract-->>User : error
```

## Prerequisites

Prerequisites are the same as the first session: https://github.com/marigold-dev/training-dapp-1#memo-prerequisites.

Get the code from the session 2 solution [here](https://github.com/marigold-dev/training-dapp-2/tree/main/solution).

## Tickets

Tickets came with a Tezos **Edo** upgrade, they are great and often misunderstood.

Ticket structure:

* Ticketer: (address) the creator contract address.
* Value: (any) Can be any type from string to bytes. It holds whatever arbitrary values.
* Amount: (nat) quantity of tickets minted.

Tickets features:

* Not comparable: it makes no sense to compare tickets because tickets of the same type are all equal and can be merged into a single ticket. When ticket types are different then it is no more comparable.
* Transferable: you can send a ticket into a Transaction parameter.
* Storable: only on smart contract storage for the moment (Note: a new protocol release will enable it for use accounts soon).
* Non-dupable: you cannot copy or duplicate a ticket, it is a unique singleton object living in a specific blockchain instance.
* Splittable: if the amount is > 2 then you can split the ticket object into 2 objects.
* Mergeable: you can merge tickets from the same ticketer and the same type.
* Mintable/burnable: anyone can create and destroy tickets.

Example of usage:

* Authentication and Authorization token: giving a ticket to a user provides you with Authentication. Adding some claims/rules on the ticket provides you with some rights.
* Simplified FA1.2/FA2 token: representing crypto token with tickets (mint/burn/split/join), but it does not have all the same properties and does not respect the TZIP standard.
* Voting rights: giving 1 ticket that counts for 1 vote on each member.
* Wrapped crypto: holding XTZ collateral against a ticket, and redeeming it later.
* Many others ...

## Minting

Minting is the action of creating a ticket from the void. In general, minting operations are done by administrators of smart contracts or either by an end user.

1. Edit the `./contracts/pokeGame.jsligo` file and add a map of ticket ownership to the default `storage` type.
   This map keeps a list of consumable tickets for each authorized user. It is used as a burnable right to poke.

   ```jsligo
   export type storage = {
     pokeTraces: map<address, pokeMessage>,
     feedback: string,
     ticketOwnership: map<address, ticket<string>> //ticket of claims
   };
   ```

   To fill this map, add a new administration endpoint. A new entrypoint `Init` is adding x tickets to a specific user.

   > Note: to simplify, there is no security around this entrypoint, but in Production it should.

   Tickets are very special objects that cannot be **DUPLICATED**. During compilation to Michelson, using a variable twice, copying a structure holding tickets generates `DUP` command. To avoid our contract failing at runtime, LIGO parses statically our code during compilation time to detect any DUP on tickets.

   To solve most of the issues, segregate ticket objects from the rest of the storage, or structures containing ticket objects to avoid compilation errors. To do this, just destructure any object until you get tickets isolated.

   For each function having a storage as parameter, `store` object needs to be destructured to isolate `ticketOwnership` object holding our tickets. Then, don't use anymore the `store` object or it creates a **DUP** error.

2. Add the new `Init` function.

   ```jsligo
   @entry
   const init = ([a, ticketCount]: [address, nat], store: storage): return_ => {
     const { pokeTraces, feedback, ticketOwnership } = store;
     if (ticketCount == (0 as nat)) {
       return [
         list([]) as list<operation>,
         { pokeTraces, feedback, ticketOwnership }
       ]
     } else {
       const t: ticket<string> =
         Option.unopt(Tezos.create_ticket("can_poke", ticketCount));
       return [
         list([]) as list<operation>,
         { pokeTraces, feedback, ticketOwnership: Map.add(a, t, ticketOwnership) }
       ]
     }
   };
   ```

   The Init function looks at how many tickets to create from the current caller, and then it is added to the current map.

3. Modify the poke function.

   ```jsligo
   @entry
   const poke = (_: unit, store: storage): return_ => {
     const { pokeTraces, feedback, ticketOwnership } = store;
     const [t, tom]: [option<ticket<string>>, map<address, ticket<string>>] =
       Map.get_and_update(
         Tezos.get_source(),
         None() as option<ticket<string>>,
         ticketOwnership
       );
     return match(t) {
       when (None):
         failwith("User does not have tickets => not allowed")
       when (Some(_t)):
         [
           list([]) as list<operation>,
           {
             feedback,
             pokeTraces: Map.add(
               Tezos.get_source(),
               { receiver: Tezos.get_self_address(), feedback: "" },
               pokeTraces
             ),
             ticketOwnership: tom
           }
         ]
     }
   };
   ```

   First, extract an existing optional ticket from the map. If an operation is done directly on the map, even trying to find or get this object in the structure, a DUP Michelson instruction is generated. Use the secure `get_and_update` function from the Map library to extract the item from the map and avoid any copy.

   > Note: more information about this function [here](https://ligolang.org/docs/reference/map-reference).

   In a second step, look at the optional ticket, if it exists, then burn it (destroy it) and add a trace of execution, otherwise fail with an error message.

4. Same for `pokeAndGetFeedback` function, do the same checks and type modifications as below.

   ```jsligo
   @no_mutation
   @entry
   const pokeAndGetFeedback = (oracleAddress: address, store: storage): return_ => {
     const { pokeTraces, feedback, ticketOwnership } = store;
     ignore(feedback);
     const [t, tom]: [option<ticket<string>>, map<address, ticket<string>>] =
       Map.get_and_update(
         Tezos.get_source(),
         None() as option<ticket<string>>,
         ticketOwnership
       );
     let feedbackOpt: option<string> =
       Tezos.call_view("feedback", unit, oracleAddress);
     return match(t) {
       when (None):
         failwith("User does not have tickets => not allowed")
       when (Some(_t)):
         match(feedbackOpt) {
           when (Some(feedback)):
             do {
               let feedbackMessage = {
                 receiver: oracleAddress,
                 feedback: feedback
               };
               return [
                 list([]) as list<operation>,
                 {
                   feedback,
                   pokeTraces: Map.add(
                     Tezos.get_source(),
                     feedbackMessage,
                     pokeTraces
                   ),
                   ticketOwnership: tom
                 }
               ]
             }
           when (None):
             failwith("Cannot find view feedback on given oracle address")
         }
     }
   };
   ```

5. Update the storage initialization on `pokeGame.storageList.jsligo`.

   ```jsligo
   #import "pokeGame.jsligo" "Contract"

   const default_storage = {
       pokeTraces: Map.empty as map<address, Contract.pokeMessage>,
       feedback: "kiss",
       ticketOwnership: Map.empty as
           map<
               address,
               ticket<string>
           > //ticket of claims

   };
   ```

6. Compile the contract to check for any errors.

   > Note: don't forget to check that Docker is running for taqueria.

   ```bash
   npm i

   TAQ_LIGO_IMAGE=ligolang/ligo:1.6.0 taq compile pokeGame.jsligo
   ```

   Check on logs that everything is fine.

   Try to display a DUP error now.

7. Add this line on `poke function` just after the first line of storage destructuration `const { pokeTraces, feedback, ticketOwnership } = store;`.

   ```jsligo
   const t2 = Map.find_opt(Tezos.get_source(), ticketOwnership);
   ```

8. Compile again.

   ```bash
   TAQ_LIGO_IMAGE=ligolang/ligo:1.6.0 taq compile pokeGame.jsligo
   ```

   This time you should see the `DUP` warning generated by the **find** function.

   ```logs
   Warning: variable "ticketOwnership" cannot be used more than once.
   ```

9. Remove it.

## Test your code

Update the unit test files to see if you can still poke.

1. Edit the `./contracts/unit_pokeGame.jsligo` file.

   ```jsligo
   #import "./pokeGame.jsligo" "PokeGame"

   export type main_fn = module_contract<parameter_of PokeGame, PokeGame.storage>;

   const _ = Test.reset_state(2 as nat, list([]) as list<tez>);

   const faucet = Test.nth_bootstrap_account(0);

   const sender1: address = Test.nth_bootstrap_account(1);

   const _1 = Test.log("Sender 1 has balance : ");

   const _2 = Test.log(Test.get_balance_of_address(sender1));

   const _3 = Test.set_baker(faucet);

   const _4 = Test.set_source(faucet);

   const initial_storage = {
     pokeTraces: Map.empty as map<address, PokeGame.pokeMessage>,
     feedback: "kiss",
     ticketOwnership: Map.empty as map<address, ticket<string>>
   };

   const initial_tez = 0 as tez;

   export const _testPoke = (
     taddr: typed_address<parameter_of PokeGame, PokeGame.storage>,
     s: address,
     ticketCount: nat,
     expectedResult: bool
   ): unit => {
     const contr = Test.to_contract(taddr);
     const contrAddress = Tezos.address(contr);
     Test.log("contract deployed with values : ");
     Test.log(contr);
     Test.set_source(s);
     const statusInit =
       Test.transfer_to_contract(contr, Init([sender1, ticketCount]), 0 as tez);
     Test.log(statusInit);
     Test.log("*** Check initial ticket is here ***");
     Test.log(Test.get_storage(taddr));
     const status: test_exec_result =
       Test.transfer_to_contract(contr, Poke(), 0 as tez);
     Test.log(status);
     const store: PokeGame.storage = Test.get_storage(taddr);
     Test.log(store);
     return match(status) {
       when (Fail(tee)):
         match(tee) {
           when (Other(msg)):
             assert_with_error(expectedResult == false, msg)
           when (Balance_too_low(_record)):
             assert_with_error(expectedResult == false, "ERROR Balance_too_low")
           when (Rejected(s)):
             assert_with_error(expectedResult == false, Test.to_string(s[0]))
         }
       when (Success(_n)):
         match(
           Map.find_opt(
             s,
             (Test.get_storage(taddr) as PokeGame.storage).pokeTraces
           )
         ) {
           when (Some(pokeMessage)):
             do {
               assert_with_error(
                 pokeMessage.feedback == "",
                 "feedback " + pokeMessage.feedback + " is not equal to expected "
                 + "(empty)"
               );
               assert_with_error(
                 pokeMessage.receiver == contrAddress,
                 "receiver is not equal"
               )
             }
           when (None()):
             assert_with_error(expectedResult == false, "don't find traces")
         }
     }
   };

   const _5 = Test.log("*** Run test to pass ***");

   const testSender1Poke =
     (
       (): unit => {
         const orig =
           Test.originate(contract_of(PokeGame), initial_storage, initial_tez);
         _testPoke(orig.addr, sender1, 1 as nat, true)
       }
     )();

   const _6 = Test.log("*** Run test to fail ***");

   const testSender1PokeWithNoTicketsToFail =
     (
       (): unit => {
         const orig =
           Test.originate(contract_of(PokeGame), initial_storage, initial_tez);
         _testPoke(orig.addr, sender1, 0 as nat, false)
       }
     )();
   ```

   * On `Init([sender1, ticketCount])`, initialize the smart contract with some tickets.
   * On `Fail`, check if you have an error on the test (i.e. the user should be allowed to poke).
   * On `testSender1Poke`, test with the first user using a preexisting ticket.
   * On `testSender1PokeWithNoTicketsToFail`, test with the same user again but with no ticket, and an error should be caught.

2. Run the test, and look at the logs to track execution.

   ```bash
   TAQ_LIGO_IMAGE=ligolang/ligo:1.6.0 taq test unit_pokeGame.jsligo
   ```

   The first test should be fine.

   ```logs
   ┌──────────────────────┬───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
   │ Contract             │ Test Results                                                                                                                                                          │
   ├──────────────────────┼───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
   │ unit_pokeGame.jsligo │ "Sender 1 has balance : "                                                                                                                                             │
   │                      │ 3800000000000mutez                                                                                                                                                    │
   │                      │ "*** Run test to pass ***"                                                                                                                                            │
   │                      │ "contract deployed with values : "                                                                                                                                    │
   │                      │ KT1HeEVF74BLi3fYCpr1tpkDGmruFBNjMATo(None)                                                                                                                            │
   │                      │ Success (1858n)                                                                                                                                                       │
   │                      │ "*** Check initial ticket is here ***"                                                                                                                                │
   │                      │ {feedback = "kiss" ; pokeTraces = [] ; ticketOwnership = [tz1hkMbkLPkvhxyqsQoBoLPqb1mruSzZx3zy -> (KT1HeEVF74BLi3fYCpr1tpkDGmruFBNjMATo , ("can_poke" , 1n))]}        │
   │                      │ Success (1024n)                                                                                                                                                       │
   │                      │ {feedback = "kiss" ; pokeTraces = [tz1hkMbkLPkvhxyqsQoBoLPqb1mruSzZx3zy -> {feedback = "" ; receiver = KT1HeEVF74BLi3fYCpr1tpkDGmruFBNjMATo}] ; ticketOwnership = []} │
   │                      │ "*** Run test to fail ***"                                                                                                                                            │
   │                      │ "contract deployed with values : "                                                                                                                                    │
   │                      │ KT1HDbqhYiKs8e3LkNAcT9T2MQgvUdxPtbV5(None)                                                                                                                            │
   │                      │ Success (1399n)                                                                                                                                                       │
   │                      │ "*** Check initial ticket is here ***"                                                                                                                                │
   │                      │ {feedback = "kiss" ; pokeTraces = [] ; ticketOwnership = []}                                                                                                          │
   │                      │ Fail (Rejected (("User does not have tickets => not allowed" , KT1HDbqhYiKs8e3LkNAcT9T2MQgvUdxPtbV5)))                                                                │
   │                      │ {feedback = "kiss" ; pokeTraces = [] ; ticketOwnership = []}                                                                                                          │
   │                      │ Everything at the top-level was executed.                                                                                                                             │
   │                      │ - testSender1Poke exited with value ().                                                                                                                               │
   │                      │ - testSender1PokeWithNoTicketsToFail exited with value ().                                                                                                            │
   │                      │                                                                                                                                                                       │
   │                      │ 🎉 All tests passed 🎉                                                                                                                                                │
   └──────────────────────┴───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
   ```

3. Redeploy the smart contract.

   Let's play with the CLI to compile and deploy.

   ```bash
   TAQ_LIGO_IMAGE=ligolang/ligo:1.6.0 taq compile pokeGame.jsligo
   taq generate types ./app/src
   taq deploy pokeGame.tz -e testing
   ```

   ```logs
   ┌─────────────┬──────────────────────────────────────┬──────────┬──────────────────┬────────────────────────────────┐
   │ Contract    │ Address                              │ Alias    │ Balance In Mutez │ Destination                    │
   ├─────────────┼──────────────────────────────────────┼──────────┼──────────────────┼────────────────────────────────┤
   │ pokeGame.tz │ KT1TC1DabCTmdMXuuCxwUmyb51bn2mbeNvbW │ pokeGame │ 0                │ https://ghostnet.ecadinfra.com │
   └─────────────┴──────────────────────────────────────┴──────────┴──────────────────┴────────────────────────────────┘
   ```

## Adapt the frontend code

1. Rerun the app and check that you can not use the app anymore without tickets.

   ```bash
   cd app
   yarn dev
   ```

2. Connect with any wallet with enough tez, and Poke your contract.

   ![pokefail](/img/tutorials/dapp-pokefail.png)

   The Kukai wallet is giving me back the error from the smart contract.

   ![kukaifail](/img/tutorials/dapp-kukaifail.png)

   Ok, so let's authorize some minting on my user and try again to poke.

3. Add a new button for minting on a specific contract, and replace the full content of `App.tsx` with:

   ```typescript
   import { NetworkType } from '@airgap/beacon-types';
   import { BeaconWallet } from '@taquito/beacon-wallet';
   import { TezosToolkit } from '@taquito/taquito';
   import * as api from '@tzkt/sdk-api';
   import { BigNumber } from 'bignumber.js';
   import { useEffect, useState } from 'react';
   import './App.css';
   import ConnectButton from './ConnectWallet';
   import DisconnectButton from './DisconnectWallet';
   import { PokeGameWalletType, Storage } from './pokeGame.types';
   import { address, nat } from './type-aliases';

   function App() {
     api.defaults.baseUrl = 'https://api.ghostnet.tzkt.io';

     const [Tezos, setTezos] = useState<TezosToolkit>(
       new TezosToolkit('https://ghostnet.ecadinfra.com')
     );
     const [wallet, setWallet] = useState<BeaconWallet>(
       new BeaconWallet({
         name: 'Training',
         preferredNetwork: NetworkType.GHOSTNET,
       })
     );

     const [contracts, setContracts] = useState<Array<api.Contract>>([]);
     const [contractStorages, setContractStorages] = useState<
       Map<string, Storage>
     >(new Map());

     const fetchContracts = () => {
       (async () => {
         const tzktcontracts: Array<api.Contract> =
           await api.contractsGetSimilar(
             import.meta.env.VITE_CONTRACT_ADDRESS,
             {
               includeStorage: true,
               sort: { desc: 'id' },
             }
           );
         setContracts(tzktcontracts);
         const taquitoContracts: Array<PokeGameWalletType> = await Promise.all(
           tzktcontracts.map(
             async (tzktcontract) =>
               (await Tezos.wallet.at(
                 tzktcontract.address!
               )) as PokeGameWalletType
           )
         );
         const map = new Map<string, Storage>();
         for (const c of taquitoContracts) {
           const s: Storage = await c.storage();
           map.set(c.address, s);
         }
         setContractStorages(map);
       })();
     };

     useEffect(() => {
       (async () => {
         const activeAccount = await wallet.client.getActiveAccount();
         if (activeAccount) {
           setUserAddress(activeAccount.address);
           const balance = await Tezos.tz.getBalance(activeAccount.address);
           setUserBalance(balance.toNumber());
         }
       })();
     }, []);

     const [userAddress, setUserAddress] = useState<string>('');
     const [userBalance, setUserBalance] = useState<number>(0);
     const [contractToPoke, setContractToPoke] = useState<string>('');

     //poke
     const poke = async (
       e: React.MouseEvent<HTMLButtonElement, MouseEvent>,
       contract: api.Contract
     ) => {
       e.preventDefault();
       let c: PokeGameWalletType = await Tezos.wallet.at('' + contract.address);
       try {
         const op = await c.methodsObject
           .pokeAndGetFeedback(contractToPoke as address)
           .send();
         await op.confirmation();
         alert('Tx done');
       } catch (error: any) {
         console.log(error);
         console.table(`Error: ${JSON.stringify(error, null, 2)}`);
       }
     };

     //mint
     const mint = async (
       e: React.MouseEvent<HTMLButtonElement>,
       contract: api.Contract
     ) => {
       e.preventDefault();
       let c: PokeGameWalletType = await Tezos.wallet.at('' + contract.address);
       try {
         console.log('contractToPoke', contractToPoke);
         const op = await c.methods
           .init(userAddress as address, new BigNumber(1) as nat)
           .send();
         await op.confirmation();
         alert('Tx done');
       } catch (error: any) {
         console.log(error);
         console.table(`Error: ${JSON.stringify(error, null, 2)}`);
       }
     };

     return (
       <div className="App">
         <header className="App-header">
           <ConnectButton
             Tezos={Tezos}
             setTezos={setTezos}
             setUserAddress={setUserAddress}
             setUserBalance={setUserBalance}
             wallet={wallet}
           />

           <DisconnectButton
             wallet={wallet}
             setUserAddress={setUserAddress}
             setUserBalance={setUserBalance}
           />

           <div>
             I am {userAddress} with {userBalance} mutez
           </div>
         </header>

         <br />
         <div>
           <button onClick={fetchContracts}>Fetch contracts</button>
           <table>
             <thead>
               <tr>
                 <th>address</th>
                 <th>trace "contract - feedback - user"</th>
                 <th>action</th>
               </tr>
             </thead>
             <tbody>
               {contracts.map((contract) => (
                 <tr>
                   <td style={{ borderStyle: 'dotted' }}>{contract.address}</td>
                   <td style={{ borderStyle: 'dotted' }}>
                     {contractStorages.get(contract.address!) !== undefined &&
                     contractStorages.get(contract.address!)!.pokeTraces
                       ? Array.from(
                           contractStorages
                             .get(contract.address!)!
                             .pokeTraces.entries()
                         ).map(
                           (e) =>
                             e[1].receiver +
                             ' ' +
                             e[1].feedback +
                             ' ' +
                             e[0] +
                             ','
                         )
                       : ''}
                   </td>
                   <td style={{ borderStyle: 'dotted' }}>
                     <input
                       type="text"
                       onChange={(e) => {
                         console.log('e', e.currentTarget.value);
                         setContractToPoke(e.currentTarget.value);
                       }}
                       placeholder="enter contract address here"
                     />
                     <button onClick={(e) => poke(e, contract)}>Poke</button>
                     <button onClick={(e) => mint(e, contract)}>
                       Mint 1 ticket
                     </button>
                   </td>
                 </tr>
               ))}
             </tbody>
           </table>
         </div>
       </div>
     );
   }

   export default App;
   ```

   > Note: You maybe have noticed, but the full typed generated Taquito class is used for the storage access now. It improves maintenance in case you contract storage has changed.

4. Refresh the page, now that you have the Mint button.

5. Mint a ticket on this contract.

   ![mint](/img/tutorials/dapp-mint.png)

6. Wait for the Tx popup confirmation and then try to poke again, it should succeed now.

   ![success](/img/tutorials/dapp-success.png)

7. Wait for the Tx popup confirmation and try to poke again, you should be out of tickets and it should fail.

   ![kukaifail](/img/tutorials/dapp-kukaifail.png)

   Congratulations, you know how to use tickets and avoid DUP errors.

   > Takeaways:
   >
   > * You can go further and improve the code like consuming one 1 ticket quantity at a time and manage it the right way.
   > * You can also implement different type of Authorization mechanism, not only `can poke` claim.
   > * You can also try to base your ticket on some duration time like JSON token can do, not using the data field as a string but as bytes and store a timestamp on it.

## Summary

Now, you understand tickets. If you want to learn more about tickets, read this great article [here](https://www.marigold.dev/post/tickets-for-dummies).

In the next training, you will learn how to upgrade smart contracts.

When you are ready, continue to [Part 4: Smart contract upgrades](/tutorials/dapp/part-4).


# Part 4: Smart contract upgrades

# Upgradable Poke game

Previously, you learned how to use tickets and don't mess up with it.
In this third session, you will enhance your skills on:

* Upgrading a smart contract with lambda function code.
* Upgrading a smart contract with proxy.

As you may know, smart contracts are immutable but in real life, applications are not and evolve. During the past several years, bugs and vulnerabilities in smart contracts caused millions of dollars to get stolen or lost forever. Such cases may even require manual intervention in blockchain operation to recover the funds.

Let's see some tricks that allow you to upgrade a contract.

# Prerequisites

There is nothing more than you need on the first session: https://github.com/marigold-dev/training-dapp-1#memo-prerequisites.

Get the code from the session 3 or the solution [here](https://github.com/marigold-dev/training-dapp-3/tree/main/solution).

# Upgrades

As everyone knows, one feature of blockchain is to keep immutable code on a block. This allows transparency, traceability, and trustlessness.

But the application lifecycle implies evolving and upgrading code to fix bugs or bring functionalities. So, how to do it?

> https://gitlab.com/tezos/tzip/-/blob/master/proposals/tzip-18/tzip-18.md

> Note: All below solutions break in a wait the fact that a smart contract is immutable. **Trust** preservation can be safe enough if the upgrade process has some security and authenticity around it. Like the first time an admin deploys a smart contract, any user should be able to trust the code reading it with free read access, the same should apply to the upgrade process (notification of new code version, admin identification, whitelisted auditor reports, ...). To resume, if you really want to avoid DEVOPS centralization, you are about to create a DAO with a voting process among some selected users/administrators in order to deploy the new version of the smart contract ... but let's simplify and talk here only about classical centralized admin deployment.

## Naive approach

One can deploy a new version of the smart contract and do a redirection to the new address on the front end side.

Complete flow.

```mermaid
sequenceDiagram
  Admin->>Tezos: originate smart contract A
  Tezos-->>Admin: contractAddress A
  User->>frontend: click on %myfunction
  frontend->>SmartContractA: transaction %myfunction
  Note right of SmartContractA : executing logic of A
  Admin->>Tezos: originate smart contract B with A storage as init
  Tezos-->>Admin: contractAddress B
  Admin->>frontend: change smart contract address to B
  User->>frontend: click on %myfunction
  frontend->>SmartContractB: transaction %myfunction
  Note right of SmartContractB : executing logic of B
```

| Pros          | Cons                                                                                           |
| ------------- | ---------------------------------------------------------------------------------------------- |
| Easiest to do | Old contract remains active, so do bugs. Need to really get rid off it                         |
|               | Need to migrate old storage, can cost a lot of money or even be too big to copy at init time   |
|               | Need to sync/update frontend at each backend migration                                         |
|               | Lose reference to previous contract address, can lead to issues with other dependent contracts |

## Stored Lambda function

This time, the code will be on the storage and being executed at runtime.

Init.

```mermaid
sequenceDiagram
  Admin->>Tezos: originate smart contract with a lambda Map on storage, initialized Map.literal(list([["myfunction","<SOME_CODE>"]]))
  Tezos-->>Admin: contractAddress
```

Interaction.

```mermaid
sequenceDiagram
  User->>SmartContract: transaction %myfunction
  Note right of SmartContract : Tezos.exec(lambaMap.find_opt(myfunction))
```

Administration.

```mermaid
sequenceDiagram
  Admin->>SmartContract: transaction(["myfunction","<SOME_CODE>"],0,updateLambdaCode)
  Note right of SmartContract : Check caller == admin
  Note right of SmartContract : Map.add("myfunction","<SOME_CODE>",lambaMap)
```

### Pros/Cons

| Pros                                                                                               | Cons                                                                                                               |
| -------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------ |
| No more migration of code and storage. Update the lambda function code that is on existing storage | For the storage, all has to be stores as bytes PACKING/UNPACKING it so type checking is lost                       |
| keep same contract address                                                                         | IDE or tools do not work anymore on lambda code. Michelson does not protect us from some kinds of mistakes anymore |
|                                                                                                    | Unexpected changes can cause other contract callers to fail, Interface benefits is lost                            |
|                                                                                                    | Harder to audit and trace, can lead to really big security nd Trust issues                                         |
|                                                                                                    | Storing everything as bytes is limited to PACK-able types like nat, string, list, set, map                         |

### Implementation

Change the implementation of the function `pokeAndGetFeedback`. The feedback is now a lambda function on the storage.
It is required to:

* Add a new entrypoint to change the lambda code.
* Update the current entrypoint for calling the lambda.

1. Let's start with adding the lambda function definition of the storage.

   ```jsligo
   export type feedbackFunction = (oracleAddress: address) => string;

   export type storage = {
     pokeTraces: map<address, pokeMessage>,
     feedback: string,
     ticketOwnership: map<address, ticket<string>>, //ticket of claims
     feedbackFunction: feedbackFunction
   };
   ```

   Let's make minor changes as you have 1 additional field `feedbackFunction` on storage destructuring.

2. Edit the `PokeAndGetFeedback` function where the lambda `feedbackFunction(..)` is executed

   ```jsligo
   @no_mutation
   @entry
   const pokeAndGetFeedback = (oracleAddress: address, store: storage): return_ => {
     const { pokeTraces, feedback, ticketOwnership, feedbackFunction } = store;
     const [t, tom]: [option<ticket<string>>, map<address, ticket<string>>] =
       Map.get_and_update(
         Tezos.get_source(),
         None() as option<ticket<string>>,
         ticketOwnership
       );
     let feedbackMessage = {
       receiver: oracleAddress,
       feedback: feedbackFunction(oracleAddress)
     };
     return match(t) {
       when (None()):
         failwith("User does not have tickets => not allowed")
       when (Some(_t)):
         [
           list([]) as list<operation>,
           {
             feedback,
             pokeTraces: Map.add(Tezos.get_source(), feedbackMessage, pokeTraces),
             ticketOwnership: tom,
             feedbackFunction
           }
         ]
     }
   };
   ```

   Notice the line with `feedbackFunction(oracleAddress)` and call the lambda with the address parameter.

   The first time, the current code is injected to check that it still works, and then, modify the lambda code on the storage.

3. To modify the lambda function code, add an extra admin entrypoint `updateFeedbackFunction`.

   ```jsligo
   @entry
   const updateFeedbackFunction = (newCode: feedbackFunction, store: storage): return_ => {
     const { pokeTraces, feedback, ticketOwnership, feedbackFunction } = store;
     ignore(feedbackFunction);
     return [
       list([]),
       { pokeTraces, feedback, ticketOwnership, feedbackFunction: newCode }
     ]
   };
   ```

4. The storage definition is broken, fix all storage missing field warnings on `poke` and `init` functions.

   ```jsligo
   @entry
   const poke = (_: unit, store: storage): return_ => {
     const { pokeTraces, feedback, ticketOwnership, feedbackFunction } = store;
     const [t, tom]: [option<ticket<string>>, map<address, ticket<string>>] =
       Map.get_and_update(
         Tezos.get_source(),
         None() as option<ticket<string>>,
         ticketOwnership
       );
     return match(t) {
       when (None()):
         failwith("User does not have tickets => not allowed")
       when (Some(_t)):
         [
           list([]) as list<operation>,
           {
             feedback,
             pokeTraces: Map.add(
               Tezos.get_source(),
               { receiver: Tezos.get_self_address(), feedback: "" },
               pokeTraces
             ),
             ticketOwnership: tom,
             feedbackFunction
           }
         ]
     }
   };

   @entry
   const init = ([a, ticketCount]: [address, nat], store: storage): return_ => {
     const { pokeTraces, feedback, ticketOwnership, feedbackFunction } = store;
     if (ticketCount == (0 as nat)) {
       return [
         list([]) as list<operation>,
         { pokeTraces, feedback, ticketOwnership, feedbackFunction }
       ]
     } else {
       const t: ticket<string> =
         Option.unopt(Tezos.create_ticket("can_poke", ticketCount));
       return [
         list([]) as list<operation>,
         {
           pokeTraces,
           feedback,
           ticketOwnership: Map.add(a, t, ticketOwnership),
           feedbackFunction
         }
       ]
     }
   };
   ```

5. Change the initial storage with the old initial value of the lambda function (i.e. calling a view to get feedback).

   ```jsligo
   #import "pokeGame.jsligo" "Contract"

   const default_storage = {
       pokeTraces: Map.empty as map<address, Contract.pokeMessage>,
       feedback: "kiss",
       ticketOwnership: Map.empty as map<address, ticket<string>>, //ticket of claims
       feedbackFunction: (
           (oracleAddress: address): string => {
               return match(
                   Tezos.call_view("feedback", unit, oracleAddress) as
                       option<string>
               ) {
                   when (Some(feedback)):
                       feedback
                   when (None()):
                       failwith(
                           "Cannot find view feedback on given oracle address"
                       )
               };
           }
       )
   };
   ```

6. Compile and play with the CLI.

   ```bash
   npm i
   TAQ_LIGO_IMAGE=ligolang/ligo:1.6.0 taq compile pokeGame.jsligo
   ```

7. Redeploy to testnet

   ```bash
   taq deploy pokeGame.tz -e testing
   ```

   ```logs
   ┌─────────────┬──────────────────────────────────────┬──────────┬──────────────────┬────────────────────────────────┐
   │ Contract    │ Address                              │ Alias    │ Balance In Mutez │ Destination                    │
   ├─────────────┼──────────────────────────────────────┼──────────┼──────────────────┼────────────────────────────────┤
   │ pokeGame.tz │ KT1VjFawYQ4JeEEAVchqaYK1NmXCENm2ufer │ pokeGame │ 0                │ https://ghostnet.ecadinfra.com │
   └─────────────┴──────────────────────────────────────┴──────────┴──────────────────┴────────────────────────────────┘
   ```

8. Test the dApp frontend.

   Regenerate types and run the frontend.

   ```bash
   taq generate types ./app/src
   cd app
   yarn dev
   ```

9. Run the user sequence on the web page:

   1. Mint 1 ticket.
   2. wait for confirmation.
   3. poke a contract address.
   4. wait for confirmation.
   5. click on the button to refresh the contract list.
      So far so good, you have the same result as the previous training.

   Update the lambda function in the background with the CLI through the new admin entrypoint. Return a fixed string this time, just for demo purposes, and verify that the lambda executed is returning another output.

10. Edit the file `pokeGame.parameterList.jsligo`.

    ```jsligo
    #import "pokeGame.jsligo" "Contract"
    const default_parameter : parameter_of Contract = UpdateFeedbackFunction((_oracleAddress : address) : string => "YEAH!!!");
    ```

11. Compile all and call an init transaction.

    ```bash
    TAQ_LIGO_IMAGE=ligolang/ligo:1.6.0 taq compile pokeGame.jsligo
    taq call pokeGame --param pokeGame.parameter.default_parameter.tz -e testing
    ```

    ```logs
    ┌────────────────┬──────────────────────────────────────┬─────────────────────────────────────────┬────────────┬────────────────┬────────────────────────────────┐
    │ Contract Alias │ Contract Address                     │ Parameter                               │ Entrypoint │ Mutez Transfer │ Destination                    │
    ├────────────────┼──────────────────────────────────────┼─────────────────────────────────────────┼────────────┼────────────────┼────────────────────────────────┤
    │ pokeGame       │ KT1VjFawYQ4JeEEAVchqaYK1NmXCENm2ufer │ (Left { DROP ; PUSH string "YEAH!!!" }) │ default    │ 0              │ https://ghostnet.ecadinfra.com │
    │                │                                      │                                         │            │                │                                │
    └────────────────┴──────────────────────────────────────┴─────────────────────────────────────────┴────────────┴────────────────┴────────────────────────────────┘
    ```

12. Run the user sequence on the web page:

    1. Mint 1 ticket.
    2. Wait for confirmation.
    3. Poke a contract address.
    4. Wait for confirmation.
    5. Click on the button to refresh the contract list.

    You see that the feedback has changed to `YEAH!!!`.

13. Optional: fix the unit tests.

## Proxy pattern

The goal is to have a proxy contract maintaining the application lifecycle, it is an enhancement of the previous naive solution.
Deploy a completely new smart contract, but this time, the end user is not interacting directly with this contract. Instead, the proxy becomes the default entrypoint and keeps the same facing address.

Init

```mermaid
sequenceDiagram
  Admin->>Tezos: originate proxy(admin,[])
  Tezos-->>Admin: proxyAddress
  Admin->>Tezos: originate smart contract(proxyAddress,v1)
  Tezos-->>Admin: contractV1Address
  Admin->>Proxy: upgrade([["endpoint",contractV1Address]],{new:contractV1Address})
```

Interaction

```mermaid
sequenceDiagram
  User->>Proxy: call("endpoint",payloadBytes)
  Proxy->>SmartContractV1: main("endpoint",payloadBytes)
```

Administration

```mermaid
sequenceDiagram
  Admin->>Proxy: upgrade([["endpoint",contractV2Address]],{old:contractV1Address,new:contractV2Address})
  Note right of Proxy : Check caller == admin
  Note right of Proxy : storage.entrypoints.set["endpoint",contractV2Address]
  Proxy->>SmartContractV1: main(["changeVersion",{old:contractV1Address,new:contractV2Address}])
  Note left of SmartContractV1 : storage.tzip18.contractNext = contractV2Address
```

> Note: 2 location choices for the smart contract storage:
>
> * At proxy level: storage stays unique and immutable.
> * At end-contract level: storage is new at each new version and need to be migrated.

### Pros/Cons

| Pros                                                                      | Cons                                                                                                                                                    |
| ------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Migration is transparent for frontend                                     | smart contract code `Tezos.SENDER` always refers to the proxy, so you need to be careful                                                                |
| if the storage is unchanged, keep the storage at proxy level without cost | If storage changes, need to migrate storage from old contract to new contract and it costs money and having storage at proxy level is not more possible |
| keep same contract address                                                | If a contract interface changed, then re-originate the proxy                                                                                            |
|                                                                           | No all of types are compatible with PACKING/UNPACKING, and type checking is lost                                                                        |
|                                                                           | IDE or tools do not work anymore on lambda code. Michelson does not protect us from some kinds of mistakes anymore                                      |
|                                                                           | Unexpected changes can cause other contract callers to fail, Interface benefits are lost                                                                |
|                                                                           | Harder to audit and trace, can lead to really big security nd Trust issues                                                                              |
|                                                                           | Storing everything as bytes is limited to PACK-able types like nat, string, list, set, map                                                              |

### Implementation

#### Rewrite the smart contract to make it generic

1. Rename the file `pokeGame.jsligo` to `pokeGameLambda.jsligo` , as you can have a look on it later.

2. Remove pokeGame.parameterList.jsligo.

3. Get back the original version of `pokeGame.jsligo` from previous training as it is easier to start from here.

4. Create a new file `tzip18.jsligo`.

   ```bash
   taq create contract tzip18.jsligo
   ```

5. Edit the file.

   ```jsligo
   // Tzip 18 types
   export type tzip18 = {
     proxy: address,
     version: nat,
     contractPrevious: option<address>,
     contractNext: option<address>
   };
   ```

   This type is included on all smart contract storages to track the proxy address and the last contract version. It is used to block old smart contract instances to be called and check who can call who.

6. Get back to `pokeGame.jsligo` and import this file on the first line.

   ```jsligo
   #import "./tzip18.jsligo" "TZIP18"
   ```

7. Add the type to the storage definition.

   ```jsligo
   export type storage = {
     pokeTraces: map<address, pokeMessage>,
     feedback: string,
     ticketOwnership: map<address, ticket<string>>, //ticket of claims
     tzip18: TZIP18.tzip18
   };
   ```

8. Fix all missing tzip18 fields on the storage structure in the file.

   ```jsligo
   const poke = (
     _: { entrypointName: string, payload: bytes },
     [pokeTraces, feedback, ticketOwnership, tzip18]: [
       map<address, pokeMessage>,
       string,
       map<address, ticket<string>>,
       TZIP18.tzip18
     ]
   ): return_ => {
     //extract opt ticket from map

     const [t, tom]: [option<ticket<string>>, map<address, ticket<string>>] =
       Map.get_and_update(
         Tezos.get_source(),
         None() as option<ticket<string>>,
         ticketOwnership
       );
     return match(t) {
       when (None()):
         failwith("User does not have tickets => not allowed")
       when (Some(_t)):
         [
           list([]) as list<operation>,
           {
             //let t burn

             feedback,
             pokeTraces: Map.add(
               Tezos.get_source(),
               { receiver: Tezos.get_self_address(), feedback: "" },
               pokeTraces
             ),
             ticketOwnership: tom,
             tzip18,
           }
         ]
     };
   };

   @no_mutation
   const pokeAndGetFeedback = (
     oracleAddress: address,
     [pokeTraces, feedback, ticketOwnership, tzip18]: [
       map<address, pokeMessage>,
       string,
       map<address, ticket<string>>,
       TZIP18.tzip18
     ]
   ): return_ => {
     //extract opt ticket from map

     const [t, tom]: [option<ticket<string>>, map<address, ticket<string>>] =
       Map.get_and_update(
         Tezos.get_source(),
         None() as option<ticket<string>>,
         ticketOwnership
       );
     //Read the feedback view

     let feedbackOpt: option<bytes> =
       Tezos.call_view("getView", "feedback", oracleAddress);
     return match(t) {
       when (None()):
         failwith("User does not have tickets => not allowed")
       when (Some(_t)):
         match(feedbackOpt) {
           when (Some(f)):
             do {
               let feedbackMessage = {
                 receiver: oracleAddress,
                 feedback: Option.unopt(Bytes.unpack(f) as option<string>),
               };
               return [
                 list([]) as list<operation>,
                 {
                   feedback,
                   pokeTraces: Map.add(
                     Tezos.get_source(),
                     feedbackMessage,
                     pokeTraces
                   ),
                   ticketOwnership: tom,
                   tzip18,
                 }
               ]
             }
           when (None()):
             failwith("Cannot find view feedback on given oracle address")
         }
     };
   };

   const init = (
     [a, ticketCount]: [address, nat],
     [pokeTraces, feedback, ticketOwnership, tzip18]: [
       map<address, pokeMessage>,
       string,
       map<address, ticket<string>>,
       TZIP18.tzip18
     ]
   ): return_ => {
     return ticketCount == (0 as nat) ? [
         list([]) as list<operation>,
         { feedback, pokeTraces, ticketOwnership, tzip18 }
       ] : [
         list([]) as list<operation>,
         {
           feedback,
           pokeTraces,
           ticketOwnership: Map.add(
             a,
             Option.unopt(Tezos.create_ticket("can_poke", ticketCount)),
             ticketOwnership
           ),
           tzip18,
         }
       ]
   };
   ```

   The view call signature is different:

   * It returns optional bytes.
   * Calling **getView** generic view exposed by the proxy.
   * Passing the view named **feedback** (to dispatch to the correct function once you reach the code that will be executed).
   * Finally, unpack the bytes result and cast it to string.

   With generic calls, a **unique** dispatch function has to be used and not multiple **@entry**.

9. Write a main function annotated with @entry.
   The parameter is a string representing the entrypoint name and some generic bytes that are required to be cast later on.
   In a way, compiler checks are broken, so the code is to be well-written and well-cast as earliest as possible to mitigate risks.

   ```jsligo
   @entry
   export const main = (action: { entrypointName: string, payload: bytes }, store: storage): return_ => {
     //destructure the storage to avoid DUP

     const { pokeTraces, feedback, ticketOwnership, tzip18 } = store;
     const canBeCalled: bool =
       match(tzip18.contractNext) {
         when (None()):
           false // I am the last version, but I cannot be called directly (or is my proxy, see later)

         when (Some(contract)):
           do {
             if (Tezos.get_sender() == contract) {
               return true;
             } // I am not the last but a parent contract is calling me
             else {
               return false;
             }
           } // I am not the last version and a not-parent is trying to call me

       };
     if (Tezos.get_sender() != tzip18.proxy && ! canBeCalled) {
       return failwith("Only the proxy or contractNext can call this contract");
     };
     if (action.entrypointName == "Poke") {
       return poke(action, [pokeTraces, feedback, ticketOwnership, tzip18]);
     } else {
       if (action.entrypointName == "PokeAndGetFeedback") {
         return match(Bytes.unpack(action.payload) as option<address>) {
           when (None()):
             failwith("Cannot find the address parameter for PokeAndGetFeedback")
           when (Some(other)):
             pokeAndGetFeedback(
               other,
               [pokeTraces, feedback, ticketOwnership, tzip18]
             )
         };
       } else {
         if (action.entrypointName == "Init") {
           return match(Bytes.unpack(action.payload) as option<[address, nat]>) {
             when (None()):
               failwith("Cannot find the address parameter for changeVersion")
             when (Some(initParam)):
               init(
                 [initParam[0], initParam[1]],
                 [pokeTraces, feedback, ticketOwnership, tzip18]
               )
           };
         } else {
           if (action.entrypointName == "changeVersion") {
             return match(Bytes.unpack(action.payload) as option<address>) {
               when (None()):
                 failwith("Cannot find the address parameter for changeVersion")
               when (Some(other)):
                 changeVersion(
                   other,
                   [pokeTraces, feedback, ticketOwnership, tzip18]
                 )
             };
           } else {
             return failwith("Non-existant method");
           }
         }
       }
     }
   };
   ```

   * Start checking that only the proxy contract or the parent of this contract can call the main function. Enable this feature in case the future contract wants to run a migration *script* itself, reading from children's storage (looking at `tzip18.contractPrevious` field ).
   * With no more variants, the pattern matching is broken, and `if...else` statement has to be used instead.
   * When a payload is passed, unpack it and cast it with `(Bytes.unpack(action.payload) as option<MY_TYPE_HERE>)`. It means the caller and callee agree on the payload structure for each endpoint.

10. Add the last missing function to change the version of this contract and make it obsolete (just before the main function).

    ```jsligo
    /**
    * Function called by a parent contract or administrator to set the current version on an old contract
    **/

    const changeVersion = (
      newAddress: address,
      [pokeTraces, feedback, ticketOwnership, tzip18]: [
        map<address, pokeMessage>,
        string,
        map<address, ticket<string>>,
        TZIP18.tzip18
      ]
    ): return_ => {
      return [
        list([]) as list<operation>,
        {
          pokeTraces,
          feedback,
          ticketOwnership,
          tzip18: { ...tzip18, contractNext: Some(newAddress) },
        }
      ]
    };
    ```

11. Change the view to a generic one and do an `if...else` on `viewName` argument.

    ```jsligo
    @view
    const getView = (viewName: string, store: storage): bytes => {
      if (viewName == "feedback") {
        return Bytes.pack(store.feedback);
      } else return failwith("View " + viewName + " not found on this contract");
    };
    ```

12. Change the initial storage.

    > Note: for the moment, initialize the proxy address to a fake KT1 address because the proxy is not yet deployed.

    ```jsligo
    #import "pokeGame.jsligo" "Contract"

    const default_storage : Contract.storage = {
        pokeTraces: Map.empty as map<address, Contract.pokeMessage>,
        feedback: "kiss",
        ticketOwnership: Map.empty as map<address, ticket<string>>, //ticket of claims
        tzip18: {
            proxy: "KT1LXkvAPGEtdFNfFrTyBEySJvQnKrsPn4vD" as address,
            version: 1 as nat,
            contractPrevious: None() as option<address>,
            contractNext: None() as option<address>
        }
    };
    ```

13. Compile.

    ```bash
    TAQ_LIGO_IMAGE=ligolang/ligo:1.6.0 taq compile pokeGame.jsligo
    ```

    All good.

#### Write the unique proxy

1. Create a file `proxy.jsligo`.

   ```bash
   taq create contract proxy.jsligo
   ```

2. Define the storage and entrypoints on it.

   ```jsligo
   export type storage = {
     governance: address, //admins
     entrypoints: big_map<string, entrypointType> //interface schema map
   };

   type _return = [list<operation>, storage];
   ```

   The storage:

   * Holds a /or several admins.

   * Maintains the interface schema map for all underlying entrypoints.

   > Note on parameters: use @entry syntax, parameters is 2 functions.
   >
   > * **call**: forward any request to the right underlying entrypoint.
   > * **upgrade**: admin endpoint to update the interface schema map or change smart contract version.

3. Add our missing types just above.

   ```jsligo
   export type callContract = {
     entrypointName: string,
     payload: bytes
   };

   export type entrypointType = {
     method: string,
     addr: address
   };

   export type entrypointOperation = {
     name: string,
     isRemoved: bool,
     entrypoint: option<entrypointType>
   };

   export type changeVersion = {
     oldAddr: address,
     newAddr: address
   };
   ```

   * **callContract**: payload from user executing an entrypoint (name+payloadBytes)
   * **entrypointType**: payload to be able to call an underlying contract (name+address)
   * **entrypointOperation**: change the entrypoint interface map (new state of the map)
   * **changeVersion**: change the smart contract version (old/new addresses)

4. Add the `Call`entrypoint (simple forward). (Before the main function).

   ```jsligo
   // the proxy function

   @entry
   const callContract = (param: callContract, store: storage): _return => {
     return match(Big_map.find_opt(param.entrypointName, store.entrypoints)) {
       when (None):
         failwith("No entrypoint found")
       when (Some(entry)):
         match(
           Tezos.get_contract_opt(entry.addr) as option<contract<callContract>>
         ) {
           when (None):
             failwith("No contract found at this address")
           when (Some(contract)):
             [
               list(
                 [
                   Tezos.transaction(
                     { entrypointName: entry.method, payload: param.payload },
                     Tezos.get_amount(),
                     contract
                   )
                 ]
               ) as list<operation>,
               store
             ]
         }
     }
   };
   ```

   It gets the entrypoint to call and the payload in bytes and just forwards it to the right location.

5. Then, write the `upgrade` entrypoint. (Before the main function).

   ```jsligo
   /**
   * Function for administrators to update entrypoints and change current contract version
   **/

   @entry
   const upgrade = (
     param: [list<entrypointOperation>, option<changeVersion>],
     store: storage
   ): _return => {
     if (Tezos.get_sender() != store.governance) {
       return failwith("Permission denied")
     };
     let [upgraded_ep_list, changeVersionOpt] = param;
     const update_storage = (
       l: list<entrypointOperation>,
       m: big_map<string, entrypointType>
     ): big_map<string, entrypointType> => {
       return match(l) {
         when ([]):
           m
         when ([x, ...xs]):
           do {
             let b: big_map<string, entrypointType> =
               match(x.entrypoint) {
                 when (None):
                   do {
                     if (x.isRemoved == true) {
                       return Big_map.remove(x.name, m)
                     } else {
                       return m
                     }
                   } //mean to remove or unchanged

                 when (Some(_ep)):
                   do {
                     //means to add new or unchanged

                     if (x.isRemoved == false) {
                       return match(x.entrypoint) {
                         when (None):
                           m
                         when (Some(c)):
                           Big_map.update(x.name, Some(c), m)
                       }
                     } else {
                       return m
                     }
                   }
               };
             return update_storage(xs, b)
           }
       }
     };
     //update the entrypoint interface map

     const new_entrypoints: big_map<string, entrypointType> =
       update_storage(upgraded_ep_list, store.entrypoints);
     //check if version needs to be changed

     return match(changeVersionOpt) {
       when (None):
         [list([]) as list<operation>, { ...store, entrypoints: new_entrypoints }]
       when (Some(change)):
         do {
           let op_change: operation =
             match(
               Tezos.get_contract_opt(change.oldAddr) as
                 option<contract<callContract>>
             ) {
               when (None):
                 failwith("No contract found at this address")
               when (Some(contract)):
                 do {
                   let amt = Tezos.get_amount();
                   let payload: address = change.newAddr;
                   return Tezos.transaction(
                     {
                       entrypointName: "changeVersion",
                       payload: Bytes.pack(payload)
                     },
                     amt,
                     contract
                   )
                 }
             };
           return [
             list([op_change]) as list<operation>,
             { ...store, entrypoints: new_entrypoints }
           ]
         }
     }
   };
   ```

   * It loops over the new interface schema to update and do so.
   * If a **changeVersion** is required, it calls the old contract to take the new version configuration (and it disables itself).

6. The last change is to expose any view from the underlying contract and declare it at the end of the file.

   ```jsligo
   @view
   export const getView = (viewName: string, store: storage): bytes => {
     return match(Big_map.find_opt(viewName, store.entrypoints)) {
       when (None):
         failwith("View " + viewName + " not declared on this proxy")
       when (Some(ep)):
         Option.unopt(
           Tezos.call_view("getView", viewName, ep.addr) as option<bytes>
         )
     }
   };
   ```

   * Expose a generic view on the proxy and pass the name of the final function called on the underlying contract (as the smart contract view is not unreachable/hidden by the proxy contract).
   * Search for an exposed view on the interface schema to retrieve the contract address, then call the view and return the result as an *exposed* view.

7. Compile.

   ```bash
   TAQ_LIGO_IMAGE=ligolang/ligo:1.6.0 taq compile proxy.jsligo
   ```

#### Deployment

1. Edit `proxy.storageList.jsligo` to this below ( **!!! be careful to point the *governance* address to your taq default user account !!!**).

   ```jsligo
   const default_storage: Contract.storage = {
       governance: "tz1VSUr8wwNhLAzempoch5d6hLRiTh8Cjcjb" as address, //admins
       entrypoints: Big_map.empty as
           big_map<
               string,
               Contract.entrypointType
           > //interface schema map

   };
   ```

2. Compile and deploy it.

   ```bash
   TAQ_LIGO_IMAGE=ligolang/ligo:1.6.0 taq compile proxy.jsligo
   taq deploy proxy.tz -e testing
   ```

   ```logs
   ┌──────────┬──────────────────────────────────────┬───────┬──────────────────┬────────────────────────────────┐
   │ Contract │ Address                              │ Alias │ Balance In Mutez │ Destination                    │
   ├──────────┼──────────────────────────────────────┼───────┼──────────────────┼────────────────────────────────┤
   │ proxy.tz │ KT1Ego8vYEa4tPwkJirZfwxgJrqfmTcd8KMU │ proxy │ 0                │ https://ghostnet.ecadinfra.com │
   └──────────┴──────────────────────────────────────┴───────┴──────────────────┴────────────────────────────────┘
   ```

   Keep this **proxy address**, as you need to report it below on `tzip18.proxy` field.

3. Deploy a smart contract V1. ( :warning: Change with the **proxy address** on the file `pokeGame.storageList.jsligo` like here below ).

   ```jsligo
    #import "pokeGame.jsligo" "Contract"

    const default_storage: Contract.storage = {
        pokeTraces: Map.empty as map<address, Contract.pokeMessage>,
        feedback: "kiss",
        ticketOwnership: Map.empty as map<address, ticket<string>>, //ticket of claims
        tzip18: {
            proxy: "KT1Ego8vYEa4tPwkJirZfwxgJrqfmTcd8KMU" as address,
            version: 1 as nat,
            contractPrevious: None() as option<address>,
            contractNext: None() as option<address>
        }
    };
   ```

4. Deploy the underlying V1 contract.

   ```bash
   TAQ_LIGO_IMAGE=ligolang/ligo:1.6.0 taq compile pokeGame.jsligo
   taq deploy pokeGame.tz -e testing
   ```

   ```logs
   ┌─────────────┬──────────────────────────────────────┬──────────┬──────────────────┬────────────────────────────────┐
   │ Contract    │ Address                              │ Alias    │ Balance In Mutez │ Destination                    │
   ├─────────────┼──────────────────────────────────────┼──────────┼──────────────────┼────────────────────────────────┤
   │ pokeGame.tz │ KT1FqTZuuJCHz7Fe3J3AdpYgo2CGyhrJ6NAp │ pokeGame │ 0                │ https://ghostnet.ecadinfra.com │
   └─────────────┴──────────────────────────────────────┴──────────┴──────────────────┴────────────────────────────────┘
   ```

5. Tell the proxy that there is a first contract deployed with some interface.
   Edit the parameter file `proxy.parameterList.jsligo` (:warning: Change with the smart contract address on each command line on `addr` fields below).

   ```jsligo
   #import "proxy.jsligo" "Contract"

   const initProxyWithV1: parameter_of Contract =
       Upgrade(
           [
               list(
                   [
                       {
                           name: "Poke",
                           isRemoved: false,
                           entrypoint: Some(
                               {
                                   method: "Poke",
                                   addr: "KT1FqTZuuJCHz7Fe3J3AdpYgo2CGyhrJ6NAp" as
                                       address
                               }
                           )
                       },
                       {
                           name: "PokeAndGetFeedback",
                           isRemoved: false,
                           entrypoint: Some(
                               {
                                   method: "PokeAndGetFeedback",
                                   addr: "KT1FqTZuuJCHz7Fe3J3AdpYgo2CGyhrJ6NAp" as
                                       address
                               }
                           )
                       },
                       {
                           name: "Init",
                           isRemoved: false,
                           entrypoint: Some(
                               {
                                   method: "Init",
                                   addr: "KT1FqTZuuJCHz7Fe3J3AdpYgo2CGyhrJ6NAp" as
                                       address
                               }
                           )
                       },
                       {
                           name: "changeVersion",
                           isRemoved: false,
                           entrypoint: Some(
                               {
                                   method: "changeVersion",
                                   addr: "KT1FqTZuuJCHz7Fe3J3AdpYgo2CGyhrJ6NAp" as
                                       address
                               }
                           )
                       },
                       {
                           name: "feedback",
                           isRemoved: false,
                           entrypoint: Some(
                               {
                                   method: "feedback",
                                   addr: "KT1FqTZuuJCHz7Fe3J3AdpYgo2CGyhrJ6NAp" as
                                       address
                               }
                           )
                       }
                   ]
               ) as list<Contract.entrypointOperation>,
               None() as option<Contract.changeVersion>
           ]
       );
   ```

6. Compile & Call it.

   ```bash
   TAQ_LIGO_IMAGE=ligolang/ligo:1.6.0 taq compile proxy.jsligo
   taq call proxy --param proxy.parameter.initProxyWithV1.tz -e testing
   ```

   Output:

   ```logs
   ┌────────────────┬──────────────────────────────────────┬───────────────────────────────────────────────────────────────────────────────────────────────────────┬────────────┬────────────────┬────────────────────────────────┐
   │ Contract Alias │ Contract Address                     │ Parameter                                                                                             │ Entrypoint │ Mutez Transfer │ Destination                    │
   ├────────────────┼──────────────────────────────────────┼───────────────────────────────────────────────────────────────────────────────────────────────────────┼────────────┼────────────────┼────────────────────────────────┤
   │ proxy          │ KT1Ego8vYEa4tPwkJirZfwxgJrqfmTcd8KMU │ (Left (Pair { Pair "Poke" False (Some (Pair "Poke" "KT1FqTZuuJCHz7Fe3J3AdpYgo2CGyhrJ6NAp")) ;         │ default    │ 0              │ https://ghostnet.ecadinfra.com │
   │                │                                      │               Pair "PokeAndGetFeedback"                                                               │            │                │                                │
   │                │                                      │                    False                                                                              │            │                │                                │
   │                │                                      │                    (Some (Pair "PokeAndGetFeedback" "KT1FqTZuuJCHz7Fe3J3AdpYgo2CGyhrJ6NAp")) ;        │            │                │                                │
   │                │                                      │               Pair "Init" False (Some (Pair "Init" "KT1FqTZuuJCHz7Fe3J3AdpYgo2CGyhrJ6NAp")) ;         │            │                │                                │
   │                │                                      │               Pair "changeVersion"                                                                    │            │                │                                │
   │                │                                      │                    False                                                                              │            │                │                                │
   │                │                                      │                    (Some (Pair "changeVersion" "KT1FqTZuuJCHz7Fe3J3AdpYgo2CGyhrJ6NAp")) ;             │            │                │                                │
   │                │                                      │               Pair "feedback" False (Some (Pair "feedback" "KT1FqTZuuJCHz7Fe3J3AdpYgo2CGyhrJ6NAp")) } │            │                │                                │
   │                │                                      │             None))                                                                                    │            │                │                                │
   │                │                                      │                                                                                                       │            │                │                                │
   └────────────────┴──────────────────────────────────────┴───────────────────────────────────────────────────────────────────────────────────────────────────────┴────────────┴────────────────┴────────────────────────────────┘
   ```

#### Update the frontend

1. Go on the frontend side, recompile all, and generate typescript classes.

   ```bash
   TAQ_LIGO_IMAGE=ligolang/ligo:1.6.0 taq compile pokeGame.jsligo
   TAQ_LIGO_IMAGE=ligolang/ligo:1.6.0 taq compile proxy.jsligo
   taq generate types ./app/src
   ```

2. Change the script to extract the proxy address instead of the contract one, edit `./app/package.json`, and replace the line of script with:

   ```json
       "dev": "jq -r -f filter.jq ../.taq/testing-state.json > .env && vite",
   ```

3. Where you created a new file `filter.jq` with the below content.

   ```bash
   echo '"VITE_CONTRACT_ADDRESS=" + last(.tasks[] | select(.task == "deploy" and .output[0].contract == "proxy.tz").output[0].address)' > ./app/filter.jq
   ```

4. Edit `./app/src/App.tsx` and change the contract address, display, etc ...

   ```typescript
   import { NetworkType } from '@airgap/beacon-types';
   import { BeaconWallet } from '@taquito/beacon-wallet';
   import { PackDataResponse } from '@taquito/rpc';
   import { MichelCodecPacker, TezosToolkit } from '@taquito/taquito';
   import * as api from '@tzkt/sdk-api';
   import { useEffect, useState } from 'react';
   import './App.css';
   import ConnectButton from './ConnectWallet';
   import DisconnectButton from './DisconnectWallet';
   import {
     Storage as ContractStorage,
     PokeGameWalletType,
   } from './pokeGame.types';
   import { Storage as ProxyStorage, ProxyWalletType } from './proxy.types';
   import { address, bytes } from './type-aliases';

   function App() {
     api.defaults.baseUrl = 'https://api.ghostnet.tzkt.io';

     const [Tezos, setTezos] = useState<TezosToolkit>(
       new TezosToolkit('https://ghostnet.ecadinfra.com')
     );
     const [wallet, setWallet] = useState<BeaconWallet>(
       new BeaconWallet({
         name: 'Training',
         preferredNetwork: NetworkType.GHOSTNET,
       })
     );

     const [contracts, setContracts] = useState<Array<api.Contract>>([]);
     const [contractStorages, setContractStorages] = useState<
       Map<string, ProxyStorage & ContractStorage>
     >(new Map());

     const fetchContracts = () => {
       (async () => {
         const tzktcontracts: Array<api.Contract> =
           await api.contractsGetSimilar(
             import.meta.env.VITE_CONTRACT_ADDRESS,
             {
               includeStorage: true,
               sort: { desc: 'id' },
             }
           );
         setContracts(tzktcontracts);
         const taquitoContracts: Array<ProxyWalletType> = await Promise.all(
           tzktcontracts.map(
             async (tzktcontract) =>
               (await Tezos.wallet.at(tzktcontract.address!)) as ProxyWalletType
           )
         );
         const map = new Map<string, ProxyStorage & ContractStorage>();
         for (const c of taquitoContracts) {
           const s: ProxyStorage = await c.storage();
           try {
             let firstEp: { addr: address; method: string } | undefined =
               await s.entrypoints.get('Poke');

             if (firstEp) {
               let underlyingContract: PokeGameWalletType =
                 await Tezos.wallet.at('' + firstEp!.addr);
               map.set(c.address, {
                 ...s,
                 ...(await underlyingContract.storage()),
               });
             } else {
               console.log(
                 'proxy is not well configured ... for contract ' + c.address
               );
               continue;
             }
           } catch (error) {
             console.log(error);
             console.log(
               'final contract is not well configured ... for contract ' +
                 c.address
             );
           }
         }
         console.log('map', map);
         setContractStorages(map);
       })();
     };

     useEffect(() => {
       (async () => {
         const activeAccount = await wallet.client.getActiveAccount();
         if (activeAccount) {
           setUserAddress(activeAccount.address);
           const balance = await Tezos.tz.getBalance(activeAccount.address);
           setUserBalance(balance.toNumber());
         }
       })();
     }, []);

     const [userAddress, setUserAddress] = useState<string>('');
     const [userBalance, setUserBalance] = useState<number>(0);
     const [contractToPoke, setContractToPoke] = useState<string>('');
     //poke
     const poke = async (
       e: React.MouseEvent<HTMLButtonElement>,
       contract: api.Contract
     ) => {
       e.preventDefault();
       let c: ProxyWalletType = await Tezos.wallet.at('' + contract.address);
       try {
         console.log('contractToPoke', contractToPoke);

         const p = new MichelCodecPacker();
         let contractToPokeBytes: PackDataResponse = await p.packData({
           data: { string: contractToPoke },
           type: { prim: 'address' },
         });
         console.log('packed', contractToPokeBytes.packed);

         const op = await c.methods
           .callContract(
             'PokeAndGetFeedback',
             contractToPokeBytes.packed as bytes
           )
           .send();
         await op.confirmation();
         alert('Tx done');
       } catch (error: any) {
         console.log(error);
         console.table(`Error: ${JSON.stringify(error, null, 2)}`);
       }
     };

     //mint
     const mint = async (
       e: React.MouseEvent<HTMLButtonElement>,
       contract: api.Contract
     ) => {
       e.preventDefault();
       let c: ProxyWalletType = await Tezos.wallet.at('' + contract.address);
       try {
         console.log('contractToPoke', contractToPoke);
         const p = new MichelCodecPacker();
         let initBytes: PackDataResponse = await p.packData({
           data: {
             prim: 'Pair',
             args: [{ string: userAddress }, { int: '1' }],
           },
           type: { prim: 'Pair', args: [{ prim: 'address' }, { prim: 'nat' }] },
         });
         const op = await c.methods
           .callContract('Init', initBytes.packed as bytes)
           .send();
         await op.confirmation();
         alert('Tx done');
       } catch (error: any) {
         console.log(error);
         console.table(`Error: ${JSON.stringify(error, null, 2)}`);
       }
     };

     return (
       <div className="App">
         <header className="App-header">
           <ConnectButton
             Tezos={Tezos}
             setTezos={setTezos}
             setUserAddress={setUserAddress}
             setUserBalance={setUserBalance}
             wallet={wallet}
           />

           <DisconnectButton
             wallet={wallet}
             setUserAddress={setUserAddress}
             setUserBalance={setUserBalance}
           />

           <div>
             I am {userAddress} with {userBalance} mutez
           </div>

           <br />
           <div>
             <button onClick={fetchContracts}>Fetch contracts</button>
             <table>
               <thead>
                 <tr>
                   <th>address</th>
                   <th>trace "contract - feedback - user"</th>
                   <th>action</th>
                 </tr>
               </thead>
               <tbody>
                 {contracts.map((contract) => (
                   <tr>
                     <td style={{ borderStyle: 'dotted' }}>
                       {contract.address}
                     </td>
                     <td style={{ borderStyle: 'dotted' }}>
                       {contractStorages.get(contract.address!) !== undefined &&
                       contractStorages.get(contract.address!)!.pokeTraces
                         ? Array.from(
                             contractStorages
                               .get(contract.address!)!
                               .pokeTraces.entries()
                           ).map(
                             (e) =>
                               e[1].receiver +
                               ' ' +
                               e[1].feedback +
                               ' ' +
                               e[0] +
                               ','
                           )
                         : ''}
                     </td>
                     <td style={{ borderStyle: 'dotted' }}>
                       <input
                         type="text"
                         onChange={(e) => {
                           console.log('e', e.currentTarget.value);
                           setContractToPoke(e.currentTarget.value);
                         }}
                         placeholder="enter contract address here"
                       />
                       <button onClick={(e) => poke(e, contract)}>Poke</button>
                       <button onClick={(e) => mint(e, contract)}>
                         Mint 1 ticket
                       </button>
                     </td>
                   </tr>
                 ))}
               </tbody>
             </table>
           </div>
         </header>
       </div>
     );
   }
   export default App;
   ```

   * The contract address now is pointing to the new **proxy** address.
   * Merge the proxy and contract storage into `ProxyStorage&ContractStorage` type definition. Fetching the contracts is appending the storage of the underlying contract to the proxy storage.
   * The call to expose the entrypoint is altered. As all are generic, now on the proxy side, there are only `await c.methods.callContract("my_entrypoint_name",my_packed_payload_bytes).send()` calls.

5. Run the frontend locally.

   ```bash
   cd app
   yarn dev
   ```

6. Do all the same actions as before through the proxy.

   1. Login.
   2. Refresh the contract list.
   3. Mint 1 ticket.
   4. Wait for the confirmation popup.
   5. Poke.
   6. Wait for the confirmation popup.
   7. Refresh the contract list.

   Deploy a new contract V2 and test it again.

   > Note: Remember that the `storage.feedback` field cannot change on any deployed smart contract because there is no exposed method to update it.
   > Let's change this value for the new contract instance, and call it `hello`.

7. Edit `pokeGame.storageList.jsligo` and add a new variable to it. Don't forget again to change `proxy` and `contractPrevious` by our values!

   ```jsligo
   const storageV2: Contract.storage = {
     pokeTraces: Map.empty as map<address, Contract.pokeMessage>,
     feedback: "hello",
     ticketOwnership: Map.empty as map<address, ticket<string>>,
     tzip18: {
       proxy: "KT1Ego8vYEa4tPwkJirZfwxgJrqfmTcd8KMU" as address,
       version: 2 as nat,
       contractPrevious: Some(
         "KT1FqTZuuJCHz7Fe3J3AdpYgo2CGyhrJ6NAp" as address
       ) as option<address>,
       contractNext: None() as option<address>,
     },
   };
   ```

   ```bash
   TAQ_LIGO_IMAGE=ligolang/ligo:1.6.0 taq compile pokeGame.jsligo
   taq deploy pokeGame.tz -e testing --storage pokeGame.storage.storageV2.tz
   ```

   ```logs
   ┌─────────────┬──────────────────────────────────────┬──────────┬──────────────────┬────────────────────────────────┐
   │ Contract    │ Address                              │ Alias    │ Balance In Mutez │ Destination                    │
   ├─────────────┼──────────────────────────────────────┼──────────┼──────────────────┼────────────────────────────────┤
   │ pokeGame.tz │ KT1GFn9rRsMGp1JFthymxCDxQLd2xrWoXXPw │ pokeGame │ 0                │ https://ghostnet.ecadinfra.com │
   └─────────────┴──────────────────────────────────────┴──────────┴──────────────────┴────────────────────────────────┘
   ```

8. Tell the proxy that there are new V2 entrypoints and remove the V1 ones.
   Add a new parameter variable on `proxy.parameterList.jsligo`. Don't forget to change the `addr` values with the new contract address just above.

   ```jsligo
   const initProxyWithV2: parameter_of Contract =
       Upgrade(
           [
               list(
                   [
                       {
                           name: "Poke",
                           isRemoved: false,
                           entrypoint: Some(
                               {
                                   method: "Poke",
                                   addr: "KT1GFn9rRsMGp1JFthymxCDxQLd2xrWoXXPw" as
                                       address
                               }
                           )
                       },
                       {
                           name: "PokeAndGetFeedback",
                           isRemoved: false,
                           entrypoint: Some(
                               {
                                   method: "PokeAndGetFeedback",
                                   addr: "KT1GFn9rRsMGp1JFthymxCDxQLd2xrWoXXPw" as
                                       address
                               }
                           )
                       },
                       {
                           name: "Init",
                           isRemoved: false,
                           entrypoint: Some(
                               {
                                   method: "Init",
                                   addr: "KT1GFn9rRsMGp1JFthymxCDxQLd2xrWoXXPw" as
                                       address
                               }
                           )
                       },
                       {
                           name: "changeVersion",
                           isRemoved: false,
                           entrypoint: Some(
                               {
                                   method: "changeVersion",
                                   addr: "KT1GFn9rRsMGp1JFthymxCDxQLd2xrWoXXPw" as
                                       address
                               }
                           )
                       },
                       {
                           name: "feedback",
                           isRemoved: false,
                           entrypoint: Some(
                               {
                                   method: "feedback",
                                   addr: "KT1GFn9rRsMGp1JFthymxCDxQLd2xrWoXXPw" as
                                       address
                               }
                           )
                       }
                   ]
               ) as list<Contract.entrypointOperation>,
               None() as option<Contract.changeVersion>
           ]
       );
   ```

9. Call the proxy to make the changes.

   ```bash
   TAQ_LIGO_IMAGE=ligolang/ligo:1.6.0 taq compile proxy.jsligo
   taq call proxy --param proxy.parameter.initProxyWithV2.tz -e testing
   ```

10. Check the logs.

    ```logs
    ┌────────────────┬──────────────────────────────────────┬───────────────────────────────────────────────────────────────────────────────────────────────────────┬────────────┬────────────────┬────────────────────────────────┐
    │ Contract Alias │ Contract Address                     │ Parameter                                                                                             │ Entrypoint │ Mutez Transfer │ Destination                    │
    ├────────────────┼──────────────────────────────────────┼───────────────────────────────────────────────────────────────────────────────────────────────────────┼────────────┼────────────────┼────────────────────────────────┤
    │ proxy          │ KT1Ego8vYEa4tPwkJirZfwxgJrqfmTcd8KMU │ (Left (Pair { Pair "Poke" False (Some (Pair "Poke" "KT1GFn9rRsMGp1JFthymxCDxQLd2xrWoXXPw")) ;         │ default    │ 0              │ https://ghostnet.ecadinfra.com │
    │                │                                      │               Pair "PokeAndGetFeedback"                                                               │            │                │                                │
    │                │                                      │                    False                                                                              │            │                │                                │
    │                │                                      │                    (Some (Pair "PokeAndGetFeedback" "KT1GFn9rRsMGp1JFthymxCDxQLd2xrWoXXPw")) ;        │            │                │                                │
    │                │                                      │               Pair "Init" False (Some (Pair "Init" "KT1GFn9rRsMGp1JFthymxCDxQLd2xrWoXXPw")) ;         │            │                │                                │
    │                │                                      │               Pair "changeVersion"                                                                    │            │                │                                │
    │                │                                      │                    False                                                                              │            │                │                                │
    │                │                                      │                    (Some (Pair "changeVersion" "KT1GFn9rRsMGp1JFthymxCDxQLd2xrWoXXPw")) ;             │            │                │                                │
    │                │                                      │               Pair "feedback" False (Some (Pair "feedback" "KT1GFn9rRsMGp1JFthymxCDxQLd2xrWoXXPw")) } │            │                │                                │
    │                │                                      │             None))                                                                                    │            │                │                                │
    │                │                                      │                                                                                                       │            │                │                                │
    └────────────────┴──────────────────────────────────────┴───────────────────────────────────────────────────────────────────────────────────────────────────────┴────────────┴────────────────┴────────────────────────────────┘
    ```

11. Back to the web app, test the flow again:

    1. Refresh the contract list.
    2. Mint 1 ticket.
    3. Wait for the confirmation popup.
    4. Poke.
    5. Wait for the confirmation popup.
    6. Refresh the contract list.

    Now, the proxy is calling the contract V2 and should return `hello` on the traces and no more `kiss`.

#### Set the old smart contract as obsolete

1. Add a new parameter on `proxy.parameterList.jsligo` to force the change of version of the old contract (:warning: replace below with your addresses for V1 and V2).

   ```jsligo
   const changeVersionV1ToV2: parameter_of Contract =
       Upgrade(
           [
               list([]) as list<Contract.entrypointOperation>,
               Some(
                   {
                       oldAddr: "KT1FqTZuuJCHz7Fe3J3AdpYgo2CGyhrJ6NAp" as address,
                       newAddr: "KT1GFn9rRsMGp1JFthymxCDxQLd2xrWoXXPw" as address
                   }
               ) as option<Contract.changeVersion>
           ]
       );
   ```

2. Compile.

   ```bash
   TAQ_LIGO_IMAGE=ligolang/ligo:1.6.0 taq compile proxy.jsligo
   taq call proxy --param proxy.parameter.changeVersionV1ToV2.tz -e testing
   ```

3. Check logs.

   ```logs
   ┌────────────────┬──────────────────────────────────────┬───────────────────────────────────────────────────────────────────────────────────────────────────────────┬────────────┬────────────────┬────────────────────────────────┐
   │ Contract Alias │ Contract Address                     │ Parameter                                                                                                 │ Entrypoint │ Mutez Transfer │ Destination                    │
   ├────────────────┼──────────────────────────────────────┼───────────────────────────────────────────────────────────────────────────────────────────────────────────┼────────────┼────────────────┼────────────────────────────────┤
   │ proxy          │ KT1Ego8vYEa4tPwkJirZfwxgJrqfmTcd8KMU │ (Left (Pair {}                                                                                            │ default    │ 0              │ https://ghostnet.ecadinfra.com │
   │                │                                      │             (Some (Pair "KT1FqTZuuJCHz7Fe3J3AdpYgo2CGyhrJ6NAp" "KT1GFn9rRsMGp1JFthymxCDxQLd2xrWoXXPw")))) │            │                │                                │
   │                │                                      │                                                                                                           │            │                │                                │
   └────────────────┴──────────────────────────────────────┴───────────────────────────────────────────────────────────────────────────────────────────────────────────┴────────────┴────────────────┴────────────────────────────────┘
   ```

4. Check on an indexer that the V1 `storage.tzip18.contractNext` is pointing to the next version address V2: [old V1 contract storage](https://ghostnet.tzkt.io/KT18ceGtUsNtQTk9smxQcaxAswRVkHDDKDgK/storage/).

   This ends the proxy pattern implementation. The old contract is no longer **runnable** and the proxy is pointing to the last version.

## Alternative: Composability

Managing a monolithic smart contract like a microservice can reduce the problem, on the other side it increases complexity and application lifecycle on the OPS side.

That's your tradeoff.

## Summary

Now, you can upgrade deployed contracts.


# Build a simple web application

This tutorial shows you how to create a simple web application that uses Tezos.
Specifically, this application will be the user-facing web front end for a bank application that accepts deposits and returns withdrawals of test tokens.

You will learn:

* How to create a web application and import libraries that access Tezos
* How to connect to a user's wallet
* How to send a transaction to a smart contract on behalf of a user
* How to get information from Tezos and show it on a web page

## Prerequisites

This tutorial uses JavaScript, so it will be easier if you are familiar with JavaScript.

You do not need any familiarity with any of the libraries in the tutorial, including [Taquito](https://tezostaquito.io/), a library that helps developers access Tezos.

## The tutorial application

In this tutorial, you build a web application that allows users to send test tokens to a simulated bank on Tezos and withdraw them later.

The application looks like this:

![Completed bank application, showing information about the user's wallet and buttons to deposit or withdraw tez](/img/tutorials/bank-app-complete.png)

The application connects to a user's cryptocurrency wallet and shows the balance of that wallet in Tezos's native currency, which is referred to as tez, by the ticker symbol XTZ, or the symbol ꜩ.
It provides an input field and slider for the user to select an amount of tez to deposit and a button to send the deposit transaction to Tezos.
It also provides a button to withdraw the amount from Tezos.

The application is based on JavaScript, so it uses several JS-based tools to build and package the application:

* **[Svelte](https://svelte.dev/)** for the JavaScript framework
* **[Vite](https://vitejs.dev/)** (pronounced like *veet*) to bundle the application and provide the libraries to the user's browser

To access the user's wallet and run transactions on Tezos, the application uses these libraries:

* **[Taquito](https://tezostaquito.io/)** to interact with the Tezos blockchain
* **[Beacon](https://docs.walletbeacon.io/)** to access users' wallets

The code for the completed application is in this GitHub repository: https://github.com/trilitech/tutorial-applications/tree/main/bank-tutorial.

When you're ready, move to the next section to begin setting up the application.


# Part 1: Setting up the application

You can access Tezos through any JavaScript framework.
This tutorial uses the Svelte framework, and the following steps show you how to start a Svelte application and add the Tezos-related dependencies.

## Setting up the app

1. Run these commands to install Svelte with TypeScript and Vite:

   ```bash
   npm create vite@latest bank-tutorial -- --template svelte
   cd bank-tutorial
   npm install
   ```

2. Install the Tezos-related dependencies:

   ```bash
   npm install @taquito/taquito @taquito/beacon-wallet @airgap/beacon-types
   ```

3. Install the `buffer`, `events`, and `vite-compatible-readable-stream` libraries:

   ```bash
   npm install --save-dev buffer events vite-compatible-readable-stream
   ```

4. Update the `vite.config.js` file to the following code:

   ```javascript
   import { defineConfig, mergeConfig } from "vite";
   import path from "path";
   import { svelte } from "@sveltejs/vite-plugin-svelte";

   export default ({ command }) => {
     const isBuild = command === "build";

     return defineConfig({
       plugins: [svelte()],
         define: {
           global: {}
         },
       build: {
         target: "esnext",
         commonjsOptions: {
           transformMixedEsModules: true
         }
       },
       server: {
         port: 4000
       },
       resolve: {
         alias: {
           "@airgap/beacon-types": path.resolve(
             path.resolve(),
             `./node_modules/@airgap/beacon-types/dist/${
             isBuild ? "esm" : "cjs"
             }/index.js`
           ),
           // polyfills
           "readable-stream": "vite-compatible-readable-stream",
           stream: "vite-compatible-readable-stream"
         }
       }
     });
   };
   ```

   This updated file includes these changes to the default Vite configuration:

   * It sets the `global` object to `{}` so the application can provide the value for this object in the HTML file
   * It includes the a path to the Beacon SDK
   * It provides polyfills for `readable-stream` and `stream`

5. Update the default HTML file `index.html` to the following code:

   ```html
   <!DOCTYPE html>
   <html lang="en">
     <head>
       <meta charset="UTF-8" />
       <link rel="icon" href="/favicon.ico" />
       <meta name="viewport" content="width=device-width, initial-scale=1.0" />
       <script>
         const global = globalThis;
       </script>
       <script type="module">
         import { Buffer } from "buffer";
         window.Buffer = Buffer;
       </script>
       <title>Tezos Bank dApp</title>
     </head>
     <body>
       <script type="module" src="/src/main.js"></script>
     </body>
   </html>
   ```

   This updated file sets the `global` variable to `globalThis` and adds a buffer object to the window.
   The Beacon SDK requires this configuration to run in a Vite app.

6. Replace the `src/main.js` file with this code:

   ```javascript
   import { mount } from 'svelte';
   import './app.css'
   import App from './App.svelte';

   const app = mount(App, { target: document.body });

   export default app
   ```

## Configuring Svelte

Svelte files include several different types of code in a single file.
The application's files have separate sections for JavaScript, style, and HTML code, as in this example:

```html
<script>
  // JavaScript or TypeScript code
</script>

<style>
  /* CSS or Sass code */
</style>

<main>
  <!-- HTML code -->
</main>
```

Svelte components are fully contained, which means that the style and code that you apply inside a component doesn't leak into the other components.
Styles and scripts that are shared among components typically go in the `src/styles` and `scripts` or `src/scripts` folders.

Follow these steps to set up the `src/App.svelte` file, which is the main component and container for other Svelte components:

1. Replace the default `src/App.svelte` file with this code:

   ```html
   <script>
   </script>

   <main>
   </main>

   <style>
   </style>
   ```

You will add code to connect to the user's wallet in the next section.


# Part 2: Accessing wallets

Accessing the user's wallet is a prerequisite for interacting with the Tezos blockchain.
Accessing the wallet allows your app to see the tokens in it and to prompt the user to submit transactions, but it does not give your app direct control over the wallet.
Users must still confirm all transactions in their wallet application.

Using a wallet application in this way saves you from having to implement payment processing and security in your application.
As you see in this section, it takes only a few lines of code to connect to a user's wallet.

## Creating and funding a wallet

To use the application, you need a wallet and some tez tokens.

1. Install a Tezos-compatible wallet.
   Which wallet you install is up to you and whether you want to install a wallet on your computer, in a browser extension, or as a mobile app.

   If you don't know which one to choose, try the [Temple](https://templewallet.com/) browser extension, because then you can use it in the same browser that you are using to view the web app.

   Desktop wallets for Tezos include the [Temple](https://templewallet.com/) browser extension, [Kukai](https://wallet.kukai.app/), and [Umami](https://umamiwallet.com/).

   Mobile apps include [Temple](https://templewallet.com/), [Kukai](https://wallet.kukai.app/), and [Umami](https://umamiwallet.com/).

2. Switch the wallet to use the Ghostnet testnet instead of Tezos Mainnet.
   Ghostnet is a network for testing Tezos applications where tokens are free so you don't have to spend real currency to work with your applications.

   For example, for the Temple browser wallet, click **Tezos Mainnet** at the top and then click **Ghostnet Testnet**, as in this picture:

   ![Selecting the Ghostnet testnet in the Temple wallet](/img/tutorials/temple-switch-network.png)

3. From your wallet, get the address of your account, which starts with `tz1`.
   This is the address that applications use to work with your wallet.

4. Go to the Ghostnet faucet page at https://faucet.ghostnet.teztnets.com.

5. On the faucet page, paste your wallet address into the input field labeled "Or fund any address" and click the button for the amount of tez to add to your wallet.
   20 tez is enough to work with the tutorial application, and you can return to the faucet later if you need more tez.

   It may take a few minutes for the faucet to send the tokens and for those tokens to appear in your wallet.

   You can use the faucet as much as you need to get tokens on the testnet, but those tokens are worthless and cannot be used on Mainnet.

   ![Fund your wallet using the Ghostnet Faucet](/img/tutorials/wallet-funding.png)

6. If you created a new account, initialize the account by sending any amount of tez to any other account.

   Before the new account can use dApps, it must send at least one transaction to Tezos.
   This first transaction reveals the public key that proves that transactions came from this account.

   If your account is new, you can send 1 tez to any other account, including your own account, via your wallet application to reveal the account.

Now you have an account and funds that you can use in dApps.

## Connecting to the user's wallet

In this section, you add code to connect to the user's wallet with the Taquito `TezosToolkit` and Beacon `BeaconWallet` objects.
Taquito accesses Tezos and Beacon accesses wallets.

IMPORTANT: however you design your app, it is essential to use a single instance of the `BeaconWallet` object.
It is also highly recommended use a single instance of the `TezosToolkit` object.
Creating multiple instances can cause problems in your app and with Taquito in general.

This application keeps these objects in the `App.svelte` file because this is the only component in the application.
If you add more components, you should move these objects to a separate file to maintain a single instance of them.

1. In the `src/App.svelte` file, add these imports to the `<script>` section:

   ```javascript
   import { BeaconWallet } from "@taquito/beacon-wallet";
   import { NetworkType } from "@airgap/beacon-types";
   import { TezosToolkit } from "@taquito/taquito";
   ```

2. Under those imports, create these constants that represent the Taquito toolkit's access to Tezos:

   ```javascript
   const rpcUrl = "https://ghostnet.ecadinfra.com";
   const Tezos = new TezosToolkit(rpcUrl);
   ```

3. Create variables to represent the wallet itself, its account address, and its balance:

   ```javascript
   let wallet;
   let address;
   let balance;
   ```

4. Still within the `<script>` section, add this function to connect to the user's wallet:

   ```javascript
   const connectWallet = async () => {
     const newWallet = new BeaconWallet({
       name: "Simple dApp tutorial",
       network: {
        type: NetworkType.GHOSTNET,
      },
     });
     await newWallet.requestPermissions();
     address = await newWallet.getPKH();
     getWalletBalance(address);
     wallet = newWallet;
   };
   ```

   This function creates an instance of the Beacon wallet toolkit, uses the `requestPermissions()` function to ask the user's permission to connect to it, and retrieves its address and balance.
   It provides a name for the app, which appears in the wallet UI when it asks the user to allow the connection.
   It also includes the network to use, such as the Tezos main network or test network.

5. Add this function to disconnect from the user's wallet:

   ```javascript
   const disconnectWallet = () => {
     wallet.client.clearActiveAccount();
     wallet = undefined;
   };
   ```

6. Add this function to get the wallet's balance:

   ```javascript
   const getWalletBalance = async (walletAddress) => {
     const balanceMutez = await Tezos.tz.getBalance(walletAddress);
     balance = balanceMutez.div(1000000).toFormat(2);
   };
   ```

7. Update the `<main>` section to have this code:

   ```html
   <h1>Tezos bank dApp</h1>

   <div class="card">
      {#if wallet}
       <p>The address of the connected wallet is {address}.</p>
       <p>Its balance in tez is {balance}.</p>
       <p>To get tez, go to <a href="https://faucet.ghostnet.teztnets.com/" target="_blank">
          https://faucet.ghostnet.teztnets.com/
         </a>.
       </p>
       <p>
         <button on:click={disconnectWallet}> Disconnect wallet </button>
       </p>
      {:else}
       <button on:click={connectWallet}> Connect wallet </button>
      {/if}
   </div>
   ```

   The `if` condition in this code shows a button to connect to a wallet if there is no connected wallet.
   If there is a connected wallet, it shows the address and balance of the wallet in tez.

   The application could connect immediately when the page loads, but it's better user experience to let the page load first and allow the user to connect the wallet when they trust the application.
   Connecting the wallet is harmless because it does not give the application any control over the user's account, but it is still better user experience to keep the user in control.
   For this reason, dApps should have prominent buttons to connect and disconnect wallets.

The complete `App.svelte` file looks like this:

```html
<script>
  import { BeaconWallet } from "@taquito/beacon-wallet";
  import { NetworkType } from "@airgap/beacon-types";
  import { TezosToolkit } from "@taquito/taquito";

  const rpcUrl = "https://ghostnet.ecadinfra.com";
  const Tezos = new TezosToolkit(rpcUrl);

  let wallet;
  let address;
  let balance;

  const connectWallet = async () => {
    const newWallet = new BeaconWallet({
      name: "Simple dApp tutorial",
      network: {
        type: NetworkType.GHOSTNET,
      },
    });
    await newWallet.requestPermissions();
    address = await newWallet.getPKH();
    getWalletBalance(address);
    wallet = newWallet;
  };

  const disconnectWallet = () => {
    wallet.client.clearActiveAccount();
    wallet = undefined;
  };

  const getWalletBalance = async (walletAddress) => {
    const balanceMutez = await Tezos.tz.getBalance(walletAddress);
    balance = balanceMutez.div(1000000).toFormat(2);
  };
</script>

<main>
  <h1>Tezos bank dApp</h1>

  <div class="card">
    {#if wallet}
      <p>The address of the connected wallet is {address}.</p>
      <p>Its balance in tez is {balance}.</p>
      <p>
        To get tez, go to <a
          href="https://faucet.ghostnet.teztnets.com/"
          target="_blank"
        >
          https://faucet.ghostnet.teztnets.com/
        </a>.
      </p>
      <p>
        <button on:click={disconnectWallet}> Disconnect wallet </button>
      </p>
    {:else}
      <button on:click={connectWallet}> Connect wallet </button>
    {/if}
  </div>
</main>

<style>
</style>
```

## Using the application

To try the application, run `npm run dev` and open the page http://localhost:4000/ in a web browser.

Because no wallet is connected, the app shows the "Connect wallet" button, as in this picture:

![The initial page of the bank dApp, showing a title and the button that connects to the user's wallet](/img/tutorials/bank-app-connect-button.png)

When you click **Connect wallet**, the `connectWallet` function runs and the Beacon toolkit opens, showing some of the types of wallets it can connect to:

![The Beacon wallet connection popup](/img/tutorials/beacon-connect-wallet-options.png)

The procedure for connecting each type of wallet is different.
For example, if you are using the Temple browser extension, you click **Temple** and then **Connect now**.
Then the Temple wallet shows a popup that allows you to confirm that you want to connect your wallet to the application, as in this picture:

![Connecting to the application in the Temple wallet](/img/tutorials/temple-connect-wallet.png)

Then the application runs the `getWalletBalance` function, which gets the wallet's balance in tez tokens.
Because the Svelte component's variables changed, the application refreshes automatically and shows the wallet address, balance, and "Disconnect wallet" button:

![The application showing information about the connected wallet](/img/tutorials/bank-app-first-connection.png)

If you click **Disconnect wallet**, the application goes back to its initial state.

Now the application can connect to user wallets.
In the next section, you add code to use the wallet to get the user's approval to send transactions to Tezos.

## Design considerations

Interacting with a wallet in a decentralized application is a new paradigm for many developers and users.
Follow these practices to make the process easier for users:

* Let users manually connect their wallets instead of prompting users to connect their wallet immediately when the app loads.
  Getting a wallet pop-up window before the user can see the page is annoying.
  Also, users may hesitate to connect a wallet before they have had time to look at and trust the application, even though connecting the wallet is harmless.

* Provide a prominent button to connect and disconnect wallets.

* Put the button in a predictable position, typically at the top right or left corner of the interface.

* Use "Connect" as the label for the button.
  Avoid words like "sync" because they can have different meanings in dApps.

* Display the status of the wallet clearly in the UI.
  You can also add information about the wallet, including token balances and the connected network for the user's convenience, as this tutorial application does.
  Showing information about the tokens and updating it after transactions allows the user to verify that the application is working properly.

* Enable and disable functions of the application based on the status of the wallet connection.
  For example, if the wallet is not connected, disable buttons for transactions that require a wallet connection.
  Also, disable transaction buttons while transactions are pending to prevent users from making duplicate transactions.


# Part 3: Sending transactions

Now that the application can connect to the user's wallet, it can get the user's approval to send transactions to Tezos with that wallet.

## The tutorial smart contract

This decentralized application (or dApp) uses a *smart contract* on Tezos, which is a type of program that runs on a blockchain.
This contract behaves like an API, because your application calls its entrypoints to run commands.

In this case, the smart contract was deployed for the purposes of this tutorial, so it is not a full-featured application.
It does two things to simulate a bank:

* It accepts deposits of tez tokens that users send and records how many tokens they sent.
* It accepts a request to withdraw tez and sends them back to the user's wallet.

The contract has two *entrypoints* for these functions, named "deposit" and "withdraw."
These entrypoints are like API endpoints or functions in a program: clients can call them and pass parameters to them.
However, unlike API endpoints and functions, they do not return a value.

## Steps for sending transactions

Sending transactions with Taquito involves these general steps:

1. Create an object that represents the smart contract to call.

2. Disable UI elements related to the transaction to prevent the user from sending duplicate transactions.

3. Create the transaction, including specifying this information:

   * The entrypoint to call
   * The parameters to pass
   * The amount of tez to pass, if any
   * Maximum amounts for the fees for the transaction

4. Send the transaction to the user's wallet for approval.

5. Wait for the transaction to complete.

6. Update information about the user's wallet and other details in the UI based on the result of the transaction.

7. Enable UI elements that were disabled during the transaction.

## Making a deposit transaction

Follow these steps to set up the application to send transactions to the deposit entrypoint:

1. In the `App.svelte` file, add the address of the contract as a constant with the other constants in the `<script>` section:

   ```javascript
   const contractAddress = "KT1R4i4qEaxF7v3zg1M8nTeyrqk8JFmdGLuu";
   ```

   The address of the deployed smart contract for this tutorial is `KT1R4i4qEaxF7v3zg1M8nTeyrqk8JFmdGLuu`.
   You can use this address to look up the status of the contract and see its storage and recent transactions on a block explorer such as https://better-call.dev/.
   For example, this is a link to information about the tutorial contract: https://better-call.dev/ghostnet/KT1R4i4qEaxF7v3zg1M8nTeyrqk8JFmdGLuu/operations.

2. Add variables to represent the amount that the user is depositing and the state of the UI button for the deposit:

   ```javascript
   let depositAmount = 1;
   let depositButtonActive = false;
   let depositButtonLabel = "Deposit";
   ```

3. Add this function to send the deposit transaction:

   ```javascript
   const deposit = async () => {
     depositButtonActive = false;
     depositButtonLabel = "Depositing...";

     Tezos.setWalletProvider(wallet);
     const contract = await Tezos.wallet.at(contractAddress);

     const transactionParams = await contract.methods
       .deposit()
       .toTransferParams({
         amount: depositAmount,
       });
     const estimate = await Tezos.estimate.transfer(transactionParams);

     const operation = await Tezos.wallet
       .transfer({
         ...transactionParams,
         ...estimate,
       })
       .send();

     console.log(`Waiting for ${operation.opHash} to be confirmed...`);

     await operation.confirmation(2);

     console.log(
       `Operation injected: https://ghost.tzstats.com/${operation.opHash}`
     );

     await getWalletBalance(address);
     depositButtonActive = true;
     depositButtonLabel = "Deposit";
   };
   ```

   This function does the general transaction steps from above:

   1. It changes variables to indicate the status of the transaction in the UI.
   2. It creates an object that represents the contract.
   3. It uses the `Tezos.estimate.transfer` method to estimate the fees for the transaction.
   4. It submits the transaction using the fee estimate and the amount of tez to send.
      Estimating the fees is important because the transaction must include the cost to increase the contract's storage in case this is the first time that the account is calling the contract.
      These fee amounts are only maximums; Tezos automatically takes the actual amount for fees from the account.
   5. It waits for the transaction to be confirmed.
      In this case, it waits for the transaction to appear in at least 2 Tezos blocks, which ensures that the transaction has been recorded permanently on the blockchain.
   6. It updates the UI with the new wallet balance.
   7. It changes variables to update the UI.

4. At the end of the `connectWallet` function, add code to enable the deposit button:

   ```javascript
   depositButtonActive = true;
   ```

   The updated `connectWallet` function looks like this:

   ```javascript
   const connectWallet = async () => {
     const newWallet = new BeaconWallet({
       name: "Simple dApp tutorial",
       network: {
        type: NetworkType.GHOSTNET,
      },
     });
     await newWallet.requestPermissions();
     address = await newWallet.getPKH();
     await getWalletBalance(address);
     wallet = newWallet;
     depositButtonActive = true;
   };
   ```

5. In the `<main>` section, after the link to the faucet, add this code:

   ```html
   <p>
     Deposit tez:
     <input type="number" bind:value={depositAmount} min="1" max="100" />
     <input type="range" bind:value={depositAmount} min="1" max="100" />
     <button on:click={deposit} disabled={!depositButtonActive}> {depositButtonLabel} </button>
   </p>
   ```

   This code creates an input field and slider to let the user select an amount from 1 to 100 tez.
   It also adds a button to start the transaction.

   The updated application looks like this:

   ![The updated application with fields to set the amount and a button to send the transaction](/img/tutorials/bank-app-deposit.png)

6. Send a deposit with your wallet using the application:

   1. Make sure the application is still running and open it in your web browser.
      Because you made changes to the application, it refreshes automatically and you must connect your wallet again.

   2. Connect your wallet.

   3. Note the amount of tez in your wallet currently.

   4. Select an amount of tez to send that is less than your current wallet balance.
      Note that you must select less tez than the total balance of your wallet because the transaction adds fees.

   5. Click **Deposit**.

      The wallet application prompts you to approve the transaction, including the amount of tez to send and the maximum amounts for the fees.
      For example, this is how the transaction looks in Temple wallet for sending 9 tez:

      ![The transaction in the Temple wallet, showing the fees and prompting the user to approve the transaction](/img/tutorials/bank-app-deposit-transaction.png)

      The "Deposit" button changes to "Depositing..." while it waits for the transaction to be completed.
      When it changes back to "Deposit," the transaction is complete.

   6. Note the new balance of your wallet.

## Making a withdrawal transaction

The process for making a withdrawal is simpler because the user does not need to select an amount.
Instead, the withdrawal entrypoint checks its storage to see how much the user has deposited and sends that amount back to the user's account.

1. Add variables to represent the state of the UI button for the withdrawal:

   ```javascript
   let withdrawButtonActive = true;
   let withdrawButtonLabel = "Withdraw";
   ```

2. Add this function to send the withdrawal transaction:

   ```javascript
   const withdraw = async () => {
     withdrawButtonActive = false;
     withdrawButtonLabel = "Withdrawing...";

     Tezos.setWalletProvider(wallet);
     const contract = await Tezos.wallet.at(contractAddress);

     const transactionParams = await contract.methods
       .withdraw()
       .toTransferParams();
     const estimate = await Tezos.estimate.transfer(transactionParams);

     const operation = await Tezos.wallet
       .transfer({
         ...transactionParams,
         ...estimate,
       })
       .send();

     console.log(`Waiting for ${operation.opHash} to be confirmed...`);

     await operation.confirmation(2);

     console.log(
       `Operation injected: https://ghost.tzstats.com/${operation.opHash}`
     );

     await getWalletBalance(address);
     withdrawButtonActive = true;
     withdrawButtonLabel = "Withdraw";
   }
   ```

   This function is similar to the `deposit` function with these main differences:

   * Instead of calling the `deposit` endpoint, it calls the `withdraw` endpoint.
   * It always sends 0 tez with the transaction.
   * It doesn't estimate the fees because this transaction does not result in a storage increase.

3. In the `<main>` section, after the deposit button, add a button to start the withdrawal transaction:

   ```html
   <p>
     Withdraw tez:
     <button on:click={withdraw} disabled={!withdrawButtonActive}> {withdrawButtonLabel} </button>
   </p>
   ```

4. Make a withdrawal by opening the application, connecting your wallet again, and clicking **Withdraw**.
   The application sends the withdrawal transaction and your wallet's balance in the app updates.

Now that the application can send transactions, in the next section, you improve the user interface by showing the user's balance in the bank.

Here is the completed code of the `App.svelte` file at the end of this section:

```html
<script>
  import { BeaconWallet } from "@taquito/beacon-wallet";
  import { NetworkType } from "@airgap/beacon-types";
  import { TezosToolkit } from "@taquito/taquito";

  const rpcUrl = "https://ghostnet.ecadinfra.com";
  const Tezos = new TezosToolkit(rpcUrl);
  const contractAddress = "KT1R4i4qEaxF7v3zg1M8nTeyrqk8JFmdGLuu";

  let wallet;
  let address;
  let balance;

  let depositAmount = 1;
  let depositButtonActive = false;
  let depositButtonLabel = "Deposit";

  let withdrawButtonActive = true;
  let withdrawButtonLabel = "Withdraw";

  const connectWallet = async () => {
    const newWallet = new BeaconWallet({
      name: "Simple dApp tutorial",
      network: {
        type: NetworkType.GHOSTNET,
      },
    });
    await newWallet.requestPermissions();
    address = await newWallet.getPKH();
    await getWalletBalance(address);
    wallet = newWallet;
    depositButtonActive = true;
  };

  const disconnectWallet = () => {
    wallet.client.clearActiveAccount();
    wallet = undefined;
  };

  const getWalletBalance = async (walletAddress) => {
    const balanceMutez = await Tezos.tz.getBalance(walletAddress);
    balance = balanceMutez.div(1000000).toFormat(2);
  };

  const deposit = async () => {
    depositButtonActive = false;
    depositButtonLabel = "Depositing...";

    Tezos.setWalletProvider(wallet);
    const contract = await Tezos.wallet.at(contractAddress);

    const transactionParams = await contract.methods
      .deposit()
      .toTransferParams({
        amount: depositAmount,
      });
    const estimate = await Tezos.estimate.transfer(transactionParams);

    const operation = await Tezos.wallet
      .transfer({
        ...transactionParams,
        ...estimate,
      })
      .send();

    console.log(`Waiting for ${operation.opHash} to be confirmed...`);

    await operation.confirmation(2);

    console.log(
      `Operation injected: https://ghost.tzstats.com/${operation.opHash}`
    );

    await getWalletBalance(address);
    depositButtonActive = true;
    depositButtonLabel = "Deposit";
  };

  const withdraw = async () => {
    withdrawButtonActive = false;
    withdrawButtonLabel = "Withdrawing...";

    Tezos.setWalletProvider(wallet);
    const contract = await Tezos.wallet.at(contractAddress);

    const transactionParams = await contract.methods
      .withdraw()
      .toTransferParams();
    const estimate = await Tezos.estimate.transfer(transactionParams);

    const operation = await Tezos.wallet
      .transfer({
        ...transactionParams,
        ...estimate,
      })
      .send();

    console.log(`Waiting for ${operation.opHash} to be confirmed...`);

    await operation.confirmation(2);

    console.log(
      `Operation injected: https://ghost.tzstats.com/${operation.opHash}`
    );

    await getWalletBalance(address);
    withdrawButtonActive = true;
    withdrawButtonLabel = "Withdraw";
  };
</script>

<main>
  <h1>Tezos bank dApp</h1>

  <div class="card">
    {#if wallet}
      <p>The address of the connected wallet is {address}.</p>
      <p>Its balance in tez is {balance}.</p>
      <p>
        To get tez, go to <a
          href="https://faucet.ghostnet.teztnets.com/"
          target="_blank"
        >
          https://faucet.ghostnet.teztnets.com/
        </a>.
      </p>
      <p>
        Deposit tez:
        <input type="number" bind:value={depositAmount} min="1" max="100" />
        <input type="range" bind:value={depositAmount} min="1" max="100" />
        <button on:click={deposit} disabled={!depositButtonActive}>
          {depositButtonLabel}
        </button>
      </p>
      <p>
        Withdraw tez:
        <button on:click={withdraw} disabled={!withdrawButtonActive}>
          {withdrawButtonLabel}
        </button>
      </p>
      <p>
        <button on:click={disconnectWallet}> Disconnect wallet </button>
      </p>
    {:else}
      <button on:click={connectWallet}> Connect wallet </button>
    {/if}
  </div>
</main>

<style>
</style>
```


# Part 4: Getting information

In this section, you improve the user experience of the application by providing information from Tezos on the page.
Specifically, you show the amount of tez that the user has stored in the smart contract and that is available to withdraw.

Your app can do this because information on Tezos is public, including the code of smart contracts and their data storage.

In this case, the contract's storage is a data type called a big-map.
It maps account addresses with a number that indicates the amount of tez that address has deposited.
Your app can query that amount by getting the contract's storage and looking up the value for the user's account.

You can look up the storage manually by going to a block explorer and going to the Storage tab.
For example, Better Call Dev shows the storage for this contract like this:

![The block explorer, showing the storage for the contract in one big-map object](/img/tutorials/bank-app-block-explorer-storage.png)

You can expand the big-map object and search for the record that is related to your account address to see how much tez you have deposited.

## Accessing the contract storage

Your application can use the Taquito library to access the storage for the contract and look up the user's balance in the contract:

1. In the `App.svelte` file, in the `<script>` section, add a `bankBalance` variable to represent the user's balance in the contract:

   ```javascript
   let bankBalance;
   ```

2. Add a function to access the contract's storage and get the user's balance:

   ```javascript
   const getBankBalance = async (walletAddress) => {
     const contract = await Tezos.wallet.at(contractAddress);
     const storage = await contract.storage();
     const balanceMutez = await storage.get(walletAddress);
     bankBalance = isNaN(balanceMutez) ? 0 : balanceMutez / 1000000;
   }
   ```

   Like the `deposit` and `withdraw` functions, this function creates an object that represents the contract.
   Then it retrieves the contract's storage.,
   In this case, the contract's storage is a [big-map](/smart-contracts/data-types/complex-data-types#big-maps), so Taquito represents it as a `BigMapAbstraction` object and the application uses the `get` method to look up a value from it.
   If it does not find a value, it sets the user's balance to 0.
   If it finds a value, it divides by 1 million because the contract stores values in mutez, which is 1 millionth of a tez.

   Your IDE may show an error on the `get` method because it is not aware of the data type of the storage and that it has this method.
   You can ignore this error.

3. Call the `getBankBalance` function at the end of the `deposit`, `withdraw`, and `connectWallet` functions by adding this line of code to each:

   ```javascript
   await getBankBalance(address);
   ```

4. In the `<main>` section, after the line that shows the wallet balance in tez, add this code to show the bank balance:

   ```html
   <p>Its balance in the bank is {bankBalance}.</p>
   ```

5. Open the application in a web browser, connect your wallet again, and see your balance in the contract.
   You can run deposits and withdrawals and see the amount change.
   If the amount does not change, make sure that you call the `getBankBalance` function after each transaction.

For example, this image shows the bank balance at 18 tez:

![The completed application with a connected wallet and a bank balance of 18 tez](/img/tutorials/bank-app-complete.png)

## Summary

Now you have an application that can:

* Connect to wallets
* Send transactions to Tezos
* Retrieve information about Tezos

The code for the completed application is in this GitHub repository: https://github.com/trilitech/tutorial-applications/tree/main/bank-tutorial.

If you want to continue with the application, you can try creating a better UI.
Here are some ideas:

* Prevent the user from selecting more tez to deposit than the wallet balance.
* Use the Taquito [`estimate`](https://tezostaquito.io/docs/transaction_limits) function to get an estimate of the fees for the transaction instead of hard-coding them.
* Show toasts or messages on the page to notify the user when transactions complete.

You can also deploy your own smart contracts to use from your applications.
For a tutorial on deploying a simple smart contract, see [Deploy a smart contract](/tutorials/smart-contract).


# Create a fungible token with the SmartPy FA2 library

This tutorial shows you how to use SmartPy's FA2 library to create standards-compliant tokens.

In this tutorial you will learn:

* What a fungible token is and how its contract works
* What the FA2 standard is and why token standards are important
* How to use the SmartPy FA2 library to create token contracts
* How to use a local sandbox to test contracts
* How to write custom token behaviors
* How to deploy the contract
* How to interact with tokens directly in wallet apps

## Prerequisites

To run this tutorial, you should have a basic understanding of how Tezos works, what blockchain tokens are, and the ability to use the command-line terminal on your computer.

If you haven't worked with smart contracts before, start with the tutorial https://docs.tezos.com/tutorials/smart-contract.

## What is a fungible token?

Fungible tokens are collections of identical, interchangeable tokens, just like one US dollar or Euro is the same as any other US dollar or Euro.
Any number of different accounts can each have a quantity of a certain fungible token.

By contrast, non-fungible tokens are unique and not interchangeable.
Therefore, only one account can own a specific NFT at one time.

The term "NFT" is often misused when assets are represented on blockchains, and is often confused with a fungible token.
Make sure that you understand the difference.

For more information about types of tokens, see [Tokens](/architecture/tokens).

## What is the FA2 standard?

FA2 is a standard interface for tokens on Tezos.
It supports several different token types, including fungible and non-fungible tokens.

Adhering to the FA2 standard allows developers to create new types of tokens while ensuring that the tokens work with existing wallets and applications.
The FA2 standard leaves enough freedom for developers to define rules for transferring tokens and for how tokens behave.

For more information about FA2 tokens, see [FA2 tokens](/architecture/tokens/FA2).

## What is the SmartPy FA2 library?

The SmartPy FA2 library provides classes and other tools to simplify creating FA2-compliant tokens in the SmartPy language.
You create a contract that inherits from a base class in the library to select a kind of token (fungible, single-asset, or non-fungible).
Then you inherit mixins to customize how the token works.

For more information about the SmartPy FA2 library, see [FA2 lib](https://smartpy.io/guides/FA2-lib/overview) in the SmartPy documentation.

## Tutorial application

In this tutorial, you use the SmartPy FA2 library to create a contract that manages multiple fungible tokens.
You add automated tests to the token, deploy it to a local sandbox, customize it further, and deploy it to a test network.
Finally, you work with the token in your own Tezos wallet.

The completed smart contracts are available here: https://github.com/trilitech/tutorial-applications/tree/main/smartpy_fa2_fungible

When you're ready, move to the next section to start setting up your token.


# Part 1: Setting up a simple FA2 token

In the first part of this tutorial, you create an FA2 token contact that has only the basic features that the standard requires.
For example, the standard does not require the contract to have `mint` and `burn` entrypoints that allow administrators to create and destroy tokens.
In this case, you create the contract with all of the tokens that it will ever have.

## Prerequisites

To run this part of the tutorial, makes sure that you have the following tools installed:

* [Python](https://www.python.org/) and the `pip` package manager
* [SmartPy](https://smartpy.io/manual/introduction/installation) version 0.20.0 or later; to verify the version of SmartPy you have installed, run `pip list | grep smartpy`

## Tutorial contract

The completed contract that you create in this part is at [part_1_complete.py](https://github.com/trilitech/tutorial-applications/blob/main/smartpy_fa2_fungible/part_1_complete.py).

## Using the library to create a contract

The FA2 library provides classes that you can extend to create your contract class.
Each class creates a certain type of token contract:

* `main.Nft`: Non-fungible tokens, which are unique digital assets
* `main.Fungible`: Fungible tokens, which are interchangeable assets, like tez or other cryptocurrencies
* `main.SingleAsset`: Single-asset tokens, which are a simplified case of fungible tokens, allowing only one token type per contract

Follow these steps to create your own token contract based on the `main.Fungible` base class:

1. Create a Python file with a `.py` extension, such as `fa2_fungible.py`, in any text editor.

2. In the file, import SmartPy and its FA2 modules:

   ```smartpy
   import smartpy as sp
   from smartpy.templates import fa2_lib as fa2

   # Alias the main template for FA2 contracts
   main = fa2.main
   ```

3. Create a SmartPy module to store your contract class and import the FA2 module:

   ```smartpy
   @sp.module
   def my_module():
       import main
   ```

4. In the module, create a contract class that inherits from the base class and the `OnchainviewBalanceOf` class, which provides an on-chain view that provides token balances:

   ```smartpy
   class MyFungibleContract(
       main.Fungible,
       main.OnchainviewBalanceOf,
   ):
   ```

5. Create the contract's `__init__()` method and initialize the superclasses:

   ```smartpy
   def __init__(self, contract_metadata, ledger, token_metadata):

       # Initialize on-chain balance view
       main.OnchainviewBalanceOf.__init__(self)

       # Initialize fungible token base class
       main.Fungible.__init__(self, contract_metadata, ledger, token_metadata)
   ```

   Note the order of these classes both in the `class` statement and within the `__init__()` method.
   You must inherit and initialize these classes in a specific order for them to work, as described in [Mixins](https://smartpy.io/manual/libraries/FA2-lib/mixins).

6. Outside the module, add these two utility functions to call views in the contract:

   ```smartpy
   def _get_balance(fa2_contract, args):
       """Utility function to call the contract's get_balance view to get an account's token balance."""
       return sp.View(fa2_contract, "get_balance")(args)


   def _total_supply(fa2_contract, args):
       """Utility function to call the contract's total_supply view to get the total amount of tokens."""
       return sp.View(fa2_contract, "total_supply")(args)
   ```

At this point, the contract looks like this:

```smartpy
import smartpy as sp
from smartpy.templates import fa2_lib as fa2

# Alias the main template for FA2 contracts
main = fa2.main

@sp.module
def my_module():
    import main

    class MyFungibleContract(
        main.Fungible,
        main.OnchainviewBalanceOf,
    ):
        def __init__(self, contract_metadata, ledger, token_metadata):

            # Initialize on-chain balance view
            main.OnchainviewBalanceOf.__init__(self)

            # Initialize fungible token base class
            main.Fungible.__init__(self, contract_metadata, ledger, token_metadata)


def _get_balance(fa2_contract, args):
    """Utility function to call the contract's get_balance view to get an account's token balance."""
    return sp.View(fa2_contract, "get_balance")(args)


def _total_supply(fa2_contract, args):
    """Utility function to call the contract's total_supply view to get the total amount of tokens."""
    return sp.View(fa2_contract, "total_supply")(args)
```

Indentation is significant in Python, so make sure that your contract is indented like this example.

This short contract is all of the necessary code for a basic FA2 token contract.
The inherited classes provide all of the necessary entrypoints.

## Adding the contract to a test scenario

SmartPy provides a testing framework that runs contracts in a realistic simulation called a test scenario.
This test scenario is also the way SmartPy compiles contracts to Michelson for deployment, so you must add your contract to a test scenario.

1. At the end of the contract file, define a test scenario function with this code:

   ```smartpy
   @sp.add_test()
   def test():
   ```

   The code within this scenario is ordinary Python, not SmartPy, so you can do all of the things that you can normally do in Python, including importing modules and calling external APIs.
   Code within a SmartPy module (annotated with `@sp.module`) is SmartPy code and is limited by what you can do in smart contracts.
   Importing modules and calling external APIs isn't possible in SmartPy modules, except for the modules that SmartPy provides.

2. Inside the test scenario function, initialize the test scenario by passing a name for the scenario and the module to use in the scenario to the `sp.test_scenario` function:

   ```smartpy
   # Create and configure the test scenario
   scenario = sp.test_scenario("fa2_lib_fungible", my_module)
   ```

3. Define test accounts to use in the scenario with the `sp.test_account` function:

   ```smartpy
   # Define test accounts
   alice = sp.test_account("Alice")
   bob = sp.test_account("Bob")
   ```

4. Set up token metadata, which describes the tokens to users.
   For example, these lines create metadata for two token types, named `Token Zero` and `Token One`:

   ```smartpy
   # Define initial token metadata
   tok0_md = fa2.make_metadata(name="Token Zero", decimals=0, symbol="Tok0")
   tok1_md = fa2.make_metadata(name="Token One", decimals=0, symbol="Tok1")
   ```

   The `fa2.make_metadata` function creates a token metadata object that complies with the [TZIP-12](https://gitlab.com/tezos/tzip/-/blob/master/proposals/tzip-12/tzip-12.md) standard.

   Your contract can have as many types of fungible tokens as you want, but the examples in this tutorial use these two token types.
   The contract assigns them numeric IDs starting at 0.

5. Create the starting ledger for the contract, which lists the tokens and their owners.
   This example gives 10 of token 0 to the Alice test account and 10 of token 1 to the Bob test account:

   ```smartpy
   # Define tokens and initial owners
   initial_ledger = {
       (alice.address, 0): 10,
       (bob.address, 1): 10,
   }
   ```

   The type of this ledger is set by the FA2 standard, so casting it to the `ledger_fungible` type helps you make sure that your ledger matches the standard.

   The ledger is a big map where the key is a pair of the token owner and token ID and the value is the amount of tokens.
   In table format, the ledger looks like this:

   key | value
   \--- | ---
   Alice, token ID 0 | 10
   Bob, token ID 1 | 10

   You can distribute tokens to any accounts that you want in the test scenario.
   Because the contract has no `mint` entrypoint, this initial ledger defines all of the tokens and token types that the contract contains.

6. Create an instance of the contract in the test scenario and pass the values for its initial storage:

   ```smartpy
   # Instantiate the FA2 fungible token contract
   contract = my_module.MyFungibleContract(sp.big_map(), initial_ledger, [tok0_md, tok1_md])
   ```

   These are the parameters for the contract's `__init__()` method:

   * The contract metadata, which is blank for now
   * The initial ledger
   * The metadata for the token types, in a list

7. Add the contract to the test scenario, which deploys (originates) it to the simulated Tezos environment:

   ```smartpy
   # Originate the contract in the test scenario
   scenario += contract
   ```

At this point, the contract looks like this:

```smartpy
import smartpy as sp
from smartpy.templates import fa2_lib as fa2

# Alias the main template for FA2 contracts
main = fa2.main

@sp.module
def my_module():
    import main

    class MyFungibleContract(
        main.Fungible,
        main.OnchainviewBalanceOf,
    ):
        def __init__(self, contract_metadata, ledger, token_metadata):

            # Initialize on-chain balance view
            main.OnchainviewBalanceOf.__init__(self)

            # Initialize fungible token base class
            main.Fungible.__init__(self, contract_metadata, ledger, token_metadata)


def _get_balance(fa2_contract, args):
    """Utility function to call the contract's get_balance view to get an account's token balance."""
    return sp.View(fa2_contract, "get_balance")(args)


def _total_supply(fa2_contract, args):
    """Utility function to call the contract's total_supply view to get the total amount of tokens."""
    return sp.View(fa2_contract, "total_supply")(args)


@sp.add_test()
def test():
    # Create and configure the test scenario
    scenario = sp.test_scenario("fa2_lib_fungible", my_module)

    # Define test accounts
    alice = sp.test_account("Alice")
    bob = sp.test_account("Bob")

    # Define initial token metadata
    tok0_md = fa2.make_metadata(name="Token Zero", decimals=0, symbol="Tok0")
    tok1_md = fa2.make_metadata(name="Token One", decimals=0, symbol="Tok1")

    # Define tokens and initial owners
    initial_ledger = {
        (alice.address, 0): 10,
        (bob.address, 1): 10,
    }

    # Instantiate the FA2 fungible token contract
    contract = my_module.MyFungibleContract(sp.big_map(), initial_ledger, [tok0_md, tok1_md])

    # Originate the contract in the test scenario
    scenario += contract
```

## Adding tests

SmartPy has built-in tools for testing contracts as part of the test scenario.
In test scenarios, you can call contract entrypoints, verify the contract storage, and do other things to make sure that the contract is working as expected.

Follow these steps to add tests to the contract:

1. At the end of the file, add this code to verify the initial state of the ledger:

   ```smartpy
   scenario.h2("Verify the initial owners of the tokens")
   scenario.verify(
       _get_balance(contract, sp.record(owner=alice.address, token_id=0)) == 10
   )
   scenario.verify(
       _get_balance(contract, sp.record(owner=bob.address, token_id=0)) == 0
   )
   scenario.verify(
       _get_balance(contract, sp.record(owner=alice.address, token_id=1)) == 0
   )
   scenario.verify(
       _get_balance(contract, sp.record(owner=bob.address, token_id=1)) == 10
   )
   scenario.verify(_total_supply(contract, sp.record(token_id=0)) == 10)
   scenario.verify(_total_supply(contract, sp.record(token_id=1)) == 10)
   ```

   This code uses the `get_balance_of` and `total_supply` views to check the current owners of the tokens and the total amount of tokens when the contract is deployed.

   Note that the calls to these views are within the `scenario.verify` function.
   To verify details about the deployed contract, you must use this function to access the state of the contract within the test scenario.

2. Add this code to call the contract's `transfer` entrypoint and verify that the tokens transferred correctly:

   ```smartpy
   scenario.h2("Transfer tokens")
   # Bob sends 3 of token 1 to Alice
   contract.transfer(
       [
           sp.record(
               from_=bob.address,
               txs=[sp.record(to_=alice.address, amount=3, token_id=1)],
           ),
       ],
       _sender=bob,
   )
   scenario.verify(
       _get_balance(contract, sp.record(owner=alice.address, token_id=0)) == 10
   )
   scenario.verify(
       _get_balance(contract, sp.record(owner=bob.address, token_id=0)) == 0
   )
   scenario.verify(
       _get_balance(contract, sp.record(owner=alice.address, token_id=1)) == 3
   )
   scenario.verify(
       _get_balance(contract, sp.record(owner=bob.address, token_id=1)) == 7
   )
   scenario.verify(_total_supply(contract, sp.record(token_id=0)) == 10)
   scenario.verify(_total_supply(contract, sp.record(token_id=1)) == 10)

   # Alice sends 4 of token 0 to Bob
   contract.transfer(
       [
           sp.record(
               from_=alice.address,
               txs=[sp.record(to_=bob.address, amount=4, token_id=0)],
           ),
       ],
       _sender=alice,
   )
   scenario.verify(
       _get_balance(contract, sp.record(owner=alice.address, token_id=0)) == 6
   )
   scenario.verify(
       _get_balance(contract, sp.record(owner=bob.address, token_id=0)) == 4
   )
   scenario.verify(
       _get_balance(contract, sp.record(owner=alice.address, token_id=1)) == 3
   )
   scenario.verify(
       _get_balance(contract, sp.record(owner=bob.address, token_id=1)) == 7
   )
   scenario.verify(_total_supply(contract, sp.record(token_id=0)) == 10)
   scenario.verify(_total_supply(contract, sp.record(token_id=1)) == 10)
   ```

   This code calls the transfer entrypoint, passes the transfer information, and adds the `_sender=bob` parameter to indicate that the transfer came from Bob's account.
   Then it calls the contract's views again to verify that the tokens were transferred and that the total supply of tokens remains the same.
   Then it tries again from Alice's account.

3. Test an entrypoint call that should fail by adding this code:

   ```smartpy
   # Bob cannot transfer Alice's tokens
   contract.transfer(
       [
           sp.record(
               from_=alice.address,
               txs=[sp.record(to_=bob.address, amount=1, token_id=0)],
           ),
       ],
       _sender=bob,
       _valid=False,
   )
   ```

   This call should fail because it comes from Bob's account but the call tries to transfer tokens out of Alice's account.
   The call includes the `_valid=False` parameter to indicate that this call should fail.

You can add any number of tests to your test scenario.
In practice, you should test all features of your contract thoroughly to identify any problems before deployment.

## Compiling the contract

To compile the contract, use the `python` command, just like any other Python file:

```bash
python fa2_fungible.py
```

If SmartPy compiles your contract successfully, nothing is printed to the command line output.
Its compiler writes your contract to a folder with the name in the `sp.test_scenario` function, which is `fa2_lib_fungible` in this example.
This folder has many files, including:

* `log.txt`: A compilation log that lists the steps in the test scenario and connects them to the other files that the compiler created.
* `step_003_cont_0_contract.tz`: The compiled Michelson contract, which is what you deploy to Tezos in the next section.
  The compiler also creates a JSON version of the compiled contract.
* `step_003_cont_0_storage.tz`: The compiled Michelson value of the initial contract storage, based on the parameters you passed when you instantiated the contract in the test scenario.
  The compiler also creates a JSON and Python version of the storage.
* `step_003_cont_0_types.py`: The Python types that the contract uses, which can help you call the contract from other SmartPy contracts.

You can use the compiled contract and storage files to deploy the contract.
In the next section, you deploy the contract to a local Tezos sandbox.

## Troubleshooting

If the `python` command shows any errors, make sure that your contract matches the example.
In particular, check your indentation, because indentation is significant in Python and SmartPy.

You can compare your contract with the completed contract here: [part_1_complete.py](https://github.com/trilitech/tutorial-applications/blob/main/smartpy_fa2_fungible/part_1_complete.py).

<!-- TODO more troubleshooting -->

## (Optional) Deploy the contract to the Octez client mockup mode

The Octez client provides a few local sandbox modes that you can use to test contracts without uploading them to a test network or running a local Tezos environment.

Follow these steps to set up the Octez client mockup mode and deploy the contract to it:

1. Install the Octez client by following the steps in [Installing the Octez client](/developing/octez-client/installing).

2. Set up the Octez client mockup mode:

   1. Run this command to start mockup mode:

      ```bash
      octez-client \
        --protocol ProtoALphaALphaALphaALphaALphaALphaALphaALphaDdp3zK \
        --base-dir /tmp/mockup \
        --mode mockup \
        create mockup
      ```

      Now you can run commands in mockup mode by prefixing them with `octez-client --mode mockup --base-dir /tmp/mockup`.

   2. Create an alias for mockup mode:

      ```bash
      alias mockup-client='octez-client --mode mockup --base-dir /tmp/mockup'
      ```

      Now you can run commands in mockup mode with the `mockup-client` alias, as in this example:

      ```bash
      mockup-client list known addresses
      ```

3. Deploy the contract to mockup mode:

   1. Create two Octez accounts to represent the Alice and Bob accounts in the test scenario:

      ```bash
      mockup-client gen keys alice
      mockup-client gen keys bob
      ```

   2. Get the addresses for Alice and Bob by running this command:

      ```bash
      mockup-client list known addresses
      ```

   3. Replace the addresses in the initial storage value in the `step_003_cont_0_storage.tz` file with the mockup addresses.
      For example, the file might look like this:

      ```michelson
      (Pair {Elt (Pair "tz1Utg2AKcbLgVokY7J8QiCjcfo5KHk3VtHU" 1) 10; Elt (Pair "tz1XeaZgLqgCqMA3Egz5Q7bqiqdFefaNoQd5" 0) 10} (Pair {} (Pair 2 (Pair {} (Pair {Elt 0 10; Elt 1 10} {Elt 0 (Pair 0 {Elt "decimals" 0x30; Elt "name" 0x546f6b656e205a65726f; Elt "symbol" 0x546f6b30}); Elt 1 (Pair 1 {Elt "decimals" 0x30; Elt "name" 0x546f6b656e204f6e65; Elt "symbol" 0x546f6b31})})))))
      ```

      Now you can use this file as the initial storage value and give the initial tokens to the mockup addresses.

   4. Deploy the contract by passing the compiled contract and initial storage value to the `originate contract` command.
      For example, if your compiled files are in the `fa2_lib_fungible` folder, the command looks like this:

      ```bash
      mockup-client originate contract smartpy_fa2_fungible \
        transferring 0 from bootstrap1 \
        running fa2_lib_fungible/step_003_cont_0_contract.tz \
        --init "$(cat fa2_lib_fungible/step_003_cont_0_storage.tz)" --burn-cap 3 --force
      ```

      If you see errors that refer to unexpected characters, make sure the paths to the files are correct and that you changed only the content of addresses inside quotes in the storage file.

      If you see the error "Keys in a map literal must be in strictly ascending order, but they were unordered in literal," reverse the order of the two addresses.

      If the deployment succeeds, the Octez client prints the address of the contract and aliases it as `smartpy_fa2_fungible`.

   5. Use the built-in `get_balance_of` view to see the tokens that one of the accounts owns:

      ```bash
      mockup-client run view get_balance_of \
        on contract smartpy_fa2_fungible \
        with input '{Pair "tz1Utg2AKcbLgVokY7J8QiCjcfo5KHk3VtHU" 1}'
      ```

      The response shows a Michelson value that includes the ID and amount of tokens that the address owns, as in this example:

      ```michelson
      { Pair (Pair "tz1Utg2AKcbLgVokY7J8QiCjcfo5KHk3VtHU" 1) 10 }
      ```

   <!-- TODO make a transaction or wait? We'd have to send tez from bootstrap to alice and then get the addresses right in the param file. -->

For more information, see [Mockup mode](https://octez.tezos.com/docs/user/mockup.html) in the Octez documentation.

Now you have a basic FA2 fungible token contract that starts with a predefined amount of tokens.

In the next part, you add minting and burning functionality to the contract so an administrator can create and destroy tokens.


# Part 2: Adding minting and burning entrypoints

In this part, you add entrypoints that allow an administrator account to create tokens and allow users to burn their own tokens.

The SmartPy FA2 library provides *mixins* that add these entrypoints so you don't have to code them yourself.
Mixins are modular classes that add specific pieces of functionality.

## Tutorial contract

The completed contract that you create in this part is at [part_2_complete.py](https://github.com/trilitech/tutorial-applications/blob/main/smartpy_fa2_fungible/part_2_complete.py).

## Adding the admin, mint, and burn entrypoints

To add mint and burn entrypoints to the contract, you need three mixins: the mixins for those two entrypoints and a mixin that enables administrator functionality.
Only the admin account can mint tokens, but anyone can burn their own tokens.

1. In the contract, update the `class` statement to include the new mixins:

   ```smartpy
   # Order of inheritance: [Admin], [<policy>], <base class>, [<other mixins>].
   class MyFungibleContract(
       main.Admin,
       main.Fungible,
       main.MintFungible,
       main.BurnFungible,
       main.OnchainviewBalanceOf,
   ):
   ```

2. Update the `__init__()` function to accept the admin address and initialize the mixins:

   ```smartpy
   def __init__(self, admin_address, contract_metadata, ledger, token_metadata):

       # Initialize on-chain balance view
       main.OnchainviewBalanceOf.__init__(self)

       # Initialize the fungible token-specific entrypoints
       main.BurnFungible.__init__(self)
       main.MintFungible.__init__(self)

       # Initialize fungible token base class
       main.Fungible.__init__(self, contract_metadata, ledger, token_metadata)

       # Initialize administrative permissions
       main.Admin.__init__(self, admin_address)
   ```

   The order that you import and initialize the mixins is significant, so make sure your updates match the code above.

3. In the test scenario, add an administrator test account to the existing Alice and Bob test accounts:

   ```smartpy
   # Define test accounts
   admin = sp.test_account("Admin")
   alice = sp.test_account("Alice")
   bob = sp.test_account("Bob")
   ```

4. Update the command to deploy the contract to include the administrator address:

   ```smartpy
   # Instantiate the FA2 fungible token contract
   contract = my_module.MyFungibleContract(admin.address, sp.big_map(), initial_ledger, [tok0_md, tok1_md])
   ```

5. At the end of the test scenario, add a test to verify that the admin account can mint more of an existing token:

   ```smartpy
   scenario.h2("Mint tokens")

   # Mint more of an existing token
   contract.mint(
       [
           sp.record(to_=alice.address, amount=4, token=sp.variant("existing", 0)),
           sp.record(to_=bob.address, amount=4, token=sp.variant("existing", 1)),
       ],
       _sender=admin,
   )
   scenario.verify(
       _get_balance(contract, sp.record(owner=alice.address, token_id=0)) == 10
   )
   scenario.verify(
       _get_balance(contract, sp.record(owner=bob.address, token_id=0)) == 4
   )
   scenario.verify(
       _get_balance(contract, sp.record(owner=alice.address, token_id=1)) == 3
   )
   scenario.verify(
       _get_balance(contract, sp.record(owner=bob.address, token_id=1)) == 11
   )
   scenario.verify(_total_supply(contract, sp.record(token_id=0)) == 14)
   scenario.verify(_total_supply(contract, sp.record(token_id=1)) == 14)
   ```

6. Add a test to verify that other users can't mint tokens:

   ```smartpy
   # Other users can't mint tokens
   contract.mint(
       [
           sp.record(to_=alice.address, amount=4, token=sp.variant("existing", 0)),
       ],
       _sender=alice,
       _valid=False
   )
   ```

7. Add a test to verify that the admin account can create a new token type:

   ```smartpy
   # Create a token type
   tok2_md = fa2.make_metadata(name="Token Two", decimals=0, symbol="Tok2")
   contract.mint(
       [
           sp.record(to_=alice.address, amount=5, token=sp.variant("new", tok2_md)),
       ],
       _sender=admin,
   )
   scenario.verify(
       _get_balance(contract, sp.record(owner=alice.address, token_id=2)) == 5
   )
   ```

8. Add a test to verify that users can burn their tokens but not other accounts' tokens:

   ```smartpy
   scenario.h2("Burn tokens")

   # Verify that you can burn your own token
   contract.burn([sp.record(token_id=2, from_=alice.address, amount=1)], _sender=alice)
   scenario.verify(
       _get_balance(contract, sp.record(owner=alice.address, token_id=2)) == 4
   )
   # Verify that you can't burn someone else's token
   contract.burn(
       [sp.record(token_id=2, from_=alice.address, amount=1)],
       _sender=bob,
       _valid=False,
   )
   scenario.verify(
       _get_balance(contract, sp.record(owner=alice.address, token_id=2)) == 4
   )
   scenario.verify(
       _total_supply(contract, sp.record(token_id=2)) == 4
   )
   ```

9. Run the `python fa2_fungible.py` command to compile and test your contract.
   If you see any errors, make sure that your code matches the code above or compare with the completed contract here: [part_2_complete.py](https://github.com/trilitech/tutorial-applications/blob/main/smartpy_fa2_fungible/part_2_complete.py).

Note that there are many more output files in the `fa2_lib_fungible` folder.
The SmartPy compiler creates output files for each call to an entrypoint in the test scenario.
You can use these files to verify that the scenario is testing the contract properly.

You can also use these files as precompiled parameters for contract calls, as shown in the next section.

## (Optional) Test the contract in the Octez client mockup mode

You can test the mint and burn entrypoints in mockup mode, but you must be sure to deploy the contract with an address that you can use as the administrator, as described in these steps:

1. Get the address of one of the existing bootstrap accounts in the mockup by running this command:

   ```bash
   mockup-client list known addresses
   ```

2. Replace the first address in the initial storage value in the `step_003_cont_0_storage.tz` file with the bootstrap account address.
   For example, the file might look like this, with `tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx` as the bootstrap account:

   ```michelson
   (Pair "tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx" (Pair {Elt (Pair "tz1Rp4Bv8iUhYnNoCryHQgNzN2D7i3L1LF9C" 1) 10; Elt (Pair "tz1WxrQuZ4CK1MBUa2GqUWK1yJ4J6EtG1Gwi" 0) 10} (Pair {} (Pair 2 (Pair {} (Pair {Elt 0 10; Elt 1 10} {Elt 0 (Pair 0 {Elt "decimals" 0x30; Elt "name" 0x546f6b656e205a65726f; Elt "symbol" 0x546f6b30}); Elt 1 (Pair 1 {Elt "decimals" 0x30; Elt "name" 0x546f6b656e204f6e65; Elt "symbol" 0x546f6b31})}))))))
   ```

3. Deploy the contract by running this command:

   ```bash
   mockup-client originate contract smartpy_fa2_fungible \
     transferring 0 from bootstrap1 \
     running fa2_lib_fungible/step_003_cont_0_contract.tz \
     --init "$(cat fa2_lib_fungible/step_003_cont_0_storage.tz)" --burn-cap 3 --force
   ```

4. Mint more of an existing token by following these steps:

   1. Open the file `fa2_lib_fungible/log.txt`.

   2. Find the output file that shows the parameters for the call to the `mint` entrypoint.
      For example, this logging information shows that the parameters are in the file `fa2_lib_fungible/step_028_cont_0_params.tz`:

      ```
      h2: Mint tokens
      file fa2_lib_fungible/step_028_cont_0_params.py
      file fa2_lib_fungible/step_028_cont_0_params.tz
      file fa2_lib_fungible/step_028_cont_0_params.json
      Executing mint([sp.record(to_ = sp.address('tz1WxrQuZ4CK1MBUa2GqUWK1yJ4J6EtG1Gwi'), token = existing(0), amount = 4), sp.record(to_ = sp.address('tz1Rp4Bv8iUhYnNoCryHQgNzN2D7i3L1LF9C'), token = existing(1), amount = 4)])...
      ```

   3. Use that output file as the parameter for a call to the `mint` entrypoint.
      For example, this command uses the file `fa2_lib_fungible/step_028_cont_0_params.tz`:

      ```bash
      mockup-client --wait none transfer 0 \
        from bootstrap1 to smartpy_fa2_fungible --entrypoint "mint" \
        --arg "$(cat fa2_lib_fungible/step_028_cont_0_params.tz)" --burn-cap 2
      ```

   4. Run this command to use the `get_balance_of` view to see that the tokens have been minted and added to the account:

      ```bash
      mockup-client run view get_balance_of on contract smartpy_fa2_fungible with input '{Pair "tz1WxrQuZ4CK1MBUa2GqUWK1yJ4J6EtG1Gwi" 0}'
      ```

      The response shows that the account now has 14 of token type 0:

      ```michelson
      { Pair (Pair "tz1WxrQuZ4CK1MBUa2GqUWK1yJ4J6EtG1Gwi" 0) 14 }
      ```

Now you have an FA2 token contract with minting and burning functionality.
In the next part, you add metadata to provide information about the contract and its tokens to apps such as wallets.


# Part 3: Adding metadata

In this part, you configure the metadata for the contract.

Contract metadata provides details about the contract itself, including its name, description, and what standards it follows.
This information lets off-chain applications like wallets and block explorers show information about the contract.
Contracts can also store other information in metadata, including the code for off-chain views and information about error messages.

Contracts that manage tokens also store metadata about those tokens, including descriptions of the tokens and links to preview media.

Generally, contracts store their metadata and token metadata off-chain and include only a link to it in their storage.
Storing the metadata off-chain saves space and makes it easier for off-chain applications to access it.

## Storing metadata with IPFS

Many contracts store metadata with the InterPlanetary File System (IPFS) protocol.
This protocol stores files in a decentralized peer-to-peer network and indexes them by their hash.
That way, users can access media by its hash, and the hash allows them to verify that the files have not changed.
As long as one IPFS user has a copy of the data, they can re-upload it to IPFS with the same hash so it is seamlessly available again.

Therefore, uploading data to IPFS doesn't mean that it will be available forever; at least one user must keep a copy of it.
Instructing an IPFS node to keep a copy of a file is called *pinning* the file.
SmartPy provides a function that uploads data to IPFS via the Pinata service and instructs Pinata to pin it.

## Tutorial contract

The completed contract that you create in this part is at [part_3_complete.py](https://github.com/trilitech/tutorial-applications/blob/main/smartpy_fa2_fungible/part_3_complete.py).

## Getting a Pinata API key

SmartPy test scenarios can upload files to IPFS with [Pinata](https://www.pinata.cloud/), so to follow this part of the tutorial, you need a free account on https://www.pinata.cloud and an API key.

Follow these steps to create a Pinata API key:

1. Create a free Pinata account at https://app.pinata.cloud/developers/api-keys.

2. Go to the API Keys tab and click **New Key**.

3. On the Create New API Key page, expand API Endpoint Access and enable the `pinFileToIPFS` permission, as in this picture:

   <img src="/img/tutorials/pinata-key-permissions.png" alt="Selecting the permissions for the Pinata key" style={{width: 300}} />

4. In the **Key Name** field, give the key a name, such as "My Key."

5. Click **Create Key**.

   The API Key Info window shows the API key and secret, which you must copy immediately, because it is not shown again.

6. Copy the API Key and API Secret fields and save the values on your computer.
   You need these values in the next section.

   You can see the new API key on the API Keys tab:

   ![The new Pinata API key in the Pinata web app](/img/tutorials/created-pinata-key.png)

## Uploading metadata

The SmartPy `sp.pin_on_ipfs` function uploads metadata to IPFS via your Pinata account and "pins" it to ensure that it remains available until you remove it.
In this section, you add code to use this function to upload and pin contract metadata to IPFS when the test scenario runs.
It is still advisable to save a local copy of your metadata, just as you would with any upload service.

1. After the code that instantiates the contract in the test scenario, use the `sp.create_tzip16_metadata` function to create a metadata object that is compatible with the [TZIP-16](https://gitlab.com/tezos/tzip/-/blob/master/proposals/tzip-16/tzip-16.md) standard for contract metadata:

   ```smartpy
   # Build contract metadata content
   contract_metadata = sp.create_tzip16_metadata(
       name="My FA2 fungible token contract",
       description="This is an FA2 fungible token contract using SmartPy.",
       version="1.0.0",
       license_name="CC-BY-SA",
       license_details="Creative Commons Attribution Share Alike license 4.0 https://creativecommons.org/licenses/by/4.0/",
       interfaces=["TZIP-012", "TZIP-016"],
       authors=["SmartPy <https://smartpy.io/#contact>"],
       homepage="https://smartpy.io/ide?template=fa2_lib_fungible.py",
       # Optionally, upload the source code to IPFS and add the URI here
       source_uri=None,
       offchain_views=contract.get_offchain_views(),
   )
   ```

   This code must come after you create the contract but before you add the contract to the scenario because it uses the `contract.get_offchain_views` function to retrieve the contract's off-chain views.
   Off-chain views are stored in metadata, not in the contract code or storage.

2. Optional: Edit the metadata fields with information about your contract.

3. Add permission information to the metadata with this code:

   ```smartpy
   # Add the info specific to FA2 permissions
   contract_metadata["permissions"] = {
       # The operator policy chosen:
       # owner-or-operator-transfer is the default.
       "operator": "owner-or-operator-transfer",
       # Those two options should always have these values.
       # It means that the contract doesn't use the hook mechanism.
       "receiver": "owner-no-hook",
       "sender": "owner-no-hook",
   }
   ```

   This metadata describes who is allowed to transfer tokens.
   The permissions in this code allow token owners and operators to transfer tokens.
   For more information about operators, see [FA2 tokens](/architecture/tokens/FA2).

4. Pin the metadata to IPFS and get its URI with this code:

   ```smartpy
   # Upload the metadata to IPFS and get its URI
   metadata_uri = sp.pin_on_ipfs(contract_metadata, api_key=None, secret_key=None)
   ```

5. Update the `None` values in the `sp.pin_on_ipfs` function with your Pinata API key and secret key.
   You can also put them in the `PINATA_KEY` and `PINATA_SECRET` environment variables and remove the `api_key` and `secret_key` parameters from the function call.

6. Create the contract metadata and add it to the contract with this code:

   ```smartpy
   # Create the metadata big map based on the IPFS URI
   contract_metadata = sp.scenario_utils.metadata_of_url(metadata_uri)

   # Update the scenario instance with the new metadata
   contract.data.metadata = contract_metadata
   ```

   This code creates a big map that has a single entry that points to the metadata URI.

7. Run the `python fa2_fungible.py` command to compile and test your contract.
   Now, SmartPy uploads the metadata as part of the compilation process.

8. In your Pinata account, verify that the metadata file uploaded correctly.
   By default, the file is named "No name set" and looks like this in your Pinata files:

   ![The uploaded file on Pinata](/img/tutorials/pinata-pinned-file.png)

   You can click this file to see it and verify that the name and description at the top of the file match the name and description of your contract.
   The rest of the file is the code of off-chain views that the FA2 library adds automatically.

The completed contract is at [part_3_complete.py](https://github.com/trilitech/tutorial-applications/blob/main/smartpy_fa2_fungible/part_3_complete.py).

Now when you deploy the completed contract, wallets and block explorers can show information about it.


# Part 4: Customizing operations

As shown in previous parts, the SmartPy FA2 library provides the entrypoints that the standard requires.
You can override these entrypoints, but you must be sure to follow the standard.
You can also customize their behavior by setting security policies.

<!-- TODO add link to security policy doc when new docs come out -->

You can also customize the contract by adding your own entrypoints.
In this part, you add an entrypoint that allows users to exchange one token for another.
To convert one token into another, the entrypoint follows these general steps:

1. Verify that the source and target tokens are defined.
2. Burn the source tokens by decreasing the amount in the ledger for the account or fail if the account doesn't have enough.
3. Mint the target tokens by increasing the amount in the ledger for the account.

The burn and mint steps are straightforward as long as you understand how FA2 contracts store information in their ledger.
As described in [Part 1](/tutorials/smartpy-fa2-fungible/basic-fa2-token), the contract stores information about who owns tokens in a key-value store:

* The key is a pair that contains the address of the owner and the ID of the token
* The value is the quantity of tokens

In table format, the ledger might look like this after some mint and burn transactions:

key | value
--- | ---
Alice, token ID 0 | 10
Alice, token ID 1 | 2
Alice, token ID 2 | 1
Alice, token ID 4 | 5
Bob, token ID 1 | 2
Bob, token ID 2 | 8
Bob, token ID 3 | 14

That means that to get the amount of the source token that an account has, you must put the address and token ID together as a pair.

## Tutorial contract

The completed contract that you create in this part is at [part_4_complete.py](https://github.com/trilitech/tutorial-applications/blob/main/smartpy_fa2_fungible/part_4_complete.py).

## Exchanging one token for another

Follow these steps to create the `convert` entrypoint that exchanges one token for another:

1. At the beginning of the module, after the `def my_module():` statement but before the `class` statement, add a type that represents the information for a token transfer:

   ```smartpy
   conversion_type: type = sp.record(
       source_token_id = sp.nat,  # The ID of the source token
       target_token_id = sp.nat,  # The ID of the target token
       amount = sp.nat,  # The number of source tokens to convert
   )
   ```

   The type includes the ID of the source token, the ID of the token to convert it into, and the amount of tokens to convert.

2. After this type, create a type that is a list of conversions:

   ```smartpy
   conversion_batch: type = sp.list[conversion_type]
   ```

   This type is the parameter for the `convert` entrypoint.
   The FA2 standard says that custom entrypoints should accept batches for parameters to allow users to do multiple things in a single transaction.

3. After the `__init__()` function, add an entrypoint with the `@sp.entrypoint` annotation and accept a parameter of the `conversion_match` type:

   ```smartpy
   # Convert one token into another
   @sp.entrypoint
   def convert(self, batch):
       sp.cast(batch, conversion_batch)
   ```

4. Loop over the conversions in the batch:

   ```smartpy
   for conversion in batch:
   ```

5. Within the loop, destructure the conversion into individual variables:

   ```smartpy
   record(source_token_id, target_token_id, amount).match = conversion
   ```

6. Add this code to verify that the contract's security policy allows transfers (which it does by default) and that the source and target token exist:

   ```smartpy
   # Verify that transfers are allowed
   assert self.private.policy.supports_transfer, "FA2_TX_DENIED"
   # Verify that the source and target tokens exist
   assert self.is_defined_(source_token_id), "FA2_TOKEN_UNDEFINED"
   assert self.is_defined_(target_token_id), "FA2_TOKEN_UNDEFINED"
   ```

7. Create a pair that represents the key for the source token type:

   ```smartpy
   # Get a pair to represent the key for the ledger for the source tokens
   from_source = (sp.sender, source_token_id)
   ```

   Note that this code uses `sp.sender` instead of `sp.source` to identify the account that sent the transaction.
   The source is the account that initiated the original transaction that led to this entrypoint call, while the sender is the account that made the call that led directly to this entrypoint call.
   Using sender here is important to prevent other contracts from accepting a transaction from an account and then sending other transactions that impersonate that account.
   For more information, see [Avoiding flaws](https://opentezos.com/smart-contracts/avoiding-flaws) on opentezos.com.

8. Add this code to burn the source tokens:

   ```smartpy
   # Burn the source tokens
   self.data.ledger[from_source] = sp.as_nat(
       self.data.ledger.get(from_source, default=0) - amount,
       error="FA2_INSUFFICIENT_BALANCE",
   )
   is_supply = sp.is_nat(
       self.data.supply.get(source_token_id, default=0) - amount
   )
   with sp.match(is_supply):
       with sp.case.Some as supply:
           self.data.supply[source_token_id] = supply
       with None:
           self.data.supply[source_token_id] = 0
   ```

   This code uses the key from the previous step to subtract the tokens from the ledger entry.
   Then it updates the contract storage with the total number of that type of token remaining.

9. Add this code to create a pair that represents the key for the target token type:

   ```smartpy
   # Get a pair to represent the key for the ledger for the target tokens
   from_target = (sp.sender, target_token_id)
   ```

10. Add this code to mint the target tokens:

    ```smartpy
    # Mint the target tokens
    target_amount = self.data.ledger.get(from_target, default=0)
    self.data.ledger[from_target] = amount + target_amount
    self.data.supply[target_token_id] += amount
    ```

    This code attempts to retrieve the record by the pair in the previous step.
    If it exists, the code adds the number of tokens to the existing amount.
    If not, it creates a new record in the ledger.
    Finally, it increases the supply of that token.

11. At the end of the file, add this test to verify that a user can convert their own tokens:

    ```smartpy
    scenario.h2("Convert tokens")

    # Verify that you can convert your own tokens
    conversions = [
        sp.record(source_token_id = 0, target_token_id = 1, amount = 2),
    ]
    contract.convert(
        conversions,
        _sender=alice
    )
    scenario.verify(
        _get_balance(contract, sp.record(owner=alice.address, token_id=0)) == 8
    )
    scenario.verify(
        _get_balance(contract, sp.record(owner=alice.address, token_id=1)) == 5
    )
    scenario.verify(_total_supply(contract, sp.record(token_id=0)) == 12)
    scenario.verify(_total_supply(contract, sp.record(token_id=1)) == 16)
    ```

That's all that's necessary to convert one fungible token into another.
If you wanted to extend this feature, you could implement an exchange rate, take a fee for converting tokens, or allow only certain accounts to convert tokens.
You could also test the entrypoint more thoroughly, such as testing that a user can't convert more tokens than they have.

If you want to, you can deploy this new contract to the mockup mode with the same commands as in [Part 1: Setting up a simple FA2 token](/tutorials/smartpy-fa2-fungible/basic-fa2-token) and try it out locally.
In the next section, you deploy it to a test network.


# Part 5: Deploying the contract

So far you have used the token in the SmartPy test scenario and in the Octez client local sandbox.
To test it on a live network, you can use the Ghostnet test network.

For more information about testnets, see [Testing on sandboxes and testnets](/developing/testnets).

## Configuring the Octez client for Ghostnet

Follow these steps to set up your installation of the Octez client to work with Ghostnet:

1. Go to https://teztnets.com/ghostnet-about and copy the URL of a public RPC node for Ghostnet, such as https://rpc.ghostnet.teztnets.com.

2. Use that URL to configure the Octez client in this command:

   ```bash
   octez-client -E https://rpc.ghostnet.teztnets.com config update
   ```

3. If you don't have an account on Ghostnet, create or import one with the instructions in [Creating accounts](/developing/octez-client/accounts).

4. Use the [Ghostnet faucet](https://faucet.ghostnet.teztnets.com/) to get some tez for the account.

## Setting the admin account in the contract

Currently, the admin account in the contract is an automatically-generated account.
Follow these steps to use your account as the admin account instead:

1. Compile the contract with the `python` command as you did in previous steps.

2. Get the address of your account by running this command:

   ```bash
   octez-client list known addresses
   ```

3. Update the `step_003_cont_0_storage.tz` file and replace the first address listed with your account.
   This is the field that stores the admin account in the contract storage.

4. Deploy the contract to Ghostnet by passing your account alias, the compiled contract, and initial storage value to the `originate contract` command.
   For example, if your account is named `my_account` and the compiled files are in the `fa2_lib_fungible` folder, the command looks like this:

   ```bash
   octez-client originate contract smartpy_fa2_fungible \
       transferring 0 from my_account \
       running fa2_lib_fungible/step_003_cont_0_contract.tz \
       --init "$(cat fa2_lib_fungible/step_003_cont_0_storage.tz)" --burn-cap 3 --force
   ```

5. Copy the address of the contract from the output of the command.
   The contract address starts with `KT1`.

6. Look up the contract on the block explorer [Better Call Dev](https://better-call.dev/)

   Note that the block explorer recognizes that the contract is FA2-compliant and shows an FA2 icon at the top of the page.
   The block explorer also shows information about the tokens on the Tokens tab.

7. Mint some tokens and send them to your account from the Interact tab.
   For example, to mint tokens of an existing token type, click **Add**, select `existing` for the transaction, and specify your address and the number of tokens to create, as in this picture:

   <img src="/img/tutorials/fa2-fungible-mint-bcd.png" alt="Specifying parameters for the mint transaction" style={{width: 300}} />

## Interact with the token in a wallet

Because the token is FA2-compliant, wallet applications can work with it directly.
However, you must add the token contract to your wallet for it to recognize the token.

The process for adding a token contract to a wallet depends on the wallet application.
Here are steps for the Temple wallet:

1. Copy the address of the contract.
   You can use the command `octez-client list known contracts` to print the addresses of contracts that the Octez client knows about.

2. Open the Temple wallet and sign in.

3. Under the list of tokens, click **Manage assets list**:

   <img src="/img/tutorials/fa2-fungible-temple-assets-list.png" alt="The new token in the Temple wallet" style={{width: 300}} />

4. From the popup window, click **Manage**:

   <img src="/img/tutorials/fa2-fungible-temple-manage-assets.png" alt="The Manage button in the popup window" style={{width: 300}} />

5. Click **Add Asset**:

   <img src="/img/tutorials/fa2-fungible-temple-add-asset.png" alt="Adding an asset to the tokens list" style={{width: 300}} />

6. In the window that opens add information about the token, including the contract address, the token ID (such as 0 or 1), and the the symbol for the token, such as `TOK0`:

   <img src="/img/tutorials/fa2-fungible-temple-adding-token.png" alt="Adding information about the token" style={{width: 300}} />

7. Click **Add Asset**.

Now the token appears in your wallet just like any other token:

<img src="/img/tutorials/fa2-fungible-in-temple.png" alt="Opening the asset list filter" style={{width: 300}} />

From here, you can run transactions on the token, such as sending it to a different account.

## Next steps

Now that you have an FA2-compliant token, you can use it with all kinds of Tezos dApps.
If you want to continue working with the token, here are some ideas:

* Implement an exchange rate for the `convert` entrypoint
* Implement other custom behaviors for your token while keeping it FA2-compliant
* Build a front-end application to make it easier to interact with it
* Add other token types and metadata for them
* Try creating a single asset contract or an NFT contract with the SmartPy FA2 library


# Create NFTs from a web application

This tutorial shows you how to create a web application that interacts with the Tezos blockchain to create (mint) non-fungible tokens (NFTs).
NFTs are unique digital assets that can represent art, collectibles, or virtually any kind of digital content on the blockchain.
Specifically, this application includes a user-facing front end web application and a Tezos smart contract that acts as the backend and manages data about the tokens.

No prior knowledge of NFTs or Tezos is required, but because the tutorial application uses JavaScript, some familiarity with JavaScript makes it easier to understand.

## Learning objectives

In this tutorial, you will learn:

* How to use the [Taquito](https://tezostaquito.io/) JavaScript/TypeScript SDK to access Tezos and user wallets and to send transactions to Tezos
* How to connect to wallets and accounts
* What smart contracts are and how to call them from a web application
* How to mint NFTs on behalf of a user
* How to deploy your own smart contract to manage NFTs
* How to get information about NFTs and their owners from Tezos

## What is a non-fungible token (NFT)?

An NFT is a special type of blockchain token that represents something unique.
Fungible tokens such as XTZ and real-world currencies like dollars and euros are interchangeable; each one is the same as every other.
By contrast, each NFT is unique and not interchangeable.
NFTs can represent ownership over digital or physical assets like virtual collectibles or unique artwork, or anything that you want them to represent.

Like other types of Tezos tokens, a collection of NFTs is managed by a smart contract.
The smart contract defines what information is in each token and how the tokens behave, such as what happens when a user transfers an NFT to another user.
It also keeps a ledger that records which account owns each NFT.

In this tutorial, you create NFTs that comply with the FA2 standard (formally known as the [TZIP-12](https://gitlab.com/tezos/tzip/-/blob/master/proposals/tzip-12/tzip-12.md) standard), the current standard for tokens on Tezos.
The FA2 standard creates a framework for how tokens behave on Tezos, including fungible, non-fungible, and other types of tokens.
It provides a standard API to transfer tokens, check token balances, manage operators (addresses that are permitted to transfer tokens on behalf of the token owner), and manage token metadata.

## Tutorial application

The application that you set up in this tutorial has two parts:

* The **smart contract** runs on the Tezos blockchain to manage the NFTs, including creating, transferring, and destroying them
* The **frontend application** runs on a web server and allows the user to connect their wallet, send a request to the smart contract to create an NFT, and to see information about the NFTs that they own

The front end of the application shows buttons that users can click to connect and to mint NFTs:

<img src="/img/tutorials/create-nfts-show-info-ids.png" alt="The application showing the IDs of the owned NFTs" style={{width: 500}} />

The source code of the completed application is available here: https://github.com/trilitech/tutorial-applications/tree/main/create-nfts.

## Prerequisites

To run this tutorial you need Node.JS and NPM installed.
See https://nodejs.org/.
You can verify that they are installed by running these commands:

```bash
node --version
npm --version
```

## Tutorial sections

* [Part 1: Setting up the application](/tutorials/create-nfts/setting-up-app)
* [Part 2: Connecting to wallets](/tutorials/create-nfts/connect-wallet)
* [Part 3: Sending transactions](/tutorials/create-nfts/send-transactions)
* [Part 4: Creating the contract](/tutorials/create-nfts/create-contract)
* [Part 5: Showing token information](/tutorials/create-nfts/show-info)
* [Summary](/tutorials/create-nfts/summary)


# Part 1: Setting up the application

You can access Tezos through any JavaScript framework.
This tutorial uses the Svelte framework to create a simple UI quickly.
The following steps show you how to start a Svelte application and add the Tezos-related dependencies.
If you are familiar with Svelte, note that this application includes its own Svelte SPA, so it does not require SvelteKit.

## Setting up the application

1. Run these commands to create a starter Svelte project:

   ```bash
   npm create vite@latest create-nfts -- --template svelte
   cd create-nfts
   npm install
   ```

2. Install the Tezos-related dependencies:

   ```bash
   npm install @taquito/taquito @taquito/utils @taquito/beacon-wallet @airgap/beacon-types
   ```

3. Install the `buffer`, `events`, and `vite-compatible-readable-stream` libraries:

   ```bash
   npm install --save-dev buffer events vite-compatible-readable-stream
   ```

4. Update the `vite.config.js` file to the following code:

   ```javascript
    import { defineConfig, mergeConfig } from "vite";
    import path from "path";
    import { svelte } from "@sveltejs/vite-plugin-svelte";

    export default ({ command }) => {
      const isBuild = command === "build";

    return defineConfig({
      plugins: [svelte()],
        define: {
            global: {}
        },
      build: {
        target: "esnext",
        commonjsOptions: {
            transformMixedEsModules: true
        }
        },
      server: {
        port: 4000
        },
      resolve: {
        alias: {
         "@airgap/beacon-types": path.resolve(
           path.resolve(),
           `./node_modules/@airgap/beacon-types/dist/${
           isBuild ? "esm" : "cjs"
           }/index.js`
          ),
         // polyfills
         "readable-stream": "vite-compatible-readable-stream",
         stream: "vite-compatible-readable-stream"
        }
        }
    });
    };
   ```

   This updated file includes these changes to the default Vite configuration:

   * It sets the `global` object to `{}` so the application can provide the value for this object in the HTML file
   * It includes the path to the Beacon SDK, which Taquito uses to connect to wallets
   * It provides polyfills for `readable-stream`

5. Update the default HTML file, `index.html`, to the following code:

   ```html
   <!DOCTYPE html>
   <html lang="en">
     <head>
       <meta charset="UTF-8" />
       <link rel="icon" href="/favicon.ico" />
       <meta name="viewport" content="width=device-width, initial-scale=1.0" />
       <script>
         const global = globalThis;
       </script>
       <script type="module">
         import { Buffer } from "buffer";
         window.Buffer = Buffer;
       </script>
       <title>Create NFTs</title>
     </head>
     <body>
       <script type="module" src="/src/main.js"></script>
     </body>
   </html>
   ```

   This updated file sets the `global` variable to `globalThis` and adds a buffer object to the window.
   The application requires this configuration to use the Beacon SDK to connect to wallets in a Vite app.

6. In the `src/main.js` file, import the style sheets by replacing the default code of the file with this code:

   ```javascript
   import './app.css'
   import { mount } from 'svelte';
   import App from './App.svelte'

   const app = mount(App, { target: document.body });

   export default app
   ```

   This code targets the `body` tag to inject the HTML produced by JavaScript instead of a `div` tag inside the `body` tag as Svelte apps do by default.
   Your applications can target any tag on the page.

## File structure

The structure of the tutorial application looks like this:

```
- src
  - assets
  - lib
  - app.css
  - App.svelte
  - main.js
  - vite-env.d.ts
- index.html
- jsconfig.json
- package-lock.json
- package.json
- svelte.config.js
- vite.config.js
```

Here are descriptions for each of these files:

* **assets** -> Contains the favicon and other static files such as images for the application.
* **lib** -> Contains the components that make up the app interface:
* **app.css** -> Contains global styles that apply to the entire app.
* **App.svelte** -> The entrypoint of the application, which contains the components that are bundled into the final application.
* **main.js** -> Where the JavaScript for the app is bundled before being injected into the HTML file.
* **vite-env.d.ts** -> A JavaScript declaration file automatically generated by Vite to provide type definitions for environment variables.
* **index.html** -> Contains the root element where the Svelte app gets attached.
* **jsconfig.json** -> Configuration options for JavaScript.
* **package.json** -> Contains metadata about the project like its name, version, and dependencies.
* **svelte.config.js** -> Configuration file for the Svelte application.
* **vite.config.js** -> Used to customize Vite's behavior, including defining plugins, setting up aliases, and more.

## Configuring the Svelte application

Svelte files include several different types of code in a single file.
This example page has separate sections for JavaScript, style, and HTML code:

```html
<script lang="ts">
  // Your JavaScript code
</script>

<style lang="scss">
  /* Your styles */
</style>

<main>
  <!-- Your HTML code -->
</main>
```

Svelte components are fully contained, which means that the style and JS/TS code that you apply inside a component doesn't leak into the other components of your app.
Styles and scripts that are shared among components typically go in the `src/styles` and `scripts` or `src/scripts` folders.

Follow these steps to set up the `src/App.svelte` file, which is the container for the other Svelte components:

1. In the `App.svelte` file, replace the default `<main>` section with this code to set up a title for the interface:

   ```html
   <main>
     <h1>Create NFTs</h1>

   </main>
   ```

   You will add elements to the web application interface later.

2. Replace the default `<style>` section with this code:

   ```scss
   <style>
   </style>
   ```

   Later, you can add styles to this section or the shared CSS files.

3. Remove the default JavaScript section and replace it with this code, which imports the libraries and components that the app uses:

   ```html
   <script lang="ts">
     import { BeaconWallet } from "@taquito/beacon-wallet";
     import { NetworkType } from "@airgap/beacon-types";
     import { TezosToolkit, MichelsonMap} from "@taquito/taquito";
     import { stringToBytes } from '@taquito/utils';
   </script>
   ```

   The imports include these elements:

   * `BeaconWallet`: This class provides a user interface for connecting to wallets, ensuring that users can securely sign transactions and call smart contracts
   * `NetworkType`: An enumeration that lists the different types of networks on the Tezos blockchain
   * `TezosToolkit`: This is the base class for Taquito, which gives you access to most of its Tezos-related features
   * `MichelsonMap`: This class represents the Michelson  map data type, which Tezos uses to store data, including the metadata for the NFTs that the application creates
   * `stringToBytes`: A utility that converts strings to bytes to store in the token metadata

4. In the same `<script lang="ts">` section, add the following code to initialize Taquito and set it to use a Ghostnet RPC node:

   ```javascript
     const rpcUrl = "https://rpc.ghostnet.teztnets.com";
     const Tezos = new TezosToolkit(rpcUrl);
   ```

   This code creates an instance of the `TezosToolkit` object, which provides access to the Tezos chain itself.
   You can change the RPC node to use a different Tezos network (such as switching to Tezos Mainnet when you are ready to deploy the application in production) or if the node you are using is slow or down,
   For URLs to other RPC nodes, see https://teztnets.com.

Now you have the framework of a web application that can access Tezos.
In the next part, you add buttons that connect to the user's wallet and send transactions to Tezos on the user's behalf.
Continue to [Part 2: Connecting to wallets](/tutorials/create-nfts/connect-wallet).


# Part 2: Connecting to wallets

Before the application can interact with Tezos, you must connect to the user's wallet.
Connecting to a wallet allows your application to get the address of the user's account, get information about the tokens in that account, and create transactions for the user to approve.
Connecting to a wallet doesn't give the application direct control over an account, only the ability to send transactions to the wallet for the user to approve and sign.

To connect to a user's wallet, you use the Beacon toolkit, which is a standard interface for Tezos wallets.

:::note

However you design your app, you must use a single instance of the `BeaconWallet` object.
It is also highly recommended to use a single instance of the `TezosToolkit` object.
Creating multiple instances can cause problems in your app and with Taquito in general.

Because this sample application has only one page, it defines the `TezosToolkit` and `BeaconWallet` objects in the code of that page.
If your application has multiple pages, define these objects in a single file and re-use them on each page.

:::

1. In the file `src/App.svelte`, in the `<script lang="ts">` section, after the existing code, add this code to connect to the user's wallet and get basic information about it, including its address and balance in tez:

   ```javascript
   let wallet;
   let address;
   let balance;
   let statusMessage = "Connect your wallet.";
   let buttonActive = false;

   const connectWallet = async () => {
     try {
       const newWallet = new BeaconWallet({
         name: "NFT app tutorial",
         network: {
          type: NetworkType.GHOSTNET,
        },
       });
       await newWallet.requestPermissions();
       address = await newWallet.getPKH();
       const balanceMutez = await Tezos.tz.getBalance(address);
       balance = balanceMutez.div(1000000).toFormat(2);
       buttonActive = true;
       statusMessage = "Wallet connected. Ready to mint NFTs.";
       wallet = newWallet;
     } catch (error) {
       console.error("Error connecting wallet:", error);
     }
   };
   ```

   This `connectWallet` function provides a name for the app, which appears in the wallet UI when it asks the user to allow the connection.
   It also includes the network to use, such as the Tezos main network or test network.
   When it is connected, it sets the `buttonActive` flag to true, which the UI will use to enable the button to create NFTs.

2. After the `connectWallet` function, add a function to disconnect the user's wallet:

   ```javascript
   const disconnectWallet = () => {
     wallet.client.clearActiveAccount();
     statusMessage = "Connect your wallet.";
     wallet = undefined;
     buttonActive = false;
   };
   ```

   The `disconnectWallet` function runs these steps to disconnect the wallet and reset the state of the app:

   1. It closes the connection to the Beacon SDK.
   2. It nullifies the wallet reference by setting the `wallet` variable to `undefined`.
   3. It deactivates the NFT button by setting the `buttonActive` flag to false.

3. Update the `<main>` block to have this code, which creates a button that the user can click to connect or disconnect their wallet:

   ```html
   <main>
     <h1>Simple NFT dApp</h1>

     <div class="card">
       {#if wallet}
         <p>The address of the connected wallet is {address}.</p>
         <p>Its balance in tez is {balance}.</p>
         <button on:click={disconnectWallet}>Disconnect wallet</button>
       {:else}
         <button on:click={connectWallet}>Connect wallet</button>
       {/if}
         <p>{statusMessage}</p>
     </div>
   </main>
   ```

   Now you have functions that allow your application to connect and disconnect wallets.

## Testing the wallet connection

Follow these steps to test that the application can connect to wallets:

1. Make sure that you have a wallet and some tez on the Ghostnet testnet in your account.
   See [Installing and funding a wallet](/developing/wallet-setup).

2. Start the application by running the command `npm run dev` in the folder that contains the `package.json` file.

3. Open the web application in a web browser at `http://localhost:4000`.

   The application shows the connection button and status message:

   <img src="/img/tutorials/create-nfts-connect-not-connected.png" alt="The application showing the wallet connection button" style={{width: 300}} />

4. Click the **Connect wallet** button and follow the prompts to connect your wallet.
   The popup window can connect to wallet apps in your web browser or show a barcode to connect to a wallet app on a mobile device.

   When the wallet connects successfully, the web application changes to show the connected account address and its balance in tez:

   <img src="/img/tutorials/create-nfts-connect-connected.png" alt="The application showing information about the connected account" style={{width: 300}} />

   If the wallet doesn't connect correctly, make sure that your application matches the application at https://github.com/trilitech/tutorial-applications/tree/main/create-nfts/part-2.

5. Click the **Disconnect wallet** button and see that the wallet disconnects and the information disappears from the page.

Now your application can connect to wallets.
In the next section, you create transactions for the user wallet to send to Tezos.
Review the design considerations for dApps below and then continue to [Part 3: Sending transactions](/tutorials/create-nfts/send-transactions).

## Design considerations

Interacting with a wallet in a decentralized application is a new paradigm for many developers and users.
Follow these practices to make the process easier for users:

* Let users manually connect their wallets instead of prompting users to connect their wallet immediately when the app loads.
  Getting a wallet pop-up window before the user can see the page is annoying.
  Also, users may hesitate to connect a wallet before they have had time to look at and trust the application, even though connecting the wallet is harmless.

* Provide a prominent button to connect or disconnect wallets.

* Put the button in a predictable position, typically at the top right or left corner of the interface.

* Use **Connect** as the label for the button.
  Avoid words like "sync" because they can have different meanings in dApps.

* Display the status of the wallet connection clearly in the UI.
  You can also add information about the wallet, including token balances and the connected network for the user's convenience.
  Showing information about the tokens and updating it after transactions allows the user to verify that the application is working properly.

* Enable and disable functions of the application based on the status of the wallet connection.
  For example, if the wallet is not connected, disable buttons for transactions that require a wallet connection.


# Part 3: Sending transactions

To send a transaction to Tezos, a dApp creates the transaction, including its parameters.
Then it sends the transaction to the user's wallet application.
With the user's approval, the wallet encrypts ("signs") the transaction with the user's private key and sends it to Tezos.

In this section, you add functions to the application that send a transaction that creates ("mints") an NFT on Tezos.
The transaction calls a pre-deployed smart contract that manages NFTs.
In a later section, you will deploy your own contract to manage your NFTs, but for now you can use the pre-deployed contract to learn about how it works.

## The pre-deployed contract

You can see the pre-deployed contract by looking up its address `KT1SRdvmiXjQxtY78sefFY2qrCHNpNttWZXq` on a block explorer such as these:

* https://ghostnet.tzkt.io/KT1SRdvmiXjQxtY78sefFY2qrCHNpNttWZXq
* https://better-call.dev/ghostnet/KT1SRdvmiXjQxtY78sefFY2qrCHNpNttWZXq

The block explorer shows the transactions that the contract has received and information about the tokens that it manages.
Usually the block explorer has a **Tokens** tab for contracts that manage tokens.
For example, Better Call Dev shows the tokens like this:

<img src="/img/tutorials/create-nfts-transaction-existing-tokens.png" alt="The tokens in the pre-deployed contract" style={{width: 300}} />

Most tokens have metadata that describes what the token represents.
For example, the first token on the pre-deployed contract has this metadata:

<img src="/img/tutorials/create-nfts-transaction-token-metadata.png" alt="The metadata of one token" style={{width: 300}} />

Normally, contracts that manage tokens have restrictions on who can mint tokens, but for the purposes of the tutorial, this contract allows any account to mint NFTs.

## Minting NFTs

To call a smart contract, you need the address of the contract, the name of  the entrypoint to call, and a properly formatted parameter.

1. In the `App.svelte` file, in the `<script>` section, add a constant with the address of the pre-deployed contract:

   ```javascript
   const nftContractAddress = "KT1Lr8m7HgfY5UF6nXDDcXDxDgEmKyMeds1b";
   ```

2. Add a constant with a pre-deployed image.
   The application will use this image to represent the NFT in wallet applications.

   ```javascript
   const defaultImage = "https://gateway.pinata.cloud/ipfs/QmRCp4Qc8afPrEqtM1YdRvNagWCsFGXHgGjbBYrmNsBkcE";
   ```

3. Add a function called `createNFT` that creates an NFT, first checking if the button is active because the wallet is connected:

   ```javascript
   if (!buttonActive) {
     return;
   }
   buttonActive = false;
   statusMessage = "Minting NFT; please wait...";
   ```

4. Further inside the function, create the metadata for the token:

   ```javascript
   // Create token metadata
   const metadata = new MichelsonMap();
   metadata.set("name", stringToBytes("My Token"));
   metadata.set("symbol", stringToBytes("Tok"));
   metadata.set("decimals", stringToBytes("0"));
   metadata.set("artifactUri", stringToBytes(defaultImage));
   metadata.set("displayUri", stringToBytes(defaultImage));
   metadata.set("thumbnailUri", stringToBytes(defaultImage));
   ```

   These are the metadata fields that the pre-deployed contract expects for new tokens.
   When you create your own contract you can define the fields, but these fields are commonly used for Tezos FA2 tokens, including NFTs.

   Note that the value of the `decimals` field is set to zero because the token cannot be divided like a fungible token can.

   Also note that each field is converted from a string to bytes because token metadata is stored as a key-value map with string keys and byte values.

5. Create the parameter for the transaction:

   ```javascript
   const mintItem = {
     to_: address,
     metadata: metadata,
   };

   const mintParameter = [mintItem];
   ```

   There is no standard way that FA2 contracts mint tokens; in fact, FA2 contracts are not required to have a `mint` entrypoint.
   In this case, the mint entrypoint accepts a list of tokens to create, with each list item including the address of the token owner and the metadata for the new token.
   You can set up your contract to mint tokens in any way.

6. Within a `try/catch` block, create an object that represents the contract and call its `mint` entrypoint by adding this code:

   ```javascript
   try {
     Tezos.setWalletProvider(wallet);

     console.log("getting contract");
     const nftContract = await Tezos.wallet.at(nftContractAddress);

     console.log("minting");
     const op = await nftContract.methodsObject.mint(mintParameter).send();

     console.log(`Waiting for ${op.opHash} to be confirmed...`);
     const hash = await op.confirmation(2).then(() => op.opHash);
     console.log(`Operation injected: https://ghostnet.tzkt.io/${hash}`);
   } catch (error) {
     console.error("Error minting NFT:", error);
   } finally {
     statusMessage = "Ready to mint another NFT.";
     buttonActive = true;
   }
   ```

   When you call the `Tezos.wallet.at()` method, Taquito creates an object that represents the contract.
   This object has a `methodsObject` property that has a method for each entrypoint in the contract.
   In this way, the `nftContract.methodsObject.mint()` method represents a call to the contract's `mint` entrypoint.

   The complete function looks like this:

   ```javascript
   const createNFT = async () => {
   if (!buttonActive) {
     return;
   }
   buttonActive = false;
   statusMessage = "Minting NFT; please wait...";

   // Create token metadata
   const metadata = new MichelsonMap();
   metadata.set("name", stringToBytes("My Token"));
   metadata.set("symbol", stringToBytes("Tok"));
   metadata.set("decimals", stringToBytes("0"));
   metadata.set("artifactUri", stringToBytes(defaultImage));
   metadata.set("displayUri", stringToBytes(defaultImage));
   metadata.set("thumbnailUri", stringToBytes(defaultImage));

   const mintItem = {
     to_: address,
     metadata: metadata,
   };

   const mintParameter = [mintItem];

   try {
     Tezos.setWalletProvider(wallet);

     console.log("getting contract");
     const nftContract = await Tezos.wallet.at(nftContractAddress);

     console.log("minting");
     const op = await nftContract.methodsObject.mint(mintParameter).send();

     console.log(`Waiting for ${op.opHash} to be confirmed...`);
     const hash = await op.confirmation(2).then(() => op.opHash);
     console.log(`Operation injected: https://ghostnet.tzkt.io/${hash}`);
   } catch (error) {
     console.error("Error minting NFT:", error);
   } finally {
     statusMessage = "Ready to mint another NFT.";
     buttonActive = true;
   }

   }
   ```

7. In the `<main>` section, add a button to call the `createNFT` function.
   The `<main>` section looks like this:

   ```javascript
   <main>
     <h1>Create NFTs</h1>

     <div class="card">
       {#if wallet}
         <p>The address of the connected wallet is {address}.</p>
         <p>Its balance in tez is {balance}.</p>
         <button on:click={disconnectWallet}>Disconnect wallet</button>
         <button on:click={createNFT}>Create NFT</button>
       {:else}
         <button on:click={connectWallet}>Connect wallet</button>
       {/if}
       <p>{statusMessage}</p>
     </div>
   </main>
   ```

8. Run the application with the command `npm run dev` and connect your wallet as you did previously.

9. Click the **Create NFT** button and approve the transaction in your wallet.

10. Verify that the NFT was created by looking up the transaction hash in a block explorer.
    Here are some ways to get the transaction hash:

    * Open the browser console and find the message that starts with `Operation injected`.
    * Click the link in the confirmation window in your wallet application.
    * Open the contract in a block explorer and look at the most recent transaction or search for your address in its recent transactions.

    For example, [this transaction](https://ghostnet.tzkt.io/oopNizDc1p6uuCLsbEP4LEzUvgiJefPFe6W9QZur9kfZzDui9bb/19762971) shows the address of the token creator, the `mint` entrypoint, and the name of the new token:

    <img src="/img/tutorials/create-nfts-transaction-completed-transaction.png" alt="The completed transaction" style={{width: 300}} />

## Viewing the NFT in your wallet

Because the contract follows the FA2 standard, Tezos wallets can show information about it.
However, your wallet is not immediately aware that you have the token.
You can add the token to your wallet manually to see it and work with it in your wallet:

1. In your wallet, go to the tab that shows NFTs, which is usually called "Collectibles" or "NFTs."

   For example, the Temple wallet shows NFTs on the Collectibles tab:

   <img src="/img/tutorials/create-nfts-transaction-temple-no-nfts.png" alt="The Collectibles tab of the Temple wallet, showing no NFTs" style={{width: 300}} />

2. Add the predefined contract address `KT1Lr8m7HgfY5UF6nXDDcXDxDgEmKyMeds1b` as a source of NFTs.

   For example, in Temple, click **Manage assets list > Manage**, click **Add Collectible**, add the contract address in the **Address** field, and click **Add Asset**:

   <img src="/img/tutorials/create-nfts-transaction-temple-add-contract.png" alt="Adding a contract to Temple" style={{width: 300}} />

   In most cases you can leave the asset ID blank and the wallet will retrieve all of your tokens in the contract.

   Now the wallet shows the NFT:

   <img src="/img/tutorials/create-nfts-transaction-temple-show-nft.png" alt="An NFT in the Temple wallet" style={{width: 300}} />

   You can click the token to see information about it and to send it to another account.
   Because the contract is FA2-compliant, wallets can perform operations on the token without any further information.

   <img src="/img/tutorials/create-nfts-transaction-temple-show-nft-info.png" alt="An NFT in the Temple wallet" style={{width: 300}} />

Now you can create NFTs with your application and the built-in contract.
In the next section you start creating your own contract to create NFTs your own way.
Continue to [Part 4: Creating the contract](/tutorials/create-nfts/create-contract).


# Part 4: Creating the contract

Up to this point, your web application used a pre-deployed smart contract to manage tokens.
In this section, you create and deploy your own smart contract to control your own tokens.
Creating your own smart contract allows you to customize the tokens and their behavior, such as their metadata, how they are minted, transferred, and burned, and the rules for creating, transferring, and destroying them.

The contract that you create in this section is written in the SmartPy language, which is a language for contracts based on Python.
For more information about SmartPy, see [SmartPy](/smart-contracts/languages/smartpy) in this documentation or the complete documentation for [SmartPy](https://smartpy.io/).

## The SmartPy FA2 library

SmartPy provides a library that helps you create FA2-compatible token contracts.
Instead of having to write all of the code yourself, you can import code from the FA2 library that controls how the contract and its tokens behave.
Then you can customize the behavior and run tests to verify that your contract works before you deploy it.

For more information about the SmartPy FA2 library, see [FA2 Lib](https://smartpy.io/manual/libraries/FA2-lib/overview) in the SmartPy documentation.

## Loading a template in the SmartPy online IDE

You can work with SmartPy contracts in any text or code editor, but an easy way to with with contracts without installing anything is to use the SmartPy online IDE.
This IDE includes templates for smart contracts and can compile, test, and deploy contracts directly in the browser.

Follow these steps to create a contract using a template for FA2 NFTs:

1. Open the SmartPy online IDE at https://smartpy.io/ide.

2. From the Welcome popup, go to the **TEMPLATES** tab, expand **Token contracts** and click the template named "Example NFT contract using the FA2 library."

   <img src="/img/tutorials/create-nfts-contract-template-window.png" alt="Selecting the template in the SmartPy IDE" style={{width: 300}} />

   If the Welcome popup doesn't appear, click the **TEMPLATES** button at the top right of the editor.

3. Specify a name for the new contract such as `fa2-nft` and click **IMPORT CONTRACT**.
   The IDE loads the contract template in the editor.

## The contract template

To use the SmartPy FA2 library in a contract, you create a contract like any other SmartPy contract.
Then you import one base class from the library and as many mixins as you want.

* Base classes provide the functionality for a single type of FA token:

  * `main.Nft`: Non-fungible tokens, which are unique digital assets
  * `main.Fungible`: Fungible tokens, which are interchangeable assets, like tez or other cryptocurrencies
  * `main.SingleAsset`: Single-asset tokens, which are a simplified case of fungible tokens, allowing only one token type per contract

* Mixins provide additional features.
  Some of these mixins include:

  * `main.Admin`: Provides the `is_administrator` method and the `set_administrator` entrypoint to control the administrator of the contract.
  * `main.BurnNft`: Provides a `burn` entrypoint that destroys tokens.
  * `main.MintNft`: Provides a `mint` entrypoint that creates tokens.
    This mixin requires the `main.Admin` mixin and by default allows only the administrator to mint tokens.
  * `main.OnchainviewBalanceOf`: Provides a view that returns information about who owns tokens.

For more information, see [Base classes](https://smartpy.io/manual/libraries/FA2-lib/base_classes) and [Mixins](https://smartpy.io/manual/libraries/FA2-lib/mixins).

Note the order of the base class and mixins; they must be imported and initialized in a specific order to work properly.
There is information on the ordering in comments in the template and in the [FA2 lib](https://smartpy.io/manual/libraries/FA2-lib/overview) documentation.
The main part of the contract template looks like this:

```smartpy
import smartpy as sp
from smartpy.templates import fa2_lib as fa2

# Main template for FA2 contracts
main = fa2.main


@sp.module
def my_module():
    import main

    # Order of inheritance: [Admin], [<policy>], <base class>, [<other mixins>].
    class MyNFTContract(
        main.Admin,
        main.Nft,
        main.MintNft,
        main.BurnNft,
        main.OnchainviewBalanceOf,
    ):
        def __init__(self, admin_address, contract_metadata, ledger, token_metadata):
            """Initializes the contract with NFT functionalities.
            The base class is required; all mixins are optional.
            The initialization must follow this order:

            - Other mixins such as OnchainviewBalanceOf, MintNFT, and BurnNFT
            - Base class: NFT
            - Transfer policy
            - Admin
            """

            # Initialize on-chain balance view
            main.OnchainviewBalanceOf.__init__(self)

            # Initialize the NFT-specific entrypoints
            main.BurnNft.__init__(self)
            main.MintNft.__init__(self)

            # Initialize the NFT base class
            main.Nft.__init__(self, contract_metadata, ledger, token_metadata)

            main.Admin.__init__(self, admin_address)
```

## Customizing the contract template

You can customize the contract by using a different base class, using different mixins, or overriding the entrypoints that the base class and mixins provide.
For example, [the pre-deployed contract](https://github.com/trilitech/tutorial-applications/tree/main/create-nfts/contract/pre-deployed-fa2-nft.py) overrides the internal function `is_administrator_` to allow anyone to mint a token, not just the administrator as in most NFT contracts.

Many token contracts change the metadata from the default, so in these steps you set up custom metadata for your tokens:

1. After the contract code but before the test code that begins with `@sp.add_test()`, add a function to encode token metadata in the format that the contract stores it in:

   ```smartpy
   # Create token metadata
   # Adapted from fa2.make_metadata
   def create_metadata(symbol, name, decimals, displayUri, artifactUri, description, thumbnailUri):
       return sp.map(
           l={
               "name": sp.scenario_utils.bytes_of_string(name),
               "decimals": sp.scenario_utils.bytes_of_string("%d" % decimals),
               "symbol": sp.scenario_utils.bytes_of_string(symbol),
               "displayUri": sp.scenario_utils.bytes_of_string(displayUri),
               "artifactUri": sp.scenario_utils.bytes_of_string(artifactUri),
               "description": sp.scenario_utils.bytes_of_string(description),
               "thumbnailUri": sp.scenario_utils.bytes_of_string(thumbnailUri),
           }
       )
   ```

   This function accepts metadata fields and encodes them as a map where the key is a string and the value is a series of bytes.

2. Optional: Customize the metadata by adding or removing fields.

   Later you will change the web application to include this metadata in the mint transaction.

3. Update the metadata in the test to use this function by removing this code:

   ```smartpy
   # Define initial token metadata and ownership
   tok0_md = fa2.make_metadata(name="Token Zero", decimals=1, symbol="Tok0")
   tok1_md = fa2.make_metadata(name="Token One", decimals=1, symbol="Tok1")
   tok2_md = fa2.make_metadata(name="Token Two", decimals=1, symbol="Tok2")
   token_metadata = [tok0_md, tok1_md, tok2_md]
   ledger = {0: alice.address, 1: alice.address, 2: bob.address}
   ```

   and replacing it with this code:

   ```smartpy
   # Precreated image on IPFS
   token_thumb_uri = "https://gateway.pinata.cloud/ipfs/QmRCp4Qc8afPrEqtM1YdRvNagWCsFGXHgGjbBYrmNsBkcE"

   # Define initial token metadata and ownership
   tok0_md = create_metadata(
           "Tok0",
           "Token Zero",
           0,
           token_thumb_uri,
           token_thumb_uri,
           "My first token",
           token_thumb_uri,
   )
   tok1_md = create_metadata(
           "Tok1",
           "Token One",
           0,
           token_thumb_uri,
           token_thumb_uri,
           "My second token",
           token_thumb_uri,
   )
   tok2_md = create_metadata(
           "Tok2",
           "Token Two",
           0,
           token_thumb_uri,
           token_thumb_uri,
           "My third token",
           token_thumb_uri,
   )
   token_metadata = [tok0_md, tok1_md, tok2_md]
   ledger = {0: alice.address, 1: alice.address, 2: bob.address}
   ```

4. Optional: Edit the metadata for these three tokens.
   You can change the names, symbols, and descriptions or replace the default picture with a picture of your own.
   Usually, developers store token media such as pictures with the InterPlanetary File System (IPFS) protocol using a tool such as [Pinata](https://www.pinata.cloud/).

5. Set yourself as the administrator of the contract:

   1. Replace the line `admin = sp.test_account("Admin")` with this line, using your address for `<MY_ADDRESS>`:

      ```smartpy
      admin = sp.address("<MY_ADDRESS>")
      ```

   2. Replace these lines:

      ```smartpy
      contract = my_module.MyNFTContract(
          admin.address, sp.big_map(), ledger, token_metadata
      )
      ```

      with these lines:

      ```smartpy
      contract = my_module.MyNFTContract(
          admin, sp.big_map(), ledger, token_metadata
      )
      ```

6. Above the code of the contract, click **Run Code** to compile the contract and run the tests:

   <img src="/img/tutorials/create-nfts-contract-template-run-code.png" alt="Running the contract and tests" style={{width: 300}} />

   If you see an error, make sure that your code matches [the completed contract file](https://github.com/trilitech/tutorial-applications/tree/main/create-nfts/contract/fa2-from-template.py)

   If the contract compiles and the tests pass, the IDE shows the starting value of the contract storage and the results of the tests in the right-hand pane:

   <img src="/img/tutorials/create-nfts-contract-template-completed-tests.png" alt="Information about the compiled contract and completed tests" style={{width: 300}} />

   This storage includes your address as the administrator and test account addresses as the starting token owners.
   Optionally, you can change the starting token owner address like you changed the admin address.

## Deploying the contract

When you are satisfied with the contract and its tests, you can originate (deploy) it to the test network.

Originating the contract includes specifying the initial value for its storage.
The IDE generates this value based on how you originated the contract in the tests.
The tests used generated test accounts, so if you want to have control over the contract you must change the addresses in this generated storage value.

1. In the IDE, under the section that shows the origination storage values for the contract, click **Deploy contract**.

2. In the Michelson pop-up window, click **Continue**.

3. In the Direct Network Contract Origination window, under Node and Network, select the Ghostnet network.

4. In the Wallet section, connect your wallet.

   The **Beacon** tab allows you to connect to most wallet types.
   If you can't connect your wallet, you can click the **Secret key** tab and enter your account's secret key directly.

5. Click **ESTIMATE COST FROM RPC**.

6. When you are ready to deploy the contract, go to the Deploy Contract section and click **DEPLOY CONTRACT**.

7. In the Pre-Signature Information window, click **Accept**.

8. Approve the transaction in your wallet.

   When the contract is deployed successfully, the page shows the new contract address under Origination Result, as in this picture:

   <img src="/img/tutorials/create-nfts-contract-template-deployed.png" alt="The address of the new contract" style={{width: 300}} />

9. Click **OPEN EXPLORER** to view the contract in the SmartPy block explorer.
   From this block explorer, you can click the links to see the contract in other block explorers.

10. Copy the address of the new contract.

## Using the contract in your application

Now your contract is deployed and you can use it in the frontend application to create NFTs with it.

1. In your application's `App.svelte` file, update this line with the address of your deployed contract:

   ```javascript
   const nftContractAddress = "KT1Lr8m7HgfY5UF6nXDDcXDxDgEmKyMeds1b";
   ```

2. If you changed the metadata by adding or removing fields, make updates in the file to change the token metadata to match.
   Remember that the format for metadata fields is a string and a sequence of bytes, as in the current code:

   ```javascript
   metadata.set("name", stringToBytes("My Token"));
   metadata.set("symbol", stringToBytes("Tok"));
   metadata.set("decimals", stringToBytes("0"));
   metadata.set("artifactUri", stringToBytes(defaultImage));
   metadata.set("displayUri", stringToBytes(defaultImage));
   metadata.set("description", stringToBytes("A token I minted"));
   metadata.set("thumbnailUri", stringToBytes(defaultImage));
   ```

3. Restart the web application and mint tokens with it from your administrator account.
   The web application creates the NFTs on your new contract just like it did on the prebuilt contract.
   You can use the address of the contract or the link in the log to look them up on a block explorer.

In the next section you use Taquito to retrieve information about your tokens from the contract and show them on the web application.
Continue to [Part 5: Showing token information](/tutorials/create-nfts/show-info).


# Part 5: Showing token information

You can use Taquito to retrieve information about tokens from Tezos.
In this section, you retrieve information about the connected user's tokens and show them on the web page.

The process takes a few steps because of how the data about the token owners is stored.
The ledger that records the owner of each token isn't stored as a simple table or as a single object.
Instead, each entry in the big-map (in this case, an entry that represents the owner of each token) is lazily deserialized.
In other words, when you look up the owner of a token, Tezos reads only the entry for that token ID, not the entire table of owners.
Reading a single entry like this reduces the cost of reading data from the ledger, especially as the ledger gets large.
For more information about maps and big-maps, see [Big-maps and maps](/smart-contracts/data-types/complex-data-types#big-maps).

## Getting token owners

If you ignore the internal complexities of how the data is stored in the big-map, you can imagine that the contract stores data about the NFT owners in a table.
One column of the table stores the ID of the NFT and the other column stores the address of the owner, as in this example:

Token ID | Owner
--- | ---
0 | `tz1QCVQinE8iVj1H2fckqx6oiM85CNJSK9Sx`
1 | `tz1QCVQinE8iVj1H2fckqx6oiM85CNJSK9Sx`
2 | `tz1hQKqRPHmxET8du3fNACGyCG8kZRsXm2zD`
3 | `tz1Z2iXBaFTd1PKhEUxCpXj7LzY7W7nRouqf`

Data about fungible tokens is stored differently; see [Tokens](/architecture/tokens) for examples.

In this section, you create a function to read the data from the contract's ledger to find the IDs of the tokens that the connected account owns.

1. In the `src/App.svelte` file, add a top-level variable to represent the list of tokens that the connected account owns:

   ```javascript
   let userNfts;
   ```

2. Add a function that retrieves the NFTs that the user owns and puts them in the top-level variable:

   ```javascript
   const getUserNfts = async () => {
     if (!address) {
       return;
     }
     // Get the ID of the big-map that records token owners
     const contract = await Tezos.wallet.at(nftContractAddress);
     const nftStorage = await contract.storage();
     const ledger = nftStorage['ledger'];
     const ledgerID = ledger.id.toString();

     // Get the contents of the big-map
     const data = await fetch(`${rpcUrl}/chains/main/blocks/head/context/raw/json/big_maps/index/${ledgerID}/contents`);
     const keys = await data.json();

     // Get the owner of each NFT
     const tokenOwners = await Promise.all(
       keys.map((_k, index) => ledger.get(index.toString()))
     );

     // Filter to the IDs of the tokens that the connected address owns
     userNfts = tokenOwners.reduce((matchingIndexes, ownerAddress, index) => {
       if (ownerAddress === address) {
         matchingIndexes.push(index);
       }
       return matchingIndexes;
     }, []);
   };
   ```

   This function starts by requesting the storage of the contract.
   However, due to the way that big-maps are stored, the contract storage that Taquito provides does not contain the token owners.
   Instead, it contains an ID of the big-map, which the code uses to retrieve the current fields in the big-map.
   Then it retrieves the data in each of these fields, which is the address of the account that owns the token for a given ID.

3. Call the `getUserNfts` function at the end of the `connectWallet` and `createNFT` functions.

4. In the `<main>` section, after the "Create NFT" button, add a section that shows the NFTs that the connected account owns:

   ```javascript
   <div class="user-nfts">
     {#if userNfts?.length > 0}
       <p>
         IDs of your NFTs:
         {#each userNfts as nftID, index}
           {nftID}
           {#if index < userNfts.length - 1}
             <span>,&nbsp;</span>
           {/if}
         {/each}
       </p>
     {:else if userNfts?.length === 0}
       <p>The connected account has no NFTs.</p>
     {:else}
       <p>Loading this account's NFTs...</p>
     {/if}
   </div>
   ```

5. Run the application.
   After you connect your wallet, the application should show the IDs of the NFTs that the connected account owns, as in this picture:

   <img src="/img/tutorials/create-nfts-show-info-ids.png" alt="The application showing the IDs of the owned NFTs" style={{width: 300}} />

   If you don't see the IDs of the NFTs that your account owns, compare your source code to the code in https://github.com/trilitech/tutorial-applications/tree/main/create-nfts/part-5.

Now you can get information about NFTs in web applications.
You could extend the application to provide links for each NFT, a table of the NFTs and their owners, or a thumbnail image for each NFT.
For some closing information about the tutorial, see the [Summary](/tutorials/create-nfts/summary).


# Summary

Now you have an application that can connect to a user's wallet, send transactions on the user's behalf, and get information from Tezos.
You also learned:

* How to use Beacon to connect to Tezos-compatible wallets
* How to use Taquito to send transactions to Tezos and get information from Tezos
* Best practices for interacting with user wallets in decentralized applications
* Creating and deploying smart contracts with SmartPy, its FA2 library, and its online IDE

If you want to continue with the application, here are some ideas:

* Customize how the contract behaves, such as requiring a fee to mint a token
* Provide more information about the tokens on the web interface
* Allow users to send tokens to other users from the web interface

If you want to expand your knowledge of Tezos and tokens, see these tutorials:

* [Build an NFT marketplace](/tutorials/build-an-nft-marketplace)
* [Create a fungible token with the SmartPy FA2 library](/tutorials/smartpy-fa2-fungible)
* [Deploy a Smart Rollup](/tutorials/smartpy-fa2-fungible)


# Run a Tezos node in 5 steps

As described in [Nodes](/architecture/nodes), Tezos nodes are peer-to-peer programs that run the Tezos network.
Anyone can run a node, and they might do so for many different reasons, including:

* Running nodes makes the Tezos network resilient and secure
* Public nodes may have rate limits, so running your own node allows you to send unlimited requests to it to get information about Tezos or to send transactions from your dApps
* Running a node is part of being a baker and receiving the rewards for baking

This tutorial covers setting up a Tezos node as a baker, which includes running these processes:

* An Octez node, sometimes referred to as a Tezos node
* A baker daemon
* A [DAL](/architecture/data-availability-layer) node

:::note

If you want to use a Ledger hardware wallet to secure your keys, see [Bake using a Ledger device](/tutorials/bake-with-ledger).

:::

## Why is a DAL node needed?

The Tezos data availability layer (DAL) is a peer-to-peer network that Tezos Smart Rollups can use to fetch data securely.
The DAL is a key component for the scalability and bandwidth of Tezos and it's important for bakers to run DAL nodes along with their layer 1 nodes.

When users and dApps submit data to the DAL, bakers use DAL nodes to verify that the data is available.
Then the bakers attest that the data is available.
Smart Rollup nodes can retrieve the data from DAL nodes only when enough bakers have attested that the data is available.
Therefore, the DAL needs bakers who run layer 1 nodes, attesters, and DAL nodes.

Starting with the Rio upgrade, 10% of bakers' rewards are tied to their participation in attesting DAL data.

## Do you already run a baker?

For current bakers, it's a straightforward process to add a DAL node.
If you are familiar with running a node and baker, you can add a DAL node to your existing setup by following the instructions in [Running a DAL attester node](https://octez.tezos.com/docs/shell/dal_run.html).

## Running a baker and DAL node from start to finish

This guide covers the process of running a node, baker, and DAL node from start to finish, accessible for Tezos users with no prior experience in baking or running nodes.
This guide walks you through how to join Ghostnet as a baker and attest the publication of data on the DAL network on Ghostnet.
The steps for participating on any other network, including Tezos Mainnet, are similar.

:::note Attestation rights delay

Bakers need attestation rights to attest that data is available on the DAL.
Depending on the network, it takes time for bakers to get attestation rights.
The delay on Ghostnet is about 1 day, so in this tutorial you do setup work, wait 1 day for attestation rights, and verify that your DAL node and baker are working properly.

If you don't want to wait that long, you can use Weeklynet, where the delay is about an hour.
However, to use Weeklynet, you must use a specific version of the Octez suite.
You must also be aware that the network completely resets and moves to a new version of the Octez suite every Wednesday.
For information about using Weeklynet, see [Testing on testnets](/developing/testnets).

:::

## Diagram

In this guide, you set up the Octez client and several Octez daemons, including a layer 1 node, a baker, and a DAL node.
The following diagram shows these daemons with a blue background:

![A diagram of the DAL architecture, with the daemons that you create in this guide highlighted](/img/tutorials/join-dal-baker-overview.png)

<!-- https://lucid.app/lucidchart/b6b076ec-194c-4011-8e20-fa348bb983f3/edit?page=0_0# -->

## Prerequisites

To run the Octez daemons persistently, you need a cloud-based computer or a computer that stays running constantly.
For other system requirements, see the documentation for the [latest release of the Octez suite](https://octez.tezos.com/docs/releases/latest.html)
(search for section "Minimal hardware specifications").

## Other options for running a baker

These instructions are for baking with the Octez suite programs.
Other tools can help you set up a baker, but they are not covered in these instructions.
Here are some of these tools:

* [BakeBuddy and Ledger Nano](https://www.bakebuddy.xyz/): An intuitive plug-and-use method for setting up a node and baker
* [Kiln and Ledger Nano](https://gitlab.com/tezos-kiln/kiln): An intuitive plug-and-use method for setting up a node and baker
* [Signatory's remote Signer via the Cloud](https://www.ecadlabs.com/signatory)

## References

* For an overview of the DAL, see [Data Availability Layer](/architecture/data-availability-layer).
* For an introduction to how the DAL works, see the tutorial [Implement a file archive with the DAL and a Smart Rollup](/tutorials/build-files-archive-with-dal).
* For technical information about the DAL, see [Data-Availability Layer](https://octez.tezos.com/docs/shell/dal.html) in the Octez documentation.

## Getting started

To get started, go to [Step 1: Run an Octez node](/tutorials/join-dal-baker/run-node).


# Step 1: Run an Octez node

The first thing you need is a Tezos layer 1 node, which is an instance of the `octez-node` program and part of the Octez suite of programs.

## Installing Octez

The version of Octez to use depends on the Tezos network that you are using.

* For Mainnet or Ghostnet, install the most recent release of Octez, including `octez-client`, `octez-node`, `octez-dal-node`, and the baker for the current protocol:

  * On MacOS, run these commands:

    ```bash
    brew tap serokell/tezos-packaging-stable https://github.com/serokell/tezos-packaging-stable.git
    brew install tezos-client tezos-node tezos-dal-node tezos-baker-PsQuebec
    ```

  * On Linux and Windows WSL, download and install the built binaries from the [Octez release page](https://gitlab.com/tezos/tezos/-/releases), as in this example for Ubuntu:

    ```bash
    wget -O octez-binaries-22.0-linux-x86_64.tar.gz https://gitlab.com/tezos/tezos/-/package_files/185580267/download
    tar xf octez-binaries-22.0-linux-x86_64.tar.gz
    sudo cp octez-x86_64/octez* /usr/local/bin/
    ```

* For Weeklynet, look up the necessary version of Octez at https://teztnets.com/weeklynet-about and install it with the instructions there.

For more installation options, see [Installing Octez](https://octez.tezos.com/docs/introduction/howtoget.html) in the Octez documentation.

If you build from source, you can use the `latest-release` branch to work with Ghostnet.

## Running the layer 1 node

1. Ensure that the port on which the node listens for connections from peer nodes (by default, 9732) is accessible from outside its system.
   You may need to adapt your firewall rules or set up network address translation (NAT) to direct external traffic to the node.

2. Initialize the Octez node for the network.
   For example, to initialize it for Ghostnet, run this command:

   ```bash
   octez-node config init --network ghostnet
   ```

   By default, the node stores its data in the folder `$HOME/.tezos-node`.

3. Download a rolling snapshot of the network from https://snapshot.tzinit.org based on the instructions on that site.
   For example, the command to download a Ghostnet snapshot from the European servers might look like this:

   ```bash
   wget -O snapshot_file https://snapshots.eu.tzinit.org/ghostnet/rolling
   ```

   If you get an error that says that the data directory is invalid, clean up the directory as the error message indicates.

4. Load the snapshot in the node by running this command:

   ```bash
   octez-node snapshot import snapshot_file
   ```

5. Install the Zcash parameters as described [Install Zcash Parameters](https://octez.tezos.com/docs/introduction/howtoget.html#setup-zcash-params) in the Octez documentation.

6. Start the node:

   ```
   octez-node run --rpc-addr 127.0.0.1:8732
   ```

   You may add option `--log-output="$HOME/octez-node.log"` to redirect its output in a log file.

   At first launch, the node generates a fresh identity file used to identify itself on the network.
   Then it bootstraps the chain, which takes a variable amount of time depending on how many blocks need to be loaded.

7. Make sure the Octez client uses your node by running this command:

   ```bash
   octez-client -E http://localhost:8732 config update
   ```

   If you see an error that says "Failed to acquire the protocol version from the node," ensure that your node is running and verify that the host name and port in the `config update` command are correct.

8. Wait for your node to bootstrap by running this command:

   ```bash
   octez-client bootstrapped
   ```

   The client waits until it is connected and the node is running at the current level.
   When it is connected and the node is updated, the command prints the message `Node is bootstrapped`.
   The time it takes depends on how many blocks the node must retrieve to catch up from the snapshot to the current head block.

9. Optional: Hide the Octez client's network warning message by running this command:

   ```bash
   export TEZOS_CLIENT_UNSAFE_DISABLE_DISCLAIMER=y
   ```

   This command suppresses the message that your instance of the Octez client is not using Mainnet.

10. Ensure that the node runs persistently.
    Look up how to run programs persistently in the documentation for your operating system.
    You can also refer to [Setting up Octez Services](https://octez.tezos.com/docs/introduction/services.html) in the Octez documentation.

    For example, if your operating system uses the `systemd` software suite, your service file might look like this example:

    ```systemd title="/etc/systemd/system/octez-node.service"
    [Unit]
    Description=Octez node
    Wants=network-online.target
    After=network-online.target

    [Install]
    WantedBy=multi-user.target

    [Service]
    Type=simple
    User=tezos
    ExecStart=octez-node run --rpc-addr 127.0.0.1:8732 --data-dir $HOME/.tezos-node
    WorkingDirectory=/opt/octez-node
    Restart=on-failure
    RestartSec=5
    StandardOutput=append:/opt/octez-node.log
    StandardError=append:/opt/octez-node.log
    SyslogIdentifier=%n
    ```

    If you name this service file `/etc/systemd/system/octez-node.service`, you can start it by running these commands:

    ```bash
    sudo systemctl daemon-reload
    sudo systemctl start octez-node.service
    ```

    You can stop it by running this command:

    ```bash
    sudo systemctl stop octez-node.service
    ```

    The `systemd` software suite uses the `journalctl` program for logging, so you can use it to monitor the node and the other Octez daemons you run.
    For example, this command prints the log of the Octez node service as it is updated, similar to the `tail -f` command:

    ```bash
    journalctl --follow --unit=octez-node.service
    ```

    The `journalctl` program has options that let you search logs during time periods.
    For example, this command shows log entries between two times:

    ```bash
    journalctl --unit=octez-node.service --since "20 minutes ago" --until "60 seconds ago"
    ```

    For more information about logging, see the documentation for the `journalctl` program.

11. Optional: When the node has bootstrapped and caught up with the current head block, you can delete the snapshot file to save space.

In the meantime, you can continue the baking infrastructure while the node is bootstrapping.
Continue to [Step 2: Set up baker accounts](/tutorials/join-dal-baker/prepare-account).


# Step 2: Set up baker accounts

In this section you use the Octez client to set up two accounts for your baker:

* The baker key itself (also called the manager key) stakes tez and registers as a delegate
* The consensus key is the key that the baker uses to sign attestations, which are generally referred to as *consensus operations*

## Why set up a consensus key?

Using a separate consensus key is not required but it is good security practice.
Signing consensus operations incurs no fees, so you can set up a consensus key with no tez.
You can generate and use this key on a remote machine that runs the baker and keep the baker key with your staked tez in a more secure location to reduce risk to your funds.
This prevents you from having to move private keys between machines, which is inherently dangerous.

If the consensus key is compromised or lost, you can create a new consensus key and switch the baker to it without changing how your tez is staked and delegated and without moving your delegators and stakers to a new account.
In this way you can avoid transferring or backing up the consensus key or you can store it in a Key Management System (KMS) or Hardware Security Module (HSM) where no one has access to its private key.

However, the consensus key can drain the liquid (unstaked) tez from the baker key, so you must keep the consensus key secure like all other keys.

For more information about consensus keys, see [Consensus key](https://octez.tezos.com/docs/user/key-management.html#consensus-key) in the Octez documentation.

## Creating the accounts

In this section, you use the Octez client to create these accounts and set them up for baking.

1. Create or import an account in the Octez client to be the baker account (sometimes called the "manager" account).
   The simplest way to get an account is to use the Octez client to randomly generate an account.
   This command creates an account and associates it with the `my_baker` alias:

   ```bash
   octez-client gen keys my_baker
   ```

   You can get the address of the generated account with this command:

   ```bash
   octez-client show address my_baker
   ```

   You can check the liquid balance of the account with this command:

   ```bash
   octez-client get balance for my_baker
   ```

2. Ensure your account has at least 6,000 tez to stake, plus a small liquid amount for transaction fees.

   If you are using a testnet and need more tez, you can get tez from the testnet faucet.
   For example, if you are using Ghostnet, use the Ghostnet faucet linked from https://teztnets.com/ghostnet-about to send tez to the baker account.

   Running a baker requires staking at least 6,000 tez, but the more tez it stakes, the more rights it gets and the less time it has to wait to produce blocks and make attestations.
   However, be aware that getting large amounts of tez from the faucet may take a long time (sometimes more than one hour) to prevent abuse of the faucet.
   Consequently, some large requests may time out or fail and need to be resubmitted.

   When the account receives its tez, it owns enough stake to bake but has still no consensus or DAL rights because it has not declared its intention to become a baker.

3. (Optional) Set up a separate account to be the consensus key.
   This command creates an account and associates it with the `consensus_key` alias:

   ```bash
   octez-client gen keys consensus_key
   ```

   This account does not need any tez.

4. Register the baker account as a delegate and set its consensus key (if you set one) by running the following command:

   ```bash
   octez-client register key my_baker as delegate with consensus key consensus_key
   ```

   If you are not using a consensus key, omit the argument `with consensus key consensus_key`.

5. Stake at least 6,000 tez with the account, saving a small liquid amount for transaction fees.
   Staked tez is temporarily frozen and cannot be spent, so you need some unstaked tez to pay transaction fees.

   Pass the amount to the `stake` command, as in this example:

   ```bash
   octez-client stake 6000 for my_baker
   ```

   You can check how much you have staked by running this command:

   ```bash
   octez-client get staked balance for my_baker
   ```

   You can also check the full balance of the account (staked + non-staked) with this command:

   ```bash
   octez-client get full balance for my_baker
   ```

Now the baker account has staked enough tez to earn the right to make attestations, including attestations that data is available on the DAL.
If you set up a consensus key, that key is authorized to sign consensus operations on behalf of the baker account.
However, the accounts do not receive these rights until a certain amount of time has passed.

While you wait for attestation rights, continue to [Step 3: Run an Octez DAL node](/tutorials/join-dal-baker/run-dal-node).


# Step 3: Run an Octez DAL node

The DAL node is responsible for temporarily storing data and providing it to bakers and Smart Rollups.
As described in [Run a Tezos node in 5 steps](/tutorials/join-dal-baker), 10% of baker rewards are tied to their participation in attesting DAL data.

Follow these steps to run the DAL node:

1. Ensure that the port on which the DAL node listens for connections from peer nodes (by default, 11732) is accessible from outside its system.
   You may need to adapt your firewall rules or set up network address translation (NAT) to direct external traffic to the DAL node.
   For more information, see [Running a DAL attester node](https://octez.tezos.com/docs/shell/dal_run.html) in the Octez documentation.

2. Initialize the DAL node by running its `config init` command, passing the address of your `octez-node` instance in the `--endpoint` argument and your baker's account address in the `--attester-profiles` argument.
   For example, this command initializes the DAL node with the address of a local `octez-node` instance on port 8732 and stores data in the default DAL node directory (`~/.tezos-dal-node`):

   ```bash
   octez-dal-node config init --endpoint http://127.0.0.1:8732 \
     --attester-profiles=tz1...
   ```

   You cannot use the `my_baker` alias from the Octez client as in the previous section, so you must specify the address of your baker's account explicitly.

3. Start the DAL node by running this command:

   ```bash
   octez-dal-node run
   ```

   You may append `>>"$HOME/octez-dal-node.log" 2>&1` to redirect its output in a log file.

   This, too, may take some time to launch the first time because it needs to generate a new identity file, this time for the DAL network.

   If you need to change the address or port that the DAL node listens for connections to other nodes on, pass the `--public-addr` argument.
   By default, it listens on port 11732 on all available network interfaces, equivalent to `--public-addr 0.0.0.0:11732`.

4. Verify that the DAL node is connected to the DAL network by running this command:

   ```bash
   curl http://localhost:10732/p2p/points/info
   ```

   where `10732` is the default port on which the DAL node serves RPC calls.
   You can override it with the `--rpc-addr` argument.

   You may need to install the `curl` program.

   The response lists the network connections that the DAL node has, as in this example:

   ```json
   [
     {
       "point": "46.137.127.32:11732",
       "info": {
         "trusted": true,
         "state": {
           "event_kind": "running",
           "p2p_peer_id": "idrpUzezw7VJ4NU6phQYuxh88RiU1t"
         },
         "p2p_peer_id": "idrpUzezw7VJ4NU6phQYuxh88RiU1t",
         "last_established_connection": [
           "idrpUzezw7VJ4NU6phQYuxh88RiU1t",
           "2024-10-24T15:02:31.549-00:00"
         ],
         "last_seen": [
           "idrpUzezw7VJ4NU6phQYuxh88RiU1t",
           "2024-10-24T15:02:31.549-00:00"
         ]
       }
     },
     {
       "point": "52.31.26.230:11732",
       "info": {
         "trusted": true,
         "state": {
           "event_kind": "running",
           "p2p_peer_id": "idqrcQybXbKwWk42bn1XjeZ33xgduC"
         },
         "p2p_peer_id": "idqrcQybXbKwWk42bn1XjeZ33xgduC",
         "last_established_connection": [
           "idqrcQybXbKwWk42bn1XjeZ33xgduC",
           "2024-10-24T15:02:31.666-00:00"
         ],
         "last_seen": [
           "idqrcQybXbKwWk42bn1XjeZ33xgduC",
           "2024-10-24T15:02:31.666-00:00"
         ]
       }
     }
   ]
   ```

   It may take a few minutes for the node to connect to the DAL network.

   You can also verify that the DAL node is connected by viewing its log.
   When the node is bootstrapped it logs messages that look like this:

   ```
   Aug 12 17:44:19.985: started tracking layer 1's node
   Aug 12 17:44:24.418: layer 1 node's block at level 7538687, round 0 is final
   Aug 12 17:44:29.328: layer 1 node's block at level 7538688, round 0 is final
   ```

   The DAL node waits for blocks to be finalized, so this log lags 2 blocks behind the layer 1 node's log.

   Now the DAL node is connected to the DAL network but it is not yet receiving data.

5. Ensure that the DAL node runs persistently.
   Look up how to run programs persistently in the documentation for your operating system.
   You can also refer to [Setting up Octez Services](https://octez.tezos.com/docs/introduction/services.html) in the Octez documentation.

   For example, if your operating system uses the `systemd` software suite, your service file might look like this example:

   ```systemd
   [Unit]
   Description=Octez DAL node
   Wants=network-online.target
   After=network-online.target
   Requires=octez-node.service

   [Install]
   WantedBy=multi-user.target
   RequiredBy=octez-baker.service

   [Service]
   Type=simple
   User=tezos
   ExecStart=/usr/bin/octez-dal-node run --data-dir $HOME/.tezos-dal-node
   WorkingDirectory=$HOME/.tezos-dal-node
   Restart=on-failure
   RestartSec=5
   StandardOutput=append:/opt/octez-dal-node.log
   StandardError=append:/opt/octez-dal-node.log
   SyslogIdentifier=%n
   ```

Now that you have a DAL node running, you can start a baking daemon that uses that DAL node.
Continue to [Step 4: Run an Octez baking daemon](/tutorials/join-dal-baker/run-baker).


# Step 4: Run an Octez baking daemon

Now that you have a layer 1 node and a DAL node, you can run a baking daemon that can create blocks and attests to DAL data.
If you already have a baking daemon, you can restart it to connect to the DAL node.

:::warning Run one baker per account

Be sure to run only one baking daemon per Tezos account.
If you run more than one, you risk double-baking or double-attesting and being slashed.
However, it is safe to run two baking daemons during the protocol upgrade process because one daemon uses the previous protocol and the other daemon uses the new protocol.

:::

1. Optional: Set up a remote signer to secure the keys that the baker uses as described in [Signer](https://octez.tezos.com/docs/user/key-management.html#signer) in the Octez documentation.

2. Run a baking daemon with the following arguments:

   * Use the consensus key, not the baker key, if you are using a consensus key
   * Pass the URL to your DAL node with the `--dal-node` argument
   * Pass the `--liquidity-baking-toggle-vote` argument; for more information, see [Liquidity baking](https://octez.tezos.com/docs/active/liquidity_baking.html) in the Octez documentation
   * Pass the `--adaptive-issuance-vote` argument; for more information, see [Adaptive issuance](https://octez.tezos.com/docs/active/adaptive_issuance.html) in the Octez documentation

   For example:

   ```bash
   octez-baker-PsRiotum run with local node "$HOME/.tezos-node" consensus_key --liquidity-baking-toggle-vote pass --adaptive-issuance-vote on --dal-node http://127.0.0.1:10732
   ```

   Note that the command for the baker depends on the protocol version.
   This example uses the Rio protocol, so the command starts with `octez-baker-PsRiotum`.
   Check the current version of the protocol to see what command to run, and change this command when you upgrade to newer versions of the protocol.

   You may append `>>"$HOME/octez-baker.log" 2>&1` to redirect its output in a log file.

3. Ensure that the baker runs persistently.
   Look up how to run programs persistently in the documentation for your operating system.

   For example, if your operating system uses the `systemd` software suite, your service file might look like this example:

   ```systemd title="/etc/systemd/system/octez-baker-PsRiotum.service"
   [Unit]
   Description=Octez baker PsRiotum
   Wants=network-online.target
   After=network-online.target
   Requires=octez-node.service

   [Install]
   WantedBy=multi-user.target

   [Service]
   Type=simple
   User=tezos
   ExecStart=octez-baker-PsRiotum run with local node "$HOME/.tezos-node" consensus_key --liquidity-baking-toggle-vote pass --adaptive-issuance-vote on --dal-node http://127.0.0.1:10732
   WorkingDirectory=/opt/octez-baker
   Restart=on-failure
   RestartSec=5
   StandardOutput=append:/opt/octez-baker.log
   StandardError=append:/opt/octez-baker.log
   SyslogIdentifier=%n
   ```

   If you name this service file `/etc/systemd/system/octez-baker-PsRiotum.service`, you can start it by running these commands:

   ```bash
   sudo systemctl daemon-reload
   sudo systemctl start octez-baker-PsRiotum.service
   ```

   You can stop it by running this command:

   ```bash
   sudo systemctl stop octez-baker-PsRiotum.service
   ```

4. In the same terminal window, run this command:

   ```bash
   curl http://localhost:10732/p2p/gossipsub/topics
   ```

   DAL nodes share shards and information about them over a peer-to-peer pub/sub network built on the Gossipsub P2P protocol.
   As layer 1 assigns shards to the bakers, the Gossipsub network manages topics that DAL nodes can subscribe to.
   For example, if a user submits data to slot 1, the network has a list of topics: a topic to identify the slot 1 shards assigned to baker A, a topic to identify the slot 1 shards assigned to baker B, and so on for all the bakers that are assigned shards from slot 1.

   Then, the baker daemon automatically asks the DAL node to subscribe to the topics that provide the shards that it is assigned to.

   In the results of this command, each topic contains a shard and the address of the baker that is assigned to it.
   The DAL node and baker are listening to these topics and attesting that the data that they refer to is available.

   This command returns all of the topics that the baker is subscribed to in the format `{"slot_index":<index>,"pkh":"<ADDRESS OF BAKER>"}` where `index` varies between `0` included and the number of slot indexes excluded.

   You can also look at the baker logs to see if it injects the expected operations. At each level, the baker is expected to do a subset of these operations:

   * Receive a block proposal (log message: "received new proposal ... at level ..., round ...")
   * Inject a preattestation for it (log message: "injected preattestation ... for my_baker (<address>) for level ..., round ...")
   * Receive a block (log message: "received new head ... at level ..., round ...")
   * Inject a consensus attestation for it (log message: "injected attestation ... for my_baker (<address>) for level ..., round ...")
   * Attach a DAL attestation to it, indicating which of the shards assigned to the baker have been seen on the DAL network (log message: "ready to attach DAL attestation for level ..., round ..., with bitset ... for my_baker (<address>) to attest slots published at level ...")

## Upgrading the baker

The version of the baker program depends on the version of the Tezos protocol.
Therefore, when a new version of the Tezos protocol becomes active, you must start the baker for the new protocol immediately.

To simplify the upgrade process, you can follow these steps when the new protocol is about to be activated:

1. Check the release pages in the [Octez documentation](https://octez.tezos.com/docs) (section `Changes in Octez releases`) or check the posts on the forum at https://forum.tezosagora.org to see which version of the Octez suite supports the upcoming protocol and upgrade your Octez suite if necessary.
   The Octez release page gives instructions for upgrading.

2. Leave the baker for the previous protocol running, such as the `octez-baker-PsQuebec` daemon.

3. Start the baker for the new protocol, such as the `octez-baker-PsRiotum` daemon.
   This daemon is not yet able to bake because it is using the future version of the protocol, but you can run it early without causing any problems.
   However, make sure not to run the baker twice **for the same protocol version and the same baker account**, to avoid being slashed for double signing.

4. When the new version of the protocol becomes active, the previous protocol baker is no longer able to bake and the new protocol baker begins to bake automatically.

5. Then you can stop the previous protocol baker.

You can upgrade accusers with a similar process.

## Backing up and restoring the baker

The Octez baking daemon stores persistent operational data in the Octez client's data directory, notably consensus high-water marks and [random seed nonces](https://octez.tezos.com/docs/active/randomness_generation.html).
If you want to back up the baker or move it to another machine and restore it, you must copy the nonce file or files from the Octez client's data directory to the equivalent directory on the new machine.
These nonce files are named `net<NETWORK_ID>_stateful_nonces` and `net<NETWORK_ID>_nonces`, where `<NETWORK_ID>` is the ID of the network, such as `netXdQprcVkpaWU_stateful_nonces` for Mainnet or `netXnHfVqm9ie_stateful_nonces` for Ghostnet.
All deployments have the `net<NETWORK_ID>_stateful_nonces` file but only legacy baking deployments running versions of Octez prior to 20.0rc1 have the `net<NETWORK_ID>_nonces` file.

After you have moved the nonce files to the new machine and verified that the baker runs normally for one cycle, you can remove the legacy `net<NETWORK_ID>_nonces` file.

## Calculating the delay for attestation rights

If you are setting up a new baker, you must wait until it receives attestation rights before it can bake blocks or attest to DAL data.
The delay to receive attestation rights is a number of cycles determined by the value of the `consensus_rights_delay` constant.
You must wait until the end of the current cycle (represented below as `remaining_current_cycle`) and then for this number of cycles to pass before the baker receives attestation rights.

A cycle is a number of blocks; the `blocks_per_cycle` constant determines how many blocks are in a cycle.
The `minimal_block_delay` constant determines the time between blocks in seconds.
Therefore, you can calculate the approximate time in seconds that it takes a baker to receive attestation rights with this formula:

```
remaining_current_cycle + (consensus_rights_delay * blocks_per_cycle * minimal_block_delay)
```

Follow these steps to calculate the delay to receive attestation rights:

1. Run these commands to get the values of the network constants:

   ```bash
   octez-client rpc get /chains/main/blocks/head/context/constants | jq | grep consensus_rights_delay
   ```

   ```bash
   octez-client rpc get /chains/main/blocks/head/context/constants | jq | grep blocks_per_cycle
   ```

   ```bash
   octez-client rpc get /chains/main/blocks/head/context/constants | jq | grep minimal_block_delay
   ```

   You may need to install the `jq` program to run these commands.

2. Using the values from the responses, calculate the attestation rights delay in seconds.
   For example, if `consensus_rights_delay` is 2 cycles, `blocks_per_cycle` is 10,800 blocks, and `minimal_block_delay` is 4 seconds, a new baker receives attestation rights after a delay of about 86,400 seconds.

3. Divide the number of seconds by 86,400 to get the attestation delay in days.
   For example, if the delay is 86,400 seconds, that time is about 1 day.

   The exact time can be slightly longer because the `minimal_block_delay` constant is the minimum time between blocks.
   If the first baker chosen to bake a block does not bake it after a certain amount of time, other bakers have the opportunity to bake it, which increases the time between blocks.

   :::note

   The amount of tez that the account stakes determines how often it is called on to make attestations, not how quickly it receives rights.
   Therefore, staking more tez brings more rewards but does not reduce the attestation delay.

   :::

4. Add the time remaining in the current cycle.
   For example, you can go to https://tzkt.io/ and click the network indicator at the top left of the page, as in this picture:

   <img src="/img/tutorials/tzkt-next-cycle.png" alt="The TZKT block explorer, showing information about the current cycle" style={{width: 300}} />

5. After the delay computed above has passed, **the baker log** (not the Octez node log, neither the DAL node log) should contain lines that look like this:

   * Consensus pre-attestations: `injected preattestation ...`
   * Consensus attestations: `injected attestation ...`
   * Attach DAL attestations: `ready to attach DAL attestation ...`

   These lines log the attestations that the baker makes.

   If the baker does not have attestation rights, the log contains lines that start with `The following delegates have no attesting rights at level ...`.

   Note that even though the baker daemon is using the consensus key, the attestations refer to the baker key.
   The consensus key makes attestations on behalf of the baker key but the baking daemon does not need access to the baker key.

After the attestation delay, whether or not you have attestation rights, proceed to [Step 5: Verifications](/tutorials/join-dal-baker/verify-rights).

## Optional: Run an accuser

The accuser is a daemon that monitors blocks and looks for problems, such as bakers who double-sign blocks or inject multiple attestations.
If it finds a problem, it posts a denunciation operation, which leads to penalizing the misbehaving baker.
You don't have to run an accuser, but if you do, you can receive as a reward part of the penalties of the denounced baker.

Like the baker, the command for the accuser has the protocol name at the end.
For example, if your operating system uses the `systemd` software suite, the attester service file might look like this example:

```systemd title="/etc/systemd/system/octez-accuser-PsRiotum.service"
[Unit]
Description=Octez accuser PsRiotum
Wants=network-online.target
After=network-online.target
Requires=octez-node.service

[Install]
WantedBy=multi-user.target

[Service]
Type=simple
User=tezos
ExecStart=octez-accuser-PsRiotum run
WorkingDirectory=/opt/octez-accuser
Restart=on-failure
RestartSec=5
StandardOutput=append:/opt/octez-accuser.log
StandardError=append:/opt/octez-accuser.log
SyslogIdentifier=%n
```


# Step 5: Verifications

After the delay that you calculated in [Step 4: Run an Octez baking daemon](/tutorials/join-dal-baker/run-baker), follow these instructions to verify the activity or diagnose and fix issues.

1. Record the address of your baker account (not the consensus account) in an environment variable so you can use it for commands that cannot get addresses by their Octez client aliases:

   ```bash
   MY_BAKER="$(octez-client show address my_baker | head -n 1 | cut -d ' ' -f 2)"
   ```

2. Run these commands to get the (consensus) attestation rights for the baker in the current cycle:

   1. Get the current cycle by running this command:

      ```bash
      octez-client rpc get /chains/main/blocks/head | jq | grep '"cycle"'
      ```

   2. Use the current cycle as the `<current-cycle>` parameter in this command.
      Beware, this command may take several minutes to finish if the list of rights is long:

      ```bash
      octez-client rpc get "/chains/main/blocks/head/helpers/attestation_rights?delegate=$MY_BAKER&cycle=<current-cycle>"
      ```

   When the baker has attestation rights, the command returns information about them, as in this example:

   ```json
   [ { "level": 9484,
    "delegates":
      [ { "delegate": "tz1Zs6zjxtLxmff51tK2AVgvm4PNmdNhLcHE",
          "first_slot": 280, "attestation_power": 58,
          "consensus_key": "tz1Zs6zjxtLxmff51tK2AVgvm4PNmdNhLcHE" } ] }
      ...
    ]
   ```

   If the command returns an empty array (`[]`), the baker has no rights in the specified cycle.

   * Check to see if you will receive rights two cycles in the future, using commands similar to those above for the current cycle.
     You can see who will receive rights no farther than two cycles in the future.
     This number of cycles is set by the `consensus_rights_delay` network parameter.

     If this returns a list of future attestation rights for your account, you must wait for that cycle to arrive.

   * Otherwise, make sure that your node and baker are running.

   * Verify that the staked balance of your baker account is at least 6,000 tez by running the command `octez-client get staked balance for my_baker`.
     If the response is less than 6,000 tez, you have not staked enough.
     Ensure that you are registered as a delegate and stake more tez, retaining a small amount for transaction fees.
     If necessary you can get more from the faucet.

   * Check to see if you are active and re-register as a delegate if necessary:

     1. Run this command to see if your account is marked as inactive:

        ```bash
        octez-client rpc get /chains/main/blocks/head/context/delegates/$MY_BAKER/deactivated
        ```

        Baker accounts are deactivated when the baker is offline for a certain time.

     2. If the value for the `deactivated` field is `true`, re-register as a baker by running this command:

        ```bash
        octez-client register key my_baker as delegate with consensus key consensus_key
        ```

     When the next cycle starts, Tezos calculates attestation rights for two cycles in the future and includes your baker.

     You can find when the next cycle will start by running these commands:

     1. Find the last level of the current cycle by running this command:

        ```bash
        octez-client rpc get "/chains/main/blocks/head/helpers/levels_in_current_cycle"
        ```

     ```
     1. Pass the last level of the cycle as the `<last-block>` parameter in this command:
     ```

     ````
        ```bash
        octez-client rpc get "/chains/main/blocks/head/helpers/attestation_rights?level=<last-block>" | grep '"estimated_time"'
        ```

        The response shows the estimated time when the cycle will end.
     ````

     You can also find when the next cycle will start by going to a block explorer such as https://ghostnet.tzkt.io.
     For example, this drop-down shows that the next cycle starts in 29 minutes:

     <img src="/img/tutorials/tzkt-next-cycle.png" alt="The TZKT block explorer, showing information about the current cycle" style={{width: 300}} />

3. When your baker receives attestation rights as determined by the `/chains/main/blocks/head/helpers/attestation_rights` RPC call, run this command to get the shards that are assigned to your DAL node for the next block:

   ```bash
   octez-client rpc get "/chains/main/blocks/head/context/dal/shards?delegates=$MY_BAKER"
   ```

   The response includes your account's address and a list of shards, as in this example:

   ```json
   [ { "delegate": "tz1QCVQinE8iVj1H2fckqx6oiM85CNJSK9Sx",
    "indexes": [ 25, 27, 67, 73, 158, 494 ] } ]
   ```

   These shards are pieces of data that the baker is assigned to attest.

   Note that you have to potentially execute the command above during many block levels in order to find a block where you have some shards assigned.
   There is currently no simple command line to get all your DAL rights for a whole cycle, but you can call it in a loop for future levels until you see some shards.
   First, get the current level:

   ```bash
   octez-client rpc get /chains/main/blocks/head | jq '.header.level'
   ```

   and pass it as the `<current-level>` parameter in this command:

   ```bash
   l=<current-level>; while true; echo $l; do octez-client rpc get "/chains/main/blocks/head/context/dal/shards?delegates=$MY_BAKER&level=$l"; l=$((l+1)); done
   ```

   If the DAL is active, you should see shards assigned for at least some levels but not necessarily every level.

4. Verify the baker's activity on the Explorus block explorer by going to the Consensus Ops page at https://explorus.io/consensus_ops, selecting Ghostnet, and searching for your baker account address (only the first few characters).

   For example, this screenshot shows consensus operations that include DAL attestations, indicated by a number in the "DAL attestation bitset" column.

   ![DAL consensus operations, showing DAL consensus operations](/img/tutorials/dal-explorus-consensus-ops.png)

   If there is no DAL attestation, the block explorer shows a document icon with an X in it: ![](/img/tutorials/dal-explorus-no-attestation-icon.png).
   This icon can appear before the bakers complete attestations and then turn into a binary number when they attest.

   If you see the rights, you will see the attestations in the baker's log when scheduled. Now you have a complete DAL baking setup.
   Your baker is attesting to the availability of DAL data and the DAL node is sharing it to Smart Rollups across the network.

If you don't see DAL attestation rights:

* Verify that your DAL node is connected to the network by following the instructions in [Troubleshooting](https://octez.tezos.com/docs/shell/dal_run.html#troubleshooting) in the Octez documentation.

## Optional: Changing the consensus key

If you need to change the consensus key that the baker daemon uses, you can change it without changing the baker key.
The new key takes effect after the same attestation delay that you had to wait for your baker to receive attestation rights when you first set it up:

```
remaining_current_cycle + (consensus_rights_delay * blocks_per_cycle * minimal_block_delay)
```

Follow these steps to change the consensus key:

1. Generate a new consensus key with the `octez-client gen keys` command or import a private key into the instance of the Octez client on the same machine as the baking daemon.

2. Use this new key as the consensus key for your baker account by running this command, with the address or alias of the new consensus key as the `<NEW CONSENSUS KEY>` variable:

   ```bash
   octez-client set consensus key for my_baker to <NEW CONSENSUS KEY>
   ```

3. Wait for the change to take effect.
   During this time you can leave the baking daemon running with the old consensus key.

4. When the new consensus key is active, stop the baking daemon and restart it with the new consensus key.

To revoke the consensus key, set the consensus key to the baker key, as in this command:

```bash
octez-client set consensus key for my_baker to my_baker
```

Consensus keys can transfer the liquid (unstaked) tez from the baker key to any other account with the `drain delegate` command, as in this example:

```bash
octez-client drain delegate my_baker to consensus_key with consensus_key
```

## Optional: Unstaking your tez and receiving your baking rewards

If you leave the baker running, you can see rewards accrue by running the command `octez-client get staked balance for my_baker`.
This amount starts at the amount that you originally staked and increases with your baking rewards.

You can unstake your tez and withdraw your stake and any baking rewards with the `octez-client unstake` command.
For example, this command unstakes 6,000 tez:

```bash
octez-client unstake 6000 for my_baker
```

You can substitute "everything" for the amount of tez to unstake everything.

Then, after the same delay of `consensus_rights_delay` cycles, run this command to retrieve the tez:

```bash
octez-client finalize unstake for my_baker
```

Then you can do whatever you want with the tez, including sending it back to the faucet for someone else to use.
The Ghostnet faucet's address is `tz1a4GT7THHaGDiTxgXoatDWcZfJ5j29z5RC`, so you can send funds back with this command:

```bash
octez-client transfer 6000 from my_baker to tz1a4GT7THHaGDiTxgXoatDWcZfJ5j29z5RC
```

For a summary, see [Conclusion](/tutorials/join-dal-baker/conclusion).


# Conclusion

In this guide you have gone through all the steps needed to participate as a baker and DAL node.
The steps for participating on any other network, including Tezos Mainnet, are similar, but other networks have different parameters.
For example, the attestation delay on Mainnet is 2 weeks.

You could further improve the setup by defining system services so that the daemons are automatically launched when the machine starts.
You could also plug a monitoring solution such as the Prometheus + Grafana combo; a Grafana dashboard template for DAL nodes is available in Grafazos.
The interactions between your baker and the chain can be observed on the Explorus block explorer which is aware of the DAL and can in particular display which DAL slots are being used at each level.

As a next step, you can create a Smart Rollup that uses DAL data in the tutorial [Implement a file archive with the DAL and a Smart Rollup](/tutorials/build-files-archive-with-dal).


# Bake using a Ledger device

## What is a Ledger device?

A Ledger device is a physical wallet provided by [Ledger](https://www.ledger.com). Its main purpose is to store the holder's private keys without ever disclosing them.

Ledger devices support many blockchains by installing applications, such as an application to manage Tezos accounts and keys and an application to allow a Tezos baker to use keys on the Ledger.

## Why use a Ledger device to bake?

The baker daemon must have constant access to the baker's private key so that it can sign consensus operations and blocks.
If a malicious entity manages to get access to this private key, it will also gain access to the baker's funds.
Keeping your private key on a Ledger device and only interacting with an application dedicated to baking would prevent any direct access to your private key.

## Setting up your Ledger to launch a baker signing with Ledger

Follow this tutorial before setting up your baker with the tutorial [Run a Tezos node in 5 steps](/tutorials/join-dal-baker). This tutorial will tell you when to switch to that tutorial and what changes to make so the baker you set up will use the accounts on your Ledger device.

In this tutorial, we'll look at:

* how to install the Tezos baking application on your Ledger device
* how to configure your Ledger device so that the [Ledger baking application of Tezos](https://github.com/trilitech/ledger-app-tezos-baking) works properly
* how to use an external signer (`octez-signer`) while running your baker for enhanced protection

## Prerequisites

* A Ledger device: Nano S, Nano S+, Nano X, Stax or Flex
* A computer or cloud VM that can run without interruptions, because the baker program must run persistently
* The latest version of the Octez suite, including the `octez-signer` program

:::note

Note that a PIN input will be required after a power failure. To ensure a truly persistent system, please use a [UPS](https://wikipedia.org/wiki/Uninterruptible_power_supply).

:::


# Install the Ledger baking application of Tezos

[`Tezos Baking`](https://github.com/trilitech/ledger-app-tezos-baking) is the application developed to bake on Tezos using your Ledger device.
It allows you to sign block and consensus operations while keeping your private keys secure in the Ledger hardware. Some of its additional features are:

1. HWM tracking to avoid double baking
2. Restricted signing permission, i.e. it only allows signing baking related operations. You can not approve signing of funds transfer using baking app on Ledger.

## Download `Ledger Live`

To download the Tezos baking application, you first need to download `Ledger Live`.
[`Ledger Live`](https://www.ledger.com/ledger-live) is the application provided by Ledger to allow you to download the various applications compatible with your Ledger device.

## Download `Tezos Baking`

Once you have downloaded `Ledger Live`, launch it.

The Tezos baking application is only available when developer mode is activated. To activate it, go to settings and, in the `Experimental features` tab, activate `Developer mode`. With developer mode enabled, the Tezos baking application is now accessible.

Click on `My Ledger`. If you have not already done so, connect your Ledger device to the USB port and authorize the secure connection to `Ledger Live` on your Ledger device.

Search for the `Tezos Baking` application and click on `Install`.

![Install the Ledger Tezos Baking application from Ledger Live](/img/tutorials/bake-with-ledger/install-ledger-tezos-baking-app.gif)

## Download `Tezos Wallet (XTZ)`

To be able to sign the operations needed to set up your baker, you also need the `Tezos Wallet (XTZ)` application.
[`Tezos Wallet (XTZ)`](https://github.com/trilitech/ledger-app-tezos-wallet) is the application developed to sign Tezos operations using your Ledger device.

Find and install the `Tezos Wallet (XTZ)` application.


# Set up your ledger

## Disable PIN lock

The Tezos baking application allows you to bake securely without interruption. However, you will need to disable auto PIN lock feature in the Ledger to avoid getting locked out of the Ledger. Otherwise the Ledger device will lock itself and baking app will not work.

:::note Warning

Disabling the automatic lock on your Ledger device poses a risk that if any other app except baking-app is left open on your device, someone could get access to your funds by using that Ledger if left unattended.
The Tezos baking application is extremely secure and it only allows you to sign baking-related transactions and requires a PIN code to exit the application. However, remember to **reactivate the automatic lock on your Ledger device if you stop using the Tezos baking application on this device**.

:::

Go to the settings of your Ledger device and search for the automatic PIN lock option, then deactivate it.

* For **NanoS, NanoS+ and NanoX** devices: Go to `Settings` > `Security` > `PIN lock`, then select `No PIN lock` (`Off` for **NanoS**).
* For **Stax and Flex** devices: Go to `Settings` > `Lock screen` > `Auto-lock`, then disable `Auto-lock`.

## Charging & Battery Saver Considerations

Since your baker runs continuously, it is **strongly recommended to keep your Ledger device constantly powered** to prevent it from running out of battery.

On **NanoX, Stax, and Flex** devices, a battery saver setting allows your Ledger to automatically power off after a period of inactivity to preserve battery life. However, since the Baking app requires the device to remain active at all times, it is **highly recommended to disable this option**.

* For **NanoX** devices: Go to `Settings` > `General` > `Battery Saver`, then select `Never power off`.
* For **Stax and Flex** devices: Go to `Settings` > `Battery` > `Auto Power-Off`, then disable `Auto Power-Off`.

## Screen saver

In order to preserve the performance and integrity of your Ledger device, it is **strongly recommended** to activate the screen saver of your Ledger device. Go to the settings of your Ledger device and look for the screen saver option, then activate it for a value that suits you.

* For **NanoS, NanoS+ and NanoX** devices: Go to `Settings` > `Security` > `Screen saver`.
* For **Stax and Flex** devices there is no screen saver as of writing this article (Jan 25).

## HWM option

:::note Warning

HWM (High Watermark) protection exists in the Ledger `Tezos Baking` application to avoid double-baking, double-attesting or double-preattesting at the level. The HWM is stored in NVRAM (Non-volatile Random Access Memory), after every signature, by the `Tezos Baking` application (that is on each pre-attestation, attestation, but also while signing blocks).

The NVRAM on Ledger has limited read/write lifetime, thus frequent updates of NVRAM leads to NVRAM burn. To resolve this, an **optional** setting called HWM (ENABLE/DISABLE) is added to the Ledger `Tezos Baking` application (since v 2.4.7). When disabled, it allows storing HWM on RAM instead of NVRAM during the signature of operations. This increases the speed/performance of the Ledger `Tezos Baking` application and extends the lifetime of Ledger devices. The last HWM value on the Ledger’s RAM is written to NVRAM at the time of exiting the Ledger `Tezos Baking` application for persistent storage.
In case of an abrupt interruption of the Ledger `Tezos Baking` application, e.g. caused by an abrupt power off of the Ledger device, the current HWM value may not be updated to the device’s NVRAM. Thus, it’s important to reset the value of the HWM on the Ledger device to the highest HWM value signed by the baker, before resuming baking. (See [Setup the Ledger high watermark (HWM)](/tutorials/bake-with-ledger/run-baker#setup-the-ledger-high-watermark-hwm) to setup the HWM)

:::

For additional protection from double-baking, this tutorial demonstrates the use of an external signer (`octez-signer`), which keeps track of HWM and prevents double baking. It's recommended to use this external signer when you disable the HWM feature on your Ledger device.


# Set up your Ledger baking key with octez-signer

It’s recommended to use a separate machine to run the remote signer. For simplicity, in this tutorial, we assume a setup where the Ledger device is connected to the same machine running the baker binary. On the same machine, the following commands can be used to set up the baking key with `octez-signer`.

## Import a key from your Ledger device to the `octez-signer` context

Let's start by importing a key from your Ledger device for `octez-signer`.
Connect your Ledger device with a USB cable and open the `Tezos Baking` application.
To see the available keys, run:

```bash
octez-signer list connected ledgers
```

Output:

```console
## Ledger `masculine-pig-stupendous-dugong`
Found a Tezos Baking 2.4.7 (git-description: "v2.4.7-70-g3195b4d2")
application running on Ledger Nano S Plus at [1-1.4.6:1.0].

To use keys at BIP32 path m/44'/1729'/0'/0' (default Tezos key path), use one
of:
  octez-client import secret key ledger_username "ledger://masculine-pig-stupendous-dugong/ed25519/0h/0h"
  octez-client import secret key ledger_username "ledger://masculine-pig-stupendous-dugong/secp256k1/0h/0h"
  octez-client import secret key ledger_username "ledger://masculine-pig-stupendous-dugong/P-256/0h/0h"
  octez-client import secret key ledger_username "ledger://masculine-pig-stupendous-dugong/bip25519/0h/0h"
```

Key's URIs are of the form `ledger://<animals>/<curve>[/<path>]` where:

* `<animals>` is the identifier of the ledger.
* `<curve>` is the signing curve
* `<path>` is a BIP32 path anchored at m/44h/1729h. The ledger does not yet support non-hardened paths, so each node of the path must be hardened.

:::note Signing curve

The `secp256k1` and `P-256` signature schemes (resp. `tz2` and `tz3`) have the best signature performance with the `Tezos Baking` application.

:::

Choose one of the URIs shown, modifying the BIP32 path as you like, then import it using `octez-signer`:

```bash
octez-signer import secret key my_ledger_key "ledger://masculine-pig-stupendous-dugong/secp256k1/0h/0h"
```

On your Ledger device, you should see a screen sequence similar to:
![Ledger Key Review](/img/tutorials/bake-with-ledger/pkh-review.png)

<!-- https://lucid.app/lucidchart/26df7357-40e6-4c1b-8ffe-0e4b8eebf707/edit?beaconFlowId=D98D3B908C0603CC&invitationId=inv_08b134b7-3e40-4429-af31-101e36489cc3&page=0_0# -->

If the public key hash displayed on your Ledger is equal to the address displayed in the command output, you can approve.

Output:

```console
Please validate (and write down) the public key hash displayed on the Ledger,
it should be equal
to `tz...`:
Tezos address added: tz...
```

## Authorise the baking key in the `Tezos Baking` application

For your security, the `Tezos Baking` application only allows one key to be used for signing. So you need to specify which key you want to bake with:

```bash
octez-signer setup ledger to bake for my_ledger_key
```

On your Ledger device, you should see a screen sequence similar to:
![Ledger Setup Review](/img/tutorials/bake-with-ledger/setup-review.png)

<!-- https://lucid.app/lucidchart/26df7357-40e6-4c1b-8ffe-0e4b8eebf707/edit?beaconFlowId=D98D3B908C0603CC&invitationId=inv_08b134b7-3e40-4429-af31-101e36489cc3&page=0_0# -->

If the information displayed on your Ledger is similar to the information displayed in the command output, you can approve.

Output:

```console
Setting up the ledger:
* Main chain ID: 'Unspecified' -> NetXdQprcVkpaWU
* Main chain High Watermark: 0 (round: 0) -> 0 (round: 0)
* Test chain High Watermark: 0 (round: 0) -> 0 (round: 0)
Authorized baking for address: tz...
Corresponding full public key: ..pk...
```

## Link `octez-signer` to `octez-client`

Now that your baking key on `octez-signer` is linked to your Ledger device, `octez-signer` will be in charge of signing using your Ledger device. Let's launch `octez-signer`:

```bash
octez-signer launch socket signer -a localhost
```

> The default port is `7732`.

To be able to sign from `octez-client` and from the baker binaries, you have to link your remote signer for `octez-client`.
In a new terminal, run:

```bash
octez-client -R 'tcp://localhost:7732' config update
```

This way, the key stored in the context of your `octez-signer` will be accessible by remote from the `octez-client` context.


# Running a baker signing using a Ledger baking key

Now that the Ledger baking key is set up, you can follow the steps of [Run a Tezos node in 5 steps](/tutorials/join-dal-baker). However, some steps will differ.

## Set up a baker account

Complete the [Step 1: Run an Octez node](/tutorials/join-dal-baker/run-node) of the tutorial, and make following changes in [Step 2: Set up a baker account](/tutorials/join-dal-baker/prepare-account).

You can use your Ledger key as your main baker key or you could use Ledger key as consensus key.

* To **use the Ledger key as your main baker key**, import it from the `octez-signer` remote with the following command:

  ```bash
  octez-client import secret key my_baker remote:tz...
  ```

  > Replace the `tz...` with the public key hash of your Ledger baking key.

  Run and sign the following operations to set up your baker. You will need to use the `Tezos Wallet (XTZ)` application.
  Quit the `Tezos Baking` application and open the `Tezos Wallet (XTZ)` application. Then set up your baker.

  ```bash
  octez-client import secret key my_baker remote:tz...
  octez-client register key my_baker as delegate
  octez-client stake 6000 for my_baker
  ```

  Your baker account is now set up and ready to bake using the Ledger.

* If you **want to use your Ledger key as a consensus key**, import it from the `octez-signer` remote with the following command:

  ```bash
  octez-client import secret key consensus_key remote:tz...
  ```

  > Replace the `tz...` with the public key hash of your Ledger baking key.

  With Ledger key imported as consensus key, you will need to generate/set up your baker key separately. You can then continue to set up your baker account. See the following commands:

  ```bash
  octez-client gen keys my_baker
  octez-client register key my_baker as delegate with consensus key consensus_key
  octez-client stake 6000 for my_baker
  ```

  By registering your baker as a delegate with the ledger key as the consensus key, the baker daemon will sign using the Ledger.

## Before running the Octez baking daemon

Complete [Step 3: Run an Octez DAL node](/tutorials/join-dal-baker/run-dal-node). For the [Step 4: Run an Octez baking daemon](/tutorials/join-dal-baker/run-baker), make following changes to setup `octez-signer` and `Tezos Baking` application.

### Setup the Ledger high watermark (HWM)

For security reasons, always reset HWM to the highest possible block value before starting to bake. The highest block can be obtained from [Tzkt](https://www.tzkt.io/blocks?expand=1). Then, use that block value as the level in the following command.

Go back to the `Tezos Baking` application and run:

```bash
octez-signer set ledger high watermark for my_ledger_key to <LEVEL>
```

On your Ledger device, you should see a screen sequence similar to:
![Ledger Setup Review](/img/tutorials/bake-with-ledger/set-hwm-review.png)

<!-- https://lucid.app/lucidchart/26df7357-40e6-4c1b-8ffe-0e4b8eebf707/edit?beaconFlowId=D98D3B908C0603CC&invitationId=inv_08b134b7-3e40-4429-af31-101e36489cc3&page=0_0# -->

Check that the HWM is the one you supplied, then you can approve.

Output:

```console
ledger://masculine-pig-stupendous-dugong/secp256k1/0h/0h has now high water mark: 42 (round: 0)
```

:::note

Alternatively, the HWM can be set up from the setup command:

```bash
octez-signer setup ledger to bake for my_ledger_key --main-hwm <LEVEL>
```

:::

### Set up additional checks for `octez-signer`

`octez-signer` also has the ability to enable various checks. Stop the previously launched `octez-signer` TCP socket and restart it with the following command:

```bash
octez-signer launch socket signer -M 0x11,0x12,0x13 -W -a localhost
```

> The `-M 0x11,0x12,0x13` option is used to only request consensus operations and blocks to be signed.

> The `-W` tag is used to activate the HWM check.

:::note Warning

The `-W` tag is required if you have chosen to disable the `High Watermark` option in the `Tezos Baking` application.

:::

## Security verifications

Everything is ready, you can now finish the tutorial [Run a Tezos node in 5 steps](/tutorials/join-dal-baker). The baking daemon will send the data to be signed to `octez-signer` which will send it to your Ledger device, which will sign them.

Once the baking daemon has started, you can check on your Ledger device that the HWM is evolving in accordance with the blocks signed by your Ledger baking key.

The `octez-signer` also stores the HWM for the blocks it has signed. You can find them in a file named `Net..._highwatermarks` in the `.tezos-client` folder.

> `Net...` being the chain-id of the chain in which you bake.

Open the file and check that the HWMs evolve in accordance with the blocks signed by your Ledger baking key:

```bash
cat .tezos-client/NetXnHfVqm9iesp_highwatermarks
```

```json
{ "blocks":
    [ { "delegate": "tz...",
        "highwatermark": { "round": 0, "level": 107095 } } ],
  "preattestations":
    [ { "delegate": "tz...",
        "highwatermark": { "round": 0, "level": 107096 } } ],
  "attestations":
    [ { "delegate": "tz...",
        "highwatermark": { "round": 0, "level": 107096 } } ] }
```

Now the baking daemon is running and using the Ledger to sign consensus (baking) operations. You can leave the baker running and check on it by looking at the block numbers at the end of the `.tezos-client/NetXnHfVqm9iesp_highwatermarks` file.


# Deploy a Smart Rollup

This tutorial covers how to deploy a Smart Rollup in a Tezos sandbox.
To run this tutorial, you should have a basic understanding of how Tezos works and the ability to use the command-line terminal on your computer.

In this tutorial, you will learn:

* What a Smart Rollup is and how they help scale Tezos
* How information passes between Tezos and Smart Rollups
* How to respond to messages from Tezos in a Smart Rollup

## What is a Smart Rollup?

Smart Rollups are processing units that run outside the Tezos network but communicate with Tezos on a regular basis.
These processing units can run arbitrarily large amounts of code without waiting for Tezos baking nodes to run and verify that code.
Smart Rollups use Tezos for information and transactions but can run large applications at their own speed, independently of the Tezos baking system.

In this way, Smart Rollups allow Tezos to scale to support large, complex applications without slowing Tezos itself or incurring large transaction and storage fees.
The processing that runs on Tezos itself via smart contracts is referred to as *layer 1* and the processing that Smart Rollups run is referred to as *layer 2*.
To learn about running code in smart contracts, see the tutorial [Deploy a smart contract](/tutorials/smart-contract).

Rollups also have an outbox, which consists of calls to smart contracts on layer 1.
These calls are how rollups send messages back to layer 1.

Smart Rollups can run any kind of applications that they want, such as:

* Financial applications that use information and transactions from Tezos
* Gaming applications that manipulate assets and keep them in sync with Tezos
* Applications that run complex logic on NFTs or other types of tokens
* Applications that communicate with other blockchains

<!--
TODO Should this intro discuss the reveal data channel?
-->

Rollups maintain consensus by publishing the hash of their state to Tezos, which other nodes can use to verify the rollup's behavior.
The specific way that rollups publish their states and maintain consensus is beyond the scope of this tutorial.
For more information about rollups and their consensus mechanism, see [Smart Optimistic Rollups](/architecture/smart-rollups).

This diagram shows a Smart Rollup interacting with layer 1 by receiving a message, running processing based on that message, and sending a transaction to layer 1:

![Diagram that shows the flow of messages in Smart Rollups](/img/tutorials/smart-rollup-overview.png)

<!-- https://lucid.app/lucidchart/74fd884e-9c71-409e-b7d3-c3a871a17178/edit?page=0_0# -->

Smart Rollups stay in sync with Tezos by passing messages to Tezos and receiving messages from Tezos and other rollups.
Each Tezos block contains a global rollups inbox that contains messages from Tezos layer 1 to all rollups.
Anyone can add a message to this inbox and all messages are visible to all rollups.
Rollups receive this inbox, filter it to the messages that they are interested in, and act on them accordingly.

## Smart Rollup analogy

Businesses talk about *horizontal scaling* versus *vertical scaling*.
If a business is growing and its employees are being overworked, the business could use vertical scaling to hire more employees or use better tools to improve the productivity of each employee.
Scaling Tezos in this way would mean using more processing power to process each new block, which would increase the cost to run baking nodes.
Also, if the business hires more employees, the amount of communication between employees increases because, for example, they have to make sure that they are working in the same way and not doing duplicate jobs.

By contrast, Smart Rollups behave like horizontal scaling.
In horizontal scaling, businesses create specialized teams that work on different portions of the workload.
These teams can work independently of other teams and take advantage of efficiencies of being focused on a specific task.
They also need to communicate less with other teams, which speeds up their work.
Smart Rollups are like separate horizontally scaled teams, with Tezos layer 1 as the source of communication between teams.

## Prerequisites

To run this tutorial, make sure that the following tools are installed:

<!--
TODO Could we install some of the tools in the docker container instead of making them install them locally?
-->

* [Docker](https://www.docker.com/)

* Rust

  The application in this tutorial uses Rust because of its support for WebAssembly (WASM), the language that Smart Rollups use to communicate.
  Rollups can use any language that has WASM compilation support.

  To install Rust via the `rustup` command, run this command:

  ```bash
  curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
  ```

  You can see other ways of installing Rust at https://www.rust-lang.org.

* Clang and LLVM

  Clang and LLVM are required for compilation to WebAssembly.
  Version 11 or later of Clang is required.
  Here are instructions for installing the appropriate tools on different operating systems:

  **MacOS**

  ```bash
  brew install llvm
  export CC="$(brew --prefix llvm)/bin/clang"
  ```

  In some cases for MacOS you may need to update your `PATH` environment variable to include LLVM by running this command:

  ```bash
  echo 'export PATH="/opt/homebrew/opt/llvm/bin:$PATH"' >> ~/.zshrc
  ```

  **Ubuntu**

  ```bash
  sudo apt-get install clang-11
  export CC=clang-11
  ```

  **Fedora**

  ```bash
  dnf install clang
  export CC=clang
  ```

  **Arch Linux**

  ```bash
  pacman -S clang
  export CC=clang
  ```

  The `export CC` command sets Clang as the default C/C++ compiler.

  After you run these commands, run `$CC --version` to verify that you have version 11 or greater installed.

  Also, ensure that your version of Clang `wasm32` target with by running the command `$CC -print-targets | grep wasm32` and verifying that the results include `wasm32`.

* AR (macOS only)

  To compile to WebAssembly on macOS, you need to use the LLVM archiver.
  If you used Homebrew to install LLVM, you can configure it to use the archiver by running this command:

  ```bash
  export AR="$(brew --prefix llvm)/bin/llvm-ar"
  ```

* WebAssembly Toolkit

  The [WebAssembly Toolkit (`wabt`)](https://github.com/WebAssembly/wabt) provides tooling for reducing (or *stripping*) the size of WebAssembly binaries (with the `wasm-strip` command) and conversion utilities between the textual and binary representations of WebAssembly (including the `wat2wasm` and `wasm2wat` commands).

  Most distributions ship a `wabt` package, which you can install with the appropriate command for your operating system:

  **MacOS**

  ```bash
  brew install wabt
  ```

  **Ubuntu**

  ```bash
  sudo apt install wabt
  ```

  **Fedora**

  ```bash
  dnf install wabt
  ```

  **Arch Linux**

  ```bash
  pacman -S wabt
  ```

  To verify that `wabt` is installed, run the command `wasm-strip --version` and verify that the version is at least 1.0.31.
  If not, you can download this version directly and extract its files: https://github.com/WebAssembly/wabt/releases/tag/1.0.31.
  Then, whenever you have to use `wasm-strip`, you can use `<path_to_wabt_1.0.31>/bin/wasm-strip` instead.

## Tutorial application

Despite the number of command-line tools needed, the code for the core of the rollup itself is relatively simple.
This core is called the *kernel* and is responsible for accepting messages from layer 1 and sending messages to layer 1.

The code for the tutorial application is here: https://gitlab.com/trili/hello-world-kernel.

The code for the kernel is in the `src/lib.rs` file.
It is written in the Rust programming language and looks like this:

```rust
use tezos_smart_rollup::inbox::InboxMessage;
use tezos_smart_rollup::kernel_entry;
use tezos_smart_rollup::michelson::MichelsonBytes;
use tezos_smart_rollup::prelude::*;

kernel_entry!(hello_kernel);

fn handle_message(host: &mut impl Runtime, msg: impl AsRef<[u8]>) {
    if let Some((_, msg)) = InboxMessage::<MichelsonBytes>::parse(msg.as_ref()).ok() {
        debug_msg!(host, "Got message: {:?}\n", msg);
    }
}

pub fn hello_kernel(host: &mut impl Runtime) {
    debug_msg!(host, "Hello, kernel!\n");

    while let Some(msg) = host.read_input().unwrap() {
        handle_message(host, msg);
    }
}
```

This example kernel has these major parts:

1. It imports resources that allow it to access and decode messages from layer 1.
2. It runs the Rust macro `kernel_entry!` to set the main function for the kernel.
3. It declares the `handle_message` function, which accepts, decodes, and processes messages from layer 1.
   In this case, the function decodes the message (which is sent as a sequence of bytes) and prints it to the log.
   The function could call any other logic that the application needs to run.
4. It declares the `hello_kernel` function, which is the main function for the kernel.
   It runs each time the kernel receives messages from layer 1, prints a logging message each time it is called, and runs the `handle_message` function on each message.

You don't need to access the other files in the application directly, but here are descriptions of them:

* `src/lib.rs`: The Rust code for the kernel
* `Cargo.toml`: The dependencies for the build process
* `rustup-toolchain.toml`: The required Rust version
* `sandbox_node.sh`: A script that sets up a Tezos sandbox for testing the rollup

The tutorial repository also includes two files that represent example message inboxes in layer 1 blocks:

* `empty_input.json`: An empty rollup message inbox
* `two_inputs.json`: A rollup message inbox with two messages

When you're ready, move to the next section to begin setting up the application.


# Part 1: Setting up the application

To set up the application for the tutorial, you must configure Rust to build the kernel and start a Docker container that has resources that are needed to debug and deploy it.

## Building the application

Follow these steps to get the application code and build it:

1. Clone the repository with the tutorial application:

   ```bash
   git clone https://gitlab.com/trili/hello-world-kernel.git
   cd hello-world-kernel/
   ```

2. Configure Rust to build WebAssembly applications:

   1. Verify that you have Rust version 1.73.0 or later installed by running `rustc --version`.

   2. If you have a version of Rust later than 1.73.0, use the `rustup override` command to use version 1.73.0:

      ```bash
      rustup override set 1.73.0
      ```

   3. Add WASM as a compilation target for Rust by running this command:

      ```bash
      rustup target add wasm32-unknown-unknown
      ```

3. Build the application by running this command:

   ```bash
   cargo build --target wasm32-unknown-unknown
   ```

   If the application builds correctly, the terminal shows a message that looks like "Finished dev \[unoptimized + debuginfo] target(s) in 15s."
   You can see the compiled application in the `target/wasm32-unknown-unknown/debug` folder.
   In particular, the compiled kernel is in the `hello_world_kernel.wasm` file.

Now the kernel is compiled into a single file that nodes can run.

## Start the Docker container

Tezos provides a Docker image that contains the Octez client, which allows you to interact with Tezos from the command line.
Later, you will use this image to run a sandbox Tezos environment for testing the rollup.

1. Make sure that Docker desktop is running.

2. Pull the most recent Tezos Docker image, which contains the most recent version of Octez:

   ```bash
   docker pull tezos/tezos:master
   ```

   You can install Octez directly on your system, but keeping it in Docker is faster and more convenient for running the tutorial application.

3. Make sure you are in the `hello-world-kernel` folder, at the same level as the `Cargo.toml` and `sandbox_node.sh` files.

4. Run this command to start the Docker image, open a command-line terminal in that image, and mount the `hello-world-kernel` folder in it:

   ```bash
   docker run -it --rm --volume $(pwd):/home/tezos/hello-world-kernel --entrypoint /bin/sh --name octez-container tezos/tezos:master
   ```

   Your command-line prompt changes to indicate that it is now inside the running Docker container.
   This image includes the Octez command-line client and other Tezos tools.
   It also uses the docker `--volume` argument to mount the contents of the `hello-world-kernel` folder in the container so you can use those files within the container.

5. Verify that the container has the necessary tools by running these commands:

   ```bash
   octez-node --version
   octez-smart-rollup-wasm-debugger --version
   octez-smart-rollup-node --version
   octez-client --version
   ```

   Each of these commands should print a version number.
   The specific version number is not important as long as you retrieved the latest image with the `docker pull tezos/tezos:master` command.

   Don't close this terminal window or exit the Docker terminal session, because Docker will close the container.
   If you accidentally close the container, you can run the `docker run ...` command again to open a new one.

Now the application is built and you have an environment that you can debug it in.
For the rest of the tutorial, you must be aware of whether you are running commands inside or outside of the Docker container.
The container has Octez but not Rust, so you run Rust commands outside of the container and Octez commands inside the container.


# Part 2: Running the kernel in debug mode

Octez provides a command named `octez-smart-rollup-wasm-debugger` that runs Smart Rollups in debug mode to make it easier to test and observe them.
Later, you will deploy the rollup to the sandbox, but running it in debug mode first verifies that it built correctly.

1. In the terminal window inside the Docker container, go to the `hello_world_kernel` folder.

2. Run this command to start the rollup and pass an empty message inbox to it:

   ```bash
   octez-smart-rollup-wasm-debugger \
     --kernel target/wasm32-unknown-unknown/debug/hello_world_kernel.wasm \
     --inputs empty_input.json
   ```

   The command prompt changes again to show that you are in debugging mode, which steps through commands.

3. At the debugging prompt, run this command to send the message inbox to the kernel:

   ```bash
   step inbox
   ```

   The response shows the logging information for the kernel, including these parts:

   * The message "Hello, kernel" from the `hello_kernel` function
   * The message "Got message: Internal(StartOfLevel)," which represents the start of the message inbox
   * The message "Got message: Internal(InfoPerLevel(InfoPerLevel ...," which provides the hash and timestamp of the previous block
   * The message "Got message: Internal(EndOfLevel)," which represents the end of the message inbox

4. Press Ctrl + C to end debugging mode.

Now you know that the kernel works.
In the next section, you optimize the kernel to be deployed to the sandbox.


# Part 3: Optimizing the kernel

To originate the kernel on Tezos, it must fit within the maximum size for a layer 1 operation (32KB).
In these steps, you reduce the size of the kernel:

1. Run this command to print the current size of the kernel:

   ```bash
   du -h target/wasm32-unknown-unknown/debug/hello_world_kernel.wasm
   ```

   You can run this command inside or outside of the Docker container.

   Because you ran it in debug mode, the size of the compiled kernel and its dependencies may be 18MB or more, which is too large to originate.

2. In a terminal window outside of the Docker container, run this command to create a release build of the kernel:

   ```bash
   cargo build --release --target wasm32-unknown-unknown
   ```

3. Check the size of the release build of the kernel:

   ```bash
   du -h target/wasm32-unknown-unknown/release/hello_world_kernel.wasm
   ```

   The release build is significantly smaller, but still too large.

4. In a terminal window outside of the Docker container, run the `wasm-strip` command to reduce the size of the kernel:

   ```bash
   wasm-strip target/wasm32-unknown-unknown/release/hello_world_kernel.wasm
   ```

   This command removes WebAssembly code that is not necessary to run rollups.
   You must run this command outside of the Docker container because it does not have the `wasm-strip` command.

5. Run the `du` command again to see the new size of the kernel:

   ```bash
   du -h target/wasm32-unknown-unknown/release/hello_world_kernel.wasm
   ```

   The size of the kernel is smaller now.
   Note that the changes that you make to the kernel outside of the Docker container also appear in the container and vice versa because the folder is mounted with the Docker `--volume` argument.

   To get the kernel running with an even smaller size, you can use the installer kernel, which includes only enough information to install your original kernel.
   To do this, your kernel is split up and stored in separate files called preimages.
   Then you run the installer kernel, it requests these files and reconstructs the original kernel.

6. Outside of the Docker container, run this command to install the installer kernel tool:

   ```bash
   cargo install tezos-smart-rollup-installer
   ```

7. Outside of the Docker container, run this command to create an installer kernel:

   ```bash
   smart-rollup-installer get-reveal-installer \
     --upgrade-to target/wasm32-unknown-unknown/release/hello_world_kernel.wasm \
     --output hello_world_kernel_installer.wasm --preimages-dir preimages/
   ```

   This command creates the following files:

   * `hello_world_kernel_installer.wasm`: The installer kernel
   * `preimages/`: A directory that contains the preimages that allow nodes to restore the original kernel code

   When a node runs the installer kernel, it retrieves the preimages through the reveal data channel, a channel that Smart Rollups use to request data from outside of layer 1.
   For more information about the reveal data channel, see [Reveal data channel](https://octez.tezos.com/docs/active/smart_rollups.html#reveal-data-channel).

8. Verify the size of the installer kernel by running this command:

   ```bash
   du -h hello_world_kernel_installer.wasm
   ```

   Now the kernel is small enough to originate on layer 1.

9. Inside of the Docker container, run the installer kernel in debug mode by running this command:

   ```bash
   octez-smart-rollup-wasm-debugger --kernel hello_world_kernel_installer.wasm \
     --preimage-dir preimages/ --inputs empty_input.json
   ```

   Then you can use the `step inbox` command to simulate receiving the inbox from layer 1.
   You can see the hello world kernel messages in the log, which shows that the upgrade from the installer kernel to the full kernel was successful.

10. Press Ctrl + C to end the debugging session.

11. Create a hexadecimal version of the installer kernel by running this command outside of the Docker container:

    ```bash
    smart-rollup-installer get-reveal-installer \
      --upgrade-to target/wasm32-unknown-unknown/release/hello_world_kernel.wasm \
      --output hello_world_kernel_installer.hex --preimages-dir preimages/
    ```

    In the next section, you originate this hex-encoded installer kernel on layer 1.


# Part 4: Deploying (originating) the rollup

Smart Rollups are originated in a way similar to smart contracts.
Instead of running the `octez-client originate contract` command, you run the `octez-client originate smart rollup` command.
This command creates an address for the rollup and stores a small amount of data about it on layer 1.

1. In the Docker container, in the `hello-world-kernel` folder, run this command to start the sandbox:

   ```bash
   ./sandbox_node.sh
   ```

   This command starts a Tezos testing environment, including a baking node running in sandbox mode and a group of test accounts.
   The console shows repeated messages that show that the node is baking blocks.
   For more information about sandbox mode, see [Sandboxed mode](https://octez.tezos.com/docs/user/sandbox.html).

   If you see an error that says "Unable to connect to the node," you can ignore it because it happens only once while the node is starting.

2. Leave that terminal instance running for the rest of the tutorial.

3. Open a new terminal window.

4. In the new terminal window, enter the Docker container by running this command:

   ```bash
   docker exec -it octez-container /bin/sh
   ```

   Now the second terminal window is running inside the container just like the first one.

5. In the new terminal window, go to the folder with the Smart Rollup code:

   ```bash
   cd hello-world-kernel
   ```

6. In the second terminal window, run this command to verify that the sandbox is running with the correct protocol:

   ```bash
   octez-client rpc get /chains/main/blocks/head/metadata | grep protocol
   ```

   The response shows the protocol that the sandbox is running, as in this example:

   ```
   { "protocol": "ProtoALphaALphaALphaALphaALphaALphaALphaALphaDdp3zK",
     "next_protocol": "ProtoALphaALphaALphaALphaALphaALphaALphaALphaDdp3zK",
   ```

   If you don't see a message that looks like this one, check for errors in the first terminal window.

   Now the sandbox is running in the Docker container and you can use it to test the rollup.

7. Run this command to deploy the installer kernel to the Tezos sandbox:

   ```bash
   octez-client originate smart rollup \
     "test_smart_rollup" from "bootstrap1" \
     of kind wasm_2_0_0 of type bytes \
     with kernel file:hello_world_kernel_installer.hex --burn-cap 3
   ```

   If you need to open a new terminal window within the Docker container, run the command `docker exec -it octez-container /bin/sh`.

   Like the command to originate a smart contract, this command uses the `--burn-cap` argument to allow the transaction to take fees from the account.
   Also like deploying a smart contract, the response in the terminal shows information about the transaction and the address of the originated Smart Rollup, which starts with `sr1`.

Now layer 1 is aware of the rollup and nodes can run the rollup kernel.


# Part 5: Running and interacting with the rollup node

Now that the Smart Rollup is originated on layer 1, anyone can run a Smart Rollup node for it.
Smart Rollup nodes are similar to baking nodes, but they run the Smart Rollup kernel instead of baking Tezos blocks.
In these steps, you start a Smart Rollup node, but note that anyone can run a node based on your kernel, including people who want to verify the rollup's behavior.

## Running a Smart Rollup node

1. Copy the contents of the `preimages` folder to a folder that the rollup node can access by running these commands:

   ```bash
   mkdir -p ~/.tezos-rollup-node/wasm_2_0_0

   cp preimages/* ~/.tezos-rollup-node/wasm_2_0_0/
   ```

2. In the second terminal window, in the Docker container, start the rollup node:

   ```bash
   octez-smart-rollup-node run operator for "test_smart_rollup" \
       with operators "bootstrap2" --data-dir ~/.tezos-rollup-node/ \
       --log-kernel-debug --log-kernel-debug-file hello_kernel.debug
   ```

   Now the node is running and writing to the log file `hello_kernel.debug`.
   Leave this command running in the terminal window just like you left the first terminal window running the Tezos sandbox.

## Interacting with the rollup node

Now you can add messages to the inbox and see the rollup node receive and respond to them.

1. Open a third terminal window and enter the Docker container again:

   ```bash
   docker exec -it octez-container /bin/sh
   ```

2. In the container, go to the `hello_world_kernel` folder.

3. Print the contents of the log file:

   ```bash
   tail -f hello_kernel.debug
   ```

   Now, each time a block is baked, the Smart Rollup node prints the contents of the messages in the Smart Rollup inbox, as in this example:

   ```
   # Hello, kernel!
   # Got message: Internal(StartOfLevel)
   # Got message: Internal(InfoPerLevel(InfoPerLevel { predecessor_timestamp: 2023-06-07T15:31:09Z, predecessor: BlockHash("BLQucC2rFyNhoeW4tuh1zS1g6H6ukzs2DQDUYArWNALGr6g2Jdq") }))
   # Got message: Internal(EndOfLevel)
   ```

4. Stop the command by pressing Ctrl + C.

5. Run this command to watch for external messages to the rollup:

   ```bash
   tail -f hello_kernel.debug | grep External
   ```

   No output appears at first because the rollup has not received any messages aside from the internal messages that indicate the beginning and end of the inbox.

   Leave this command running.

6. Open a fourth terminal window, enter the Docker container with the command `docker exec -it octez-container /bin/sh`, and go to the `hello_world_kernel` folder.

7. In this fourth terminal window, run this command to simulate adding a message to the Smart Rollup inbox:

   ```bash
   octez-client send smart rollup message '[ "test" ]' from "bootstrap3"
   ```

8. Go back to the third terminal window.

   This window shows the message that you sent in the fourth window, which it received in binary format, with the numbers representing the letters in "test."

   ```
   Got message: External([116, 101, 115, 116])
   ```

Now you can send messages to this rollup via Tezos layer 1 and act on them in the rollup code.

## Next steps

<!--
Commenting this out because there's not enough info for a tutorial user to do this without further information; consider adding this because it would be good to be able to send messages (that is, call contracts) from the rollup, and I don't know how you'd do that in the sandbox.

Currently, your rollup and kernel are running in sandbox mode.
If you want to explore further, you can try deploying the rollup to a testnet as you do in the [Deploy a smart contract](/tutorialsdeploy-your-first-smart-contract/) tutorial.
The workflow for deploying to a testnet is similar to the workflow that you used to deploy to the sandbox:

1. Configure the network to use the testnet
1. Run a node (needs to synchronize with the network — can make use of [snapshots](https://octez.tezos.com/docs/user/snapshots.html))
1. Create or import an account and fun it by a faucet
1. Originate the rollup to the testnet
1. Start the rollup node
1. Check the log file
-->

To continue your work with Smart Rollups, you can you can explore examples from the [kernel gallery](https://gitlab.com/tezos/kernel-gallery/-/tree/main/) or create your own.

## References

* [Smart Rollup documentation](https://octez.tezos.com/docs/active/smart_rollups.html)
* [Smart Rollup kernel SDK](https://gitlab.com/tezos/tezos/-/tree/master/src/kernel_sdk)
* [Smart Rollup kernel examples](https://gitlab.com/tezos/kernel-gallery/-/tree/main/)
* [Tezos Smart Rollups resources](https://airtable.com/shrvwpb63rhHMiDg9/tbl2GNV1AZL4dkGgq)
* [Tezos testnets](https://teztnets.com/)
* [Originating the installer kernel](https://tezos.stackexchange.com/questions/4784/how-to-originating-a-smart-rollup-with-an-installer-kernel/5794#5794)
* [Docker documentation](https://docs.docker.com/get-started/)


# Build an NFT marketplace

This tutorial guides you through creating a web application that allows users to buy and sell tokens of different types.
You will use the Taqueria platform to manage smart contracts and a distributed web application (dApp) to handle the backend and frontend of the project.

You will learn:

* What kinds of tokens Tezos supports
* What token standards are
* How to create contracts that are based on existing templates for token standards
* How to store token metadata in distributed storage with IPFS
* How to handle token transfers and other operations
* How to list tokens for sale and accept payments from buyers

## Prerequisites

1. Optional: If you haven't worked with Tezos NFTs before, consider doing the tutorial [Create NFTs from a web application](/tutorials/create-nfts) first.

2. Set up an account with Pinata if you don't have one already and get an API key and API secret.
   For information about setting up a Pinata account, see [Storing data and files with IPFS](/developing/ipfs).

3. Make sure that you have installed these tools:

   * [Node.JS and NPM](https://nodejs.org/en/download/): NPM is required to install the web application's dependencies
   * [Taqueria](https://taqueria.io/), version 0.43.0 or later: Taqueria is a platform that makes it easier to develop and test dApps
   * [Docker](https://docs.docker.com/engine/install/): Docker is required to run Taqueria
   * [jq](https://stedolan.github.io/jq/download/): Some commands use the `jq` program to extract JSON data
   * [`yarn`](https://yarnpkg.com/): The frontend application uses yarn to build and run (see this article for details about [differences between `npm` and `yarn`](https://www.geeksforgeeks.org/difference-between-npm-and-yarn/))
   * Any Tezos-compatible wallet that supports Ghostnet, such as [Temple wallet](https://templewallet.com/)

4. Optionally, you can install [`VS Code`](https://code.visualstudio.com/download) to edit your application code in and the [LIGO VS Code extension](https://marketplace.visualstudio.com/items?itemName=ligolang-publish.ligo-vscode) for LIGO editing features such as code highlighting and completion.
   Taqueria also provides a [Taqueria VS Code extension](https://marketplace.visualstudio.com/items?itemName=ecadlabs.taqueria-vscode) that helps visualize your project and run tasks.

5. Optional: If this is your first time using Taqueria, you may want to run through [this Taqueria training](https://github.com/marigold-dev/training-dapp-1#ghostnet-testnet-wallet).

## What are FA2 tokens?

If you've gone through the tutorial [Create NFTs from a web application](/tutorials/create-nfts) you know that NFTs are blockchain tokens that represent unique assets, usually created under the FA2 token standard.
However, the Tezos FA2 token standard allows you to create multiple types of tokens, and even more than one kind of token within the same smart contract.
When you create tokens, it's important to follow one of the token standards because then tools like wallets and block explorers can automatically work with those tokens.
For more information about Tezos token standards, see [Token standards](/architecture/tokens).

In this tutorial, you use the LIGO template for FA2 tokens to create these types of tokens:

| Token template | Number of token types | Number of tokens of each type |
| -------------- | --------------------- | ----------------------------- |
| NFT            | Any number            | 1                             |
| Single-asset   | 1                     | Any number                    |
| Multi-asset    | Any number            | Any number                    |

When you create your own applications, you can choose the token type that is appropriate for your use case.

## What is IPFS?

In most cases, developers don't store token metadata such as image files directly on Tezos.
Instead, they configure decentralized storage for the NFT data and put only the link to that data on Tezos itself.

The InterPlanetary File System (IPFS) is a protocol and peer-to-peer network for storing and sharing data in a distributed file system.
IPFS uses content-addressable storage to uniquely identify each file in a global namespace connecting all computing devices.
In this tutorial, you use [Pinata](https://www.pinata.cloud/)'s free developer plan to store your NFT metadata on IPFS and reference it on Tezos, demonstrating a scalable and cost-effective solution for handling NFT data.

## Tutorial application

This tutorial was originally created by [Marigold](https://www.marigold.dev/), which hosts versions of the tutorial application after each part of the tutorial:

* [Part 1](https://github.com/marigold-dev/training-nft-1)
* [Part 2](https://github.com/marigold-dev/training-nft-2)
* [Part 3](https://github.com/marigold-dev/training-nft-3)
* [Part 4](https://github.com/marigold-dev/training-nft-4)

The completed application at the end of the tutorial is a marketplace where administrator users can list wine bottles for sale by entering information about them and uploading a photo.
The application creates tokens based on this information and the site allows other users to buy the tokens that represent wine bottles.

![The complete application, showing wine bottles for sale](/img/tutorials/nftfactory.png)

This application is made up of a smart contract that handles the tokens and a frontend web application that handles the user interface and sends transactions to the backend.
As you work through the tutorial, you will use different smart contracts and upgrade the web application to work with them.

When you're ready, go to [Part 1: Minting tokens](/tutorials/build-an-nft-marketplace/part-1) to begin.


# Part 1: Minting tokens

To start working with the application, you create a Taqueria project and use it to deploy an FA2 contract.
Then you set up a web application to mint NFTs by calling the contract's mint endpoint and uploading an image and metadata to IPFS.

Before you begin, make sure that you have installed the tools in the [Prerequisites](/tutorials/build-an-nft-marketplace#prerequisites) section.

## Creating a Taqueria project

Taqueria manages the project structure and keeps it up to date.
For example, when you deploy a new smart contract, Taqueria automatically updates the web app to send transactions to that new smart contract.
Follow these steps to set up a Taqueria project:

1. On the command-line terminal, run these commands to set up a Taqueria project and install the LIGO and Taquito plugins:

   ```bash
   taq init nft-marketplace
   cd nft-marketplace
   taq install @taqueria/plugin-ligo
   taq install @taqueria/plugin-taquito
   ```

2. Install the `ligo/fa` library, which provides templates for creating FA2 tokens:

   ```bash
   echo '{ "name": "app", "dependencies": { "@ligo/fa": "^1.4.2" } }' >> ligo.json
   TAQ_LIGO_IMAGE=ligolang/ligo:1.6.0 taq ligo --command "install @ligo/fa"
   ```

This command can take some time because it downloads and installs the `@ligo/fa` package.

## Creating an FA2 contract from a template

The `ligo/fa` library provides a template that saves you from having to implement all of the FA2 standard yourself.
Follow these steps to create a contract that is based on the template and implements the required endpoints:

1. Create a contract to manage your NFTs:

   ```bash
   taq create contract nft.jsligo
   ```

2. Open the `contracts/nft.jsligo` file in any text editor and replace the default code with this code:

   ```jsligo
   #import "@ligo/fa/lib/fa2/nft/extendable_nft.impl.jsligo" "FA2Impl"

    /* ERROR MAP FOR UI DISPLAY or TESTS
          const errorMap : map<string,string> = Map.literal(list([
            ["0", "Enter a positive and not null amount"],
            ["1", "Operation not allowed, you need to be administrator"],
            ["2", "You cannot sell more than your current balance"],
            ["3", "Cannot find the offer you entered for buying"],
            ["4", "You entered a quantity to buy than is more than the offer quantity"],
            ["5", "Not enough funds, you need to pay at least quantity * offer price to get the tokens"],
            ["6", "Cannot find the contract relative to implicit address"],
          ]));
      */
    export type Extension = { administrators: set<address> };

    export type storage = FA2Impl.storage<Extension>; // extension administrators


    type ret = [list<operation>, storage];
   ```

   The first line of this code imports the FA2 template as the `FA2Impl` object.
   Then, the code defines error messages for the contract.

   The code defines a type for the contract storage, which contains these values:

   * `administrators`: A list of accounts that are authorized to mint NFTs
   * `ledger`: The ledger that keeps track of token ownership
   * `metadata`: The metadata for the contract itself, based on the TZIP-16 standard for contract metadata
   * `token_metadata`: The metadata for the tokens, based on the TZIP-12 standard for token metadata
   * `operators`: Information about *operators*, accounts that are authorized to transfer tokens on behalf of the owners

   The code also defines the type for the value that entrypoints return: a list of operations and the new value of the storage.

3. Add code to implement the required `transfer`, `balance_of`, and `update_operators` entrypoints:

   ```jsligo

    @entry
    const transfer = (p: FA2Impl.TZIP12.transfer, s: storage): ret => {
      const ret2: [list<operation>, storage] = FA2Impl.transfer(p, s);
      return [
        ret2[0],
        {
          ...s,
          ledger: ret2[1].ledger,
          metadata: ret2[1].metadata,
          token_metadata: ret2[1].token_metadata,
          operators: ret2[1].operators,
        }
      ]
    };

    @entry
    const balance_of = (p: FA2Impl.TZIP12.balance_of, s: storage): ret => {
      const ret2: [list<operation>, storage] = FA2Impl.balance_of(p, s);
      return [
        ret2[0],
        {
          ...s,
          ledger: ret2[1].ledger,
          metadata: ret2[1].metadata,
          token_metadata: ret2[1].token_metadata,
          operators: ret2[1].operators,
        }
      ]
    };

    @entry
    const update_operators = (p: FA2Impl.TZIP12.update_operators, s: storage): ret => {
      const ret2: [list<operation>, storage] = FA2Impl.update_operators(p, s);
      return [
        ret2[0],
        {
          ...s,
          ledger: ret2[1].ledger,
          metadata: ret2[1].metadata,
          token_metadata: ret2[1].token_metadata,
          operators: ret2[1].operators,
        }
      ]
    };
   ```

   You will add other entrypoints later, but these are the three entrypoints that every FA2 contract must have.
   Because these required entrypoints must have specific parameters, the code re-uses types from the `FA2Impl` object for those parameters.
   For example, the `FA2Impl.TZIP12.transfer` type represents the parameters for transferring tokens, including a source account and a list of target accounts, token types, and amounts.

   * The `transfer` entrypoint accepts information about the tokens to transfer.
     This implementation uses the `FA2Impl.NFT.transfer` function from the template to avoid having to re-implement what happens when tokens are transferred.

   * The `balance_of` entrypoint sends information about an owner's token balance to another contract.
     This implementation re-uses the `FA2Impl.NFT.balance_of` function.

   * The `update_operators` entrypoint updates the operators for a specified account.
     This implementation re-uses the `FA2Impl.NFT.update_operators` function.

4. After those entrypoints, add code for the `mint` entrypoint:

   ```jsligo

    @entry
    const mint = (
      [token_id, name, description, symbol, ipfsUrl]: [
        nat,
        bytes,
        bytes,
        bytes,
        bytes
      ],
      s: storage
    ): ret => {
      if (! Set.mem(Tezos.get_sender(), s.extension.administrators)) return failwith(
        "1"
      );
      const token_info: map<string, bytes> =
        Map.literal(
          list(
            [
              ["name", name],
              ["description", description],
              ["interfaces", (bytes `["TZIP-12"]`)],
              ["artifactUri", ipfsUrl],
              ["displayUri", ipfsUrl],
              ["thumbnailUri", ipfsUrl],
              ["symbol", symbol],
              ["decimals", (bytes `0`)]
            ]
          )
        ) as map<string, bytes>;
      return [
        list([]) as list<operation>,
        {
          ...s,
          ledger: Big_map.add(token_id, Tezos.get_sender(), s.ledger) as
            FA2Impl.ledger,
          token_metadata: Big_map.add(
            token_id,
            { token_id: token_id, token_info: token_info },
            s.token_metadata
          ),
          operators: Big_map.empty as FA2Impl.operators,
        }
      ]
    };
   ```

   The FA2 standard does not require a mint entrypoint, but you can add one if you want to allow the contract to create more tokens after it is originated.
   If you don't include a mint entrypoint or a way to create tokens, you must initialize the storage with all of the token information when you originate the contract.
   This mint entrypoint accepts a name, description, symbol, and IPFS URL to an image.
   It also accepts an ID number for the token, which the front end will manage; you could also set up the contract to remember the ID number for the next token.

   First, this code verifies that the transaction sender is one of the administrators.
   Then it creates a token metadata object with information from the parameters and adds it to the `token_metadata` big-map in the storage.
   Note that the `decimals` metadata field is set to 0 because the token is an NFT and therefore doesn't need any decimal places in its quantity.

   Note that there is no built-in way to get the number of tokens in the contract code; the Bigmap does not have a function such as `keys()` or `length()`.
   If you want to keep track of the number of tokens, you must add an element in the storage and increment it when tokens are created or destroyed.
   You can also get the number of tokens by analyzing the contract's storage from an off-chain application.

5. Run one of these commands to accept or decline LIGO's analytics policy:

   * `ligo analytics accept` to send analytics data to LIGO
   * `ligo analytics deny` to not send analytics data to LIGO

6. Save the contract and compile it by running this command:

   ```bash
   TAQ_LIGO_IMAGE=ligolang/ligo:1.6.0 taq compile nft.jsligo
   ```

   Taqueria compiles the contract to the file `artifacts/nft.tz`.
   It also creates the file `nft.storageList.jsligo`, which contains the starting value of the contract storage.

7. Open the file `contracts/nft.storageList.jsligo` and replace it with this code:

   ```jsligo
   #import "nft.jsligo" "Contract"

    #import "@ligo/fa/lib/fa2/nft/extendable_nft.impl.jsligo" "FA2Impl"

    const default_storage: Contract.storage = {
        extension: {
            administrators: Set.literal(
                list(["tz1VSUr8wwNhLAzempoch5d6hLRiTh8Cjcjb" as address])
            ) as set<address>
        },
        ledger: Big_map.empty as FA2Impl.ledger,
        metadata: Big_map.literal(
            list(
                [
                    ["", bytes `tezos-storage:data`],
                    [
                        "data",
                        bytes
                        `{
            "name":"FA2 NFT Marketplace",
            "description":"Example of FA2 implementation",
            "version":"0.0.1",
            "license":{"name":"MIT"},
            "authors":["Marigold<contact@marigold.dev>"],
            "homepage":"https://marigold.dev",
            "source":{
              "tools":["Ligo"],
              "location":"https://github.com/ligolang/contract-catalogue/tree/main/lib/fa2"},
            "interfaces":["TZIP-012"],
            "errors": [],
            "views": []
            }`
                    ]
                ]
            )
        ) as FA2Impl.TZIP16.metadata,
        token_metadata: Big_map.empty as FA2Impl.TZIP12.tokenMetadata,
        operators: Big_map.empty as FA2Impl.operators,
    };

   ```

   This code sets the initial value of the storage.
   In this case, the storage includes metadata about the contract and empty Bigmaps for the ledger, token metadata, and operators.
   It sets the test account Alice as the administrator, which is the only account that can mint tokens.

8. Optional: Add your address as an administrator or replace Alice's address with your own.
   Note that only the addresses in the `administrators` list will be able to create tokens.

9. Compile the contract:

   ```bash
   TAQ_LIGO_IMAGE=ligolang/ligo:1.6.0 taq compile nft.jsligo
   ```

10. Use one of these options to set up a Ghostnet account to use to deploy (originate) the contract:

    * To use your account, open the `.taq/config.local.testing.json` file and add your public key, address, and private key, so the file looks like this:

      ```json
      {
        "networkName": "ghostnet",
        "accounts": {
          "taqOperatorAccount": {
            "publicKey": "edpkvGfYw3LyB1UcCahKQk4rF2tvbMUk8GFiTuMjL75uGXrpvKXhjn",
            "publicKeyHash": "tz1VSUr8wwNhLAzempoch5d6hLRiTh8Cjcjb",
            "privateKey": "edsk3QoqBuvdamxouPhin7swCvkQNgq4jP5KZPbwWNnwdZpSpJiEbq"
          }
        }
      }
      ```

      Then make sure that the account has tez on Ghostnet.
      Use the faucet at https://faucet.ghostnet.teztnets.com to get tez if you need it.

    **OR**

    * To let Taqueria generate an account for you, follow these steps:

      1. Run the command `taq deploy nft.tz -e "testing"`, which will fail because you do not have an account configured in Taqueria.
         The response includes the address of an account that Taqueria generated for you and added to the `.taq/config.local.testing.json` file automatically.

      2. Fund the account from the faucet at https://faucet.ghostnet.teztnets.com.

11. Compile and deploy the contract to Ghostnet by running this command:

    ```bash
    taq deploy nft.tz -e "testing"
    ```

    Taqueria deploys the contract to Ghostnet and prints the address of the contract, as in this image:

    ![The output of the deployment command](/img/tutorials/taqueria-contract-deploy-result.png)

Now the backend application is ready and you can start on the frontend application.

## Creating the frontend application

To save time, this tutorial provides a starter React application.

1. In a folder outside of your Taqueria project, clone the source material by running this command:

   ```bash
   git clone https://github.com/marigold-dev/training-nft-1.git
   ```

   This repository includes the starter application and the completed application that you can refer to later.

2. In your Taqueria project, create a folder named `app` that is at the same level as the `contracts` folder.

3. From the repository, copy the contents of the `reactboilerplateapp` folder to the `app` folder.

   For information about how this starter application was created, see the "Dapp" section of this tutorial: https://github.com/marigold-dev/training-dapp-1#construction_worker-dapp.

4. From the root of your Taqueria project, run these commands to generate TypeScript types for the application:

   ```bash
   taq install @taqueria/plugin-contract-types
   taq generate types ./app/src
   ```

5. **IF YOU ARE ON A MAC**, edit the default `dev` script in the `app/package.json` file to look like this:

   ```json
   {
     "scripts": {
       "dev": "if test -f .env; then sed -i '' \"s/\\(VITE_CONTRACT_ADDRESS *= *\\).*/\\1$(jq -r 'last(.tasks[]).output[0].address' ../.taq/testing-state.json)/\" .env ; else jq -r '\"VITE_CONTRACT_ADDRESS=\" + last(.tasks[]).output[0].address' ../.taq/testing-state.json > .env ; fi && vite"
     }
   }
   ```

   This is required on Mac computers because the `sed` command behaves differently than on Unix computers.

6. Run these commands to install the dependencies for the application and start it:

   ```bash
   cd app
   yarn && yarn dev
   ```

   This application contains basic navigation and the ability to connect to wallets.
   For a tutorial that includes connecting to wallets, see [Build a simple web application](/tutorials/build-your-first-app).

   Because Taqueria automatically keeps track of your deployed contract, the application automatically accesses the contract and shows that there are no NFTs in it yet.
   The application looks like this:

   ![The starter NFT marketplace application is showing no NFTs and a button to connect to wallets](/img/tutorials/nft-marketplace-starter.png)

## Adding a mint page

The mint page uses a form that accepts information and an image and sends a transaction to the mint entrypoint:

1. Open the file `./app/src/MintPage.tsx`.

2. Replace the return value of the function (the `<Paper>` tag) with the following code:

   ```html
   <Paper>

     {storage ? (
       <Button
         disabled={storage.extension.indexOf(userAddress! as address) < 0}
         sx={{
           p: 1,
           position: "absolute",
           right: "0",
           display: formOpen ? "none" : "block",
           zIndex: 1,
         }}
         onClick={toggleDrawer(!formOpen)}
       >
         {" Mint Form " +
           (storage!.extension.indexOf(userAddress! as address) < 0
             ? " (You are not admin)"
             : "")}
         <OpenWithIcon />
       </Button>
     ) : (
       ""
     )}

     <SwipeableDrawer
       onClose={toggleDrawer(false)}
       onOpen={toggleDrawer(true)}
       anchor="right"
       open={formOpen}
       variant="temporary"
     >
       <Toolbar
         sx={
           isTablet
             ? { marginTop: "0", marginRight: "0" }
             : { marginTop: "35px", marginRight: "125px" }
         }
       />
       <Box
         sx={{
           width: isTablet ? "40vw" : "60vw",
           borderColor: "text.secondary",
           borderStyle: "solid",
           borderWidth: "1px",

           height: "calc(100vh - 64px)",
         }}
       >
         <Button
           sx={{
             position: "absolute",
             right: "0",
             display: !formOpen ? "none" : "block",
           }}
           onClick={toggleDrawer(!formOpen)}
         >
           <Close />
         </Button>
         <form onSubmit={formik.handleSubmit}>
           <Stack spacing={2} margin={2} alignContent={"center"}>
             <Typography variant="h5">Mint a new collection</Typography>

             <TextField
               id="standard-basic"
               name="token_id"
               label="token_id"
               value={formik.values.token_id}
               disabled
               variant="filled"
             />
             <TextField
               id="standard-basic"
               name="name"
               label="name"
               required
               value={formik.values.name}
               onChange={formik.handleChange}
               error={formik.touched.name && Boolean(formik.errors.name)}
               helperText={formik.touched.name && formik.errors.name}
               variant="filled"
             />
             <TextField
               id="standard-basic"
               name="symbol"
               label="symbol"
               required
               value={formik.values.symbol}
               onChange={formik.handleChange}
               error={formik.touched.symbol && Boolean(formik.errors.symbol)}
               helperText={formik.touched.symbol && formik.errors.symbol}
               variant="filled"
             />
             <TextField
               id="standard-basic"
               name="description"
               label="description"
               required
               multiline
               minRows={2}
               value={formik.values.description}
               onChange={formik.handleChange}
               error={
                 formik.touched.description &&
                 Boolean(formik.errors.description)
               }
               helperText={
                 formik.touched.description && formik.errors.description
               }
               variant="filled"
             />

             {pictureUrl ? (
               <img height={100} width={100} src={pictureUrl} />
             ) : (
               ""
             )}
             <Button variant="contained" component="label" color="primary">
               <AddCircleOutlined />
               Upload an image
               <input
                 type="file"
                 hidden
                 name="data"
                 onChange={(e: React.ChangeEvent<HTMLInputElement>) => {
                   const data = e.target.files ? e.target.files[0] : null;
                   if (data) {
                     setFile(data);
                   }
                   e.preventDefault();
                 }}
               />
             </Button>

             <Button variant="contained" type="submit">
               Mint
             </Button>
           </Stack>
         </form>
       </Box>
     </SwipeableDrawer>


     <Typography variant="h5">Mint your wine collection</Typography>

     {nftContratTokenMetadataMap.size != 0 ? (
       "//TODO"
     ) : (
       <Typography sx={{ py: "2em" }} variant="h4">
         Sorry, there is not NFT yet, you need to mint bottles first
       </Typography>
     )}
   </Paper>
   ```

   You may see errors in your IDE for missing code and imports that you will add later.

   This code shows an HTML form if the connected wallet is an administrator.
   The form includes fields for a new NFT, including a button to upload an image.

3. Inside the `MintPage` function, immediately before the `return` statement, add this [Formik](https://formik.org/) form to manage the form:

   ```typescript
   const validationSchema = yup.object({
     name: yup.string().required('Name is required'),
     description: yup.string().required('Description is required'),
     symbol: yup.string().required('Symbol is required'),
   });

   const formik = useFormik({
     initialValues: {
       name: '',
       description: '',
       token_id: 0,
       symbol: 'WINE',
     } as TZIP21TokenMetadata,
     validationSchema: validationSchema,
     onSubmit: (values) => {
       mint(values);
     },
   });
   ```

4. After this code, add state variables for the image and its URL:

   ```typescript
   const [pictureUrl, setPictureUrl] = useState<string>('');
   const [file, setFile] = useState<File | null>(null);
   ```

5. Add this code to manage a drawer that appears to show the form:

   ```typescript
   //open mint drawer if admin
   const [formOpen, setFormOpen] = useState<boolean>(false);

   useEffect(() => {
     if (storage && storage.extension.indexOf(userAddress! as address) < 0)
       setFormOpen(false);
     else setFormOpen(true);
   }, [userAddress]);

   const toggleDrawer =
     (open: boolean) => (event: React.KeyboardEvent | React.MouseEvent) => {
       if (
         event.type === 'keydown' &&
         ((event as React.KeyboardEvent).key === 'Tab' ||
           (event as React.KeyboardEvent).key === 'Shift')
       ) {
         return;
       }
       setFormOpen(open);
     };
   ```

6. Add this `mint` function:

   ```typescript
   const { enqueueSnackbar } = useSnackbar();

   const mint = async (newTokenDefinition: TZIP21TokenMetadata) => {
     try {
       //IPFS
       if (file) {
         const formData = new FormData();
         formData.append('file', file);

         const requestHeaders: HeadersInit = new Headers();
         requestHeaders.set(
           'pinata_api_key',
           `${import.meta.env.VITE_PINATA_API_KEY}`
         );
         requestHeaders.set(
           'pinata_secret_api_key',
           `${import.meta.env.VITE_PINATA_API_SECRET}`
         );

         const resFile = await fetch(
           'https://api.pinata.cloud/pinning/pinFileToIPFS',
           {
             method: 'post',
             body: formData,
             headers: requestHeaders,
           }
         );

         const responseJson = await resFile.json();
         console.log('responseJson', responseJson);

         const thumbnailUri = `ipfs://${responseJson.IpfsHash}`;
         setPictureUrl(
           `https://gateway.pinata.cloud/ipfs/${responseJson.IpfsHash}`
         );

         const op = await nftContrat!.methods
           .mint(
             new BigNumber(newTokenDefinition.token_id) as nat,
             char2Bytes(newTokenDefinition.name!) as bytes,
             char2Bytes(newTokenDefinition.description!) as bytes,
             char2Bytes(newTokenDefinition.symbol!) as bytes,
             char2Bytes(thumbnailUri) as bytes
           )
           .send();

         //close directly the form
         setFormOpen(false);
         enqueueSnackbar(
           'Wine collection is minting ... it will be ready on next block, wait for the confirmation message before minting another collection',
           { variant: 'info' }
         );

         await op.confirmation(2);

         enqueueSnackbar('Wine collection minted', { variant: 'success' });

         refreshUserContextOnPageReload(); //force all app to refresh the context
       }
     } catch (error) {
       console.table(`Error: ${JSON.stringify(error, null, 2)}`);
       let tibe: TransactionInvalidBeaconError =
         new TransactionInvalidBeaconError(error);
       enqueueSnackbar(tibe.data_message, {
         variant: 'error',
         autoHideDuration: 10000,
       });
     }
   };
   ```

   This function accepts the data that the user puts in the form.
   It uploads the image to IPFS via Pinata and gets the IPFS hash, which identifies the published file and allows clients to request it later.

   Then it calls the contract's `mint` entrypoint and passes the NFT data as bytes, as the TZIP-12 standard requires for NFT metadata.

7. Add code to set the ID for the next NFT based on the number of tokens currently in the contract:

   ```typescript
   useEffect(() => {
     (async () => {
       if (nftContratTokenMetadataMap && nftContratTokenMetadataMap.size > 0) {
         formik.setFieldValue('token_id', nftContratTokenMetadataMap.size);
       }
     })();
   }, [nftContratTokenMetadataMap?.size]);
   ```

8. Replace the imports at the top of the file with these imports:

   ```typescript
   import { AddCircleOutlined, Close } from '@mui/icons-material';
   import OpenWithIcon from '@mui/icons-material/OpenWith';
   import {
     Box,
     Button,
     Stack,
     SwipeableDrawer,
     TextField,
     Toolbar,
     useMediaQuery,
   } from '@mui/material';
   import Paper from '@mui/material/Paper';
   import Typography from '@mui/material/Typography';
   import { useFormik } from 'formik';
   import React, { useEffect, useState } from 'react';
   import * as yup from 'yup';
   import { TZIP21TokenMetadata, UserContext, UserContextType } from './App';
   import { useSnackbar } from 'notistack';
   import { BigNumber } from 'bignumber.js';
   import { address, bytes, nat } from './type-aliases';
   import { char2Bytes } from '@taquito/utils';
   import { TransactionInvalidBeaconError } from './TransactionInvalidBeaconError';
   ```

9. Save the file.

   For the complete content of the mint page, see the completed part 1 app at https://github.com/marigold-dev/training-nft-1.

10. In the file `app/.env`, replace the default `VITE_PINATA_API_KEY` and `VITE_PINATA_API_SECRET` values with your Pinata API key and API secret.
    For information about setting up a Pinata account, see [Storing data and files with IPFS](/developing/ipfs).

    Now the form has a working mint page.
    In the next section, you use it to mint NFTs.

## Minting NFTs

Mint at least one NFT so you can see it in the site and contract:

1. Open the site by going to http://localhost:5173 in your web browser.
   If the site isn't running, go to the `app` folder and run `yarn dev`.

2. Connect the administrator's wallet to the application.

   The app goes to the `/mint` page, which looks like this:

   ![The mint page shows the form to create tokens](/img/tutorials/nft-marketplace-1-mint-form.png)

3. Enter information about a bottle of wine.

   For example, you can use this information:

   * `name`: Saint Emilion - Franc la Rose
   * `symbol`: SEMIL
   * `description`: Grand cru 2007

4. Upload a picture to represent a bottle of wine.

5. Click **Mint**.

6. Approve the transaction in your wallet and wait for it to complete.

   ![Waiting for confirmation that the NFT was minted](/img/tutorials/nft-marketplace-1-minting.png)

   When the NFT has been minted, the application updates the UI but it does not have code to show the NFTs yet.
   You can see the NFT by getting the contract address, which starts with `KT1`, from the `config.local.testing.json` file and looking it up in a block explorer.

   For example, this is how https://ghostnet.tzkt.io/ shows the tokens in the contract, on the "Tokens" tab.
   Because the contract is FA2-compatible, the block explorer automatically shows information about the tokens:

   ![The TzKT block explorer is showing the token in the contract](/img/tutorials/nft-marketplace-1-tzkt-token.png)

   Now the application can mint NFTs.
   In the next section, you display the NFTs on a catalog page.

## Displaying tokens

Follow these steps to show the tokens that you have minted:

1. In the `MintPage.tsx` file, replace the `"//TODO"` comment with this code:

   ```typescript
   <Box sx={{ width: '70vw' }}>
     <SwipeableViews
       axis="x"
       index={activeStep}
       onChangeIndex={handleStepChange}
       enableMouseEvents
     >
       {Array.from(nftContratTokenMetadataMap!.entries()).map(
         ([token_id, token]) => (
           <Card
             sx={{
               display: 'block',
               maxWidth: '80vw',
               overflow: 'hidden',
             }}
             key={token_id.toString()}
           >
             <CardHeader
               titleTypographyProps={
                 isTablet ? { fontSize: '1.5em' } : { fontSize: '1em' }
               }
               title={token.name}
             />

             <CardMedia
               sx={
                 isTablet
                   ? {
                       width: 'auto',
                       marginLeft: '33%',
                       maxHeight: '50vh',
                     }
                   : { width: '100%', maxHeight: '40vh' }
               }
               component="img"
               image={token.thumbnailUri?.replace(
                 'ipfs://',
                 'https://gateway.pinata.cloud/ipfs/'
               )}
             />

             <CardContent>
               <Box>
                 <Typography>{'ID : ' + token_id}</Typography>
                 <Typography>{'Symbol : ' + token.symbol}</Typography>
                 <Typography>{'Description : ' + token.description}</Typography>
               </Box>
             </CardContent>
           </Card>
         )
       )}
     </SwipeableViews>
     <MobileStepper
       variant="text"
       steps={Array.from(nftContratTokenMetadataMap!.entries()).length}
       position="static"
       activeStep={activeStep}
       nextButton={
         <Button
           size="small"
           onClick={handleNext}
           disabled={
             activeStep ===
             Array.from(nftContratTokenMetadataMap!.entries()).length - 1
           }
         >
           Next
           <KeyboardArrowRight />
         </Button>
       }
       backButton={
         <Button size="small" onClick={handleBack} disabled={activeStep === 0}>
           <KeyboardArrowLeft />
           Back
         </Button>
       }
     />
   </Box>
   ```

   This code gets data from the contract storage and shows it on the UI.

2. Add these constants in the `MintPage` function:

   ```typescript
   const [activeStep, setActiveStep] = React.useState(0);

   const handleNext = () => {
     setActiveStep((prevActiveStep) => prevActiveStep + 1);
   };

   const handleBack = () => {
     setActiveStep((prevActiveStep) => prevActiveStep - 1);
   };

   const handleStepChange = (step: number) => {
     setActiveStep(step);
   };
   ```

3. Replace the imports at the top of the file with these imports:

   ```typescript
   import SwipeableViews from 'react-swipeable-views';
   import OpenWithIcon from '@mui/icons-material/OpenWith';
   import {
     Box,
     Button,
     CardHeader,
     CardMedia,
     MobileStepper,
     Stack,
     SwipeableDrawer,
     TextField,
     Toolbar,
     useMediaQuery,
   } from '@mui/material';
   import Card from '@mui/material/Card';
   import CardContent from '@mui/material/CardContent';
   import {
     AddCircleOutlined,
     Close,
     KeyboardArrowLeft,
     KeyboardArrowRight,
   } from '@mui/icons-material';
   import Paper from '@mui/material/Paper';
   import Typography from '@mui/material/Typography';
   import { useFormik } from 'formik';
   import React, { useEffect, useState } from 'react';
   import * as yup from 'yup';
   import { TZIP21TokenMetadata, UserContext, UserContextType } from './App';
   import { useSnackbar } from 'notistack';
   import { BigNumber } from 'bignumber.js';
   import { address, bytes, nat } from './type-aliases';
   import { char2Bytes } from '@taquito/utils';
   import { TransactionInvalidBeaconError } from './TransactionInvalidBeaconError';
   ```

4. Open the web page in the browser again and see that the NFT you created is shown, as in this picture:

![The mint page is showing one existing NFT](/img/tutorials/nft-marketplace-1-collection.png)

## Summary

Now you can create FA2-compatible NFTs with the `@ligo/fa` library and show them on a web page.

In the next section, you add the buy and sell functions to the smart contract and update the frontend application to allow these actions.

When you are ready, continue to [Part 2: Buying and selling tokens](/tutorials/build-an-nft-marketplace/part-2).


# Part 2: Buying and selling tokens

In this section, you give users the ability to list a bottle for sale and buy bottles that are listed for sale.

You can continue from your code from part 1 or start from the completed version here: https://github.com/marigold-dev/training-nft-1/tree/main/solution.

If you start from the completed version, run these commands to install dependencies for the web application:

```bash
npm i
cd ./app
yarn install
cd ..
```

## Updating the smart contract

To allow users to buy and sell tokens, the contract must have entrypoints that allow users to offer a token for sale and to buy a token that is offered for sale.
The contract storage must store the tokens that are offered for sale and their prices.

1. Update the contract storage to store the tokens that are offered for sale:

   1. In the `nft.jsligo` file, before the definition of the `storage` type, add a type that represents a token that is offered for sale:

      ```jsligo
      export type offer = {
        owner : address,
        price : nat
      };
      ```

   2. Add a map named `offers` that maps token IDs to their offer prices to the `Extension` type.
      Now the `Extension` type looks like this:

      ```jsligo
      export type Extension = {
        administrators: set<address>,
        offers: map<nat, offer>, //user sells an offer
      };
      ```

   3. In the `nft.storageList.jsligo` file, add an empty map for the offers by adding this code:

      ```jsligo
      ,
        offers: Map.empty as map<nat, Contract.offer>
      ```

      Now the `nft.storageList.jsligo` file looks like this:

      ```jsligo
      #import "nft.jsligo" "Contract"

      #import "@ligo/fa/lib/fa2/nft/extendable_nft.impl.jsligo" "FA2Impl"

      const default_storage: Contract.storage = {
          extension: {
              administrators: Set.literal(
                  list(["tz1VSUr8wwNhLAzempoch5d6hLRiTh8Cjcjb" as address])
              ) as set<address>,
              offers: Map.empty as map<nat, Contract.offer>
          },
          ledger: Big_map.empty as FA2Impl.ledger,
          metadata: Big_map.literal(
              list(
                  [
                      ["", bytes `tezos-storage:data`],
                      [
                          "data",
                          bytes
                          `{
                  "name":"FA2 NFT Marketplace",
                  "description":"Example of FA2 implementation",
                  "version":"0.0.1",
                  "license":{"name":"MIT"},
                  "authors":["Marigold<contact@marigold.dev>"],
                  "homepage":"https://marigold.dev",
                  "source":{
                    "tools":["Ligo"],
                    "location":"https://github.com/ligolang/contract-catalogue/tree/main/lib/fa2"},
                  "interfaces":["TZIP-012"],
                  "errors": [],
                  "views": []
                  }`
                      ]
                  ]
              )
          ) as FA2Impl.TZIP16.metadata,
          token_metadata: Big_map.empty as FA2Impl.TZIP12.tokenMetadata,
          operators: Big_map.empty as FA2Impl.operators,
      };
      ```

2. As you did in the previous step, make sure that the administrators in the `nft.storageList.jsligo` file includes an address that you can use to mint tokens.

3. In the `nft.jsligo` file, add a `sell` entrypoint that creates an offer for a token that the sender owns:

   ```jsligo
      @entry
    const sell = ([token_id, price]: [nat, nat], s: storage): ret => {
      //check balance of seller
      const sellerBalance = FA2Impl.get_balance([Tezos.get_source(), token_id], s);
      if (sellerBalance != (1 as nat)) return failwith("2");
      //need to allow the contract itself to be an operator on behalf of the seller
      const newOperators =
        FA2Impl.add_operator(
          s.operators,
          Tezos.get_source(),
          Tezos.get_self_address(),
          token_id
        );
      //DECISION CHOICE: if offer already exists, we just override it
      return [
        list([]) as list<operation>,
        {
          ...s,
          extension: {
            ...s.extension,
            offers: Map.add(
              token_id,
              { owner: Tezos.get_source(), price: price },
              s.extension.offers
            )
          },
          operators: newOperators
        }
      ]
    };
   ```

   This function accepts the ID of the token and the selling price as parameters.
   It verifies that the transaction sender owns the token.
   Then it adds the contract itself as an operator of the token, which allows it to transfer the token without getting permission from the seller later.
   Finally, it adds the offer and updated operators to the storage.

4. Add a `buy` entrypoint:

   ```jsligo
   @entry
    const buy = ([token_id, seller]: [nat, address], s: storage): ret => {
      //search for the offer
      return match(Map.find_opt(token_id, s.extension.offers)) {
        when (None()):
          failwith("3")
        when (Some(offer)):
          do {
            //check if amount have been paid enough
            if (Tezos.get_amount() < offer.price * (1 as mutez)) return failwith(
              "5"
            );
            // prepare transfer of XTZ to seller
            const op =
              Tezos.transaction(
                unit,
                offer.price * (1 as mutez),
                Tezos.get_contract_with_error(seller, "6")
              );
            //transfer tokens from seller to buyer
            const ledger =
              FA2Impl.transfer_token_from_user_to_user(
                s.ledger,
                token_id,
                seller,
                Tezos.get_source()
              );
            //remove offer
            return [
              list([op]) as list<operation>,
              {
                ...s,
                ledger: ledger,
                extension: {
                  ...s.extension,
                  offers: Map.update(token_id, None(), s.extension.offers),
                }
              }
            ]
          }
      }
    };
   ```

   This entrypoint accepts the token ID and seller as parameters.
   It retrieves the offer from storage and verifies that the transaction sender sent enough tez to satisfy the offer price.
   Then it transfers the token to the buyer, transfers the sale price to the seller, and removes the offer from storage.

5. Compile and deploy the new contract:

   ```bash
   TAQ_LIGO_IMAGE=ligolang/ligo:1.6.0 taq compile nft.jsligo
   taq deploy nft.tz -e "testing"
   ```

## Adding a selling page to the web application

1. Stop the web application if it is running.

2. Generate the TypeScript classes and start the server:

   ```bash
   taq generate types ./app/src
   cd ./app
   yarn dev
   ```

3. On the mint page in the `./src/MintPage.tsx` file, fix all **extension** relative errors by replacing `storage.extension` with `storage.extension.administrators` in each occurrence.

4. Open the sale page in the `./src/OffersPage.tsx` file and replace it with this code:

   ```typescript
   import { InfoOutlined } from '@mui/icons-material';
   import SellIcon from '@mui/icons-material/Sell';

   import * as api from '@tzkt/sdk-api';

   import {
     Box,
     Button,
     Card,
     CardActions,
     CardContent,
     CardHeader,
     CardMedia,
     ImageList,
     InputAdornment,
     Pagination,
     TextField,
     Tooltip,
     Typography,
     useMediaQuery,
   } from '@mui/material';
   import Paper from '@mui/material/Paper';
   import BigNumber from 'bignumber.js';
   import { useFormik } from 'formik';
   import { useSnackbar } from 'notistack';
   import React, { Fragment, useEffect, useState } from 'react';
   import * as yup from 'yup';
   import { UserContext, UserContextType } from './App';
   import ConnectButton from './ConnectWallet';
   import { TransactionInvalidBeaconError } from './TransactionInvalidBeaconError';
   import { address, nat } from './type-aliases';

   const itemPerPage: number = 6;

   const validationSchema = yup.object({
     price: yup
       .number()
       .required('Price is required')
       .positive('ERROR: The number must be greater than 0!'),
   });

   type Offer = {
     owner: address;
     price: nat;
   };

   export default function OffersPage() {
     api.defaults.baseUrl = 'https://api.ghostnet.tzkt.io';

     const [selectedTokenId, setSelectedTokenId] = React.useState<number>(0);
     const [currentPageIndex, setCurrentPageIndex] = useState<number>(1);

     let [offersTokenIDMap, setOffersTokenIDMap] = React.useState<
       Map<string, Offer>
     >(new Map());
     let [ownerTokenIds, setOwnerTokenIds] = React.useState<Set<string>>(
       new Set()
     );

     const {
       nftContrat,
       nftContratTokenMetadataMap,
       userAddress,
       storage,
       refreshUserContextOnPageReload,
       Tezos,
       setUserAddress,
       setUserBalance,
       wallet,
     } = React.useContext(UserContext) as UserContextType;

     const { enqueueSnackbar } = useSnackbar();

     const formik = useFormik({
       initialValues: {
         price: 0,
       },
       validationSchema: validationSchema,
       onSubmit: (values) => {
         console.log('onSubmit: (values)', values, selectedTokenId);
         sell(selectedTokenId, values.price);
       },
     });

     const initPage = async () => {
       if (storage) {
         console.log('context is not empty, init page now');
         ownerTokenIds = new Set();
         offersTokenIDMap = new Map();

         const token_metadataBigMapId = (
           storage.token_metadata as unknown as { id: BigNumber }
         ).id.toNumber();

         const token_ids = await api.bigMapsGetKeys(token_metadataBigMapId, {
           micheline: 'Json',
           active: true,
         });

         await Promise.all(
           token_ids.map(async (token_idKey) => {
             const token_idNat = new BigNumber(token_idKey.key) as nat;

             let owner = await storage.ledger.get(token_idNat);
             if (owner === userAddress) {
               ownerTokenIds.add(token_idKey.key);

               const ownerOffers = await storage.extension.offers.get(
                 token_idNat
               );
               if (ownerOffers)
                 offersTokenIDMap.set(token_idKey.key, ownerOffers);

               console.log(
                 'found for ' +
                   owner +
                   ' on token_id ' +
                   token_idKey.key +
                   ' with balance ' +
                   1
               );
             } else {
               console.log('skip to next token id');
             }
           })
         );
         setOwnerTokenIds(new Set(ownerTokenIds)); //force refresh
         setOffersTokenIDMap(new Map(offersTokenIDMap)); //force refresh
       } else {
         console.log('context is empty, wait for parent and retry ...');
       }
     };

     useEffect(() => {
       (async () => {
         console.log('after a storage changed');
         await initPage();
       })();
     }, [storage]);

     useEffect(() => {
       (async () => {
         console.log('on Page init');
         await initPage();
       })();
     }, []);

     const sell = async (token_id: number, price: number) => {
       try {
         const op = await nftContrat?.methods
           .sell(
             BigNumber(token_id) as nat,
             BigNumber(price * 1000000) as nat //to mutez
           )
           .send();

         await op?.confirmation(2);

         enqueueSnackbar(
           'Wine collection (token_id=' +
             token_id +
             ') offer for ' +
             1 +
             ' units at price of ' +
             price +
             ' XTZ',
           { variant: 'success' }
         );

         refreshUserContextOnPageReload(); //force all app to refresh the context
       } catch (error) {
         console.table(`Error: ${JSON.stringify(error, null, 2)}`);
         let tibe: TransactionInvalidBeaconError =
           new TransactionInvalidBeaconError(error);
         enqueueSnackbar(tibe.data_message, {
           variant: 'error',
           autoHideDuration: 10000,
         });
       }
     };

     const isDesktop = useMediaQuery('(min-width:1100px)');
     const isTablet = useMediaQuery('(min-width:600px)');

     return (
       <Paper>
         <Typography style={{ paddingBottom: '10px' }} variant="h5">
           Sell my bottles
         </Typography>
         {ownerTokenIds && ownerTokenIds.size != 0 ? (
           <Fragment>
             <Pagination
               page={currentPageIndex}
               onChange={(_, value) => setCurrentPageIndex(value)}
               count={Math.ceil(
                 Array.from(ownerTokenIds.entries()).length / itemPerPage
               )}
               showFirstButton
               showLastButton
             />

             <ImageList
               cols={
                 isDesktop ? itemPerPage / 2 : isTablet ? itemPerPage / 3 : 1
               }
             >
               {Array.from(ownerTokenIds.entries())
                 .filter((_, index) =>
                   index >= currentPageIndex * itemPerPage - itemPerPage &&
                   index < currentPageIndex * itemPerPage
                     ? true
                     : false
                 )
                 .map(([token_id]) => (
                   <Card key={token_id + '-' + token_id.toString()}>
                     <CardHeader
                       avatar={
                         <Tooltip
                           title={
                             <Box>
                               <Typography>
                                 {' '}
                                 {'ID : ' + token_id.toString()}{' '}
                               </Typography>
                               <Typography>
                                 {'Description : ' +
                                   nftContratTokenMetadataMap.get(token_id)
                                     ?.description}
                               </Typography>
                             </Box>
                           }
                         >
                           <InfoOutlined />
                         </Tooltip>
                       }
                       title={nftContratTokenMetadataMap.get(token_id)?.name}
                     />
                     <CardMedia
                       sx={{ width: 'auto', marginLeft: '33%' }}
                       component="img"
                       height="100px"
                       image={nftContratTokenMetadataMap
                         .get(token_id)
                         ?.thumbnailUri?.replace(
                           'ipfs://',
                           'https://gateway.pinata.cloud/ipfs/'
                         )}
                     />

                     <CardContent>
                       <Box>
                         <Typography variant="body2">
                           {offersTokenIDMap.get(token_id)
                             ? 'Traded : ' +
                               1 +
                               ' (price : ' +
                               offersTokenIDMap
                                 .get(token_id)
                                 ?.price.dividedBy(1000000) +
                               ' Tz)'
                             : ''}
                         </Typography>
                       </Box>
                     </CardContent>

                     <CardActions>
                       {!userAddress ? (
                         <Box marginLeft="5vw">
                           <ConnectButton
                             Tezos={Tezos}
                             nftContratTokenMetadataMap={
                               nftContratTokenMetadataMap
                             }
                             setUserAddress={setUserAddress}
                             setUserBalance={setUserBalance}
                             wallet={wallet}
                           />
                         </Box>
                       ) : (
                         <form
                           style={{ width: '100%' }}
                           onSubmit={(values) => {
                             setSelectedTokenId(Number(token_id));
                             formik.handleSubmit(values);
                           }}
                         >
                           <span>
                             <TextField
                               type="number"
                               name="price"
                               label="price"
                               placeholder="Enter a price"
                               variant="filled"
                               value={formik.values.price}
                               onChange={formik.handleChange}
                               error={
                                 formik.touched.price &&
                                 Boolean(formik.errors.price)
                               }
                               helperText={
                                 formik.touched.price && formik.errors.price
                               }
                               InputProps={{
                                 endAdornment: (
                                   <InputAdornment position="end">
                                     <Button
                                       type="submit"
                                       aria-label="add to favorites"
                                     >
                                       <SellIcon /> Sell
                                     </Button>
                                   </InputAdornment>
                                 ),
                               }}
                             />
                           </span>
                         </form>
                       )}
                     </CardActions>
                   </Card>
                 ))}{' '}
             </ImageList>
           </Fragment>
         ) : (
           <Typography sx={{ py: '2em' }} variant="h4">
             Sorry, you don't own any bottles, buy or mint some first
           </Typography>
         )}
       </Paper>
     );
   }
   ```

   This page shows the bottles that the connected account owns and allows the user to select bottles for sale.
   When the user selects bottles and adds a sale price, the page calls the `sell` entrypoint with this code:

   ```typescript
   nftContrat?.methods
     .sell(BigNumber(token_id) as nat, BigNumber(price * 1000000) as nat)
     .send();
   ```

   This code multiplies the price by 1,000,000 because the UI shows prices in tez but the contract records prices in mutez.
   Then the contract creates an offer for the selected token.

5. As you did in the previous part, connect an administrator's wallet to the application and create at least one NFT.
   The new contract that you deployed in this section has no NFTs to start with.

6. Offer a bottle for sale:

   1. Open the application and click **Trading > Sell bottles**.
      The sale page opens and shows the bottles that you own, as in this picture:

      ![The Sell bottle page shows the bottles that you can offer for sale](/img/tutorials/nft-marketplace-2-sell.png)

   2. Set the price for a bottle and then click **Sell**.

   3. Approve the transaction in your wallet and wait for the page to refresh.

   When the page refreshes, the bottle updates to show "Traded" and the offer price, as in this picture:

   ![The bottle marked available for sale](/img/tutorials/nft-markeplace-2-traded-bottle.png)

## Add a catalog and sales page

In this section, you add a catalog page to show the bottles that are on sale and allow users to buy them.

1. Open the file `./src/WineCataloguePage.tsx` and replace it with this code:

   ```typescript
   import { InfoOutlined } from '@mui/icons-material';
   import ShoppingCartIcon from '@mui/icons-material/ShoppingCart';
   import {
     Box,
     Button,
     Card,
     CardActions,
     CardContent,
     CardHeader,
     CardMedia,
     ImageList,
     Pagination,
     Tooltip,
     useMediaQuery,
   } from '@mui/material';
   import Paper from '@mui/material/Paper';
   import Typography from '@mui/material/Typography';

   import BigNumber from 'bignumber.js';
   import { useFormik } from 'formik';
   import { useSnackbar } from 'notistack';
   import React, { Fragment, useState } from 'react';
   import * as yup from 'yup';
   import { UserContext, UserContextType } from './App';
   import ConnectButton from './ConnectWallet';
   import { TransactionInvalidBeaconError } from './TransactionInvalidBeaconError';
   import { address, nat } from './type-aliases';

   const itemPerPage: number = 6;

   type OfferEntry = [nat, Offer];

   type Offer = {
     owner: address;
     price: nat;
   };

   const validationSchema = yup.object({});

   export default function WineCataloguePage() {
     const {
       Tezos,
       nftContratTokenMetadataMap,
       setUserAddress,
       setUserBalance,
       wallet,
       userAddress,
       nftContrat,
       refreshUserContextOnPageReload,
       storage,
     } = React.useContext(UserContext) as UserContextType;
     const [selectedOfferEntry, setSelectedOfferEntry] =
       React.useState<OfferEntry | null>(null);

     const formik = useFormik({
       initialValues: {
         quantity: 1,
       },
       validationSchema: validationSchema,
       onSubmit: (values) => {
         console.log('onSubmit: (values)', values, selectedOfferEntry);
         buy(selectedOfferEntry!);
       },
     });
     const { enqueueSnackbar } = useSnackbar();
     const [currentPageIndex, setCurrentPageIndex] = useState<number>(1);

     const buy = async (selectedOfferEntry: OfferEntry) => {
       try {
         const op = await nftContrat?.methods
           .buy(
             BigNumber(selectedOfferEntry[0]) as nat,
             selectedOfferEntry[1].owner
           )
           .send({
             amount: selectedOfferEntry[1].price.toNumber(),
             mutez: true,
           });

         await op?.confirmation(2);

         enqueueSnackbar(
           'Bought ' +
             1 +
             ' unit of Wine collection (token_id:' +
             selectedOfferEntry[0] +
             ')',
           {
             variant: 'success',
           }
         );

         refreshUserContextOnPageReload(); //force all app to refresh the context
       } catch (error) {
         console.table(`Error: ${JSON.stringify(error, null, 2)}`);
         let tibe: TransactionInvalidBeaconError =
           new TransactionInvalidBeaconError(error);
         enqueueSnackbar(tibe.data_message, {
           variant: 'error',
           autoHideDuration: 10000,
         });
       }
     };
     const isDesktop = useMediaQuery('(min-width:1100px)');
     const isTablet = useMediaQuery('(min-width:600px)');
     return (
       <Paper>
         <Typography style={{ paddingBottom: '10px' }} variant="h5">
           Wine catalogue
         </Typography>

         {storage?.extension.offers && storage?.extension.offers.size != 0 ? (
           <Fragment>
             <Pagination
               page={currentPageIndex}
               onChange={(_, value) => setCurrentPageIndex(value)}
               count={Math.ceil(
                 Array.from(storage?.extension.offers.entries()).length /
                   itemPerPage
               )}
               showFirstButton
               showLastButton
             />
             <ImageList
               cols={
                 isDesktop ? itemPerPage / 2 : isTablet ? itemPerPage / 3 : 1
               }
             >
               {Array.from(storage?.extension.offers.entries())

                 .filter((_, index) =>
                   index >= currentPageIndex * itemPerPage - itemPerPage &&
                   index < currentPageIndex * itemPerPage
                     ? true
                     : false
                 )
                 .map(([token_id, offer]) => (
                   <Card key={offer.owner + '-' + token_id.toString()}>
                     <CardHeader
                       avatar={
                         <Tooltip
                           title={
                             <Box>
                               <Typography>
                                 {' '}
                                 {'ID : ' + token_id.toString()}{' '}
                               </Typography>
                               <Typography>
                                 {'Description : ' +
                                   nftContratTokenMetadataMap.get(
                                     token_id.toString()
                                   )?.description}
                               </Typography>
                               <Typography>
                                 {'Seller : ' + offer.owner}{' '}
                               </Typography>
                             </Box>
                           }
                         >
                           <InfoOutlined />
                         </Tooltip>
                       }
                       title={
                         nftContratTokenMetadataMap.get(token_id.toString())
                           ?.name
                       }
                     />
                     <CardMedia
                       sx={{ width: 'auto', marginLeft: '33%' }}
                       component="img"
                       height="100px"
                       image={nftContratTokenMetadataMap
                         .get(token_id.toString())
                         ?.thumbnailUri?.replace(
                           'ipfs://',
                           'https://gateway.pinata.cloud/ipfs/'
                         )}
                     />

                     <CardContent>
                       <Box>
                         <Typography variant="body2">
                           {' '}
                           {'Price : ' +
                             offer.price.dividedBy(1000000) +
                             ' XTZ'}
                         </Typography>
                       </Box>
                     </CardContent>

                     <CardActions>
                       {!userAddress ? (
                         <Box marginLeft="5vw">
                           <ConnectButton
                             Tezos={Tezos}
                             nftContratTokenMetadataMap={
                               nftContratTokenMetadataMap
                             }
                             setUserAddress={setUserAddress}
                             setUserBalance={setUserBalance}
                             wallet={wallet}
                           />
                         </Box>
                       ) : (
                         <form
                           style={{ width: '100%' }}
                           onSubmit={(values) => {
                             setSelectedOfferEntry([token_id, offer]);
                             formik.handleSubmit(values);
                           }}
                         >
                           <Button type="submit" aria-label="add to favorites">
                             <ShoppingCartIcon /> BUY
                           </Button>
                         </form>
                       )}
                     </CardActions>
                   </Card>
                 ))}
             </ImageList>
           </Fragment>
         ) : (
           <Typography sx={{ py: '2em' }} variant="h4">
             Sorry, there is not NFT to buy yet, you need to mint or sell
             bottles first
           </Typography>
         )}
       </Paper>
     );
   }
   ```

2. Disconnect your administrator account from the application and connect with a different account that has enough tez to buy a bottle.

3. In the web application, click **Trading > Wine catalogue**.
   The page looks like this:

   ![The catalog page shows one bottle for sale](/img/tutorials/nft-marketplace-2-buy.png)

4. Buy a bottle by clicking **Buy** and confirming the transaction in your wallet.

5. When the transaction completes, click **Trading > Sell bottles** and see that you own the bottle and that you can offer it for sale.

## Summary

Now you and other users can buy and sell NFTs from the marketplace dApp.

In the next part, you create a different type of token, called a single-asset token.
Instead of creating multiple token types with a quantity of exactly 1 as with the NFTs in this part, you create a single token type with any quantity you want.

For the complete content of the contract and web app at the end of this part, see the completed part 2 app at https://github.com/marigold-dev/training-nft-2.

To continue, go to [Part 3: Managing tokens with quantities](/tutorials/build-an-nft-marketplace/part-3).


# Part 3: Managing tokens with quantities

Because only one of each NFT can exist, they are not the right token type to represent wine bottles, which have a type and a quantity of bottles of that type.
So in this part, you change the application to use a single-asset template, which lets you create a single token ID with a quantity that you define.

Of course, a wine store has many different bottles of wine with different quantities, so in the next part, you use a multi-asset template to represent bottles in that situation.

You can continue from your code from part 2 or start from the completed version here: https://github.com/marigold-dev/training-nft-2/tree/main/solution.

If you start from the completed version, run these commands to install dependencies for the web application:

```bash
npm i
cd ./app
yarn install
cd ..
```

## Updating the smart contract

To use the single-asset template, you must change the code that your smart contract imports from the NFT template to the single-asset template:

1. In the `nft.jsligo` file, change the first line to this code:

   ```jsligo
   #import "@ligo/fa/lib/fa2/asset/single_asset.impl.jsligo" "FA2Impl"
   ```

2. Change the offer type to store a quantity and a price, as in this code:

   ```jsligo
   export type offer = { quantity: nat, price: nat };
   ```

3. Change the **offers** BigMap in the `Extension`

   ```jsligo
   export type Extension = {
      administrators: set<address>,
      offers: map<address, offer>, //user sells an offer
    };
   ```

   Now the **offers** value is indexed on the address of the seller instead of the token ID because there is only one token ID.

4. Replace the `mint` entrypoint with this code:

   ```jsligo
   @entry
    const mint = (
      [quantity, name, description, symbol, ipfsUrl]: [
        nat,
        bytes,
        bytes,
        bytes,
        bytes
      ],
      s: storage
    ): ret => {
      if (quantity <= (0 as nat)) return failwith("0");
      if (! Set.mem(Tezos.get_sender(), s.extension.administrators)) return failwith("1");
      const token_info: map<string, bytes> =
        Map.literal(
          list(
            [
              ["name", name],
              ["description", description],
              ["interfaces", (bytes `["TZIP-12"]`)],
              ["artifactUri", ipfsUrl],
              ["displayUri", ipfsUrl],
              ["thumbnailUri", ipfsUrl],
              ["symbol", symbol],
              ["decimals", (bytes `0`)]
            ]
          )
        ) as map<string, bytes>;
      return [
        list([]) as list<operation>,
        {
          ...s,
          ledger: Big_map.literal(list([[Tezos.get_sender(), quantity as nat]])) as
            FA2Impl.ledger,
          token_metadata: Big_map.add(
            0 as nat,
            { token_id: 0 as nat, token_info: token_info },
            s.token_metadata
          ),
          operators: Big_map.empty as FA2Impl.operators,
        }
      ]
    };
   ```

   This updated entrypoint accepts a parameter for the number of tokens to mint.

5. Replace the `sell` entrypoint with this code:

   ```jsligo
    @entry
    const sell = ([quantity, price]: [nat, nat], s: storage): ret => {
      //check balance of seller
      const sellerBalance = FA2Impl.get_amount_for_owner(s)(Tezos.get_source());
      if (quantity > sellerBalance) return failwith("2");
      //need to allow the contract itself to be an operator on behalf of the seller
      const newOperators =
        FA2Impl.add_operator(
          s.operators,
          Tezos.get_source(),
          Tezos.get_self_address()
        );
      //DECISION CHOICE: if offer already exists, we just override it
      return [
        list([]) as list<operation>,
        {
          ...s,
          extension: {
            ...s.extension,
            offers: Map.add(
              Tezos.get_source(),
              { quantity: quantity, price: price },
              s.extension.offers
            )
          },
          operators: newOperators
        }
      ]
    };
   ```

   This updated entrypoint accepts a quantity to offer for sale instead of a token ID.
   It also overrides any existing offers for the token.

6. Replace the `buy` entrypoint with this code:

   ```jsligo
   @entry
    const buy = ([quantity, seller]: [nat, address], s: storage): ret => {
      //search for the offer
      return match(Map.find_opt(seller, s.extension.offers)) {
        when (None()):
          failwith("3")
        when (Some(offer)):
          do {
            //check if quantity is enough
            if (quantity > offer.quantity) return failwith("4");
            //check if amount have been paid enough
            if (Tezos.get_amount() < (offer.price * quantity) * (1 as mutez)) return failwith(
              "5"
            );
            // prepare transfer of XTZ to seller
            const op =
              Tezos.transaction(
                unit,
                (offer.price * quantity) * (1 as mutez),
                Tezos.get_contract_with_error(seller, "6")
              );
            //transfer tokens from seller to buyer
            let ledger =
              FA2Impl.decrease_token_amount_for_user(s.ledger, seller, quantity);
            ledger
            = FA2Impl.increase_token_amount_for_user(
                ledger,
                Tezos.get_source(),
                quantity
              );
            //update new offer
            const newOffer = { ...offer, quantity: abs(offer.quantity - quantity) };
            return [
              list([op]) as list<operation>,
              {
                ...s,
                extension: {
                  ...s.extension,
                  offers: Map.update(seller, Some(newOffer), s.extension.offers)
                },
                ledger: ledger,
              }
            ]
          }
      }
    };
   ```

   This updated entrypoint accepts the number of tokens to buy, verifies that the quantity is less than or equal to the quantity offered for sale, verifies the sale price, and updates the offer.
   It allows a buyer to buy the full amount of tokens for sale or fewer than the offered amount.

7. Replace the content of the `nft.storageList.jsligo` file with this code:

   ```jsligo
    #import "nft.jsligo" "Contract"

    #import "@ligo/fa/lib/fa2/asset/extendable_single_asset.impl.jsligo" "FA2Impl"

    const default_storage: Contract.storage = {
        extension: {
            administrators: Set.literal(
                list(["tz1VSUr8wwNhLAzempoch5d6hLRiTh8Cjcjb" as address])
            ) as set<address>,
            offers: Map.empty as map<address, Contract.offer>,
        },
        ledger: Big_map.empty as FA2Impl.ledger,
        metadata: Big_map.literal(
            list(
                [
                    ["", bytes `tezos-storage:data`],
                    [
                        "data",
                        bytes
                        `{
            "name":"FA2 NFT Marketplace",
            "description":"Example of FA2 implementation",
            "version":"0.0.1",
            "license":{"name":"MIT"},
            "authors":["Marigold<contact@marigold.dev>"],
            "homepage":"https://marigold.dev",
            "source":{
              "tools":["Ligo"],
              "location":"https://github.com/ligolang/contract-catalogue/tree/main/lib/fa2"},
            "interfaces":["TZIP-012"],
            "errors": [],
            "views": []
            }`
                    ]
                ]
            )
        ) as FA2Impl.TZIP16.metadata,
        token_metadata: Big_map.empty as FA2Impl.TZIP12.tokenMetadata,
        operators: Big_map.empty as FA2Impl.operators,
    };
   ```

8. As in the previous parts, update the administrators to include addresses that you have access to.

9. Compile and deploy the new contract:

   ```bash
   TAQ_LIGO_IMAGE=ligolang/ligo:1.6.0 taq compile nft.jsligo
   taq deploy nft.tz -e "testing"
   ```

## Updating the frontend

1. Generate the TypeScript classes and start the server:

   ```bash
   taq generate types ./app/src
   cd ./app
   yarn dev
   ```

2. In the file `src/App.tsx`, replace the function `refreshUserContextOnPageReload` with this code:

   ```typescript
   const refreshUserContextOnPageReload = async () => {
     console.log("refreshUserContext");
     //CONTRACT
     try {
       let c = await Tezos.contract.at(nftContractAddress, tzip12);
       console.log("nftContractAddress", nftContractAddress);

       let nftContrat: NftWalletType = await Tezos.wallet.at<NftWalletType>(
         nftContractAddress
       );
       const storage = (await nftContrat.storage()) as Storage;

       try {
         let tokenMetadata: TZIP21TokenMetadata = (await c
           .tzip12()
           .getTokenMetadata(0)) as TZIP21TokenMetadata;
         nftContratTokenMetadataMap.set("0", tokenMetadata);

         setNftContratTokenMetadataMap(new Map(nftContratTokenMetadataMap)); //new Map to force refresh
       } catch (error) {
         console.log("error refreshing nftContratTokenMetadataMap: ");
       }

       setNftContrat(nftContrat);
       setStorage(storage);
     } catch (error) {
       console.log("error refreshing nft contract: ", error);
     }

     //USER
     const activeAccount = await wallet.client.getActiveAccount();
     if (activeAccount) {
       setUserAddress(activeAccount.address);
       const balance = await Tezos.tz.getBalance(activeAccount.address);
       setUserBalance(balance.toNumber());
     }

     console.log("refreshUserContext ended.");
   };
   ```

   This update shows information about the single-asset token correctly in the UI.

3. Replace the content of the `src/MintPage.tsx` file with this code:

   ```typescript
   import OpenWithIcon from "@mui/icons-material/OpenWith";
   import {
     Button,
     CardHeader,
     CardMedia,
     MobileStepper,
     Stack,
     SwipeableDrawer,
     TextField,
     Toolbar,
     useMediaQuery,
   } from "@mui/material";
   import Box from "@mui/material/Box";
   import Card from "@mui/material/Card";
   import CardContent from "@mui/material/CardContent";
   import Paper from "@mui/material/Paper";
   import Typography from "@mui/material/Typography";
   import { BigNumber } from "bignumber.js";
   import { useSnackbar } from "notistack";
   import React, { useEffect, useState } from "react";
   import { TZIP21TokenMetadata, UserContext, UserContextType } from "./App";
   import { TransactionInvalidBeaconError } from "./TransactionInvalidBeaconError";

   import {
     AddCircleOutlined,
     Close,
     KeyboardArrowLeft,
     KeyboardArrowRight,
   } from "@mui/icons-material";
   import { char2Bytes } from "@taquito/utils";
   import { useFormik } from "formik";
   import SwipeableViews from "react-swipeable-views";
   import * as yup from "yup";
   import { address, bytes, nat } from "./type-aliases";
   export default function MintPage() {
     const {
       userAddress,
       storage,
       nftContrat,
       refreshUserContextOnPageReload,
       nftContratTokenMetadataMap,
     } = React.useContext(UserContext) as UserContextType;
     const { enqueueSnackbar } = useSnackbar();
     const [pictureUrl, setPictureUrl] = useState<string>("");
     const [file, setFile] = useState<File | null>(null);

     const [activeStep, setActiveStep] = React.useState(0);

     const handleNext = () => {
       setActiveStep((prevActiveStep) => prevActiveStep + 1);
     };

     const handleBack = () => {
       setActiveStep((prevActiveStep) => prevActiveStep - 1);
     };

     const handleStepChange = (step: number) => {
       setActiveStep(step);
     };
     const validationSchema = yup.object({
       name: yup.string().required("Name is required"),
       description: yup.string().required("Description is required"),
       symbol: yup.string().required("Symbol is required"),
       quantity: yup
         .number()
         .required("Quantity is required")
         .positive("ERROR: The number must be greater than 0!"),
     });

     const formik = useFormik({
       initialValues: {
         name: "",
         description: "",
         token_id: 0,
         symbol: "WINE",
         quantity: 1,
       } as TZIP21TokenMetadata & { quantity: number },
       validationSchema: validationSchema,
       onSubmit: (values) => {
         mint(values);
       },
     });

     //open mint drawer if admin
     useEffect(() => {
       if (
         storage &&
         storage!.extension.administrators.indexOf(userAddress! as address) < 0
       )
         setFormOpen(false);
       else setFormOpen(true);
     }, [userAddress]);

     const mint = async (
       newTokenDefinition: TZIP21TokenMetadata & { quantity: number }
     ) => {
       try {
         //IPFS
         if (file) {
           const formData = new FormData();
           formData.append("file", file);

           const requestHeaders: HeadersInit = new Headers();
           requestHeaders.set(
             "pinata_api_key",
             `${import.meta.env.VITE_PINATA_API_KEY}`
           );
           requestHeaders.set(
             "pinata_secret_api_key",
             `${import.meta.env.VITE_PINATA_API_SECRET}`
           );

           const resFile = await fetch(
             "https://api.pinata.cloud/pinning/pinFileToIPFS",
             {
               method: "post",
               body: formData,
               headers: requestHeaders,
             }
           );

           const responseJson = await resFile.json();
           console.log("responseJson", responseJson);

           const thumbnailUri = `ipfs://${responseJson.IpfsHash}`;
           setPictureUrl(
             `https://gateway.pinata.cloud/ipfs/${responseJson.IpfsHash}`
           );

           const op = await nftContrat!.methods
             .mint(
               new BigNumber(newTokenDefinition.quantity) as nat,
               char2Bytes(newTokenDefinition.name!) as bytes,
               char2Bytes(newTokenDefinition.description!) as bytes,
               char2Bytes(newTokenDefinition.symbol!) as bytes,
               char2Bytes(thumbnailUri) as bytes
             )
             .send();

           //close directly the form
           setFormOpen(false);
           enqueueSnackbar(
             "Wine collection is minting ... it will be ready on next block, wait for the confirmation message before minting another collection",
             { variant: "info" }
           );

           await op.confirmation(2);

           enqueueSnackbar("Wine collection minted", { variant: "success" });

           refreshUserContextOnPageReload(); //force all app to refresh the context
         }
       } catch (error) {
         console.table(`Error: ${JSON.stringify(error, null, 2)}`);
         let tibe: TransactionInvalidBeaconError =
           new TransactionInvalidBeaconError(error);
         enqueueSnackbar(tibe.data_message, {
           variant: "error",
           autoHideDuration: 10000,
         });
       }
     };

     const [formOpen, setFormOpen] = useState<boolean>(false);

     const toggleDrawer =
       (open: boolean) => (event: React.KeyboardEvent | React.MouseEvent) => {
         if (
           event.type === "keydown" &&
           ((event as React.KeyboardEvent).key === "Tab" ||
             (event as React.KeyboardEvent).key === "Shift")
         ) {
           return;
         }
         setFormOpen(open);
       };

     const isTablet = useMediaQuery("(min-width:600px)");

     return (
       <Paper>
         {storage ? (
           <Button
             disabled={
               storage.extension.administrators.indexOf(
                 userAddress! as address
               ) < 0
             }
             sx={{
               p: 1,
               position: "absolute",
               right: "0",
               display: formOpen ? "none" : "block",
               zIndex: 1,
             }}
             onClick={toggleDrawer(!formOpen)}
           >
             {" Mint Form " +
               (storage!.extension.administrators.indexOf(
                 userAddress! as address
               ) < 0
                 ? " (You are not admin)"
                 : "")}
             <OpenWithIcon />
           </Button>
         ) : (
           ""
         )}

         <SwipeableDrawer
           onClose={toggleDrawer(false)}
           onOpen={toggleDrawer(true)}
           anchor="right"
           open={formOpen}
           variant="temporary"
         >
           <Toolbar
             sx={
               isTablet
                 ? { marginTop: "0", marginRight: "0" }
                 : { marginTop: "35px", marginRight: "125px" }
             }
           />
           <Box
             sx={{
               width: isTablet ? "40vw" : "60vw",
               borderColor: "text.secondary",
               borderStyle: "solid",
               borderWidth: "1px",

               height: "calc(100vh - 64px)",
             }}
           >
             <Button
               sx={{
                 position: "absolute",
                 right: "0",
                 display: !formOpen ? "none" : "block",
               }}
               onClick={toggleDrawer(!formOpen)}
             >
               <Close />
             </Button>
             <form onSubmit={formik.handleSubmit}>
               <Stack spacing={2} margin={2} alignContent={"center"}>
                 <Typography variant="h5">Mint a new collection</Typography>

                 <TextField
                   id="standard-basic"
                   name="token_id"
                   label="token_id"
                   value={formik.values.token_id}
                   disabled
                   variant="filled"
                 />
                 <TextField
                   id="standard-basic"
                   name="name"
                   label="name"
                   required
                   value={formik.values.name}
                   onChange={formik.handleChange}
                   error={formik.touched.name && Boolean(formik.errors.name)}
                   helperText={formik.touched.name && formik.errors.name}
                   variant="filled"
                 />
                 <TextField
                   id="standard-basic"
                   name="symbol"
                   label="symbol"
                   required
                   value={formik.values.symbol}
                   onChange={formik.handleChange}
                   error={
                     formik.touched.symbol && Boolean(formik.errors.symbol)
                   }
                   helperText={formik.touched.symbol && formik.errors.symbol}
                   variant="filled"
                 />
                 <TextField
                   id="standard-basic"
                   name="description"
                   label="description"
                   required
                   multiline
                   minRows={2}
                   value={formik.values.description}
                   onChange={formik.handleChange}
                   error={
                     formik.touched.description &&
                     Boolean(formik.errors.description)
                   }
                   helperText={
                     formik.touched.description && formik.errors.description
                   }
                   variant="filled"
                 />

                 <TextField
                   type="number"
                   id="standard-basic"
                   name="quantity"
                   label="quantity"
                   required
                   value={formik.values.quantity}
                   onChange={formik.handleChange}
                   error={
                     formik.touched.quantity && Boolean(formik.errors.quantity)
                   }
                   helperText={
                     formik.touched.quantity && formik.errors.quantity
                   }
                   variant="filled"
                 />

                 {pictureUrl ? (
                   <img height={100} width={100} src={pictureUrl} />
                 ) : (
                   ""
                 )}
                 <Button variant="contained" component="label" color="primary">
                   <AddCircleOutlined />
                   Upload an image
                   <input
                     type="file"
                     hidden
                     name="data"
                     onChange={(e: React.ChangeEvent<HTMLInputElement>) => {
                       const data = e.target.files ? e.target.files[0] : null;
                       if (data) {
                         setFile(data);
                       }
                       e.preventDefault();
                     }}
                   />
                 </Button>

                 <Button variant="contained" type="submit">
                   Mint
                 </Button>
               </Stack>
             </form>
           </Box>
         </SwipeableDrawer>

         <Typography variant="h5">Mint your wine collection</Typography>

         {nftContratTokenMetadataMap.size != 0 ? (
           <Box sx={{ width: "70vw" }}>
             <SwipeableViews
               axis="x"
               index={activeStep}
               onChangeIndex={handleStepChange}
               enableMouseEvents
             >
               {Array.from(nftContratTokenMetadataMap!.entries()).map(
                 ([token_id, token]) => (
                   <Card
                     sx={{
                       display: "block",
                       maxWidth: "80vw",
                       overflow: "hidden",
                     }}
                     key={token_id.toString()}
                   >
                     <CardHeader
                       titleTypographyProps={
                         isTablet ? { fontSize: "1.5em" } : { fontSize: "1em" }
                       }
                       title={token.name}
                     />

                     <CardMedia
                       sx={
                         isTablet
                           ? {
                               width: "auto",
                               marginLeft: "33%",
                               maxHeight: "50vh",
                             }
                           : { width: "100%", maxHeight: "40vh" }
                       }
                       component="img"
                       image={token.thumbnailUri?.replace(
                         "ipfs://",
                         "https://gateway.pinata.cloud/ipfs/"
                       )}
                     />

                     <CardContent>
                       <Box>
                         <Typography>{"ID : " + token_id}</Typography>
                         <Typography>{"Symbol : " + token.symbol}</Typography>
                         <Typography>
                           {"Description : " + token.description}
                         </Typography>
                       </Box>
                     </CardContent>
                   </Card>
                 )
               )}
             </SwipeableViews>
             <MobileStepper
               variant="text"
               steps={Array.from(nftContratTokenMetadataMap!.entries()).length}
               position="static"
               activeStep={activeStep}
               nextButton={
                 <Button
                   size="small"
                   onClick={handleNext}
                   disabled={
                     activeStep ===
                     Array.from(nftContratTokenMetadataMap!.entries()).length -
                       1
                   }
                 >
                   Next
                   <KeyboardArrowRight />
                 </Button>
               }
               backButton={
                 <Button
                   size="small"
                   onClick={handleBack}
                   disabled={activeStep === 0}
                 >
                   <KeyboardArrowLeft />
                   Back
                 </Button>
               }
             />
           </Box>
         ) : (
           <Typography sx={{ py: "2em" }} variant="h4">
             Sorry, there is not NFT yet, you need to mint bottles first
           </Typography>
         )}
       </Paper>
     );
   }
   ```

   This update changes the mint function to add a quantity field and remove the token ID field.

4. Replace the content of the `src/OffersPage.tsx` file with this code:

   ```typescript
   import { InfoOutlined } from "@mui/icons-material";
   import SellIcon from "@mui/icons-material/Sell";
   import * as api from "@tzkt/sdk-api";

   import {
     Box,
     Button,
     Card,
     CardActions,
     CardContent,
     CardHeader,
     CardMedia,
     ImageList,
     InputAdornment,
     Pagination,
     TextField,
     Tooltip,
     Typography,
     useMediaQuery,
   } from "@mui/material";
   import Paper from "@mui/material/Paper";
   import BigNumber from "bignumber.js";
   import { useFormik } from "formik";
   import { useSnackbar } from "notistack";
   import React, { Fragment, useEffect, useState } from "react";
   import * as yup from "yup";
   import { UserContext, UserContextType } from "./App";
   import ConnectButton from "./ConnectWallet";
   import { TransactionInvalidBeaconError } from "./TransactionInvalidBeaconError";
   import { address, nat } from "./type-aliases";

   const itemPerPage: number = 6;

   const validationSchema = yup.object({
     price: yup
       .number()
       .required("Price is required")
       .positive("ERROR: The number must be greater than 0!"),
     quantity: yup
       .number()
       .required("Quantity is required")
       .positive("ERROR: The number must be greater than 0!"),
   });

   type Offer = {
     price: nat;
     quantity: nat;
   };

   export default function OffersPage() {
     api.defaults.baseUrl = "https://api.ghostnet.tzkt.io";

     const [selectedTokenId, setSelectedTokenId] = React.useState<number>(0);
     const [currentPageIndex, setCurrentPageIndex] = useState<number>(1);

     let [ownerOffers, setOwnerOffers] = React.useState<Offer | null>(null);
     let [ownerBalance, setOwnerBalance] = React.useState<number>(0);

     const {
       nftContrat,
       nftContratTokenMetadataMap,
       userAddress,
       storage,
       refreshUserContextOnPageReload,
       Tezos,
       setUserAddress,
       setUserBalance,
       wallet,
     } = React.useContext(UserContext) as UserContextType;

     const { enqueueSnackbar } = useSnackbar();

     const formik = useFormik({
       initialValues: {
         price: 0,
         quantity: 1,
       },
       validationSchema: validationSchema,
       onSubmit: (values) => {
         console.log("onSubmit: (values)", values, selectedTokenId);
         sell(selectedTokenId, values.quantity, values.price);
       },
     });

     const initPage = async () => {
       if (storage) {
         console.log("context is not empty, init page now");

         const ledgerBigMapId = (
           storage.ledger as unknown as { id: BigNumber }
         ).id.toNumber();

         const ownersKeys = await api.bigMapsGetKeys(ledgerBigMapId, {
           micheline: "Json",
           active: true,
         });

         await Promise.all(
           ownersKeys.map(async (ownerKey) => {
             if (ownerKey.key === userAddress) {
               const ownerBalance = await storage.ledger.get(
                 userAddress as address
               );
               setOwnerBalance(ownerBalance.toNumber());
               const ownerOffers = await storage.extension.offers.get(
                 userAddress as address
               );
               if (ownerOffers && ownerOffers.quantity != BigNumber(0))
                 setOwnerOffers(ownerOffers!);

               console.log(
                 "found for " +
                   ownerKey.key +
                   " on token_id " +
                   0 +
                   " with balance " +
                   ownerBalance
               );
             } else {
               console.log("skip to next owner");
             }
           })
         );
       } else {
         console.log("context is empty, wait for parent and retry ...");
       }
     };

     useEffect(() => {
       (async () => {
         console.log("after a storage changed");
         await initPage();
       })();
     }, [storage]);

     useEffect(() => {
       (async () => {
         console.log("on Page init");
         await initPage();
       })();
     }, []);

     const sell = async (token_id: number, quantity: number, price: number) => {
       try {
         const op = await nftContrat?.methods
           .sell(
             BigNumber(quantity) as nat,
             BigNumber(price * 1000000) as nat //to mutez
           )
           .send();

         await op?.confirmation(2);

         enqueueSnackbar(
           "Wine collection (token_id=" +
             token_id +
             ") offer for " +
             quantity +
             " units at price of " +
             price +
             " XTZ",
           { variant: "success" }
         );

         refreshUserContextOnPageReload(); //force all app to refresh the context
       } catch (error) {
         console.table(`Error: ${JSON.stringify(error, null, 2)}`);
         let tibe: TransactionInvalidBeaconError =
           new TransactionInvalidBeaconError(error);
         enqueueSnackbar(tibe.data_message, {
           variant: "error",
           autoHideDuration: 10000,
         });
       }
     };

     const isDesktop = useMediaQuery("(min-width:1100px)");
     const isTablet = useMediaQuery("(min-width:600px)");
     return (
       <Paper>
         <Typography style={{ paddingBottom: "10px" }} variant="h5">
           Sell my bottles
         </Typography>
         {ownerBalance != 0 ? (
           <Fragment>
             <Pagination
               page={currentPageIndex}
               onChange={(_, value) => setCurrentPageIndex(value)}
               count={Math.ceil(1 / itemPerPage)}
               showFirstButton
               showLastButton
             />

             <ImageList
               cols={
                 isDesktop ? itemPerPage / 2 : isTablet ? itemPerPage / 3 : 1
               }
             >
               <Card key={userAddress + "-" + 0}>
                 <CardHeader
                   avatar={
                     <Tooltip
                       title={
                         <Box>
                           <Typography>{"ID : " + 0}</Typography>
                           <Typography>
                             {"Description : " +
                               nftContratTokenMetadataMap.get("0")?.description}
                           </Typography>
                         </Box>
                       }
                     >
                       <InfoOutlined />
                     </Tooltip>
                   }
                   title={nftContratTokenMetadataMap.get("0")?.name}
                 />
                 <CardMedia
                   sx={{ width: "auto", marginLeft: "33%" }}
                   component="img"
                   height="100px"
                   image={nftContratTokenMetadataMap
                     .get("0")
                     ?.thumbnailUri?.replace(
                       "ipfs://",
                       "https://gateway.pinata.cloud/ipfs/"
                     )}
                 />

                 <CardContent>
                   <Box>
                     <Typography variant="body2">
                       {"Owned : " + ownerBalance}
                     </Typography>
                     <Typography variant="body2">
                       {ownerOffers
                         ? "Traded : " +
                           ownerOffers?.quantity +
                           " (price : " +
                           ownerOffers?.price.dividedBy(1000000) +
                           " Tz/b)"
                         : ""}
                     </Typography>
                   </Box>
                 </CardContent>

                 <CardActions>
                   {!userAddress ? (
                     <Box marginLeft="5vw">
                       <ConnectButton
                         Tezos={Tezos}
                         nftContratTokenMetadataMap={nftContratTokenMetadataMap}
                         setUserAddress={setUserAddress}
                         setUserBalance={setUserBalance}
                         wallet={wallet}
                       />
                     </Box>
                   ) : (
                     <form
                       style={{ width: "100%" }}
                       onSubmit={(values) => {
                         setSelectedTokenId(0);
                         formik.handleSubmit(values);
                       }}
                     >
                       <span>
                         <TextField
                           type="number"
                           sx={{ width: "40%" }}
                           name="price"
                           label="price/bottle"
                           placeholder="Enter a price"
                           variant="filled"
                           value={formik.values.price}
                           onChange={formik.handleChange}
                           error={
                             formik.touched.price &&
                             Boolean(formik.errors.price)
                           }
                           helperText={
                             formik.touched.price && formik.errors.price
                           }
                         />
                         <TextField
                           sx={{
                             width: "60%",
                             bottom: 0,
                             position: "relative",
                           }}
                           type="number"
                           label="quantity"
                           name="quantity"
                           placeholder="Enter a quantity"
                           variant="filled"
                           value={formik.values.quantity}
                           onChange={formik.handleChange}
                           error={
                             formik.touched.quantity &&
                             Boolean(formik.errors.quantity)
                           }
                           helperText={
                             formik.touched.quantity && formik.errors.quantity
                           }
                           InputProps={{
                             inputProps: { min: 0, max: ownerBalance },
                             endAdornment: (
                               <InputAdornment position="end">
                                 <Button
                                   type="submit"
                                   aria-label="add to favorites"
                                 >
                                   <SellIcon /> Sell
                                 </Button>
                               </InputAdornment>
                             ),
                           }}
                         />
                       </span>
                     </form>
                   )}
                 </CardActions>
               </Card>
             </ImageList>
           </Fragment>
         ) : (
           <Typography sx={{ py: "2em" }} variant="h4">
             Sorry, you don't own any bottles, buy or mint some first
           </Typography>
         )}
       </Paper>
     );
   }
   ```

   This update changes the offers page to allow owners to specify the number of tokens to offer for sale.

5. Replace the content of the `src/WineCataloguePage.tsx` with this code:

   ```typescript
   import { InfoOutlined } from "@mui/icons-material";
   import ShoppingCartIcon from "@mui/icons-material/ShoppingCart";
   import {
     Button,
     Card,
     CardActions,
     CardContent,
     CardHeader,
     CardMedia,
     ImageList,
     InputAdornment,
     Pagination,
     TextField,
     Tooltip,
     Typography,
     useMediaQuery,
   } from "@mui/material";
   import Box from "@mui/material/Box";
   import Paper from "@mui/material/Paper";
   import BigNumber from "bignumber.js";
   import { useFormik } from "formik";
   import { useSnackbar } from "notistack";
   import React, { Fragment, useState } from "react";
   import * as yup from "yup";
   import { UserContext, UserContextType } from "./App";
   import ConnectButton from "./ConnectWallet";
   import { TransactionInvalidBeaconError } from "./TransactionInvalidBeaconError";
   import { address, nat } from "./type-aliases";

   const itemPerPage: number = 6;

   type OfferEntry = [address, Offer];

   type Offer = {
     price: nat;
     quantity: nat;
   };

   const validationSchema = yup.object({
     quantity: yup
       .number()
       .required("Quantity is required")
       .positive("ERROR: The number must be greater than 0!"),
   });

   export default function WineCataloguePage() {
     const {
       Tezos,
       nftContratTokenMetadataMap,
       setUserAddress,
       setUserBalance,
       wallet,
       userAddress,
       nftContrat,
       refreshUserContextOnPageReload,
       storage,
     } = React.useContext(UserContext) as UserContextType;
     const [selectedOfferEntry, setSelectedOfferEntry] =
       React.useState<OfferEntry | null>(null);

     const formik = useFormik({
       initialValues: {
         quantity: 1,
       },
       validationSchema: validationSchema,
       onSubmit: (values) => {
         console.log("onSubmit: (values)", values, selectedOfferEntry);
         buy(values.quantity, selectedOfferEntry!);
       },
     });
     const { enqueueSnackbar } = useSnackbar();
     const [currentPageIndex, setCurrentPageIndex] = useState<number>(1);

     const buy = async (quantity: number, selectedOfferEntry: OfferEntry) => {
       try {
         const op = await nftContrat?.methods
           .buy(BigNumber(quantity) as nat, selectedOfferEntry[0])
           .send({
             amount:
               selectedOfferEntry[1].quantity.toNumber() *
               selectedOfferEntry[1].price.toNumber(),
             mutez: true,
           });

         await op?.confirmation(2);

         enqueueSnackbar(
           "Bought " +
             quantity +
             " unit of Wine collection (token_id:" +
             selectedOfferEntry[0][1] +
             ")",
           {
             variant: "success",
           }
         );

         refreshUserContextOnPageReload(); //force all app to refresh the context
       } catch (error) {
         console.table(`Error: ${JSON.stringify(error, null, 2)}`);
         let tibe: TransactionInvalidBeaconError =
           new TransactionInvalidBeaconError(error);
         enqueueSnackbar(tibe.data_message, {
           variant: "error",
           autoHideDuration: 10000,
         });
       }
     };
     const isDesktop = useMediaQuery("(min-width:1100px)");
     const isTablet = useMediaQuery("(min-width:600px)");

     return (
       <Paper>
         <Typography style={{ paddingBottom: "10px" }} variant="h5">
           Wine catalogue
         </Typography>

         {storage?.extension.offers && storage?.extension.offers.size != 0 ? (
           <Fragment>
             <Pagination
               page={currentPageIndex}
               onChange={(_, value) => setCurrentPageIndex(value)}
               count={Math.ceil(
                 Array.from(storage?.extension.offers.entries()).filter(
                   ([_, offer]) => offer.quantity.isGreaterThan(0)
                 ).length / itemPerPage
               )}
               showFirstButton
               showLastButton
             />
             <ImageList
               cols={
                 isDesktop ? itemPerPage / 2 : isTablet ? itemPerPage / 3 : 1
               }
             >
               {Array.from(storage?.extension.offers.entries())
                 .filter(([_, offer]) => offer.quantity.isGreaterThan(0))
                 .filter((_, index) =>
                   index >= currentPageIndex * itemPerPage - itemPerPage &&
                   index < currentPageIndex * itemPerPage
                     ? true
                     : false
                 )
                 .map(([owner, offer]) => (
                   <Card key={owner}>
                     <CardHeader
                       avatar={
                         <Tooltip
                           title={
                             <Box>
                               <Typography>{"ID : " + 0}</Typography>
                               <Typography>
                                 {"Description : " +
                                   nftContratTokenMetadataMap.get("0")
                                     ?.description}
                               </Typography>
                               <Typography>{"Seller : " + owner} </Typography>
                             </Box>
                           }
                         >
                           <InfoOutlined />
                         </Tooltip>
                       }
                       title={nftContratTokenMetadataMap.get("0")?.name}
                     />
                     <CardMedia
                       sx={{ width: "auto", marginLeft: "33%" }}
                       component="img"
                       height="100px"
                       image={nftContratTokenMetadataMap
                         .get("0")
                         ?.thumbnailUri?.replace(
                           "ipfs://",
                           "https://gateway.pinata.cloud/ipfs/"
                         )}
                     />

                     <CardContent>
                       <Box>
                         <Typography variant="body2">
                           {"Price : " +
                             offer.price.dividedBy(1000000) +
                             " XTZ/bottle"}
                         </Typography>
                         <Typography variant="body2">
                           {"Available units : " + offer.quantity}
                         </Typography>
                       </Box>
                     </CardContent>

                     <CardActions>
                       {!userAddress ? (
                         <Box marginLeft="5vw">
                           <ConnectButton
                             Tezos={Tezos}
                             nftContratTokenMetadataMap={
                               nftContratTokenMetadataMap
                             }
                             setUserAddress={setUserAddress}
                             setUserBalance={setUserBalance}
                             wallet={wallet}
                           />
                         </Box>
                       ) : (
                         <form
                           style={{ width: "100%" }}
                           onSubmit={(values) => {
                             setSelectedOfferEntry([owner, offer]);
                             formik.handleSubmit(values);
                           }}
                         >
                           <TextField
                             type="number"
                             sx={{ bottom: 0, position: "relative" }}
                             fullWidth
                             name="quantity"
                             label="quantity"
                             placeholder="Enter a quantity"
                             variant="filled"
                             value={formik.values.quantity}
                             onChange={formik.handleChange}
                             error={
                               formik.touched.quantity &&
                               Boolean(formik.errors.quantity)
                             }
                             helperText={
                               formik.touched.quantity && formik.errors.quantity
                             }
                             InputProps={{
                               inputProps: { min: 0, max: offer.quantity },
                               endAdornment: (
                                 <InputAdornment position="end">
                                   <Button
                                     type="submit"
                                     aria-label="add to favorites"
                                   >
                                     <ShoppingCartIcon /> BUY
                                   </Button>
                                 </InputAdornment>
                               ),
                             }}
                           />
                         </form>
                       )}
                     </CardActions>
                   </Card>
                 ))}
             </ImageList>
           </Fragment>
         ) : (
           <Typography sx={{ py: "2em" }} variant="h4">
             Sorry, there is not NFT to buy yet, you need to mint or sell
             bottles first
           </Typography>
         )}
       </Paper>
     );
   }
   ```

   Like the other files, this update removes the token ID and adds the quantity field.

6. As you did in the previous part, connect an administrator's wallet to the application.

7. Create a token and specify a quantity to mint.
   For example, you can use this information:

   * `name`: Saint Emilion - Franc la Rose
   * `symbol`: SEMIL
   * `description`: Grand cru 2007
   * `quantity`: 1000

   ![The minting page, showing the creation of 1000 tokens](/img/tutorials/nft-marketplace-3-minting.png)

   When you approve the transaction in your wallet and the transaction completes, the page refreshes automatically and shows the new token.

8. Click **Trading > Sell bottles**, set the quantity to offer and the price per token, as shown in this picture:

   ![Setting the price and quantity for the offer](/img/tutorials/nft-marketplace-3-offer.png)

9. Click **Sell** and approve the transaction in your wallet.

10. When the transaction completes, connect with a different account, click **Trading > Wine catalogue**, and buy some bottles of wine, as shown in this picture:

    ![Buying bottles of wine](/img/tutorials/nft-marketplace-3-buy.png)

11. When the transaction completes, you can see that the different account owns the tokens and can offer them for sale for a different price.

    You can also get the address of the contract from the `.taq/config.local.testing.json` file and look up the contract in a block explorer.
    Because the contract is still FA2 compliant, the block explorer shows the token holders and the quantity of the tokens they have, such as in this picture from the [tzkt.io](https://ghostnet.tzkt.io/) block explorer:

    ![The block explorer shows the accounts that own the token](/img/tutorials/nft-marketplace-3-token-holders.png)

## Summary

Now you can manage tokens that have a quantity, but the app can manage only one type of token.

For the complete content of the contract and web app at the end of this part, see the completed part 3 app at https://github.com/marigold-dev/training-nft-3.

In the next part, you update the application to create a multi-asset contract that can handle multiple types of tokens with different quantities.

To continue, go to [Part 4: Handling multi-asset tokens](/tutorials/build-an-nft-marketplace/part-4).


# Part 4: Handling multi-asset tokens

Because a wine store can have many bottles of many different types, the appropriate template to use is the multi-asset template.
With this template, you can create as many token types as you need and set a different quantity for each type.

You can continue from your code from part 3 or start from the completed version here: https://github.com/marigold-dev/training-nft-3/tree/main/solution.

If you start from the completed version, run these commands to install dependencies for the web application:

```bash
npm i
cd ./app
yarn install
cd ..
```

## Updating the smart contract

To use the multi-asset template, you must change the code that your smart contract imports from the NFT template to the multi-asset template:

1. In the `nft.jsligo` file, change the first line to this code:

   ```jsligo
    #import "@ligo/fa/lib/fa2/asset/extendable_multi_asset.impl.jsligo" "FA2Impl"
   ```

2. In the storage, change the `offers` value to `map<[address, nat], offer>`.
   The storage type looks like this:

   ```jsligo
    export type Extension = {
      administrators: set<address>,
      offers: map<[address, nat], offer>, //user sells an offer for a token_id
    };
   ```

Now the offers map is indexed on the address of the seller and the ID of the token for sale.

1. Replace the `mint` entrypoint with this code:

   ```jsligo
      @entry
    const mint = (
      [token_id, quantity, name, description, symbol, ipfsUrl]: [
        nat,
        nat,
        bytes,
        bytes,
        bytes,
        bytes
      ],
      s: storage
    ): ret => {
      if (quantity <= (0 as nat)) return failwith("0");
      if (! Set.mem(Tezos.get_sender(), s.extension.administrators)) return failwith(
        "1"
      );
      const token_info: map<string, bytes> =
        Map.literal(
          list(
            [
              ["name", name],
              ["description", description],
              ["interfaces", (bytes `["TZIP-12"]`)],
              ["artifactUri", ipfsUrl],
              ["displayUri", ipfsUrl],
              ["thumbnailUri", ipfsUrl],
              ["symbol", symbol],
              ["decimals", (bytes `0`)]
            ]
          )
        ) as map<string, bytes>;
      return [
        list([]) as list<operation>,
        {
          ...s,
          ledger: Big_map.add(
            [Tezos.get_sender(), token_id],
            quantity as nat,
            s.ledger
          ) as FA2Impl.ledger,
          token_metadata: Big_map.add(
            token_id,
            { token_id: token_id, token_info: token_info },
            s.token_metadata
          ),
          operators: Big_map.empty as FA2Impl.operators
        }
      ]
    };

   ```

   This updated mint entrypoint accepts both a token ID and a quantity and mints the specified number of that token.

2. Replace the `sell` entrypoint with this code:

   ```jsligo
      @entry
    const sell = ([token_id, quantity, price]: [nat, nat, nat], s: storage): ret => {
      //check balance of seller
      const sellerBalance =
        FA2Impl.get_for_user([s.ledger, Tezos.get_source(), token_id]);
      if (quantity > sellerBalance) return failwith("2");
      //need to allow the contract itself to be an operator on behalf of the seller
      const newOperators =
        FA2Impl.add_operator(
          [s.operators, Tezos.get_source(), Tezos.get_self_address(), token_id]
        );
      //DECISION CHOICE: if offer already exists, we just override it
      return [
        list([]) as list<operation>,
        {
          ...s,
          extension: {
            ...s.extension,
            offers: Map.add(
              [Tezos.get_source(), token_id],
              { quantity: quantity, price: price },
              s.extension.offers
            )
          },
          operators: newOperators
        }
      ]
    };

   ```

   Like the mint entrypoint, this entrypoint now accepts a token ID and quantity as parameters.

3. Replace the `buy` entrypoint with this code:

   ```jsligo
   @entry
   const buy = ([token_id, quantity, seller]: [nat, nat, address], s: storage): ret => {
   //search for the offer
   return match(Map.find_opt([seller, token_id], s.extension.offers)) {
    when (None()):
      failwith("3")
    when (Some(offer)):
      do {
        //check if amount have been paid enough
        if (Tezos.get_amount() < offer.price * (1 as mutez)) return failwith(
          "5"
        );
        // prepare transfer of XTZ to seller
        const op =
          Tezos.transaction(
            unit,
            offer.price * (1 as mutez),
            Tezos.get_contract_with_error(seller, "6")
          );
        //transfer tokens from seller to buyer
        let ledger =
          FA2Impl.decrease_token_amount_for_user(
            [s.ledger, seller, token_id, quantity]
          );
        ledger
        = FA2Impl.increase_token_amount_for_user(
            [ledger, Tezos.get_source(), token_id, quantity]
          );
        //update new offer
        const newOffer = { ...offer, quantity: abs(offer.quantity - quantity) };
        return [
          list([op]) as list<operation>,
          {
            ...s,
            extension: {
              ...s.extension,
              offers: Map.update(
                [seller, token_id],
                Some(newOffer),
                s.extension.offers
              )
            },
            ledger: ledger
          }
        ]
      }
   }
   };
   ```

4. Update the `nft.storageList.jsligo` with this code:

   ```jsligo
   #import "nft.jsligo" "Contract"

    #import "@ligo/fa/lib/fa2/asset/extendable_multi_asset.impl.jsligo" "FA2Impl"

    const default_storage: Contract.storage = {
        extension: {
            administrators: Set.literal(
                list(["tz1VSUr8wwNhLAzempoch5d6hLRiTh8Cjcjb" as address])
            ) as set<address>,
            offers: Map.empty as map<[address, nat], Contract.offer>
        },
        ledger: Big_map.empty as FA2Impl.ledger,
        metadata: Big_map.literal(
            list(
                [
                    ["", bytes `tezos-storage:data`],
                    [
                        "data",
                        bytes
                        `{
            "name":"FA2 NFT Marketplace",
            "description":"Example of FA2 implementation",
            "version":"0.0.1",
            "license":{"name":"MIT"},
            "authors":["Marigold<contact@marigold.dev>"],
            "homepage":"https://marigold.dev",
            "source":{
              "tools":["Ligo"],
              "location":"https://github.com/ligolang/contract-catalogue/tree/main/lib/fa2"},
            "interfaces":["TZIP-012"],
            "errors": [],
            "views": []
            }`
                    ]
                ]
            )
        ) as FA2Impl.TZIP16.metadata,
        token_metadata: Big_map.empty as FA2Impl.TZIP12.tokenMetadata,
        operators: Big_map.empty as FA2Impl.operators,
    };

   ```

5. As in the previous parts, update the administrators to include addresses that you have access to.

6. Compile and deploy the new contract:

   ```bash
   TAQ_LIGO_IMAGE=ligolang/ligo:1.6.0 taq compile nft.jsligo
   taq deploy nft.tz -e "testing"
   ```

## Updating the frontend

Now that the contract handles both token IDs and quantities, you must update the frontend in the same way:

1. Generate the TypeScript classes and start the server:

   ```bash
   taq generate types ./app/src
   cd ./app
   yarn dev
   ```

2. In the file `src/App.tsx`, replace the function `refreshUserContextOnPageReload` with this code:

   ```typescript
   const refreshUserContextOnPageReload = async () => {
     console.log('refreshUserContext');
     //CONTRACT
     try {
       let c = await Tezos.contract.at(nftContractAddress, tzip12);
       console.log('nftContractAddress', nftContractAddress);

       let nftContrat: NftWalletType = await Tezos.wallet.at<NftWalletType>(
         nftContractAddress
       );
       const storage = (await nftContrat.storage()) as Storage;

       const token_metadataBigMapId = (
         storage.token_metadata as unknown as { id: BigNumber }
       ).id.toNumber();

       const token_ids = await api.bigMapsGetKeys(token_metadataBigMapId, {
         micheline: 'Json',
         active: true,
       });
       await Promise.all(
         token_ids.map(async (token_idKey) => {
           const key: string = token_idKey.key;

           let tokenMetadata: TZIP21TokenMetadata = (await c
             .tzip12()
             .getTokenMetadata(Number(key))) as TZIP21TokenMetadata;
           nftContratTokenMetadataMap.set(key, tokenMetadata);
         })
       );
       setNftContratTokenMetadataMap(new Map(nftContratTokenMetadataMap)); //new Map to force refresh
       setNftContrat(nftContrat);
       setStorage(storage);
     } catch (error) {
       console.log('error refreshing nft contract: ', error);
     }

     //USER
     const activeAccount = await wallet.client.getActiveAccount();
     if (activeAccount) {
       setUserAddress(activeAccount.address);
       const balance = await Tezos.tz.getBalance(activeAccount.address);
       setUserBalance(balance.toNumber());
     }

     console.log('refreshUserContext ended.');
   };
   ```

   This function now retrieves all of the tokens in the contract.

3. Replace the content of the `src/MintPage.tsx` file with this code:

   ```typescript
   import {
     AddCircleOutlined,
     Close,
     KeyboardArrowLeft,
     KeyboardArrowRight,
   } from '@mui/icons-material';
   import OpenWithIcon from '@mui/icons-material/OpenWith';
   import {
     Box,
     Button,
     CardHeader,
     CardMedia,
     MobileStepper,
     Stack,
     SwipeableDrawer,
     TextField,
     Toolbar,
     useMediaQuery,
   } from '@mui/material';
   import Card from '@mui/material/Card';
   import CardContent from '@mui/material/CardContent';
   import Paper from '@mui/material/Paper';
   import Typography from '@mui/material/Typography';
   import { char2Bytes } from '@taquito/utils';
   import { BigNumber } from 'bignumber.js';
   import { useFormik } from 'formik';
   import { useSnackbar } from 'notistack';
   import React, { useEffect, useState } from 'react';
   import SwipeableViews from 'react-swipeable-views';
   import * as yup from 'yup';
   import { TZIP21TokenMetadata, UserContext, UserContextType } from './App';
   import { TransactionInvalidBeaconError } from './TransactionInvalidBeaconError';
   import { address, bytes, nat } from './type-aliases';

   export default function MintPage() {
     const {
       userAddress,
       nftContrat,
       refreshUserContextOnPageReload,
       nftContratTokenMetadataMap,
       storage,
     } = React.useContext(UserContext) as UserContextType;
     const { enqueueSnackbar } = useSnackbar();
     const [pictureUrl, setPictureUrl] = useState<string>('');
     const [file, setFile] = useState<File | null>(null);

     const [activeStep, setActiveStep] = React.useState(0);

     const handleNext = () => {
       setActiveStep((prevActiveStep) => prevActiveStep + 1);
     };

     const handleBack = () => {
       setActiveStep((prevActiveStep) => prevActiveStep - 1);
     };

     const handleStepChange = (step: number) => {
       setActiveStep(step);
     };

     const validationSchema = yup.object({
       name: yup.string().required('Name is required'),
       description: yup.string().required('Description is required'),
       symbol: yup.string().required('Symbol is required'),
       quantity: yup
         .number()
         .required('Quantity is required')
         .positive('ERROR: The number must be greater than 0!'),
     });

     const formik = useFormik({
       initialValues: {
         name: '',
         description: '',
         token_id: 0,
         symbol: 'WINE',
         quantity: 1,
       } as TZIP21TokenMetadata & { quantity: number },
       validationSchema: validationSchema,
       onSubmit: (values) => {
         mint(values);
       },
     });

     //open mint drawer if admin
     useEffect(() => {
       if (
         storage &&
         storage!.extension.administrators.indexOf(userAddress! as address) < 0
       )
         setFormOpen(false);
       else setFormOpen(true);
     }, [userAddress]);

     useEffect(() => {
       (async () => {
         if (
           nftContratTokenMetadataMap &&
           nftContratTokenMetadataMap.size > 0
         ) {
           formik.setFieldValue('token_id', nftContratTokenMetadataMap.size);
         }
       })();
     }, [nftContratTokenMetadataMap?.size]);

     const mint = async (
       newTokenDefinition: TZIP21TokenMetadata & { quantity: number }
     ) => {
       try {
         //IPFS
         if (file) {
           const formData = new FormData();
           formData.append('file', file);

           const requestHeaders: HeadersInit = new Headers();
           requestHeaders.set(
             'pinata_api_key',
             `${import.meta.env.VITE_PINATA_API_KEY}`
           );
           requestHeaders.set(
             'pinata_secret_api_key',
             `${import.meta.env.VITE_PINATA_API_SECRET}`
           );

           const resFile = await fetch(
             'https://api.pinata.cloud/pinning/pinFileToIPFS',
             {
               method: 'post',
               body: formData,
               headers: requestHeaders,
             }
           );

           const responseJson = await resFile.json();
           console.log('responseJson', responseJson);

           const thumbnailUri = `ipfs://${responseJson.IpfsHash}`;
           setPictureUrl(
             `https://gateway.pinata.cloud/ipfs/${responseJson.IpfsHash}`
           );

           const op = await nftContrat!.methods
             .mint(
               new BigNumber(newTokenDefinition.token_id) as nat,
               new BigNumber(newTokenDefinition.quantity) as nat,
               char2Bytes(newTokenDefinition.name!) as bytes,
               char2Bytes(newTokenDefinition.description!) as bytes,
               char2Bytes(newTokenDefinition.symbol!) as bytes,
               char2Bytes(thumbnailUri) as bytes
             )
             .send();

           //close directly the form
           setFormOpen(false);
           enqueueSnackbar(
             'Wine collection is minting ... it will be ready on next block, wait for the confirmation message before minting another collection',
             { variant: 'info' }
           );

           await op.confirmation(2);

           enqueueSnackbar('Wine collection minted', { variant: 'success' });

           refreshUserContextOnPageReload(); //force all app to refresh the context
         }
       } catch (error) {
         console.table(`Error: ${JSON.stringify(error, null, 2)}`);
         let tibe: TransactionInvalidBeaconError =
           new TransactionInvalidBeaconError(error);
         enqueueSnackbar(tibe.data_message, {
           variant: 'error',
           autoHideDuration: 10000,
         });
       }
     };

     const [formOpen, setFormOpen] = useState<boolean>(false);

     const toggleDrawer =
       (open: boolean) => (event: React.KeyboardEvent | React.MouseEvent) => {
         if (
           event.type === 'keydown' &&
           ((event as React.KeyboardEvent).key === 'Tab' ||
             (event as React.KeyboardEvent).key === 'Shift')
         ) {
           return;
         }
         setFormOpen(open);
       };

     const isTablet = useMediaQuery('(min-width:600px)');

     return (
       <Paper>
         {storage ? (
           <Button
             disabled={
               storage.extension.administrators.indexOf(
                 userAddress! as address
               ) < 0
             }
             sx={{
               p: 1,
               position: 'absolute',
               right: '0',
               display: formOpen ? 'none' : 'block',
               zIndex: 1,
             }}
             onClick={toggleDrawer(!formOpen)}
           >
             {' Mint Form ' +
               (storage!.extension.administrators.indexOf(
                 userAddress! as address
               ) < 0
                 ? ' (You are not admin)'
                 : '')}
             <OpenWithIcon />
           </Button>
         ) : (
           ''
         )}

         <SwipeableDrawer
           onClose={toggleDrawer(false)}
           onOpen={toggleDrawer(true)}
           anchor="right"
           open={formOpen}
           variant="temporary"
         >
           <Toolbar
             sx={
               isTablet
                 ? { marginTop: '0', marginRight: '0' }
                 : { marginTop: '35px', marginRight: '125px' }
             }
           />
           <Box
             sx={{
               width: isTablet ? '40vw' : '60vw',
               borderColor: 'text.secondary',
               borderStyle: 'solid',
               borderWidth: '1px',

               height: 'calc(100vh - 64px)',
             }}
           >
             <Button
               sx={{
                 position: 'absolute',
                 right: '0',
                 display: !formOpen ? 'none' : 'block',
               }}
               onClick={toggleDrawer(!formOpen)}
             >
               <Close />
             </Button>
             <form onSubmit={formik.handleSubmit}>
               <Stack spacing={2} margin={2} alignContent={'center'}>
                 <Typography variant="h5">Mint a new collection</Typography>

                 <TextField
                   id="standard-basic"
                   name="token_id"
                   label="token_id"
                   value={formik.values.token_id}
                   disabled
                   variant="filled"
                 />
                 <TextField
                   id="standard-basic"
                   name="name"
                   label="name"
                   required
                   value={formik.values.name}
                   onChange={formik.handleChange}
                   error={formik.touched.name && Boolean(formik.errors.name)}
                   helperText={formik.touched.name && formik.errors.name}
                   variant="filled"
                 />
                 <TextField
                   id="standard-basic"
                   name="symbol"
                   label="symbol"
                   required
                   value={formik.values.symbol}
                   onChange={formik.handleChange}
                   error={
                     formik.touched.symbol && Boolean(formik.errors.symbol)
                   }
                   helperText={formik.touched.symbol && formik.errors.symbol}
                   variant="filled"
                 />
                 <TextField
                   id="standard-basic"
                   name="description"
                   label="description"
                   required
                   multiline
                   minRows={2}
                   value={formik.values.description}
                   onChange={formik.handleChange}
                   error={
                     formik.touched.description &&
                     Boolean(formik.errors.description)
                   }
                   helperText={
                     formik.touched.description && formik.errors.description
                   }
                   variant="filled"
                 />

                 <TextField
                   type="number"
                   id="standard-basic"
                   name="quantity"
                   label="quantity"
                   required
                   value={formik.values.quantity}
                   onChange={formik.handleChange}
                   error={
                     formik.touched.quantity && Boolean(formik.errors.quantity)
                   }
                   helperText={
                     formik.touched.quantity && formik.errors.quantity
                   }
                   variant="filled"
                 />

                 {pictureUrl ? (
                   <img height={100} width={100} src={pictureUrl} />
                 ) : (
                   ''
                 )}
                 <Button variant="contained" component="label" color="primary">
                   <AddCircleOutlined />
                   Upload an image
                   <input
                     type="file"
                     hidden
                     name="data"
                     onChange={(e: React.ChangeEvent<HTMLInputElement>) => {
                       const data = e.target.files ? e.target.files[0] : null;
                       if (data) {
                         setFile(data);
                       }
                       e.preventDefault();
                     }}
                   />
                 </Button>

                 <Button variant="contained" type="submit">
                   Mint
                 </Button>
               </Stack>
             </form>
           </Box>
         </SwipeableDrawer>

         <Typography variant="h5">Mint your wine collection</Typography>

         {nftContratTokenMetadataMap.size != 0 ? (
           <Box sx={{ width: '70vw' }}>
             <SwipeableViews
               axis="x"
               index={activeStep}
               onChangeIndex={handleStepChange}
               enableMouseEvents
             >
               {Array.from(nftContratTokenMetadataMap!.entries()).map(
                 ([token_id, token]) => (
                   <Card
                     sx={{
                       display: 'block',
                       maxWidth: '80vw',
                       overflow: 'hidden',
                     }}
                     key={token_id.toString()}
                   >
                     <CardHeader
                       titleTypographyProps={
                         isTablet ? { fontSize: '1.5em' } : { fontSize: '1em' }
                       }
                       title={token.name}
                     />

                     <CardMedia
                       sx={
                         isTablet
                           ? {
                               width: 'auto',
                               marginLeft: '33%',
                               maxHeight: '50vh',
                             }
                           : { width: '100%', maxHeight: '40vh' }
                       }
                       component="img"
                       image={token.thumbnailUri?.replace(
                         'ipfs://',
                         'https://gateway.pinata.cloud/ipfs/'
                       )}
                     />

                     <CardContent>
                       <Box>
                         <Typography>{'ID : ' + token_id}</Typography>
                         <Typography>{'Symbol : ' + token.symbol}</Typography>
                         <Typography>
                           {'Description : ' + token.description}
                         </Typography>
                       </Box>
                     </CardContent>
                   </Card>
                 )
               )}
             </SwipeableViews>
             <MobileStepper
               variant="text"
               steps={Array.from(nftContratTokenMetadataMap!.entries()).length}
               position="static"
               activeStep={activeStep}
               nextButton={
                 <Button
                   size="small"
                   onClick={handleNext}
                   disabled={
                     activeStep ===
                     Array.from(nftContratTokenMetadataMap!.entries()).length -
                       1
                   }
                 >
                   Next
                   <KeyboardArrowRight />
                 </Button>
               }
               backButton={
                 <Button
                   size="small"
                   onClick={handleBack}
                   disabled={activeStep === 0}
                 >
                   <KeyboardArrowLeft />
                   Back
                 </Button>
               }
             />
           </Box>
         ) : (
           <Typography sx={{ py: '2em' }} variant="h4">
             Sorry, there is not NFT yet, you need to mint bottles first
           </Typography>
         )}
       </Paper>
     );
   }
   ```

4. Replace the content of the `src/OffersPage.tsx` file with this code:

   ```typescript
   import { InfoOutlined } from '@mui/icons-material';
   import SellIcon from '@mui/icons-material/Sell';
   import * as api from '@tzkt/sdk-api';

   import {
     Box,
     Button,
     Card,
     CardActions,
     CardContent,
     CardHeader,
     CardMedia,
     ImageList,
     InputAdornment,
     Pagination,
     TextField,
     Tooltip,
     Typography,
     useMediaQuery,
   } from '@mui/material';
   import Paper from '@mui/material/Paper';
   import BigNumber from 'bignumber.js';
   import { useFormik } from 'formik';
   import { useSnackbar } from 'notistack';
   import React, { Fragment, useEffect, useState } from 'react';
   import * as yup from 'yup';
   import { UserContext, UserContextType } from './App';
   import ConnectButton from './ConnectWallet';
   import { TransactionInvalidBeaconError } from './TransactionInvalidBeaconError';
   import { address, nat } from './type-aliases';

   const itemPerPage: number = 6;

   const validationSchema = yup.object({
     price: yup
       .number()
       .required('Price is required')
       .positive('ERROR: The number must be greater than 0!'),
     quantity: yup
       .number()
       .required('Quantity is required')
       .positive('ERROR: The number must be greater than 0!'),
   });

   type Offer = {
     price: nat;
     quantity: nat;
   };

   export default function OffersPage() {
     api.defaults.baseUrl = 'https://api.ghostnet.tzkt.io';

     const [selectedTokenId, setSelectedTokenId] = React.useState<number>(0);
     const [currentPageIndex, setCurrentPageIndex] = useState<number>(1);

     let [offersTokenIDMap, setOffersTokenIDMap] = React.useState<
       Map<number, Offer>
     >(new Map());
     let [ledgerTokenIDMap, setLedgerTokenIDMap] = React.useState<
       Map<number, nat>
     >(new Map());

     const {
       nftContrat,
       nftContratTokenMetadataMap,
       userAddress,
       storage,
       refreshUserContextOnPageReload,
       Tezos,
       setUserAddress,
       setUserBalance,
       wallet,
     } = React.useContext(UserContext) as UserContextType;

     const { enqueueSnackbar } = useSnackbar();

     const formik = useFormik({
       initialValues: {
         price: 0,
         quantity: 1,
       },
       validationSchema: validationSchema,
       onSubmit: (values) => {
         console.log('onSubmit: (values)', values, selectedTokenId);
         sell(selectedTokenId, values.quantity, values.price);
       },
     });

     const initPage = async () => {
       if (storage) {
         console.log('context is not empty, init page now');
         ledgerTokenIDMap = new Map();
         offersTokenIDMap = new Map();

         const ledgerBigMapId = (
           storage.ledger as unknown as { id: BigNumber }
         ).id.toNumber();

         const owner_token_ids = await api.bigMapsGetKeys(ledgerBigMapId, {
           micheline: 'Json',
           active: true,
         });

         await Promise.all(
           owner_token_ids.map(async (owner_token_idKey) => {
             const key: { address: string; nat: string } =
               owner_token_idKey.key;

             if (key.address === userAddress) {
               const ownerBalance = await storage.ledger.get({
                 0: userAddress as address,
                 1: BigNumber(key.nat) as nat,
               });
               if (ownerBalance.toNumber() !== 0)
                 ledgerTokenIDMap.set(Number(key.nat), ownerBalance);
               const ownerOffers = await storage.extension.offers.get({
                 0: userAddress as address,
                 1: BigNumber(key.nat) as nat,
               });
               if (ownerOffers && ownerOffers.quantity.toNumber() !== 0)
                 offersTokenIDMap.set(Number(key.nat), ownerOffers);

               console.log(
                 'found for ' +
                   key.address +
                   ' on token_id ' +
                   key.nat +
                   ' with balance ' +
                   ownerBalance
               );
             } else {
               console.log('skip to next owner');
             }
           })
         );
         setLedgerTokenIDMap(new Map(ledgerTokenIDMap)); //force refresh
         setOffersTokenIDMap(new Map(offersTokenIDMap)); //force refresh

         console.log('ledgerTokenIDMap', ledgerTokenIDMap);
       } else {
         console.log('context is empty, wait for parent and retry ...');
       }
     };

     useEffect(() => {
       (async () => {
         console.log('after a storage changed');
         await initPage();
       })();
     }, [storage]);

     useEffect(() => {
       (async () => {
         console.log('on Page init');
         await initPage();
       })();
     }, []);

     const sell = async (token_id: number, quantity: number, price: number) => {
       try {
         const op = await nftContrat?.methods
           .sell(
             BigNumber(token_id) as nat,
             BigNumber(quantity) as nat,
             BigNumber(price * 1000000) as nat //to mutez
           )
           .send();

         await op?.confirmation(2);

         enqueueSnackbar(
           'Wine collection (token_id=' +
             token_id +
             ') offer for ' +
             quantity +
             ' units at price of ' +
             price +
             ' XTZ',
           { variant: 'success' }
         );

         refreshUserContextOnPageReload(); //force all app to refresh the context
       } catch (error) {
         console.table(`Error: ${JSON.stringify(error, null, 2)}`);
         let tibe: TransactionInvalidBeaconError =
           new TransactionInvalidBeaconError(error);
         enqueueSnackbar(tibe.data_message, {
           variant: 'error',
           autoHideDuration: 10000,
         });
       }
     };

     const isDesktop = useMediaQuery('(min-width:1100px)');
     const isTablet = useMediaQuery('(min-width:600px)');

     return (
       <Paper>
         <Typography style={{ paddingBottom: '10px' }} variant="h5">
           Sell my bottles
         </Typography>
         {ledgerTokenIDMap && ledgerTokenIDMap.size != 0 ? (
           <Fragment>
             <Pagination
               page={currentPageIndex}
               onChange={(_, value) => setCurrentPageIndex(value)}
               count={Math.ceil(
                 Array.from(ledgerTokenIDMap.entries()).length / itemPerPage
               )}
               showFirstButton
               showLastButton
             />

             <ImageList
               cols={
                 isDesktop ? itemPerPage / 2 : isTablet ? itemPerPage / 3 : 1
               }
             >
               {Array.from(ledgerTokenIDMap.entries())
                 .filter((_, index) =>
                   index >= currentPageIndex * itemPerPage - itemPerPage &&
                   index < currentPageIndex * itemPerPage
                     ? true
                     : false
                 )
                 .map(([token_id, balance]) => (
                   <Card key={token_id + '-' + token_id.toString()}>
                     <CardHeader
                       avatar={
                         <Tooltip
                           title={
                             <Box>
                               <Typography>
                                 {' '}
                                 {'ID : ' + token_id.toString()}{' '}
                               </Typography>
                               <Typography>
                                 {'Description : ' +
                                   nftContratTokenMetadataMap.get(
                                     token_id.toString()
                                   )?.description}
                               </Typography>
                             </Box>
                           }
                         >
                           <InfoOutlined />
                         </Tooltip>
                       }
                       title={
                         nftContratTokenMetadataMap.get(token_id.toString())
                           ?.name
                       }
                     />
                     <CardMedia
                       sx={{ width: 'auto', marginLeft: '33%' }}
                       component="img"
                       height="100px"
                       image={nftContratTokenMetadataMap
                         .get(token_id.toString())
                         ?.thumbnailUri?.replace(
                           'ipfs://',
                           'https://gateway.pinata.cloud/ipfs/'
                         )}
                     />

                     <CardContent>
                       <Box>
                         <Typography variant="body2">
                           {'Owned : ' + balance.toNumber()}
                         </Typography>
                         <Typography variant="body2">
                           {offersTokenIDMap.get(token_id)
                             ? 'Traded : ' +
                               offersTokenIDMap.get(token_id)?.quantity +
                               ' (price : ' +
                               offersTokenIDMap
                                 .get(token_id)
                                 ?.price.dividedBy(1000000) +
                               ' Tz/b)'
                             : ''}
                         </Typography>
                       </Box>
                     </CardContent>

                     <CardActions>
                       {!userAddress ? (
                         <Box marginLeft="5vw">
                           <ConnectButton
                             Tezos={Tezos}
                             nftContratTokenMetadataMap={
                               nftContratTokenMetadataMap
                             }
                             setUserAddress={setUserAddress}
                             setUserBalance={setUserBalance}
                             wallet={wallet}
                           />
                         </Box>
                       ) : (
                         <form
                           style={{ width: '100%' }}
                           onSubmit={(values) => {
                             setSelectedTokenId(token_id);
                             formik.handleSubmit(values);
                           }}
                         >
                           <span>
                             <TextField
                               type="number"
                               sx={{ width: '40%' }}
                               name="price"
                               label="price/bottle"
                               placeholder="Enter a price"
                               variant="filled"
                               value={formik.values.price}
                               onChange={formik.handleChange}
                               error={
                                 formik.touched.price &&
                                 Boolean(formik.errors.price)
                               }
                               helperText={
                                 formik.touched.price && formik.errors.price
                               }
                             />
                             <TextField
                               sx={{
                                 width: '60%',
                                 bottom: 0,
                                 position: 'relative',
                               }}
                               type="number"
                               label="quantity"
                               name="quantity"
                               placeholder="Enter a quantity"
                               variant="filled"
                               value={formik.values.quantity}
                               onChange={formik.handleChange}
                               error={
                                 formik.touched.quantity &&
                                 Boolean(formik.errors.quantity)
                               }
                               helperText={
                                 formik.touched.quantity &&
                                 formik.errors.quantity
                               }
                               InputProps={{
                                 inputProps: {
                                   min: 0,
                                   max: balance.toNumber(),
                                 },
                                 endAdornment: (
                                   <InputAdornment position="end">
                                     <Button
                                       type="submit"
                                       aria-label="add to favorites"
                                     >
                                       <SellIcon /> Sell
                                     </Button>
                                   </InputAdornment>
                                 ),
                               }}
                             />
                           </span>
                         </form>
                       )}
                     </CardActions>
                   </Card>
                 ))}{' '}
             </ImageList>
           </Fragment>
         ) : (
           <Typography sx={{ py: '2em' }} variant="h4">
             Sorry, you don't own any bottles, buy or mint some first
           </Typography>
         )}
       </Paper>
     );
   }
   ```

5. Replace the content of the `src/WineCataloguePage.tsx` file with this code:

   ```typescript
   import { InfoOutlined } from '@mui/icons-material';
   import ShoppingCartIcon from '@mui/icons-material/ShoppingCart';
   import {
     Box,
     Button,
     Card,
     CardActions,
     CardContent,
     CardHeader,
     CardMedia,
     ImageList,
     InputAdornment,
     Pagination,
     TextField,
     Tooltip,
     useMediaQuery,
   } from '@mui/material';
   import Paper from '@mui/material/Paper';
   import Typography from '@mui/material/Typography';

   import BigNumber from 'bignumber.js';
   import { useFormik } from 'formik';
   import { useSnackbar } from 'notistack';
   import React, { Fragment, useState } from 'react';
   import * as yup from 'yup';
   import { UserContext, UserContextType } from './App';
   import ConnectButton from './ConnectWallet';
   import { TransactionInvalidBeaconError } from './TransactionInvalidBeaconError';
   import { address, nat } from './type-aliases';

   const itemPerPage: number = 6;

   type OfferEntry = [{ 0: address; 1: nat }, Offer];

   type Offer = {
     price: nat;
     quantity: nat;
   };

   const validationSchema = yup.object({
     quantity: yup
       .number()
       .required('Quantity is required')
       .positive('ERROR: The number must be greater than 0!'),
   });

   export default function WineCataloguePage() {
     const {
       Tezos,
       nftContratTokenMetadataMap,
       setUserAddress,
       setUserBalance,
       wallet,
       userAddress,
       nftContrat,
       refreshUserContextOnPageReload,
       storage,
     } = React.useContext(UserContext) as UserContextType;
     const [selectedOfferEntry, setSelectedOfferEntry] =
       React.useState<OfferEntry | null>(null);

     const formik = useFormik({
       initialValues: {
         quantity: 1,
       },
       validationSchema: validationSchema,
       onSubmit: (values) => {
         console.log('onSubmit: (values)', values, selectedOfferEntry);
         buy(values.quantity, selectedOfferEntry!);
       },
     });
     const { enqueueSnackbar } = useSnackbar();
     const [currentPageIndex, setCurrentPageIndex] = useState<number>(1);

     const buy = async (quantity: number, selectedOfferEntry: OfferEntry) => {
       try {
         const op = await nftContrat?.methods
           .buy(
             selectedOfferEntry[0][1],
             BigNumber(quantity) as nat,
             selectedOfferEntry[0][0]
           )
           .send({
             amount: quantity * selectedOfferEntry[1].price.toNumber(),
             mutez: true,
           });

         await op?.confirmation(2);

         enqueueSnackbar(
           'Bought ' +
             quantity +
             ' unit of Wine collection (token_id:' +
             selectedOfferEntry[0][1] +
             ')',
           {
             variant: 'success',
           }
         );

         refreshUserContextOnPageReload(); //force all app to refresh the context
       } catch (error) {
         console.table(`Error: ${JSON.stringify(error, null, 2)}`);
         let tibe: TransactionInvalidBeaconError =
           new TransactionInvalidBeaconError(error);
         enqueueSnackbar(tibe.data_message, {
           variant: 'error',
           autoHideDuration: 10000,
         });
       }
     };
     const isDesktop = useMediaQuery('(min-width:1100px)');
     const isTablet = useMediaQuery('(min-width:600px)');
     return (
       <Paper>
         <Typography style={{ paddingBottom: '10px' }} variant="h5">
           Wine catalogue
         </Typography>

         {storage?.extension.offers && storage?.extension.offers.size != 0 ? (
           <Fragment>
             <Pagination
               page={currentPageIndex}
               onChange={(_, value) => setCurrentPageIndex(value)}
               count={Math.ceil(
                 Array.from(storage?.extension.offers.entries()).filter(
                   ([_, offer]) => offer.quantity.isGreaterThan(0)
                 ).length / itemPerPage
               )}
               showFirstButton
               showLastButton
             />
             <ImageList
               cols={
                 isDesktop ? itemPerPage / 2 : isTablet ? itemPerPage / 3 : 1
               }
             >
               {Array.from(storage?.extension.offers.entries())
                 .filter(([_, offer]) => offer.quantity.isGreaterThan(0))
                 .filter((_, index) =>
                   index >= currentPageIndex * itemPerPage - itemPerPage &&
                   index < currentPageIndex * itemPerPage
                     ? true
                     : false
                 )
                 .map(([key, offer]) => (
                   <Card key={key[0] + '-' + key[1].toString()}>
                     <CardHeader
                       avatar={
                         <Tooltip
                           title={
                             <Box>
                               <Typography>
                                 {' '}
                                 {'ID : ' + key[1].toString()}{' '}
                               </Typography>
                               <Typography>
                                 {'Description : ' +
                                   nftContratTokenMetadataMap.get(
                                     key[1].toString()
                                   )?.description}
                               </Typography>
                               <Typography>{'Seller : ' + key[0]} </Typography>
                             </Box>
                           }
                         >
                           <InfoOutlined />
                         </Tooltip>
                       }
                       title={
                         nftContratTokenMetadataMap.get(key[1].toString())?.name
                       }
                     />
                     <CardMedia
                       sx={{ width: 'auto', marginLeft: '33%' }}
                       component="img"
                       height="100px"
                       image={nftContratTokenMetadataMap
                         .get(key[1].toString())
                         ?.thumbnailUri?.replace(
                           'ipfs://',
                           'https://gateway.pinata.cloud/ipfs/'
                         )}
                     />

                     <CardContent>
                       <Box>
                         <Typography variant="body2">
                           {' '}
                           {'Price : ' +
                             offer.price.dividedBy(1000000) +
                             ' XTZ/bottle'}
                         </Typography>
                         <Typography variant="body2">
                           {'Available units : ' + offer.quantity}
                         </Typography>
                       </Box>
                     </CardContent>

                     <CardActions>
                       {!userAddress ? (
                         <Box marginLeft="5vw">
                           <ConnectButton
                             Tezos={Tezos}
                             nftContratTokenMetadataMap={
                               nftContratTokenMetadataMap
                             }
                             setUserAddress={setUserAddress}
                             setUserBalance={setUserBalance}
                             wallet={wallet}
                           />
                         </Box>
                       ) : (
                         <form
                           style={{ width: '100%' }}
                           onSubmit={(values) => {
                             setSelectedOfferEntry([key, offer]);
                             formik.handleSubmit(values);
                           }}
                         >
                           <TextField
                             type="number"
                             sx={{ bottom: 0, position: 'relative' }}
                             fullWidth
                             name="quantity"
                             label="quantity"
                             placeholder="Enter a quantity"
                             variant="filled"
                             value={formik.values.quantity}
                             onChange={formik.handleChange}
                             error={
                               formik.touched.quantity &&
                               Boolean(formik.errors.quantity)
                             }
                             helperText={
                               formik.touched.quantity && formik.errors.quantity
                             }
                             InputProps={{
                               inputProps: { min: 0, max: offer.quantity },
                               endAdornment: (
                                 <InputAdornment position="end">
                                   <Button
                                     type="submit"
                                     aria-label="add to favorites"
                                   >
                                     <ShoppingCartIcon /> BUY
                                   </Button>
                                 </InputAdornment>
                               ),
                             }}
                           />
                         </form>
                       )}
                     </CardActions>
                   </Card>
                 ))}
             </ImageList>
           </Fragment>
         ) : (
           <Typography sx={{ py: '2em' }} variant="h4">
             Sorry, there is not NFT to buy yet, you need to mint or sell
             bottles first
           </Typography>
         )}
       </Paper>
     );
   }
   ```

## Working with the completed application

Now you can create, buy, and sell bottles of wine as in the applications in the previous parts.
For example, if you connect an administrator account you can create types of wine with quantities and offer them for sale.
Then you can connect a different account and buy bottles from the available different types, as in this picture:

![Buying bottles from the available different types](/img/tutorials/nft-marketplace-4-buy.png)

## Summary

Now you can create token collections from the different templates that are available in the `@ligo/fa` library, including NFTs, single-asset tokens, and multi-asset tokens.
You can create web applications that manage token transactions and show information about tokens.

For the complete content of the contract and web app at the end of the tutorial, see the completed part 4 app at https://github.com/marigold-dev/training-nft-4.

If you want to continue with the application, you can extend the contract or application.
Here are some ideas:

* Create an online marketplace for a different kind of token, like flowers, candy, or cars
* Change how tokens behave, like sending a royalty to the marketplace as a sales fee when they are transferred
* Add error checking for the application to prevent it from sending invalid transactions
* Add new features to the marketplace, such as a shopping cart that lets people buy more than one kind of bottle at a time


# Learn and play with security

# Security

Web3 or the decentralized web introduces a new set of security challenges while reducing risks and enforcing security on the other side.

Users can interact directly with the blockchain network without any third-party protection because the paradigm is now READ-WRITE-OWN. No one is responsible for guarding your keys or seed phrase and protecting you against scams.

On the other hand, cryptography, especially hashing, ensures that the data is never altered or removed without agreement from the supporting network. Clients do not have to trust a centralized provider; implicit trust is built into the blockchain.

### Off-chain attacks

Off-chain attacks are a serious threat to the security and reliability of decentralized applications. They can exploit various vulnerabilities in the design, implementation, or deployment of smart contracts or user interfaces. Some examples of off-chain attacks are:

* Bugs: A bug is a flaw or error in the code or logic of a smart contract or a frontend. For instance, a frontend may point to a non-existent smart contract address or invoke an entrypoint with incorrect parameters. This can result in loss of funds, incorrect execution, or denial of service. Bugs can be avoided by proper testing, auditing, and maintenance of the code.
* Impersonation: An impersonation attack is when an attacker pretends to be someone else, such as a legitimate service provider, a trusted party, or a user. For example, an attacker may create a phishing UI that mimics the appearance and functionality of a real frontend, but sends the user's funds or data to the attacker's address. Alternatively, an attacker may deploy a copy of a contract on the network, with slight modifications that benefit the attacker. Impersonation attacks can be prevented by verifying the identity and authenticity of the parties involved, such as using digital signatures, checksums, or domain verification.
* Replay attacks: A replay attack is when an attacker reuses a valid transaction from one context to another, without the consent or knowledge of the original sender. For example, an attacker may copy a L1 transaction to a L2 transaction, and execute it on a different chain or layer. This can result in double-spending, unauthorized actions, or inconsistent states. Replay attacks can be mitigated by introducing nonce and chain_id fields in the transactions, which ensure that each transaction is unique and valid for a specific context. Alternatively, a timestamp can be used as a nonce, which makes it easy to detect outdated or replayed transactions.
* Trusting and no verifying: This situation occurs when a user or a contract blindly accepts or relies on data or information from an off-chain source without verifying its accuracy or integrity. For example, a user may trust an off-chain API that provides market data from an oracle or an exchange without checking if the data is correct, manipulated, or even inexistent. Similarly, a user may sign a transaction payload from a wallet without inspecting its content or destination. Trust and no verification can lead to false assumptions, incorrect decisions, or malicious actions. Trust and no verification can be avoided by applying the principle of "trust but verify," which means that any off-chain data or information should be validated by multiple sources, cross-checked with on-chain data, or confirmed by the user before using it.
* FrontRunning and MEV (Maximum Extractable Value): MEV is an economic phenomenon that can be exploited by miners, validators, and sequencers who can arbitrarily include, exclude, or re-order transactions within the blocks they produce. MEV strategies involve executing a set of on-chain interactions prepared by off-chain actors like humans or bots.
  It can be done by the baker itself because the list is known in advance at each period, or by any bots listening to the gossip network.
  Examples of common MEV strategies:

  * Sandwiching: When a large order is spotted on mempool, the attacker buys before and sells the tokens after. The large transaction will raise the price of the token. If you buy before the price increases and sell after the price increases, you earn the difference. If you cannot reorder the transaction yourself like a baker does, you will have to put higher gas, which is called PGA or Priority Gas Auctions.

  * Front running: Bakers and sequencers can simulate any transaction extracted from the mempool and look at the wallet increase of balance. If it is an arbitrage opportunity, then the attacker can decide to copy and place his own transaction before the others.

  * Arbitrage: Arbitrage is the process of buying and selling the same assets across different markets to capitalize on price discrepancies between them. It is not even considered a hack as it is the job of common traders and regulate the global market price

  → **SOLUTION**: Against MEV, there are a few solutions:

  * Reordering of transactions can be tackled through honest bakers or using Flashbots/Flashbake. Flashbake is proposing a private, off-chain system to send a transaction to a baker. It benefits the Tezos network and its users in a few ways: less mempool congestion and quicker inclusion of not publicly visible transactions.
  * Place an encrypted order, and reveal/execute it later time, or use a feature of Tezos named TimeLock. The goal is the same: hide the transaction until the last moment so no one can place an order ahead of it. This requires a smart contract to handle this kind of order and keep track of previous data to be able to execute the transaction. Anterior currency pairs history values in the context of a swap, for example.

### On-chain attacks

This training session will cover the topic of on-chain attacks, which are cyberattacks that target the blockchain network and its components. On-chain attacks can exploit various types of vulnerabilities, such as:

* Programming errors that affect the security and functionality of smart contracts, which are self-executing agreements that run on the blockchain. Smart contracts can have a larger attack surface than traditional applications, as they interact with other contracts and users on the network and so are subject to higher interest from hackers in draining funds.
* Different kinds of leaks:
  * Replay attacks: These occur when an attacker intercepts and retransmits a valid transaction on a different blockchain network, causing the same transaction to be executed twice.
  * Memory overflow: This happens when a smart contract runs out of memory or enters an unexpected context, allowing attackers to exploit a part of the code.
  * Re-entrancy attacks: These are a type of recursive call vulnerability that allows an attacker to repeatedly call a function within a smart contract before the previous call is finished, resulting in multiple withdrawals or transfers of funds.
* Blockchain user trust and management:
  * Administrators: These are the entities that have the highest level of authority and control over the contract. They can perform actions such as deploying, upgrading, pausing, or terminating the contract.
  * Lambda / mutable code: This refers to the parts of the contract code that can be changed after deployment, such as parameters, variables, or functions.
  * Checking roles: This is the process of verifying whether a user has the right to execute a certain part of the code, such as calling a function or modifying a state variable.
  * Trustable oracles: These are the external sources of data that your contract relies on, such as prices, events, or outcomes.

In this training session, we will use a hands-on approach to learn how to identify, prevent, and mitigate on-chain attacks. We will work with sample code that contains several bugs and vulnerabilities and we will try to fix them step by step. We will also discuss best practices and recommendations for developing secure and reliable smart contracts and blockchain applications.

## Prerequisites

In the next sections, some code needs to be executed. [Taqueria requires to be installed on your machine](https://taqueria.io/docs/getting-started/installation/).

To compile the code, run these commands:

```bash
npm i
TAQ_LIGO_IMAGE=ligolang/ligo:1.1.0 taq compile <MY_CONTRACT_FILE>.jsligo
```

> Alternative: You can use the Ligo compiler directly and it can be installed [here](https://ligolang.org/docs/intro/installation/?lang=jsligo)
> You will have to compile the parameters and the storage yourself. Instead of using the taq command, use this one :
>
> ```bash
> ligo compile contract ./contracts/<MY_CONTRACT_FILE>.jsligo
> ```

***

When you're ready, go to [Part 1: Programming errors](/tutorials/security/part-1)


# Part 1: Programming errors

> Note: clone this [project](https://github.com/marigold-dev/training-security-1.git) for compiling and testing this tutorial.

Programming errors in web3 are mistakes or bugs that occur when writing smart contracts.

## Bugs

Writing Michelson code requires careful attention to detail and rigorous testing. If the code contains errors or inconsistencies, it may result in a failed transaction that consumes gas and storage fees. Therefore, it is advisable to use high-level languages that compile to Michelson, such as LIGO, and to verify the generated code before deploying it on the node.

For example, LIGO uses the Option type to safely work with values that may or may not exist.
If you subtract two tez or mutez variables, the result may be a negative number, which is not valid for the tez and mutez types.
For this reason, LIGO requires you to wrap the result in an Option type, even if you are confident that the result is a positive number, as in this example:

```jsligo
option<tez> = 2mutez - 1mutez;
```

In the source code `.contracts/1-bugs.jsligo`, we have also a subtraction returning an optional value:

```jsligo
    match(store - delta) {
```

Compile the code and watch the generated Michelson code:

```bash
taq init
taq compile 1-bugs.jsligo
more ./artifacts/1-bugs.tz
```

Line 6 of the compiled Michelson uses the `SUB_MUTEZ` instruction to subtract the two values.
Next, it uses the `IF_NONE` instruction to check whether the subtraction instruction returned a result.
If it did, it returns the number.
LIGO returns a compilation error if you forget to manage the optional value and try to use the result directly.

Run the code for the decrement of 0 by 1. 0 is the default value of the storage in the **1-bugs.storageList.jsligo** file. 1 is the parameter passed on the simulation in the **1-bugs.parameterList.jsligo** file.

```bash
taq simulate 1-bugs.tz --param 1-bugs.parameter.default_parameter.tz
```

All goes well; if there is an error on the subtraction, it is caught and returns an unchanged value.

Modify directly the Michelson file **./artifacts/1-bugs.tz** to not check the diff, as in the following code. Using **SUB** will not do specific checks for mutez and will not wrap it into an optional value.

```michelson
{ parameter (or (unit %reset) (or (mutez %decrement) (mutez %increment))) ;
  storage mutez ;
  code { UNPAIR ;
         IF_LEFT
           { DROP 2 ; PUSH mutez 0 }
           { IF_LEFT {  SWAP ; SUB  } { ADD } } ;
         NIL operation ;
         PAIR } }
```

Run it again:

```bash
taq simulate 1-bugs.tz --param 1-bugs.parameter.default_parameter.tz
```

This time the operation returns an error:

```logs
Underflowing subtraction of 0 tez and 0.000001 tez
```

In this way, using the LIGO compiler instead of coding Michelson directly helps you avoid problems.

→ **SOLUTION**: Use the LIGO compiler to prevent runtime errors.

## Rounding issues

Michelson does not support floating point numbers, so rounding issues after division can happen if it is not done carefully. This can cause a smart contract to halt in some situations.

Let's take an example of the division of 101 by 4. In the file `2-rounding.jsligo` we have 2 users who would like to redeem the contract balance, with the user Alice receiving 3/4 and user Bob receiving 1/4. The contract calculates Alice's amount as the total minus 1/4 and Bob's amount as the total minus 3/4. Due to rounding, the total amount to withdraw from the contract can exceed the contract balance.

Run the following code:

```bash
taq compile 2-rounding.jsligo
taq simulate 2-rounding.tz --param 2-rounding.parameter.default_parameter.tz
```

It will fail because the result is negative. Alice will have 101-25=76 and Bob 101-(3*25)=26, so the total to redeem is 102, which is greater than the initial 101.

```logs
script reached FAILWITH instruction
with "It is a failure !!!"
```

→ **SOLUTION**: Change the way to do the operation to not be influenced by the rounding effect. Calculate the first value and use the rest for the second user.

Change the line for bob from this code:

```jsligo
const bob = s - (3n * quotient);
```

To this code:

```jsligo
const bob = s - alice;
```

Recompile and run the code:

```bash
taq compile 2-rounding.jsligo
taq simulate 2-rounding.tz --param 2-rounding.parameter.default_parameter.tz
```

All good now. =)

## Unsecure bitwise operations

A bitwise operation is a type of computation that operates on the individual bits of a binary number. A bitwise shift moves the bits of the operand to the left or right by a certain number of positions, filling the vacated bits with zeros.

However, there is a caveat: if the shift amount is too large, it can cause an overflow, which means that some bits are lost or added beyond the expected size of the input. This can lead to unexpected results or errors in the execution of the contract in Michelson.

Run our two examples shifting to left and right:

```bash
taq compile 3-bitwise.jsligo
taq simulate 3-bitwise.tz --param 3-bitwise.parameter.shiftLeftOneNat.tz
taq simulate 3-bitwise.tz --param 3-bitwise.parameter.shiftRight257times.tz
```

* The first example shifts 2n (0x0010) one time to the left, so it gives 4n (0x0100)
* The second example shifts 2n (0x0010) 257 times to the right. Because the limit is 256 shifts, it produces the error `unexpected arithmetic overflow`.

→ **SOLUTION**: To avoid this, check the size of the input and the shift amount before applying the bitwise instructions. Here you should check if the number of shifts is less than or equal to 256; otherwise, you raise an error.

## Sender vs Source confusion

When a transaction is sent by a user, it can create other transactions on other smart contracts. Depending on the transaction, the address that initiated the original transaction (the *source*) could be different from the direct sender of the additional transactions (the *sender*).

```mermaid
sequenceDiagram
  Note left of User: I am the source of tx1 and tx2
  User->>SmartContract1: transaction tx1
  Note right of SmartContract1: I am the sender of tx2
  SmartContract1->>SmartContract2: transaction tx2
```

In this example, transaction tx2 on SmartContract2 has:

* The **User** as the source
* The **SmartContract1** as the sender

**Man-in-the-middle attack**: The victim contract is checking the source `Tezos.get_source()` to give access to an endpoint. If we have a phishing contract in the middle, it can call the endpoint while appearing to be the authorized caller. In this case, it can even grab some money in addition to the malicious action.

Run the following test:

```bash
taq test 4-manInTheMiddleTest.jsligo
```

```logs
"Successfully hacked the victim and grab it money !!!"
🎉 All tests passed 🎉
```

→ **SOLUTION**: Fix the code on the file `4-manInTheMiddleVictim.jsligo`, replacing `Tezos.get_source()` by `Tezos.get_sender()`.

Run it again:

```bash
taq test 4-manInTheMiddleTest.jsligo
```

```logs
Failwith: "You are not the admin to do this action"
Trace:
File "contracts/4-manInTheMiddleTest.jsligo", line 51, character 2 to line 59, character 3 ,
File "contracts/4-manInTheMiddleTest.jsligo", line 51, character 2 to line 59, character 3 ,
File "contracts/4-manInTheMiddleTest.jsligo", line 69, characters 17-24

===
┌─────────────────────────────┬──────────────────────┐
│ Contract │ Test Results │
├─────────────────────────────┼──────────────────────┤
│ 4-manInTheMiddleTest.jsligo │ Some tests failed :( │
└─────────────────────────────┴──────────────────────┘
```

> Note: On some specific cases it is important to authorize an intermediary contract to communicate with our contract. We should not always check the source as the default behavior for rejection

## Library updates

This is a DevOps issue. If a continuous integration pipeline recompiles the code before deploying a new version and there are dependencies to fetch, it's possible that the new behavior will not be compatible with your code logic and bring new security flaws.

→ **SOLUTION**: Do more unit tests and publish CI test reports.

## Private data

One of the most important security considerations for smart contract developers is to avoid storing any sensitive or confidential information on the contract storage. This is because the contract storage is public and immutable, meaning that anyone can read its contents and those contents cannot be erased or modified. Therefore, any secret value, such as a private key, a password, or a personal identification number, should never be stored on the contract storage. Doing so exposes the secret value to potential attackers and compromises the security and privacy of the contract and its users.

→ **SOLUTION**: Instead, secret values should be stored off-chain, such as in a secure database or a hardware wallet, and only communicated to the contract when necessary using encryption with the commit-reveal pattern or zero-knowledge proofs.

## Predictable information used as a random value

Due to the deterministic nature of blockchain execution, it is not possible to generate random numbers or values within a smart contract. This means that any logic that relies on randomness, such as games, lotteries, or auctions, cannot be implemented securely and fairly on a blockchain. Therefore, smart contract developers need to find alternative ways to introduce randomness into their applications, such as using external sources of randomness (oracles) or cryptographic techniques (commit-reveal schemes).

→ **SOLUTION**:

* Use block timestamp: This approach has a low cost but also a high risk of being compromised, as the time parameter is too coarse and can be easily estimated based on the average block time.
* Use contract origination address: This approach has a low cost but also a high risk of being compromised, because it is composed of the hash of the operation concatenated with an origination index.
* Multi-participant random seed: One possible way to generate a multi-participant random seed is to ask each participant to submit a random number in a secure and verifiable way. This can be done using a commit-reveal scheme, where each participant first commits to their number by sending a hash of it and then reveals it later by sending the actual number. The hash function ensures that the participants cannot change their numbers after committing, and the reveal phase allows everyone to verify that the numbers match the hashes. The final seed can be computed by combining all the revealed numbers using some deterministic function, such as XOR or modular addition.
  However, this method has some drawbacks, such as requiring two rounds of communication and being vulnerable to a locked situation, where some participants do not reveal their numbers and prevent the seed from being generated. To avoid this, there should be some incentive mechanism or timeout mechanism to ensure that everyone reveals their numbers in time, or else they are penalized or excluded from the seed generation.
* Good randomness oracle: Creating a good off-chain random Oracle is not easy, as it requires a way to prove that the numbers are indeed random and not manipulated by anyone. One possible solution is to use a verifiable random function (VRF), which is a cryptographic algorithm that generates a random output from an input and a secret key. It produces a proof that the output was correctly computed. The proof can be verified by anyone who knows the input and the public key, but not the secret key. Chainlink is a decentralized network of Oracles that offers a VRF-based randomness Oracle for smart contracts. It claims to be one of the few, if not the only reasonably good available randomness oracle on the market. However, it has some limitations, such as being only compatible with Ethereum. Moreover, it still relies on the trustworthiness of a third party, namely the Chainlink node operators that hold the secret keys and generate the random numbers and proofs.

## Blocked state

One of the possible scenarios in a blockchain smart contract is to have a blocked state where the contract execution is paused until a certain condition is met. For example, a contract that implements a simple escrow service might have a blocked state where the seller has to confirm the delivery of the goods before the buyer can release the payment. This way, the contract ensures that both parties are satisfied with the transaction and no one can cheat or withdraw from the agreement.

Another example is in the tutorial [Create a mobile game](/tutorials/mobile). The contract in this tutorial is blocked while the players make their decisions. However, if one of the players does not reveal their choice within 10 minutes, the other player can claim a resolution and win the game by calling an entrypoint on the contract. This way, the contract is not stuck indefinitely and the honest player is rewarded.

→ **SOLUTION**:

* Define clear and objective rules for entering and exiting the blocked state, as well as for handling exceptions and disputes.
* Use timeouts or deadlines to limit the duration of the blocked state and avoid indefinite waiting or deadlock situations.
* Implement incentives or penalties to encourage or discourage certain behaviors or actions by the participants during the blocked state.
* Provide feedback and notifications to the participants about the status and progress of the contract during the blocked state.
* Use external oracles or trusted third parties to verify or arbitrate the condition that triggers the blocked state, if necessary.

***

Go to [Part 2: Leaks](/tutorials/security/part-2).


# Part 2: Leaks

> Note: clone this [project](https://github.com/marigold-dev/training-security-2.git) for compiling and testing this tutorial.

## Replay attack

A replay attack on a smart contract is a type of security vulnerability that allows an attacker to reuse a signed valid transaction multiple times. We saw in the previous part how to do off-chain replay attacks, but it is also possible to do on-chain replay attacks.
Even though Tezos prevents this kind of attack, you can try it by sending the same operation several times.

Compile and simulate the replay attack:

```bash
taq init
taq compile 1-replay.jsligo
taq simulate 1-replay.tz --param=1-replay.parameter.parameter.tz
```

The simulation will tell you that several internal transactions will be executed.
But if you deploy the code and try to execute it, it throws an error:

```bash
taq deploy 1-replay.tz --mutez 1000 -e testing

taq transfer KT1VMt7t4CboRP6jYBUdBQowHb4NR1UtmDrz -e testing
```

Tezos detect the flaw and returns this error:

```logs
  "message": "(transaction) proto.017-PtNairob.internal_operation_replay"
```

## Memory overflow

Memory overflow is a kind of attack that overloads the memory of a smart contract resulting in making this contract unusable. Even simply loading the data into memory and deserializing it at the beginning of the call could use so much gas that any call to the contract would fail. All the funds would be forever locked into the contract.

Here is the list of dangerous types to use carefully:

* Integers and nats: they can be increased to an arbitrarily large value
* Strings: they have no limit on their lengths
* Lists, sets, maps: they can contain an arbitrary number of items

→ **SOLUTION**:

* Ask the user to pay a minimum tez for each call
* Set a threshold limit
* Store data in a big_map
* Avoid unnecessary on-chain computation that can be done off-chain. For example, do not loop on-chain; instead, update a part of a map

Example with the current FA1.2 implementation: https://inference.ag/blog/2023-10-09-FA12_spenders/

You can have a look at the LIGO implementation of FA1.2 on the LIGO registry [here](https://packages.ligolang.org/package/ligo_fa1.2)

The code follows the standard but you can see that the [Allowance type is a map](https://github.com/frankhillard/ligoFA12/blob/main/lib/asset/allowance.mligo#L3C8-L3C8). It would have been better to change the standard and use a `big_map` instead of a `map`. If you implement the standard differently, then your smart contract storage definition and entrypoint signatures will not match anymore and will not be supported by other platforms.

## Re-entrancy

These attacks allow an attacker to repeatedly call a contract function in a way that drains the contract’s resources, leading to a denial of service (DoS) attack.

One of the most well-known examples of a re-entrancy attack occurred in 2016 when an attacker exploited a vulnerability in the DAO (Decentralized Autonomous Organization) contract on the Ethereum blockchain. But this popular hack is still actively used:

* Uniswap/Lendf.Me hacks (April 2020) – $25 mln, attacked by a hacker using a re-entrancy.
* The BurgerSwap hack (May 2021) – $7.2 mln, because of a fake token contract and a re-entrancy exploit.
* The SURGEBNB hack (August 2021) – $4 mln, seems to be a re-entrancy-based price manipulation attack.
* CREAM FINANCE hack (August 2021) – $18.8 mln, re-entrancy vulnerability allowed the exploiter for the second borrow.
* Siren protocol hack (September 2021) – $3.5 mln, AMM pools were exploited through re-entrancy attack.

This kind of attack is quite simple to put in place with Solidity because of the way it works.

Consider this scenario:

```mermaid
sequenceDiagram
  User->>MaliciousContract: deposit funds
  MaliciousContract->>LedgerContract: deposit funds
  User->>MaliciousContract: call withdraw
  MaliciousContract->>LedgerContract: call withdraw
  Note right of LedgerContract: checkBalance
  Note right of LedgerContract: sendFunds
  LedgerContract->>MaliciousContract: sendFunds operation
  Note right of MaliciousContract: loop calling withdraw ... x times
  MaliciousContract->>LedgerContract: call withdraw
  LedgerContract->>MaliciousContract: sendFunds operation  ... x times
  Note right of LedgerContract: ... Once finish ... UpdateBalance
```

Why is this scenario possible on Solidity?
In Solidity, when a smart contract calls another smart contract, that operation runs immediately and synchronously.
The original smart contract pauses, the other smart contract runs, and then the original smart contract resumes.
If someone calls the original smart contract multiple times very quickly, they can generate multiple operations before the original smart contract updates its state.
In the example in the previous diagram, a user may be able to run many withdraw operations and drain more than the developer expected.

Why is this scenario not possible on Tezos?
The transaction mempool queue is processed in sequence.
When a transaction is processed and involves another smart contract call, the new operation is pushed on the queue and is executed after the current operation ends and updates its state.

Let's implement a more complex scenario where the OfferContract and LedgerContract are separated. The OfferContract will naively send the money back to MaliciousContract because it relies on the **not yet modified** state of the LedgerContract. There are two operations and the modification of the state will come in second position.

```mermaid
sequenceDiagram
  User->>MaliciousContract: deposit cookies
  MaliciousContract->>LedgerContract: deposit cookies
  User->>MaliciousContract: sell cookies
  MaliciousContract->>OfferContract: sell cookies
  Note right of OfferContract: checkBalance
  OfferContract->>LedgerContract: call hasCookies view
  Note right of OfferContract: prepare post operations (sendFund + changeOwner)
  OfferContract->>MaliciousContract: sendFund
  Note right of MaliciousContract: while receiving fund on default entrypoint will loop on selling cookies
  MaliciousContract->>OfferContract: sell cookies
  Note right of OfferContract: checkBalance
  OfferContract->>LedgerContract: call hasCookies view
  Note right of OfferContract: prepare post operations (sendFund + changeOwner)
  OfferContract->>MaliciousContract: sendFund
  MaliciousContract->>OfferContract: sell cookies
  Note right of OfferContract: checkBalance
  OfferContract->>LedgerContract: call hasCookies view
  Note right of OfferContract: prepare post operations (sendFund + changeOwner)
  OfferContract->>MaliciousContract: sendFund
  OfferContract->>LedgerContract: call changeOwner
```

The issue here is clearly that we send money without updating the state first.

→ **SOLUTION**:

* Mutex safeguard: To prevent the contract from generating multiple internal operations, we can add a Mutual Exclusive semaphore Boolean named `isRunning` that is true when an operation is running. This variable locks the contract while the full transaction flow runs.

  1. Check the isRunning is false
  2. Set isRunning to true
  3. Do logic code ...
  4. Create a last operation transaction to reset the boolean to false

* Check-and-send pattern: Principle of separating state changes from external contract interactions. First, update the contract’s state, then interact with other contracts.

Compile and run the hack test first:

```bash
taq test 3-reentrancyTest.jsligo
```

The logs seem to be fine, but it is hard to guess the internal transactions and to separate the fees from the hack on the attacker's balance.

```logs
┌─────────────────────────┬─────────────────────────────────────────────┐
│ Contract                │ Test Results                                │
├─────────────────────────┼─────────────────────────────────────────────┤
│ 3-reentrancyTest.jsligo │ "ledgerContract"                            │
│                         │ KT1LQyTHEZeaecRj7hWgkzPEBD6vMEKXYzoo(None)  │
│                         │ "offerContract"                             │
│                         │ KT1M4nPCej4va4Q2iMPX2FKt8xLw5cfGjBv9(None)  │
│                         │ "maliciousContract"                         │
│                         │ KT1B7RgF6j7UpAybpdfxhLCp7hf41pNFcxyS(None)  │
│                         │ "admin initialize cookies to malicious KT1" │
│                         │ Success (1299n)                             │
│                         │ "COOKIES OWNERS"                            │
│                         │ {KT1B7RgF6j7UpAybpdfxhLCp7hf41pNFcxyS}      │
│                         │ "BALANCE OF SENDER"                         │
│                         │ 3799985579750mutez                          │
│                         │ Success (1798n)                             │
│                         │ "AFTER RUN - BALANCE OF SENDER"             │
│                         │ 3799984579749mutez                          │
│                         │ {KT1LQyTHEZeaecRj7hWgkzPEBD6vMEKXYzoo}      │
│                         │ "END RUN - BALANCE OF SENDER"               │
│                         │ 3799984579749mutez                          │
│                         │ {KT1LQyTHEZeaecRj7hWgkzPEBD6vMEKXYzoo}      │
│                         │ Everything at the top-level was executed.   │
│                         │ - testReentrancy exited with value true.    │
│                         │                                             │
│                         │ 🎉 All tests passed 🎉                      │
└─────────────────────────┴─────────────────────────────────────────────┘
```

To have a better visualization of the hack, the contract should be deployed.

Compile the first contract, the Ledger contract, and deploy it:

```bash
taq compile 3-reentrancyLedgerContract.jsligo
taq deploy 3-reentrancyLedgerContract.tz -e testing
```

Copy the contract address, in my case `KT1BJZfhC459WqCVJzPmu3vJSWFFkvyi9k1u`, and paste it in the file `3-reentrancyOfferContract.storageList.jsligo`.

Compile and deploy the second contract, the Offer contract, putting some money on the contract for the thieves:

```bash
taq compile 3-reentrancyOfferContract.jsligo
taq deploy 3-reentrancyOfferContract.tz -e testing --mutez 10000000
```

Copy the contract address, in my case `KT1CHJgXEdBPktNNPGTDaL8XEAzJV9fjSkrZ`, and paste it in the file `3-reentrancyMaliciousContract.storageList.jsligo`.

Compile and deploy the last contract, the Malicious contract which will loop and steal the funds of the Offer contract:

```bash
taq compile 3-reentrancyMaliciousContract.jsligo
taq deploy 3-reentrancyMaliciousContract.tz -e testing
```

Copy the contract address, in my case `KT1NKLZE9HkGJxjopowLqxA4pswutgMrrXyE`, and initialize the Ledger contract as the Malicious contract as some cookies on its storage. Paste the value in the file `3-reentrancyLedgerContract.parameterList.jsligo`.

When you are done, compile the Ledger contracts and call them with this parameter:

```bash
taq compile 3-reentrancyLedgerContract.jsligo
taq call 3-reentrancyLedgerContract --param 3-reentrancyLedgerContract.parameter.default_parameter.tz -e testing
```

Context is ready:

* The Malicious contract has cookies on the Ledger contract
* All deployed contract points to the correct addresses

Now the Malicious contract will try to steal funds from the Offer contract. Run the command to start the attack on the transaction flow:

```bash
octez-client transfer 0 from alice to KT1NKLZE9HkGJxjopowLqxA4pswutgMrrXyE --entrypoint attack --arg 'Unit' --burn-cap 1
```

Here you can see the result on the Ghostnet: https://ghostnet.tzkt.io/KT1NKLZE9HkGJxjopowLqxA4pswutgMrrXyE/operations/

3 refunds will be emitted instead of one.

→ **SOLUTION**: On the `3-reentrancyOfferContract.jsligo` file, line 34, swap the order of operation execution from this:

```jsligo
return [list([opTx, opChangeOwner]), s];
```

to this:

```jsligo
return [list([opChangeOwner,opTx]), s];
```

Then rerun the scenario from scratch redeploying the contracts. It should be impossible to run the attack, because the transaction will fail with this message:

```logs
"message":"user do not have cookies"
```

* Authorize withdraw transfer only to a user account: Because the user wallet cannot do callback loops, it solves the issue but this solution is not always feasible and limiting. To check if an address is a user account, verify that the sender and source are equal.

* Audit External Contract calls: This is very hard to check, for example on withdrawal for a token transfer, any contract can receive funds.

* Call third-party security experts or employ automated security tools: If you are not sure about your code, they will identify weaknesses and validate the contract’s security measures.

## Overflow

Manipulating arithmetic operations can lead to overflows and underflows.

* On Solidity: SafeMath is a library in Solidity that was designed to provide safe mathematical operations. It prevents overflow and underflow errors when working with unsigned integers (uint), which can lead to unexpected behavior in smart contracts. However, since Solidity v0.8.0, this library has been made obsolete as the language itself starts to include internal checking.

* On LIGO: For the nat, int, and timestamp types, the Michelson interpreter uses arbitrary-precision arithmetic provided by the [OCaml Zarith library](https://github.com/ocaml/Zarith). This means that their size is only limited by gas or storage limits. You can store huge numbers in a contract without reaching the limit. However, in LIGO, an overflow will cause the contract to fail.

→ **SOLUTION**:

* For large tez values, do operations with int or nat types, which have larger memory values.
* There is no other solution than using types with larger values because the default behavior is to reject the transaction in case of overflow.

> Do not confuse the OCaml Zarith library with the [Ligo MathLib library](https://packages.ligolang.org/package/@ligo/math-lib), which provides manipulation of floats and rationals instead of using basic types.

Go to [Part 3: User trust & management](/tutorials/security/part-3).


# Part 3: User trust & management

## Governance

A decentralized system is not enough to ensure the security and efficiency of a blockchain network. It also requires a robust governance model that can handle conflicts, upgrades, and innovations. Moreover, the distribution of the native token that powers the network should be fair and balanced, avoiding the concentration of power and wealth among a few actors. If these conditions are not met, the decentralized system may suffer from instability, stagnation, or manipulation. Therefore, it is important to design and implement a governance model and a token distribution strategy that aligns with the goals and values of the network and its users.

One of the challenges of designing and deploying a smart contract is to define the roles and permissions of the different parties involved in the execution of the contract. The question is who can do what?

* Who can create, modify, or terminate the contract?
  * Creation: A smart contract is generally deployed by a DevOps person or a CI pipeline. Apart from knowing the creator's address and the fees they paid, there is no critical event that can appear at this moment. The only hack here would be to impersonate another company's smart contract, as discussed in the introduction of this training.
  * Update: By design, a smart contract code cannot be modified because it is immutable. However, lambdas are an exception, as described in the next section.
  * Deletion: By design, a smart contract cannot be deleted because the code is stored on a block forever and can be called/executed at any time. The only way to terminate a smart contract would be to programmatically have a boolean to enable/disable all entrypoints.
* Who can invoke, monitor, or verify the contract functions?
  * Invocation: This depends on the role-based access set on each entrypoints. By default, all annotated `@entry` functions are exposed and are callable.
    → **SOLUTION**: Be very careful about who has the right to call each of your entrypoints. One of the best practices for writing secure and reliable code is to always check the validity and trustworthiness of the inputs and outputs of your functions. This means that you should **verify either the sender or the source** every time at the beginning of your function to act as a guard against malicious or erroneous data.
    [Look here for another way of doing RBAC with Tezos tickets](https://github.com/marigold-dev/training-dapp-3).
  * Monitoring: Anyone can do this. The most famous ones are indexers, but there is no professional alerting system so far.
  * Verification: By design, everyone can verify the code. Sometimes the code is audited and a report is available.
    → **SOLUTION**: Read the audit if available or verify the code yourself. However, the code deployed is in Michelson and the reverse engineering is not easy. Tools are missing for how to reverse engineer contracts; nevertheless if the contract is TZIP16-compliant it can refer to the LIGO source code, so you can recompile and compare the outputs.
* Who can resolve disputes or enforce penalties in case of contract violations?
  If the contract itself does not contain a function to resolve it, no resolution can happen on-chain.
  → **SOLUTION**: Use on-chain dispute if available, or off-chain dispute but this latter introduces additional complexities such as Know Your Customer (KYC) regulations and legal considerations. KYC regulations require businesses to verify the identity of their clients. This can be difficult in the context of blockchain transactions, which are often pseudonymous. Legal considerations can also be complex, especially in cross-border transactions where different jurisdictions may have different laws.

## Lambda, mutable code, and dynamic entrypoints

A smart contract is immutable but not the storage that represents the mutable state.
A common way to change the behavior of a smart contract is to store some mutable code inside its storage and then execute it from the smart contract itself.

This feature presents a **high risk and breaks the trust** you can have in the execution of the contract. If the governance is not clear and transparent, an administrator can potentially push any function and drain your funds from this contract. It is recommended to read carefully the code to see which kind of action can be done through this lambda. A lambda can access the contract's state and call other functions.
For example, if the lambda is called in a function to update a static data configuration that has few impacts, then it is not necessarily dangerous. But if the lambda can create an operation that can be executed or is returning false information to fool the user over a transaction, then it is a red flag.

> Other techniques exist to update a dApp, like the proxy pattern. It does not change the code of the smart contract, but deployed a new version of it and a proxy contract will redirect the user transaction to this new contract. The risk is located on the proxy contract. If this contract is hacked and badly protected, anyone can deploy a malicious contract and redirect to it.

For an example of upgrading smart contracts with lambdas and proxies, see [Create your minimum dapp on Tezos](/tutorials/dapp).

## (Trustable) oracles

Blockchain oracles are third-party services that provide smart contracts with external information. They serve as bridges between blockchains and the outside world, allowing smart contracts to access off-chain data. Oracles verify, query, and authenticate external data sources, and transmit any valuable data.

An [Oracle](/smart-contracts/oracles) is made of two parts:

* Off-chain: The data collector that pushes data to the on-chain contract
* On-chain: The contract that stores the data and exposes it to other contracts. Generally, a call for information involves monetization and so, some fees apply.

Who controls the oracle?
A single company or person may control the oracle. In this case, they can manipulate the data, be hacked, or the service can go down and block the full flow of execution.

→ **SOLUTION**:

* Use many decentralized oracles:
  * More actors equals less centralized power and prevents collusion.
  * Using several oracles prevents a single oracle from affecting the volatility. Using the average of several sources is better than relying on only one source, especially on CEX/DEX with few volumes.
* Always use oracles that provide timestamps: data should have a validity date associated, otherwise it is almost impossible to apply to correct data and verify afterward.

There are some providers on the market claiming to have decentralized Oracles or ZK execution:

* [Chainlink](https://chain.link/whitepaper)
* [Acurast](https://docs.acurast.com/acurast-protocol/architecture/architecture/)


# Create a mobile game

![home](/img/tutorials/mobile-picHOME.png)

Web3 mobile gaming is a new era of decentralized, blockchain-based gaming that promises to revolutionize the industry. It combines gaming with the unique features of blockchain technology, such as secure and transparent transactions, digital asset ownership, and decentralized governance. In Web3 gaming, players can enjoy a wide range of gaming experiences and participate in the creation, management, and monetization of these games through the use of cryptocurrencies, non-fungible tokens (NFTs), and decentralized autonomous organizations (DAOs).

Web3 gaming is still in its early stages, but it has the potential to transform the gaming industry and create new opportunities for gamers and developers alike.
There are two categories of web3 gaming dapp:

* The ones including web3 parts like NFT or fungible tokens but represent generally less than 25% of the application
* The ones which are 100% onchain, like on this tutorial, where all the logic is coded inside the smart contract

You will learn:

* How to import a Ligo smart contract library containing the game logic.
* How to create a mobile app with Ionic.
* How to integrate the taquito library to connect a wallet.
* How to develop the UI and interact with your smart contract.
* How to build and deploy your game to the Android store.

## Prerequisites

This tutorial uses TypeScript, so it will be easier if you are familiar with JavaScript.

1. Make sure that you have installed these tools:

   * [Node.JS and NPM](https://nodejs.org/en/download/): NPM is required to install the web application's dependencies. (currently using v18.15.0 on the solution)
   * [Taqueria](https://taqueria.io/), version 0.46.0 or later: Taqueria is a platform that makes it easier to develop and test dApps.
   * [Docker](https://docs.docker.com/engine/install/): Docker is required to run Taqueria.
   * [jq](https://stedolan.github.io/jq/download/): Some commands use the `jq` program to extract JSON data.
   * [`yarn`](https://yarnpkg.com/): The frontend application uses yarn to build and run (see this article for details about [differences between `npm` and `yarn`](https://www.geeksforgeeks.org/difference-between-npm-and-yarn/)).
   * Any Tezos-compatible wallet that supports Ghostnet, such as [Temple wallet](https://templewallet.com/).

2. Optionally, you can install [`VS Code`](https://code.visualstudio.com/download) to edit your application code in and the [LIGO VS Code extension](https://marketplace.visualstudio.com/items?itemName=ligolang-publish.ligo-vscode) for LIGO editing features such as code highlighting and completion.
   Taqueria also provides a [Taqueria VS Code extension](https://marketplace.visualstudio.com/items?itemName=ecadlabs.taqueria-vscode) that helps visualize your project and run tasks.

## The tutorial game

Shifumi or Rock paper scissors (also known by other orderings of the three items, with "rock" sometimes being called "stone," or as Rochambeau, roshambo, or ro-sham-bo) is a hand game originating from China, usually played between two people, in which each player simultaneously forms one of three shapes with an outstretched hand.

These shapes are "rock" (a closed fist), "paper" (a flat hand), and "scissors" (a fist with the index finger and middle finger extended, forming a V). "Scissors" is identical to the two-fingered V sign (also indicating "victory" or "peace") except that it is pointed horizontally instead of being held upright in the air.

[Wikipedia link](https://en.wikipedia.org/wiki/Rock_paper_scissors)

The application can be downloaded on [the Android store here](https://play.google.com/store/apps/details?id=dev.marigold.shifumi)

The code for the completed application is in this GitHub repository: [solution](https://github.com/marigold-dev/training-dapp-shifumi/tree/main/solution)

When you're ready, move to the next section [Part 1: Create the smart contract](/tutorials/mobile/part-1) to begin setting up the application.


# Part 1: Create the smart contract

On this first section, you will:

* Create the game smart contract importing an existing LIGO library
* Deploy your smart contract to the Ghostnet
* Get the Shifumi Git repository folders to copy the game UI and CSS for the second party

## Smart contract

1. Clone the repository and start a new Taqueria project:

   ```bash
   git clone https://github.com/marigold-dev/training-dapp-shifumi.git
   taq init shifumi
   cd shifumi
   taq install @taqueria/plugin-ligo
   ```

2. Download the LIGO Shifumi template, and copy the files to Taqueria **contracts** folder:

   ```bash
   TAQ_LIGO_IMAGE=ligolang/ligo:1.2.0 taq ligo --command "init contract --template shifumi-jsligo shifumiTemplate"
   cp -r shifumiTemplate/src/* contracts/
   ```

3. Compile the contract. It creates the default required file `main.storageList.jsligo`:

   ```bash
   TAQ_LIGO_IMAGE=ligolang/ligo:1.2.0 taq compile main.jsligo
   ```

4. Edit `main.storageList.jsligo` initial storage and save it:

   ```jsligo
   #import "main.jsligo" "Contract"

   const default_storage: Contract.storage = {
       metadata: Big_map.literal(
           list(
               [
                   ["", bytes `tezos-storage:contents`],
                   [
                       "contents",
                       bytes
                       `
       {
       "name": "Shifumi Example",
       "description": "An Example Shifumi Contract",
       "version": "beta",
       "license": {
           "name": "MIT"
       },
       "authors": [
           "smart-chain <tezos@smart-chain.fr>"
       ],
       "homepage": "https://github.com/ligolang/shifumi-jsligo",
       "source": {
           "tools": "jsligo",
           "location": "https://github.com/ligolang/shifumi-jsligo/contracts"
       },
       "interfaces": [
           "TZIP-016"
       ]
       }
       `
                   ]
               ]
           )
       ) as big_map<string, bytes>,
       next_session: 0 as nat,
       sessions: Map.empty as map<nat, Contract.Session.t>,
   }
   ```

5. Compile again:

   ```bash
   TAQ_LIGO_IMAGE=ligolang/ligo:1.2.0 taq compile main.jsligo
   ```

6. Deploy to Ghostnet:

   ```bash
   taq install @taqueria/plugin-taquito
   taq deploy main.tz -e "testing"
   ```

   > Note: If this is your first time using Taqueria, look at this training first: <https://github.com/marigold-dev/training-dapp-1#ghostnet-testnet>
   >
   > For advanced users, just go to `.taq/config.local.testing.json` , replace account with alice settings and then redeploy
   >
   > ```json
   > {
   >   "networkName": "ghostnet",
   >   "accounts": {
   >     "taqOperatorAccount": {
   >       "publicKey": "edpkvGfYw3LyB1UcCahKQk4rF2tvbMUk8GFiTuMjL75uGXrpvKXhjn",
   >       "publicKeyHash": "tz1VSUr8wwNhLAzempoch5d6hLRiTh8Cjcjb",
   >       "privateKey": "edsk3QoqBuvdamxouPhin7swCvkQNgq4jP5KZPbwWNnwdZpSpJiEbq"
   >     }
   >   }
   > }
   > ```

   Your smart contract is ready on Ghostnet!

   ```logs
   ┌──────────┬──────────────────────────────────────┬───────┐
   │ Contract │ Address                              │ Alias │
   ├──────────┼──────────────────────────────────────┼───────┤
   │ main.tz  │ KT1QjiZcAq63yVSCkfAr9zcFvmKBhQ7nVSWd │ main  │
   └──────────┴──────────────────────────────────────┴───────┘
   ```

## Summary

That's all for the smart contract. On the next section, you will create the mobile application and connect to your smart contract

When you are ready, continue to [Part 2: Create an Ionic mobile application](/tutorials/mobile/part-2).


# Part 2: Create an Ionic mobile application

A web3 mobile application is not different from a web2 one in terms of its basic functionality and user interface. Both types of applications can run on smartphones, tablets, and other mobile devices, and both can access the internet and provide various services to users. However, a web3 mobile application differs from a web2 one in terms of its underlying architecture and design principles. A web3 mobile application is built on decentralized technologies, such as blockchain, smart contracts, and peer-to-peer networks, that enable more transparency, security, and autonomy for users and developers.

## Create the Mobile app

[Ionic React](https://ionicframework.com/docs/react) is a good hybrid solution for creating mobile applications and compatible with the Typescript version of the [BeaconSDK](https://github.com/airgap-it/beacon-sdk). The behavior is equivalent to a classical web development, so for a web developer the ramp up is easy.

> Beacon: the protocol of communication between the dapp and the wallet.

> Note: As of today, it is not recommended to develop a native dApp in Flutter, React Native or native tools as it requires additional UI works (ex: missing wallet popup mechanism to confirm transactions).

1. Install Ionic:

   ```bash
   npm install -g @ionic/cli
   ionic start app blank --type react
   ```

2. Generate smart contract types from the Taqueria plugin:

   This command generates Typescript classes from the smart contract interface definition that is used on the frontend.

   ```bash
   taq install @taqueria/plugin-contract-types
   taq generate types ./app/src
   ```

3. Uninstall the conflicting old jest libraries/react-scripts and install the required Tezos web3 dependencies and Vite framework:

   ```bash
   cd app
   npm uninstall -S @testing-library/jest-dom @testing-library/react @testing-library/user-event @types/jest
   rm -rf src/components src/pages/Home.tsx src/pages/Home.css
   rm src/setupTests.ts src/App.test.tsx
   echo '/// <reference types="vite/client" />' > src/vite-env.d.ts

   npm install -S  @taquito/taquito @taquito/beacon-wallet @airgap/beacon-sdk  @tzkt/sdk-api
   npm install -S -D @airgap/beacon-types vite @vitejs/plugin-react-swc @types/react @types/node  @types/react@18.2.42
   ```

4. Polyfill issues fix:

   > :warning: Polyfill issues fix: Add the following dependencies in order to avoid polyfill issues. The reason is that some dependencies are Node APIs and are not included in browsers.

   1. Install the missing libraries:

      ```bash
      npm i -D process buffer crypto-browserify stream-browserify assert stream-http https-browserify os-browserify url path-browserify
      ```

   2. Create a new file `nodeSpecific.ts` in the `src` folder of your project:

      ```bash
      touch src/nodeSpecific.ts
      ```

   3. Edit it to look like this:

      ```js
      import { Buffer } from 'buffer';
      globalThis.Buffer = Buffer;
      ```

   4. Edit the `vite.config.ts` file:

      ```js
      import react from '@vitejs/plugin-react-swc';
      import path from 'path';
      import { defineConfig } from 'vite';
      // https://vitejs.dev/config/
      export default ({ command }) => {
        const isBuild = command === 'build';

        return defineConfig({
          define: { 'process.env': process.env, global: {} },
          plugins: [react()],
          build: {
            commonjsOptions: {
              transformMixedEsModules: true,
            },
          },
          resolve: {
            alias: {
              // dedupe @airgap/beacon-sdk
              // I almost have no idea why it needs `cjs` on dev and `esm` on build, but this is how it works 🤷‍♂️
              '@airgap/beacon-sdk': path.resolve(
                path.resolve(),
                `./node_modules/@airgap/beacon-sdk/dist/${
                  isBuild ? 'esm' : 'cjs'
                }/index.js`
              ),
              stream: 'stream-browserify',
              os: 'os-browserify/browser',
              util: 'util',
              process: 'process/browser',
              buffer: 'buffer',
              crypto: 'crypto-browserify',
              assert: 'assert',
              http: 'stream-http',
              https: 'https-browserify',
              url: 'url',
              path: 'path-browserify',
            },
          },
        });
      };
      ```

5. Adapt Ionic for Vite:

   1. Edit `index.html` to fix the Node buffer issue with `nodeSpecific.ts` file and point to the CSS file:

      ```html
      <!DOCTYPE html>
      <html lang="en">
        <head>
          <meta charset="utf-8" />
          <title>Ionic App</title>

          <base href="/" />

          <meta name="color-scheme" content="light dark" />
          <meta
            name="viewport"
            content="viewport-fit=cover, width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"
          />
          <meta name="format-detection" content="telephone=no" />
          <meta name="msapplication-tap-highlight" content="no" />

          <link rel="manifest" href="/manifest.json" />
          <link href="assets/styles.css" rel="stylesheet" />

          <link rel="shortcut icon" type="image/png" href="/favicon.png" />

          <!-- add to homescreen for ios -->
          <meta name="apple-mobile-web-app-capable" content="yes" />
          <meta name="apple-mobile-web-app-title" content="Ionic App" />
          <meta name="apple-mobile-web-app-status-bar-style" content="black" />
        </head>
        <body>
          <div id="root"></div>
          <script type="module" src="/src/nodeSpecific.ts"></script>
          <script type="module" src="/src/main.tsx"></script>
        </body>
      </html>
      ```

   2. Edit **src/main.tsx** to force dark mode and remove React strict mode:

      ```typescript
      import { createRoot } from 'react-dom/client';
      import App from './App';

      const container = document.getElementById('root');
      const root = createRoot(container!);

      // Add or remove the "dark" class based on if the media query matches
      document.body.classList.add('dark');

      root.render(<App />);
      ```

   3. Modify the default **package.json** default scripts to use Vite instead of the default React scripts:

      ```json
        "scripts": {
          "dev": "jq -r '\"VITE_CONTRACT_ADDRESS=\" + last(.tasks[]).output[0].address' ../.taq/testing-state.json > .env && vite --host",
          "ionic:build": "tsc -v && tsc && vite build",
          "build": " tsc -v && tsc && vite build",
          "lint": "eslint src --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
          "preview": "vite preview",
          "ionic:serve": "vite dev --host",
          "sync": "npm run build && ionic cap sync --no-build"
        },
      ```

6. Edit the default application file `src/App.tsx` to configure page routing and add the style:

   ```typescript
   import {
     IonApp,
     IonRouterOutlet,
     RefresherEventDetail,
     setupIonicReact,
   } from '@ionic/react';
   import { IonReactRouter } from '@ionic/react-router';
   import { Redirect, Route } from 'react-router-dom';

   /* Core CSS required for Ionic components to work properly */
   import '@ionic/react/css/core.css';

   /* Basic CSS for apps built with Ionic */
   import '@ionic/react/css/normalize.css';
   import '@ionic/react/css/structure.css';
   import '@ionic/react/css/typography.css';

   /* Optional CSS utils that can be commented out */
   import '@ionic/react/css/display.css';
   import '@ionic/react/css/flex-utils.css';
   import '@ionic/react/css/float-elements.css';
   import '@ionic/react/css/padding.css';
   import '@ionic/react/css/text-alignment.css';
   import '@ionic/react/css/text-transformation.css';

   /* Theme variables */
   import './theme/variables.css';

   import { NetworkType } from '@airgap/beacon-types';
   import { BeaconWallet } from '@taquito/beacon-wallet';
   import { InternalOperationResult } from '@taquito/rpc';
   import {
     PollingSubscribeProvider,
     Subscription,
     TezosToolkit,
   } from '@taquito/taquito';
   import React, { Dispatch, SetStateAction, useEffect, useState } from 'react';
   import { MainWalletType, Storage } from './main.types';
   import { HomeScreen } from './pages/HomeScreen';
   import { RulesScreen } from './pages/Rules';
   import { SessionScreen } from './pages/SessionScreen';
   import { TopPlayersScreen } from './pages/TopPlayersScreen';
   import {
     MMap,
     address,
     bytes,
     mutez,
     nat,
     timestamp,
     unit,
   } from './type-aliases';

   setupIonicReact();

   export class Action implements ActionCisor, ActionPaper, ActionStone {
     cisor?: unit;
     paper?: unit;
     stone?: unit;
     constructor(cisor?: unit, paper?: unit, stone?: unit) {
       this.cisor = cisor;
       this.paper = paper;
       this.stone = stone;
     }
   }
   export type ActionCisor = { cisor?: unit };
   export type ActionPaper = { paper?: unit };
   export type ActionStone = { stone?: unit };

   export type Session = {
     asleep: timestamp;
     board: MMap<nat, { Some: address } | null>;
     current_round: nat;
     decoded_rounds: MMap<
       nat,
       Array<{
         action: { cisor: unit } | { paper: unit } | { stone: unit };
         player: address;
       }>
     >;
     players: Array<address>;
     pool: mutez;
     result: { draw: unit } | { inplay: unit } | { winner: address };
     rounds: MMap<
       nat,
       Array<{
         action: bytes;
         player: address;
       }>
     >;
     total_rounds: nat;
   };

   export type UserContextType = {
     storage: Storage | null;
     setStorage: Dispatch<SetStateAction<Storage | null>>;
     userAddress: string;
     setUserAddress: Dispatch<SetStateAction<string>>;
     userBalance: number;
     setUserBalance: Dispatch<SetStateAction<number>>;
     Tezos: TezosToolkit;
     wallet: BeaconWallet;
     mainWalletType: MainWalletType | null;
     loading: boolean;
     setLoading: Dispatch<SetStateAction<boolean>>;
     refreshStorage: (
       event?: CustomEvent<RefresherEventDetail>
     ) => Promise<void>;
     subReveal: Subscription<InternalOperationResult> | undefined;
     subNewRound: Subscription<InternalOperationResult> | undefined;
   };
   export const UserContext = React.createContext<UserContextType | null>(null);

   const App: React.FC = () => {
     const Tezos = new TezosToolkit('https://ghostnet.tezos.marigold.dev');

     const wallet = new BeaconWallet({
       name: 'Training',
       preferredNetwork: NetworkType.GHOSTNET,
     });

     Tezos.setWalletProvider(wallet);
     Tezos.setStreamProvider(
       Tezos.getFactory(PollingSubscribeProvider)({
         shouldObservableSubscriptionRetry: true,
         pollingIntervalMilliseconds: 1500,
       })
     );

     const [userAddress, setUserAddress] = useState<string>('');
     const [userBalance, setUserBalance] = useState<number>(0);
     const [storage, setStorage] = useState<Storage | null>(null);
     const [mainWalletType, setMainWalletType] =
       useState<MainWalletType | null>(null);
     const [loading, setLoading] = useState<boolean>(false);

     const [subscriptionsDone, setSubscriptionsDone] = useState<boolean>(false);
     const [subReveal, setSubReveal] =
       useState<Subscription<InternalOperationResult>>();
     const [subNewRound, setSubNewRound] =
       useState<Subscription<InternalOperationResult>>();

     const refreshStorage = async (
       event?: CustomEvent<RefresherEventDetail>
     ): Promise<void> => {
       try {
         if (!userAddress) {
           const activeAccount = await wallet.client.getActiveAccount();
           let userAddress: string;
           if (activeAccount) {
             userAddress = activeAccount.address;
             setUserAddress(userAddress);
             const balance = await Tezos.tz.getBalance(userAddress);
             setUserBalance(balance.toNumber());
           }
         }

         console.log(
           'VITE_CONTRACT_ADDRESS:',
           import.meta.env.VITE_CONTRACT_ADDRESS
         );
         const mainWalletType: MainWalletType =
           await Tezos.wallet.at<MainWalletType>(
             import.meta.env.VITE_CONTRACT_ADDRESS
           );
         const storage: Storage = await mainWalletType.storage();
         setMainWalletType(mainWalletType);
         setStorage(storage);
         console.log('Storage refreshed');

         event?.detail.complete();
       } catch (error) {
         console.log('error refreshing storage', error);
       }
     };

     useEffect(() => {
       try {
         if (!subscriptionsDone) {
           const sub = Tezos.stream.subscribeEvent({
             tag: 'gameStatus',
             address: import.meta.env.VITE_CONTRACT_ADDRESS!,
           });

           sub.on('data', (e) => {
             console.log('on gameStatus event :', e);
             refreshStorage();
           });

           setSubReveal(
             Tezos.stream.subscribeEvent({
               tag: 'reveal',
               address: import.meta.env.VITE_CONTRACT_ADDRESS,
             })
           );

           setSubNewRound(
             Tezos.stream.subscribeEvent({
               tag: 'newRound',
               address: import.meta.env.VITE_CONTRACT_ADDRESS,
             })
           );
         } else {
           console.warn(
             'Tezos.stream.subscribeEvent already done ... ignoring'
           );
         }
       } catch (e) {
         console.log('Error with Smart contract event pooling', e);
       }

       console.log('Tezos.stream.subscribeEvent DONE');
       setSubscriptionsDone(true);
     }, []);

     useEffect(() => {
       if (userAddress) {
         console.warn('userAddress changed', wallet);
         (async () => await refreshStorage())();
       }
     }, [userAddress]);

     return (
       <IonApp>
         <UserContext.Provider
           value={{
             userAddress,
             userBalance,
             Tezos,
             wallet,
             storage,
             mainWalletType,
             setUserAddress,
             setUserBalance,
             setStorage,
             loading,
             setLoading,
             refreshStorage,
             subReveal,
             subNewRound,
           }}
         >
           <IonReactRouter>
             <IonRouterOutlet>
               <Route path={PAGES.HOME} component={HomeScreen} />
               <Route path={`${PAGES.SESSION}/:id`} component={SessionScreen} />
               <Route path={PAGES.TOPPLAYERS} component={TopPlayersScreen} />
               <Route path={PAGES.RULES} component={RulesScreen} />
               <Redirect exact from="/" to={PAGES.HOME} />
             </IonRouterOutlet>
           </IonReactRouter>
         </UserContext.Provider>
       </IonApp>
     );
   };

   export enum PAGES {
     HOME = '/home',
     SESSION = '/session',
     TOPPLAYERS = '/topplayers',
     RULES = '/rules',
   }

   export default App;
   ```

   Explanations:

   * `import "@ionic..."`: Default standard Ionic imports.
   * `import ... from "@airgap/beacon-types" ... from "@taquito/beacon-wallet" ... from "@taquito/taquito"`: Require libraries to interact with the Tezos node and the wallet.
   * `export class Action implements ActionCisor, ActionPaper, ActionStone {...}`: Representation of the LIGO variant `Action` in Typescript, which is needed when passing arguments on `Play` function.
   * `export type Session = {...}`: Taqueria exports the global storage type but not this sub-type from the storage type; it is needed for later, so extract a copy.
   * `export const UserContext = React.createContext<UserContextType | null>(null)`: Global React context that is passed along pages. More info on React context [here](https://beta.reactjs.org/learn/passing-data-deeply-with-context).
   * `const refreshStorage = async (event?: CustomEvent<RefresherEventDetail>): Promise<void> => {...`: A useful function to force the smart contract storage to refresh on React state changes (user balance, state of the game).
   * `useEffect(() => { ... Tezos.setStreamProvider(...) ... Tezos.stream.subscribeEvent({...`: During application initialization, it configures the wallet, the websocket listening to smart contract events.
   * `<IonApp><UserContext.Provider ... ><IonReactRouter><IonRouterOutlet><Route path={PAGES.HOME} component={HomeScreen} /> ... `: Injects the React context to all pages and declares the global routing of the application.
   * `export enum PAGES {  HOME = "/home", ...`: Declaration of the global routes.

7. Add the default theming (CSS, pictures, etc.) via copying the content of the git repository folder named **assets** folder to your local project (considering you cloned the repo and assets folder is on root folder).

   ```bash
   cp -r ../../assets/* .
   ```

8. Create two React Button components to connect and disconnect the wallet and add code to fetch the user public hash key and balanceL

   1. Create the 2 missing component files in the `app` folder:

      ```bash
      touch src/ConnectWallet.tsx
      touch src/DisconnectWallet.tsx
      ```

   2. In the `ConnectWallet.tsx` file, create a button that creates an instance of the wallet, gets user permissions via a popup, and retrieves account information.

      ```typescript
      import { NetworkType } from '@airgap/beacon-types';
      import { IonButton } from '@ionic/react';
      import { BeaconWallet } from '@taquito/beacon-wallet';
      import { TezosToolkit } from '@taquito/taquito';
      import { Dispatch, SetStateAction } from 'react';

      type ButtonProps = {
        Tezos: TezosToolkit;
        setUserAddress: Dispatch<SetStateAction<string>>;
        setUserBalance: Dispatch<SetStateAction<number>>;
        wallet: BeaconWallet;
      };

      const ConnectButton = ({
        Tezos,
        setUserAddress,
        setUserBalance,
        wallet,
      }: ButtonProps): JSX.Element => {
        const connectWallet = async (): Promise<void> => {
          try {
            console.log('before requestPermissions');

            await wallet.requestPermissions({
              network: {
                type: NetworkType.GHOSTNET,
                rpcUrl: 'https://ghostnet.tezos.marigold.dev',
              },
            });
            console.log('after requestPermissions');

            // gets user's address
            const userAddress = await wallet.getPKH();
            const balance = await Tezos.tz.getBalance(userAddress);
            setUserBalance(balance.toNumber());
            setUserAddress(userAddress);
          } catch (error) {
            console.log('error connectWallet', error);
          }
        };

        return (
          <IonButton expand="full" onClick={connectWallet}>
            Connect Wallet
          </IonButton>
        );
      };

      export default ConnectButton;
      ```

   3. In the `DisconnectWallet.tsx` file, create a button that cleans the wallet instance and all linked objects:

      ```typescript
      import { IonFab, IonFabButton, IonIcon } from '@ionic/react';
      import { BeaconWallet } from '@taquito/beacon-wallet';
      import { power } from 'ionicons/icons';
      import { Dispatch, SetStateAction } from 'react';

      interface ButtonProps {
        wallet: BeaconWallet;
        setUserAddress: Dispatch<SetStateAction<string>>;
        setUserBalance: Dispatch<SetStateAction<number>>;
      }

      const DisconnectButton = ({
        wallet,
        setUserAddress,
        setUserBalance,
      }: ButtonProps): JSX.Element => {
        const disconnectWallet = async (): Promise<void> => {
          setUserAddress('');
          setUserBalance(0);
          console.log('disconnecting wallet');
          await wallet.clearActiveAccount();
        };

        return (
          <IonFab slot="fixed" vertical="top" horizontal="end">
            <IonFabButton>
              <IonIcon icon={power} onClick={disconnectWallet} />
            </IonFabButton>
          </IonFab>
        );
      };

      export default DisconnectButton;
      ```

   4. Save both files.

9. Create the missing pages and the error utility class:

   ```bash
   touch src/pages/HomeScreen.tsx
   touch src/pages/SessionScreen.tsx
   touch src/pages/Rules.tsx
   touch src/pages/TopPlayersScreen.tsx
   touch src/TransactionInvalidBeaconError.ts
   ```

   The `TransactionInvalidBeaconError.ts` utility class is used to display human readable message from Beacon errors.

10. Make these updates to the files:

    * HomeScreen.tsx: the home page where you can access all other pages.

      ```typescript
      import {
        IonButton,
        IonButtons,
        IonContent,
        IonFooter,
        IonHeader,
        IonIcon,
        IonImg,
        IonInput,
        IonItem,
        IonLabel,
        IonList,
        IonModal,
        IonPage,
        IonRefresher,
        IonRefresherContent,
        IonSpinner,
        IonTitle,
        IonToolbar,
        useIonAlert,
      } from '@ionic/react';
      import { BigNumber } from 'bignumber.js';
      import { person } from 'ionicons/icons';
      import React, { useEffect, useRef, useState } from 'react';
      import { useHistory } from 'react-router-dom';
      import { PAGES, Session, UserContext, UserContextType } from '../App';
      import ConnectButton from '../ConnectWallet';
      import DisconnectButton from '../DisconnectWallet';
      import { TransactionInvalidBeaconError } from '../TransactionInvalidBeaconError';
      import Paper from '../assets/paper-logo.webp';
      import Scissor from '../assets/scissor-logo.webp';
      import Stone from '../assets/stone-logo.webp';
      import XTZLogo from '../assets/xtz.webp';
      import { SelectMembers } from '../components/TzCommunitySelectMembers';
      import { address, nat } from '../type-aliases';

      export const HomeScreen: React.FC = () => {
        const [presentAlert] = useIonAlert();
        const { push } = useHistory();

        const createGameModal = useRef<HTMLIonModalElement>(null);
        const selectGameModal = useRef<HTMLIonModalElement>(null);
        function dismissCreateGameModal() {
          console.log('dismissCreateGameModal');
          createGameModal.current?.dismiss();
        }
        function dismissSelectGameModal() {
          selectGameModal.current?.dismiss();
          const element = document.getElementById('home');
          setTimeout(() => {
            return element && element.remove();
          }, 1000); // Give a little time to properly unmount your previous page before removing the old one
        }

        const {
          Tezos,
          wallet,
          userAddress,
          userBalance,
          storage,
          mainWalletType,
          setStorage,
          setUserAddress,
          setUserBalance,
          setLoading,
          loading,
          refreshStorage,
        } = React.useContext(UserContext) as UserContextType;

        const [newPlayer, setNewPlayer] = useState<address>('' as address);
        const [total_rounds, setTotal_rounds] = useState<nat>(
          new BigNumber(1) as nat
        );
        const [myGames, setMyGames] = useState<Map<nat, Session>>();

        useEffect(() => {
          (async () => {
            if (storage) {
              const myGames = new Map(); //filtering our games
              Array.from(storage.sessions.keys()).forEach((key) => {
                const session = storage.sessions.get(key);

                if (
                  session.players.indexOf(userAddress as address) >= 0 &&
                  'inplay' in session.result
                ) {
                  myGames.set(key, session);
                }
              });
              setMyGames(myGames);
            } else {
              console.log('storage is not ready yet');
            }
          })();
        }, [storage]);

        const createSession = async (
          e: React.MouseEvent<HTMLIonButtonElement, MouseEvent>
        ) => {
          console.log('createSession');
          e.preventDefault();

          try {
            setLoading(true);
            const op = await mainWalletType?.methods
              .createSession(total_rounds, [userAddress as address, newPlayer])
              .send();
            await op?.confirmation();
            const newStorage = await mainWalletType?.storage();
            setStorage(newStorage!);
            setLoading(false);
            dismissCreateGameModal();
            setTimeout(
              () => push(PAGES.SESSION + '/' + storage?.next_session.toString()),
              500
            );
            //it was the id created
            console.log('newStorage', newStorage);
          } catch (error) {
            console.table(`Error: ${JSON.stringify(error, null, 2)}`);
            const tibe: TransactionInvalidBeaconError =
              new TransactionInvalidBeaconError(error);
            presentAlert({
              header: 'Error',
              message: tibe.data_message,
              buttons: ['Close'],
            });
            setLoading(false);
          }
          setLoading(false);
        };

        return (
          <IonPage className="container">
            <IonHeader>
              <IonToolbar>
                <IonTitle>Shifumi</IonTitle>
              </IonToolbar>
            </IonHeader>
            <IonContent fullscreen>
              <IonRefresher slot="fixed" onIonRefresh={refreshStorage}>
                <IonRefresherContent></IonRefresherContent>
              </IonRefresher>

              {loading ? (
                <div className="loading">
                  <IonItem>
                    <IonLabel>Refreshing ...</IonLabel>
                    <IonSpinner className="spinner"></IonSpinner>
                  </IonItem>
                </div>
              ) : (
                <IonList inset={true}>
                  {!userAddress ? (
                    <>
                      <div
                        style={{
                          display: 'flex',
                          flexDirection: 'row',
                          padding: '4em',
                          justifyContent: 'space-around',
                        }}
                      >
                        <IonImg src={Stone} className="logo" />
                        <IonImg src={Paper} className="logo" />
                        <IonImg src={Scissor} className="logo" />
                      </div>
                      <IonList inset={true}>
                        <ConnectButton
                          Tezos={Tezos}
                          setUserAddress={setUserAddress}
                          setUserBalance={setUserBalance}
                          wallet={wallet}
                        />
                      </IonList>
                    </>
                  ) : (
                    <IonList>
                      <IonItem style={{ padding: 0, margin: 0 }}>
                        <IonIcon icon={person} />
                        <IonLabel
                          style={{ fontSize: '0.8em', direction: 'rtl' }}
                        >
                          {userAddress}
                        </IonLabel>
                      </IonItem>
                      <IonItem style={{ padding: 0, margin: 0 }}>
                        <IonImg
                          style={{ height: 24, width: 24 }}
                          src={XTZLogo}
                        />
                        <IonLabel style={{ direction: 'rtl' }}>
                          {userBalance / 1000000}
                        </IonLabel>
                      </IonItem>

                      <div
                        style={{
                          display: 'flex',
                          flexDirection: 'row',
                          paddingTop: '10vh',
                          paddingBottom: '10vh',
                          justifyContent: 'space-around',
                          width: '100%',
                        }}
                      >
                        <IonImg src={Stone} className="logo" />
                        <IonImg src={Paper} className="logo" />
                        <IonImg src={Scissor} className="logo" />
                      </div>

                      <IonButton id="createGameModalVisible" expand="full">
                        New game
                      </IonButton>
                      <IonModal
                        ref={createGameModal}
                        trigger="createGameModalVisible"
                      >
                        <IonHeader>
                          <IonToolbar>
                            <IonButtons slot="start">
                              <IonButton
                                onClick={() => dismissCreateGameModal()}
                              >
                                Cancel
                              </IonButton>
                            </IonButtons>
                            <IonTitle>New Game</IonTitle>
                            <IonButtons slot="end">
                              <IonButton
                                strong={true}
                                onClick={(e) => createSession(e)}
                                id="createGameModal"
                              >
                                Create
                              </IonButton>
                            </IonButtons>
                          </IonToolbar>
                        </IonHeader>
                        <IonContent className="ion-padding">
                          <h2>How many total rounds ?</h2>

                          <IonItem key="total_rounds">
                            <IonLabel
                              position="stacked"
                              className="text"
                            ></IonLabel>
                            <IonInput
                              onIonChange={(str: any) => {
                                if (str.detail.value === undefined) return;
                                setTotal_rounds(
                                  new BigNumber(str.target.value) as nat
                                );
                              }}
                              value={total_rounds.toString()}
                              placeholder="total_rounds"
                              type="number"
                              label="Total Rounds"
                            />
                          </IonItem>

                          <h2>Choose your opponent player</h2>

                          <SelectMembers
                            Tezos={Tezos}
                            member={newPlayer}
                            setMember={setNewPlayer}
                          />

                          <IonItem key="newPlayer">
                            <IonInput
                              onIonChange={(str: any) => {
                                if (str.detail.value === undefined) return;
                                setNewPlayer(str.detail.value as address);
                              }}
                              labelPlacement="floating"
                              class="address"
                              value={newPlayer}
                              placeholder="...tz1"
                              type="text"
                              label="Tezos Address "
                            />
                          </IonItem>
                        </IonContent>
                      </IonModal>

                      <IonButton id="selectGameModalVisible" expand="full">
                        Join game
                      </IonButton>
                      <IonModal
                        ref={selectGameModal}
                        trigger="selectGameModalVisible"
                      >
                        <IonHeader>
                          <IonToolbar>
                            <IonButtons slot="start">
                              <IonButton
                                onClick={() => dismissSelectGameModal()}
                              >
                                Cancel
                              </IonButton>
                            </IonButtons>
                            <IonTitle>Select Game</IonTitle>
                          </IonToolbar>
                        </IonHeader>
                        <IonContent>
                          <IonList inset={true}>
                            {myGames
                              ? Array.from(myGames.entries()).map(([key, _]) => (
                                  <IonButton
                                    key={'Game-' + key.toString()}
                                    expand="full"
                                    routerLink={
                                      PAGES.SESSION + '/' + key.toString()
                                    }
                                    onClick={dismissSelectGameModal}
                                  >
                                    {'Game n°' + key.toString()}
                                  </IonButton>
                                ))
                              : []}
                          </IonList>
                        </IonContent>
                      </IonModal>

                      <IonButton routerLink={PAGES.TOPPLAYERS} expand="full">
                        Top Players
                      </IonButton>
                    </IonList>
                  )}
                </IonList>
              )}
            </IonContent>
            <IonFooter>
              <IonToolbar>
                <IonTitle>
                  <IonButton
                    color="primary"
                    routerLink={PAGES.RULES}
                    expand="full"
                  >
                    Rules
                  </IonButton>
                </IonTitle>
              </IonToolbar>
            </IonFooter>

            {userAddress ? (
              <DisconnectButton
                wallet={wallet}
                setUserAddress={setUserAddress}
                setUserBalance={setUserBalance}
              />
            ) : (
              <></>
            )}
          </IonPage>
        );
      };
      ```

      Explanation:

      * `const createGameModal`: The popup to create a new game.
      * `const selectGameModal`: The popup to select a game to join.
      * `const [newPlayer, setNewPlayer] = useState<address>("" as address)`: Used on the `New Game` popup form to add an opponent.
      * `const [total_rounds, setTotal_rounds] = useState<nat>(new BigNumber(1) as nat)`: Used on the `New Game` popup form to set number of round for one game.
      * `const [myGames, setMyGames] = useState<Map<nat, Session>>()`: Used on the `Join Game` popup window to display the games created or with invitation.
      * `Array.from(storage.sessions.keys()).forEach((key) => { ... if (session.players.indexOf(userAddress as address) >= 0 && "inplay" in session.result ...`: On storage change event, fetch and filter only games which the user can join and play (that is, with `inplay` status and where user appears on the player list).
      * `const createSession = async (...) => { ...  const op = await mainWalletType!.methods.createSession([userAddress as address, newPlayer], total_rounds).send(); ... `: This function calls the smart contract entrypoint passing these arguments: current user address, opponent address, and total rounds. Then it redirects to the newly created game page.
      * `{...<IonButton ... routerLink={PAGES.SESSION + "/" + key.toString()}`: If you click on a game button from the list it redirects you to the game to play.

    * `SessionScreen.tsx`: This page lets you play on limited rounds and shows the result of the game.

      ```typescript
      import { IonPage } from '@ionic/react';
      import React from 'react';

      export const SessionScreen: React.FC = () => {
        return <IonPage className="container"></IonPage>;
      };
      ```

      You will add more to this file later.

    * TopPlayersScreen.tsx: The player ranking page.

      ```typescript
      import { IonPage } from '@ionic/react';
      import React from 'react';

      export const TopPlayersScreen: React.FC = () => {
        return <IonPage className="container"></IonPage>;
      };
      ```

      You will add more to this file later.

    * Rules.tsx: Just some information about game rules.

      ```typescript
      import {
        IonButton,
        IonButtons,
        IonContent,
        IonHeader,
        IonImg,
        IonItem,
        IonList,
        IonPage,
        IonTitle,
        IonToolbar,
      } from '@ionic/react';
      import React from 'react';
      import { useHistory } from 'react-router-dom';
      import Clock from '../assets/clock.webp';
      import Legend from '../assets/legend.webp';
      import Paper from '../assets/paper-logo.webp';
      import Scissor from '../assets/scissor-logo.webp';
      import Stone from '../assets/stone-logo.webp';

      export const RulesScreen: React.FC = () => {
        const { goBack } = useHistory();

        /* 2. Get the param */
        return (
          <IonPage className="container">
            <IonHeader>
              <IonToolbar>
                <IonButtons slot="start">
                  <IonButton onClick={goBack}>Back</IonButton>
                </IonButtons>
                <IonTitle>Rules</IonTitle>
              </IonToolbar>
            </IonHeader>
            <IonContent fullscreen>
              <div style={{ textAlign: 'left' }}>
                <IonList>
                  <IonItem className="nopm">
                    <IonImg src={Stone} className="logo" />
                    Stone (Clenched Fist). Rock beats the scissors by hitting it
                  </IonItem>
                  <IonItem className="nopm">
                    <IonImg src={Paper} className="logo" />
                    Paper (open and extended hand) . Paper wins over stone by enveloping
                    it
                  </IonItem>
                  <IonItem className="nopm">
                    <IonImg src={Scissor} className="logo" />
                    Scissors (closed hand with the two fingers) . Scissors wins paper
                    cutting it
                  </IonItem>

                  <IonItem className="nopm">
                    <IonImg src={Clock} className="logo" />
                    If you are inactive for more than 10 minutes your opponent can
                    claim the victory
                  </IonItem>

                  <IonItem className="nopm">
                    <IonImg src={Legend} className="logo" />
                    <ul style={{ listStyle: 'none' }}>
                      <li className="win">Won round</li>
                      <li className="lose">Lost round</li>
                      <li className="draw">Draw</li>
                      <li className="current">Current Round</li>
                      <li className="missing">Missing Rounds</li>
                    </ul>
                  </IonItem>
                </IonList>
              </div>
            </IonContent>
          </IonPage>
        );
      };
      ```

    * TransactionInvalidBeaconError.ts: The utility class that formats Beacon errors.

      ```typescript
      export class TransactionInvalidBeaconError {
        name: string;
        title: string;
        message: string;
        description: string;
        data_contract_handle: string;
        data_expected_form: string;
        data_message: string;

        /**
            *
            * @param transactionInvalidBeaconError  {
            "name": "UnknownBeaconError",
            "title": "Aborted",
            "message": "[ABORTED_ERROR]:The action was aborted by the user.",
            "description": "The action was aborted by the user."
        }
        */

        constructor(transactionInvalidBeaconError: any) {
          this.name = transactionInvalidBeaconError.name;
          this.title = transactionInvalidBeaconError.title;
          this.message = transactionInvalidBeaconError.message;
          this.description = transactionInvalidBeaconError.description;
          this.data_contract_handle = '';
          this.data_expected_form = '';
          this.data_message = this.message;
          if (transactionInvalidBeaconError.data !== undefined) {
            let dataArray = Array.from<any>(
              new Map(
                Object.entries<any>(transactionInvalidBeaconError.data)
              ).values()
            );
            let contract_handle = dataArray.find(
              (obj) => obj.contract_handle !== undefined
            );
            this.data_contract_handle =
              contract_handle !== undefined
                ? contract_handle.contract_handle
                : '';
            let expected_form = dataArray.find(
              (obj) => obj.expected_form !== undefined
            );
            this.data_expected_form =
              expected_form !== undefined
                ? expected_form.expected_form +
                  ':' +
                  expected_form.wrong_expression.string
                : '';
            this.data_message =
              (this.data_contract_handle
                ? 'Error on contract: ' + this.data_contract_handle + ' '
                : '') +
              (this.data_expected_form
                ? 'error: ' + this.data_expected_form + ' '
                : '');
          }
        }
      }
      ```

11. Test the application:

    To test in web mode, run this command:

    ```bash
    npm run dev
    ```

    Make sure that your wallet is has some tez on Ghostnet and click on the **Connect** button.

    > Note: If you don't have tokens, to get some free XTZ on Ghostnet, follow this link to the [faucet](https://faucet.ghostnet.teztnets.com/).

    On the popup, select your wallet, then your account and connect.

    You are *logged*.

    Optional: Click the Disconnect button to test the logout.

## Summary

You have a mobile application where you can connect and disconnect a wallet, some default UI components and styles but not yet an interaction with your smart contract.
The next step is to be able to create a game, join a game and play a session.

When you are ready, continue to [Part 3: Create the game pages](/tutorials/mobile/part-3).


# Part 3: Create the game pages

In this section, you will create the pages to:

* Create a game: you interact with the modal `createGameModal` from the `HomeScreen.tsx` page to create a game session.
* Join a game: it redirects you to an existing game session on the `SessionScreen.tsx` page. This modal is coded on the `HomeScreen.tsx` page.
* Play a session: when you are in a game session against someone, you can play some action
  * Choose a move: Scissor, Stone, or Paper
  * Reveal your move to resolve the game round. A game session can have several rounds.
* Visualize the top player results.

## Play a game session

1. Click the `New Game` button from the home page and then create a new game.

2. Confirm the operation with your wallet.

   You are redirected the new game session page (that is blank page right now).

   > Note: you can look at the code of the modal `createGameModal` from the `HomeScreen.tsx` page to understand how it works.

3. Edit the file `./src/SessionScreen.tsx` to look like this:

   ```typescript
   import {
     IonButton,
     IonButtons,
     IonContent,
     IonFooter,
     IonHeader,
     IonIcon,
     IonImg,
     IonItem,
     IonLabel,
     IonList,
     IonPage,
     IonRefresher,
     IonRefresherContent,
     IonSpinner,
     IonTitle,
     IonToolbar,
     useIonAlert,
   } from '@ionic/react';
   import { MichelsonV1ExpressionBase, PackDataParams } from '@taquito/rpc';
   import { MichelCodecPacker } from '@taquito/taquito';
   import { BigNumber } from 'bignumber.js';
   import * as crypto from 'crypto';
   import { eye, stopCircle } from 'ionicons/icons';
   import React, { useEffect, useState } from 'react';
   import { RouteComponentProps, useHistory } from 'react-router-dom';
   import { Action, PAGES, UserContext, UserContextType } from '../App';
   import { TransactionInvalidBeaconError } from '../TransactionInvalidBeaconError';
   import Paper from '../assets/paper-logo.webp';
   import Scissor from '../assets/scissor-logo.webp';
   import Stone from '../assets/stone-logo.webp';
   import { bytes, nat, unit } from '../type-aliases';

   export enum STATUS {
     PLAY = 'Play !',
     WAIT_YOUR_OPPONENT_PLAY = 'Wait for your opponent move',
     REVEAL = 'Reveal your choice now',
     WAIT_YOUR_OPPONENT_REVEAL = 'Wait for your opponent to reveal his choice',
     FINISHED = 'Game ended',
   }

   type SessionScreenProps = RouteComponentProps<{
     id: string;
   }>;

   export const SessionScreen: React.FC<SessionScreenProps> = ({ match }) => {
     const [presentAlert] = useIonAlert();
     const { goBack } = useHistory();

     const id: string = match.params.id;

     const {
       Tezos,
       userAddress,
       storage,
       mainWalletType,
       setStorage,
       setLoading,
       loading,
       refreshStorage,
       subReveal,
       subNewRound,
     } = React.useContext(UserContext) as UserContextType;

     const [status, setStatus] = useState<STATUS>();
     const [remainingTime, setRemainingTime] = useState<number>(10 * 60);
     const [sessionEventRegistrationDone, setSessionEventRegistrationDone] =
       useState<boolean>(false);

     const registerSessionEvents = async () => {
       if (!sessionEventRegistrationDone) {
         if (subReveal)
           subReveal.on('data', async (e) => {
             console.log('on reveal event', e, id, UserContext);
             if (
               (!e.result.errors || e.result.errors.length === 0) &&
               (e.payload as MichelsonV1ExpressionBase).int === id
             ) {
               await revealPlay();
             } else
               console.warn(
                 'Warning: here we ignore this transaction event for session ',
                 id
               );
           });

         if (subNewRound)
           subNewRound.on('data', (e) => {
             if (
               (!e.result.errors || e.result.errors.length === 0) &&
               (e.payload as MichelsonV1ExpressionBase).int === id
             ) {
               console.log('on new round event:', e);
               refreshStorage();
             } else
               console.log('Warning: here we ignore this transaction event', e);
           });

         console.log(
           'registerSessionEvents registered',
           subReveal,
           subNewRound
         );
         setSessionEventRegistrationDone(true);
       }
     };

     const buildSessionStorageKey = (
       userAddress: string,
       sessionNumber: number,
       roundNumber: number
     ): string => {
       return (
         import.meta.env.VITE_CONTRACT_ADDRESS +
         '-' +
         userAddress +
         '-' +
         sessionNumber +
         '-' +
         roundNumber
       );
     };

     const buildSessionStorageValue = (
       secret: number,
       action: Action
     ): string => {
       return (
         secret +
         '-' +
         (action.cisor ? 'cisor' : action.paper ? 'paper' : 'stone')
       );
     };

     const extractSessionStorageValue = (
       value: string
     ): { secret: number; action: Action } => {
       const actionStr = value.split('-')[1];
       return {
         secret: Number(value.split('-')[0]),
         action:
           actionStr === 'cisor'
             ? new Action(true as unit, undefined, undefined)
             : actionStr === 'paper'
             ? new Action(undefined, true as unit, undefined)
             : new Action(undefined, undefined, true as unit),
       };
     };

     useEffect(() => {
       if (storage) {
         const session = storage?.sessions.get(new BigNumber(id) as nat);
         console.log(
           'Session has changed',
           session,
           'round',
           session?.current_round.toNumber(),
           'session.decoded_rounds.get(session.current_round)',
           session?.decoded_rounds.get(session?.current_round)
         );
         if (
           session &&
           ('winner' in session.result || 'draw' in session.result)
         ) {
           setStatus(STATUS.FINISHED);
         } else if (session) {
           if (
             session.decoded_rounds &&
             session.decoded_rounds.get(session.current_round) &&
             session.decoded_rounds.get(session.current_round).length === 1 &&
             session.decoded_rounds.get(session.current_round)[0].player ===
               userAddress
           ) {
             setStatus(STATUS.WAIT_YOUR_OPPONENT_REVEAL);
           } else if (
             session.rounds &&
             session.rounds.get(session.current_round) &&
             session.rounds.get(session.current_round).length === 2
           ) {
             setStatus(STATUS.REVEAL);
           } else if (
             session.rounds &&
             session.rounds.get(session.current_round) &&
             session.rounds.get(session.current_round).length === 1 &&
             session.rounds.get(session.current_round)[0].player === userAddress
           ) {
             setStatus(STATUS.WAIT_YOUR_OPPONENT_PLAY);
           } else {
             setStatus(STATUS.PLAY);
           }
         }

         (async () => await registerSessionEvents())();
       } else {
         console.log('Wait parent to init storage ...');
       }
     }, [storage?.sessions.get(new BigNumber(id) as nat)]);

     //setRemainingTime
     useEffect(() => {
       const interval = setInterval(() => {
         const diff = Math.round(
           (new Date(
             storage?.sessions.get(new BigNumber(id) as nat).asleep!
           ).getTime() -
             Date.now()) /
             1000
         );

         if (diff <= 0) {
           setRemainingTime(0);
         } else {
           setRemainingTime(diff);
         }
       }, 1000);

       return () => clearInterval(interval);
     }, [storage?.sessions.get(new BigNumber(id) as nat)]);

     const play = async (action: Action) => {
       const session_id = new BigNumber(id) as nat;
       const current_session = storage?.sessions.get(session_id);
       try {
         setLoading(true);
         const secret = Math.round(Math.random() * 63); //FIXME it should be 654843, but we limit the size of the output hexa because expo-crypto is buggy
         // see https://forums.expo.dev/t/how-to-hash-buffer-with-expo-for-an-array-reopen/64587 or https://github.com/expo/expo/issues/20706 );
         localStorage.setItem(
           buildSessionStorageKey(
             userAddress,
             Number(id),
             storage!.sessions
               .get(new BigNumber(id) as nat)
               .current_round.toNumber()
           ),
           buildSessionStorageValue(secret, action)
         );
         console.log('PLAY - pushing to session storage ', secret, action);
         const encryptedAction = await create_bytes(action, secret);
         console.log(
           'encryptedAction',
           encryptedAction,
           'session_id',
           session_id,
           'current_round',
           current_session?.current_round
         );

         const preparedCall = mainWalletType?.methods.play(
           session_id,
           current_session!.current_round,

           encryptedAction
         );

         const { gasLimit, storageLimit, suggestedFeeMutez } =
           await Tezos.estimate.transfer({
             ...preparedCall!.toTransferParams(),
             amount: 1,
             mutez: false,
           });

         console.log({ gasLimit, storageLimit, suggestedFeeMutez });
         const op = await preparedCall!.send({
           gasLimit: gasLimit * 2, //we take a margin +1000 for an eventual event in case of paralell execution
           fee: suggestedFeeMutez * 2,
           storageLimit: storageLimit,
           amount: 1,
           mutez: false,
         });

         await op?.confirmation();
         const newStorage = await mainWalletType?.storage();
         setStorage(newStorage!);
         setLoading(false);
         console.log('newStorage', newStorage);
       } catch (error) {
         console.table(`Error: ${JSON.stringify(error, null, 2)}`);
         const tibe: TransactionInvalidBeaconError =
           new TransactionInvalidBeaconError(error);
         presentAlert({
           header: 'Error',
           message: tibe.data_message,
           buttons: ['Close'],
         });
         setLoading(false);
       }
       setLoading(false);
     };

     const revealPlay = async () => {
       const session_id = new BigNumber(id) as nat;

       //force refresh in case of events
       const storage = await mainWalletType?.storage();

       const current_session = storage!.sessions.get(session_id)!;

       console.warn(
         'refresh storage because events can trigger it outisde react scope ...',
         userAddress,
         current_session.current_round
       );

       //fecth from session storage
       const secretActionStr = localStorage.getItem(
         buildSessionStorageKey(
           userAddress,
           session_id.toNumber(),
           current_session!.current_round.toNumber()
         )
       );

       if (!secretActionStr) {
         presentAlert({
           header: 'Internal error',
           message:
             'You lose the session/round ' +
             session_id +
             '/' +
             current_session!.current_round.toNumber() +
             ' storage, no more possible to retrieve secrets, stop Session please',
           buttons: ['Close'],
         });
         setLoading(false);
         return;
       }

       const secretAction = extractSessionStorageValue(secretActionStr);
       console.log('REVEAL - Fetch from session storage', secretAction);

       try {
         setLoading(true);
         const encryptedAction = await packAction(secretAction.action);

         const preparedCall = mainWalletType?.methods.revealPlay(
           session_id,
           current_session?.current_round!,

           encryptedAction as bytes,
           new BigNumber(secretAction.secret) as nat
         );

         const { gasLimit, storageLimit, suggestedFeeMutez } =
           await Tezos.estimate.transfer(preparedCall!.toTransferParams());

         //console.log({ gasLimit, storageLimit, suggestedFeeMutez });
         const op = await preparedCall!.send({
           gasLimit: gasLimit * 3,
           fee: suggestedFeeMutez * 2,
           storageLimit: storageLimit * 4, //we take a margin in case of paralell execution
         });
         await op?.confirmation();
         const newStorage = await mainWalletType?.storage();
         setStorage(newStorage!);
         setLoading(false);
         console.log('newStorage', newStorage);
       } catch (error) {
         console.table(`Error: ${JSON.stringify(error, null, 2)}`);
         const tibe: TransactionInvalidBeaconError =
           new TransactionInvalidBeaconError(error);
         presentAlert({
           header: 'Error',
           message: tibe.data_message,
           buttons: ['Close'],
         });
         setLoading(false);
       }
       setLoading(false);
     };

     /** Pack an action variant to bytes. Same is Pack.bytes()  */
     async function packAction(action: Action): Promise<string> {
       const p = new MichelCodecPacker();
       const actionbytes: PackDataParams = {
         data: action.stone
           ? { prim: 'Left', args: [{ prim: 'Unit' }] }
           : action.paper
           ? {
               prim: 'Right',
               args: [{ prim: 'Left', args: [{ prim: 'Unit' }] }],
             }
           : {
               prim: 'Right',
               args: [{ prim: 'Right', args: [{ prim: 'Unit' }] }],
             },
         type: {
           prim: 'Or',
           annots: ['%action'],
           args: [
             { prim: 'Unit', annots: ['%stone'] },
             {
               prim: 'Or',
               args: [
                 { prim: 'Unit', annots: ['%paper'] },
                 { prim: 'Unit', annots: ['%cisor'] },
               ],
             },
           ],
         },
       };
       return (await p.packData(actionbytes)).packed;
     }

     /** Pack an pair [actionBytes,secret] to bytes. Same is Pack.bytes()  */
     async function packActionBytesSecret(
       actionBytes: bytes,
       secret: number
     ): Promise<string> {
       const p = new MichelCodecPacker();
       const actionBytesSecretbytes: PackDataParams = {
         data: {
           prim: 'Pair',
           args: [{ bytes: actionBytes }, { int: secret.toString() }],
         },
         type: {
           prim: 'pair',
           args: [
             {
               prim: 'bytes',
             },
             { prim: 'nat' },
           ],
         },
       };
       return (await p.packData(actionBytesSecretbytes)).packed;
     }

     const stopSession = async () => {
       try {
         setLoading(true);
         const op = await mainWalletType?.methods
           .stopSession(new BigNumber(id) as nat)
           .send();
         await op?.confirmation(2);
         const newStorage = await mainWalletType?.storage();
         setStorage(newStorage!);
         setLoading(false);
         console.log('newStorage', newStorage);
       } catch (error) {
         console.table(`Error: ${JSON.stringify(error, null, 2)}`);
         const tibe: TransactionInvalidBeaconError =
           new TransactionInvalidBeaconError(error);
         presentAlert({
           header: 'Error',
           message: tibe.data_message,
           buttons: ['Close'],
         });
         setLoading(false);
       }
       setLoading(false);
     };

     const create_bytes = async (
       action: Action,
       secret: number
     ): Promise<bytes> => {
       const actionBytes = (await packAction(action)) as bytes;
       console.log('actionBytes', actionBytes);
       const bytes = (await packActionBytesSecret(
         actionBytes,
         secret
       )) as bytes;
       console.log('bytes', bytes);

       /* correct implementation with a REAL library */
       const encryptedActionSecret = crypto
         .createHash('sha512')
         .update(Buffer.from(bytes, 'hex'))
         .digest('hex') as bytes;

       console.log('encryptedActionSecret', encryptedActionSecret);
       return encryptedActionSecret;
     };

     const getFinalResult = (): string | undefined => {
       if (storage) {
         const result = storage.sessions.get(new BigNumber(id) as nat).result;
         if ('winner' in result && result.winner === userAddress) return 'win';
         if ('winner' in result && result.winner !== userAddress) return 'lose';
         if ('draw' in result) return 'draw';
       }
     };

     const isDesktop = () => {
       const { innerWidth } = window;
       if (innerWidth > 800) return true;
       else return false;
     };

     return (
       <IonPage className="container">
         <IonHeader>
           <IonToolbar>
             <IonButtons slot="start">
               <IonButton onClick={goBack}>Back</IonButton>
             </IonButtons>
             <IonTitle>Game n°{id}</IonTitle>
           </IonToolbar>
         </IonHeader>
         <IonContent fullscreen>
           <IonRefresher slot="fixed" onIonRefresh={refreshStorage}>
             <IonRefresherContent></IonRefresherContent>
           </IonRefresher>
           {loading ? (
             <div className="loading">
               <IonItem>
                 <IonLabel>Refreshing ...</IonLabel>
                 <IonSpinner className="spinner"></IonSpinner>
               </IonItem>
             </div>
           ) : (
             <>
               <IonList inset={true} style={{ textAlign: 'left' }}>
                 {status !== STATUS.FINISHED ? (
                   <IonItem className="nopm">Status: {status}</IonItem>
                 ) : (
                   ''
                 )}
                 <IonItem className="nopm">
                   <span>
                     Opponent:{' '}
                     {storage?.sessions
                       .get(new BigNumber(id) as nat)
                       .players.find((userItem) => userItem !== userAddress)}
                   </span>
                 </IonItem>

                 {status !== STATUS.FINISHED ? (
                   <IonItem className="nopm">
                     Round:
                     {Array.from(
                       Array(
                         storage?.sessions
                           .get(new BigNumber(id) as nat)
                           .total_rounds.toNumber()
                       ).keys()
                     ).map((roundId) => {
                       const currentRound: number = storage
                         ? storage?.sessions
                             .get(new BigNumber(id) as nat)
                             .current_round?.toNumber() - 1
                         : 0;
                       const roundwinner = storage?.sessions
                         .get(new BigNumber(id) as nat)
                         .board.get(new BigNumber(roundId + 1) as nat);

                       return (
                         <div
                           key={roundId + '-' + roundwinner}
                           className={
                             !roundwinner && roundId > currentRound
                               ? 'missing'
                               : !roundwinner && roundId === currentRound
                               ? 'current'
                               : !roundwinner
                               ? 'draw'
                               : roundwinner.Some === userAddress
                               ? 'win'
                               : 'lose'
                           }
                         ></div>
                       );
                     })}
                   </IonItem>
                 ) : (
                   ''
                 )}

                 {status !== STATUS.FINISHED ? (
                   <IonItem className="nopm">
                     {'Remaining time:' + remainingTime + ' s'}
                   </IonItem>
                 ) : (
                   ''
                 )}
               </IonList>

               {status === STATUS.FINISHED ? (
                 <IonImg
                   className={'logo-XXL' + (isDesktop() ? '' : ' mobile')}
                   src={'assets/' + getFinalResult() + '.png'}
                 />
               ) : (
                 ''
               )}

               {status === STATUS.PLAY ? (
                 <IonList
                   lines="none"
                   style={{ marginLeft: 'calc(50vw - 70px)' }}
                 >
                   <IonItem style={{ margin: 0, padding: 0 }}>
                     <IonButton
                       style={{ height: 'auto' }}
                       onClick={() =>
                         play(new Action(true as unit, undefined, undefined))
                       }
                     >
                       <IonImg src={Scissor} className="logo" />
                     </IonButton>
                   </IonItem>
                   <IonItem style={{ margin: 0, padding: 0 }}>
                     <IonButton
                       style={{ height: 'auto' }}
                       onClick={() =>
                         play(new Action(undefined, true as unit, undefined))
                       }
                     >
                       <IonImg src={Paper} className="logo" />
                     </IonButton>
                   </IonItem>
                   <IonItem style={{ margin: 0, padding: 0 }}>
                     <IonButton
                       style={{ height: 'auto' }}
                       onClick={() =>
                         play(new Action(undefined, undefined, true as unit))
                       }
                     >
                       <IonImg src={Stone} className="logo" />
                     </IonButton>
                   </IonItem>
                 </IonList>
               ) : (
                 ''
               )}

               {status === STATUS.REVEAL ? (
                 <IonButton onClick={() => revealPlay()}>
                   <IonIcon icon={eye} />
                   Reveal
                 </IonButton>
               ) : (
                 ''
               )}
               {remainingTime === 0 && status !== STATUS.FINISHED ? (
                 <IonButton onClick={() => stopSession()}>
                   <IonIcon icon={stopCircle} />
                   Claim victory
                 </IonButton>
               ) : (
                 ''
               )}
             </>
           )}
         </IonContent>
         <IonFooter>
           <IonToolbar>
             <IonTitle>
               <IonButton routerLink={PAGES.RULES} expand="full">
                 Rules
               </IonButton>
             </IonTitle>
           </IonToolbar>
         </IonFooter>
       </IonPage>
     );
   };
   ```

   Explanations:

   * `export enum STATUS {...`: This enum is used to guess the actual status of the game based on different field values. It gives the connected user the next action to do, and so controls the display of the buttons.
   * `const subReveal = Tezos.stream.subscribeEvent({tag: "reveal",...`: Websocket subscription to the smart contract `reveal` event. When it is time to reveal, it can trigger the action from the mobile app without asking the user to click the button.
   * `const subNewRound = Tezos.stream.subscribeEvent({tag: "newRound",...`: Websocket subscription to smart contract `newround` event. When a new round is ready, this event notifies the mobile to refresh the current game so the player can play the next round.
   * `const buildSessionStorageKey ...`: This function is a helper to store on browser storage a unique secret key of the player. This secret is a salt that is added to encrypt the Play action and then to decrypt the Reveal action.
   * `const buildSessionStorageValue ...`: Same as above but for the value stored as a string.
   * `const play = async (action: Action) => { ... `: Play action. It creates a player secret for this Play action randomly `Math.round(Math.random() * 63)` and stores it on the browser storage `localStorage.setItem(buildSessionStorageKey(...`. Then it packs and encrypts the Play action calling `create_bytes(action, secret)`. It estimates the cost of the transaction and adds an extra amount for the event cost `mainWalletType!.methods.play(encryptedAction,current_session!.current_round,session_id) ... Tezos.estimate.transfer(...) ... preparedCall.send({gasLimit: gasLimit + 1000, ...`. It asks for 1 XTZ from each player doing a Play action. This money is staked on the contract and freed when the game is ended. The Shifumi game itself does not take any extra fees by default. Only players win or lose money.
   * `const revealPlay = async () => {...`: Reveal action. It fetches the secret from `localStorage.getItem(...`, then it packs the secret action and reveals the secret: `mainWalletType!.methods.revealPlay(encryptedAction as bytes,new BigNumber(secretAction.secret) as nat,current_session!.current_round,session_id);`. It adds again an extra gas limit `gasLimit: gasLimit * 3`. It increases the gas limit because if two players reveal actions on the same block, the primary estimation of gas made by the wallet is not enough. The reason is that the execution of the second reveal play action executes another business logic because the first action is modifying the initial state, so the estimation at this time (with this previous state) is no longer valid.
   * `const getFinalResult`: Based on some fields, it gives the final status of the game when it is ended. When the game is ended the winner gets the money staked by the loser. In case of a draw, the staked money is sent back to the players.
   * `const stopSession = async () => {...`: There is a countdown of 10 minutes. If no player wants to play any more and the game is unfinished, someone can claim the victory and close the game calling `mainWalletType!.methods.stopSession(`. The smart contract looks at different configurations to guess if there is someone guilty or it is just a draw because no one wants to play any more. Gains are sent to the winner or in a case of draw, the tez is sent back to players.

   When the page refreshes, you can see the game session.

4. Create the Top player score page:

   The last step is to see the score of all players.

   Edit `TopPlayersScreen.tsx` to look like this:

   ```typescript
   import {
     IonButton,
     IonButtons,
     IonCol,
     IonContent,
     IonGrid,
     IonHeader,
     IonImg,
     IonPage,
     IonRefresher,
     IonRefresherContent,
     IonRow,
     IonTitle,
     IonToolbar,
   } from '@ionic/react';
   import React, { useEffect, useState } from 'react';
   import { useHistory } from 'react-router-dom';
   import { UserContext, UserContextType } from '../App';
   import Ranking from '../assets/ranking.webp';
   import { nat } from '../type-aliases';

   export const TopPlayersScreen: React.FC = () => {
     const { goBack } = useHistory();
     const { storage, refreshStorage } = React.useContext(
       UserContext
     ) as UserContextType;

     const [ranking, setRanking] = useState<Map<string, number>>(new Map());

     useEffect(() => {
       (async () => {
         if (storage) {
           const ranking = new Map(); //force refresh
           Array.from(storage.sessions.keys()).forEach((key: nat) => {
             const result = storage.sessions.get(key).result;
             if ('winner' in result) {
               const winner = result.winner;
               let score = ranking.get(winner);
               if (score) score++;
               else score = 1;
               ranking.set(winner, score);
             }
           });

           setRanking(ranking);
         } else {
           console.log('storage is not ready yet');
         }
       })();
     }, [storage]);

     /* 2. Get the param */
     return (
       <IonPage className="container">
         <IonHeader>
           <IonToolbar>
             <IonButtons slot="start">
               <IonButton onClick={goBack}>Back</IonButton>
             </IonButtons>
             <IonTitle>Top Players</IonTitle>
           </IonToolbar>
         </IonHeader>
         <IonContent fullscreen>
           <IonRefresher slot="fixed" onIonRefresh={refreshStorage}>
             <IonRefresherContent></IonRefresherContent>
           </IonRefresher>
           <div style={{ marginLeft: '40vw' }}>
             <IonImg
               src={Ranking}
               className="ranking"
               style={{ height: '10em', width: '5em' }}
             />
           </div>

           <IonGrid fixed={true} style={{ color: 'white', padding: '2vh' }}>
             <IonRow
               style={{
                 backgroundColor: 'var(--ion-color-primary)',
               }}
             >
               <IonCol className="col">Address</IonCol>
               <IonCol size="2" className="col">
                 Won
               </IonCol>
             </IonRow>

             {ranking && ranking.size > 0
               ? Array.from(ranking).map(([address, count]) => (
                   <IonRow
                     key={address}
                     style={{
                       backgroundColor: 'var(--ion-color-secondary)',
                     }}
                   >
                     <IonCol className="col tiny">{address}</IonCol>
                     <IonCol size="2" className="col">
                       {count}
                     </IonCol>
                   </IonRow>
                 ))
               : []}
           </IonGrid>
         </IonContent>
       </IonPage>
     );
   };
   ```

   Explanations:

   * `let ranking = new Map()`: It prepares a map to count the score for each winner. Looping through all sessions with `storage.sessions.keys()).forEach`, it takes only where there is a winner `if ("winner" in result)` then it increments the score `if (score) score++;else score = 1` and pushes it to the map `ranking.set(winner, score);`.

   All pages are ready. The Game is done!

## Summary

You have successfully create a Web3 game that runs 100% on-chain.
The next step is to build and distribute your game as an Android app.

When you are ready, continue to [Part 4: Publish on the Android store](/tutorials/mobile/part-4).


# Part 4: Publish on the Android store

Your game will be more successful if you publish it on the Android or Apple store. A recommendation is to start with Android as it is easy and cheaper than the iOS version.

## Bundle for Android

1. Install the [Android SDK](https://developer.android.com/about/versions/13/setup-sdk).

2. Modify the name of your app, open the `capacitor.config.json` file and change the `"appId":"dev.marigold.shifumi"` and `"appName": "Tezos Shifumi"` properties.

3. Hack: to build on Android, change `vite.config.ts` to remove the `global` field from the configuration.

   ```javascript
   export default defineConfig({
     define: {
       "process.env": process.env,
       //global: {},
     },
   ```

4. In the `ionic.config.json` file, change the Ionic config from React to a custom type build.

   ```json
   {
     "name": "shifumi",
     "integrations": {
       "capacitor": {}
     },
     "type": "custom"
   }
   ```

5. Stay in the app folder and prepare the Android release. These lines copy all files to android folder and the images resources used by the store.

   ```bash
   ionic capacitor add android
   ionic capacitor copy android
   npm install -g cordova-res
   cordova-res android --skip-config --copy
   ionic capacitor sync android
   ionic capacitor update android
   ```

   Open Android Studio and do a `Build` or `Make Project` action.

   > Note 1: in case of broken Gradle: `ionic capacitor sync android` and click **sync** on **Android studio > build**.

   > Note 2: If you have `WSL2` and difficulties to run an emulator on it, install Android studio on Windows and build, test, and package all on Windows. Push your files to your git repo, and check the `.gitignore` file for the `android` folder to verify that there are no filters on assets.
   >
   > 1. Comment the end lines in the file `ionic.config.json`:
   >
   >    ```bash
   >    # Cordova plugins for Capacitor
   >    #capacitor-cordova-android-plugins
   >
   >    # Copied web assets
   >    #app/src/main/assets/public
   >
   >    # Generated Config files
   >    #app/src/main/assets/capacitor.config.json
   >    #app/src/main/assets/capacitor.plugins.json
   >    #app/src/main/res/xml/config.xml
   >    ```
   >
   > 2. Comment out the `node_modules` and `dist` in the `.gitignore` file at your root project because it requires files from @capacitor and you need to install these libraries:
   >
   >    ```bash
   >    #node_modules/
   >    #/dist
   >    ```
   >
   > 3. Force it to be included on committed files: `git add -f android/app/src/main/assets/  ; git add -f android/capacitor-cordova-android-plugins/ ;  git add -f node_modules ;` and push to git.
   >
   > 4. Try the `Build` or `Make Project` action on Android Studio again.

   ![build.png](/img/tutorials/mobile-build.png)

   Start the emulator of your choice (or a physical device) and click `Run app`.

   ![run.png](/img/tutorials/mobile-run.png)

   Some mobile wallets do not work with emulators, so consider using a web wallet like Kukai.

   ![kukai.png](/img/tutorials/mobile-kukai.png)

   When you are connected, you can start a new game.

   ![home.png](/img/tutorials/mobile-home.png)

6. Invite Alice to play, click the address of the opponent player, and enter this code on your Android Studio terminal:

   ```bash
   adb shell input text "tz1VSUr8wwNhLAzempoch5d6hLRiTh8Cjcjb"
   ```

   ![alice.png](/img/tutorials/mobile-alice.png)

7. Click Create on the top right button.

8. Confirm the transaction in Kukai and come back to the app.

   Perfect, the round is starting!

9. Now you can run the web version on VScode, connect with alice, and play with your 2 players.

   Watch the video here to see how to play a full party.

   [![Shifumi](https://img.youtube.com/vi/SHg8VPmF_NY/0.jpg)](https://www.youtube.com/watch?v=SHg8VPmF_NY)

10. Publish your app to the Google Play store.

    To publish your app to the Android store, read the Google documentation.
    You need a developer account: https://developer.android.com/distribute/console/

    It costs 25$ for life (for information: an Apple developer account costs 99$/ year).

11. In Android studio, go to **Build > Generate Signed bundle / APK**.

    ![sign.png](/img/tutorials/mobile-sign.png)

    Follow the Google instructions to set your keystore and click **Next**.
    Watch where the binary is stored and upload it to the Google Play console app.

    After passing a (long) configuration of your application on Google Play Store and passing all Google validations, your app is published and everyone can download it on Earth.

## Summary

Having a Web3 game has many advantages like the transparency and inheritance of in-game currency. Developing the dApp is not so different from a Web2 application. Also the process of bundling to Android and iOS is similar and uses the common tools from Google and Apple.

I hope you enjoyed this tutorial and don't hesitate to leave feedback to the Marigold team!


# Implement a file archive with the DAL and a Smart Rollup

The Data Availability Layer (DAL) is a companion peer-to-peer network for the Tezos blockchain, designed to provide additional data bandwidth to Smart Rollups.
It allows users to share large amounts of data in a way that is decentralized and permissionless, because anyone can join the network and post and read data on it.

This tutorial uses the Ghostnet test network, but you can use the information in it to work with other test networks or Tezos Mainnet.

In this tutorial, you set up a file archive that stores and retrieves files with the DAL.
You will learn:

* How data is organized and shared with the DAL and the reveal data channel
* How to read data from the DAL in a Smart Rollup
* How to host a DAL node
* How to publish data and files with the DAL

See these links for more information about the DAL:

* For technical information about how the DAL works, see [Data Availability Layer](https://octez.tezos.com/docs/shell/dal.html) in the Octez documentation.
* For more information about the approach for the DAL, see [The Rollup Booster: A Data-Availability Layer for Tezos](https://research-development.nomadic-labs.com/data-availability-layer-tezos.html).

## Tutorial applications

In this tutorial, you set up these components:

* The Octez client, which you use to manage a local wallet, deploy a Smart Rollup, and send data to the DAL
* A layer 1 node to provide a connection to Tezos and information about the state of layer 1, including metadata about what data is available on the DAL
* A Data Availability Layer node (not to be confused with a layer 1 node), which stores data temporarily and distributes it to Smart Rollups
* A Smart Rollup that listens for data published to the DAL, retrieves it from the DAL node, and stores it locally
* A Smart Rollup node that runs your Smart Rollup

For simplicity, you do not set up a baker, which is responsible for verifying and attesting that the data is available before Smart Rollups can access it.
For instructions on running a layer 1 node and baker with the DAL, see the tutorial [Join the DAL as a baker, in 5 steps](/tutorials/join-dal-baker).

## Tutorial diagram

Here is a diagram that shows the components that you set up in this tutorial in a light blue background:

![A diagram of the DAL file tutorial, highlighting the Octez client, DAL node, layer 1 node, and Smart Rollup that you create with a light blue background to distinguish them from the existing DAL nodes, layer 1 nodes, and bakers](/img/tutorials/dal-file-tutorial-setup.png)

<!-- https://lucid.app/lucidchart/58f5577e-91b5-4237-89c4-a8cdf81c71ad/edit -->

## Prerequisites

This article assumes some familiarity with Smart Rollups.
If you are new to Smart Rollups, see the tutorial [Deploy a Smart Rollup](/tutorials/smart-rollup).

## Why the DAL?

The DAL has earned the nickname "Rollup Booster" from its ability to address
the last bottleneck Smart Rollups developers could not overcome without
sacrificing decentralization: block space. Smart Rollups offload
*computation* from layer 1, but the transactions that they process still need to
originate from somewhere.

By default, that "somewhere" is the layer 1 blocks, yet the size of a Tezos
block is limited to around 500KBytes. In this model, while Smart Rollups do not
compete for layer 1 gas anymore, they still compete for block space.

The DAL allows third parties to publish data and have bakers attest that the data is available.
When enough bakers have attested that the data is available, Smart Rollups can retrieve the data without the need for additional trusted third-parties.

## How the DAL works

In this tutorial, you create a file archive application that allows clients to upload data to the DAL.
You also create a Smart Rollup that listens to the DAL and responds to that data.

The DAL works like this:

1. Users post data to a DAL node.

2. The DAL node returns a certificate, which includes two parts:

   * The *commitment* is like a hash of the data but has the additional ability to identify individual shards of the data and reconstruct the original data from a certain percentage of the shards.
     The number of shards needed depends on how the data is spread across shards, which is controlled by a parameter called the *redundancy factor*.
   * The *proof* certifies the length of the data to prevent malicious users from overloading the layer with data.

3. Users post the certificate to Tezos layer 1 via the Octez client.

4. When the certificate is confirmed in a block, the DAL splits the data into shards and shares it through the peer-to-peer network.

5. Layer 1 assigns the shards to bakers.

6. Bakers verify that they are able to download the shards that they are assigned to.

7. Bakers attest that the data is available in their usual block attestations to layer 1.

   Each Tezos network has a delay of a certain number of blocks known as the *attestation lag*.
   This number of blocks determines when bakers attest that the data is available and when the data becomes available to Smart Rollups.
   For example, if a certificate is included in level 100 and the attestation lag is 4, bakers must attest that the data is available in level 104, along with their usual attestations that build on level 103.

   If enough shards are attested in that level, the data becomes available to Smart Rollups at the end of layer 104.
   If not enough shards are attested in that level, the certificate is considered bogus, the related data is dropped, and Smart Rollups cannot access it.

8. The Smart Rollup node monitors the blocks and when it sees attested DAL data, it connects to a DAL node to request the data.
   Smart Rollups must store the data if they need it because it is available on the DAL for only a short time.

The overall workflow is summarized in the following figure:

![Overall diagram of the workflow of the Data Availability Layer](/img/architecture/dal-workflow.png)

<!-- https://lucid.app/lucidchart/cc422278-7319-4a2f-858a-a7b72e1ea3a6/edit -->

There are many steps in the DAL process, but the most complicated parts (storing and sharing data) are handled automatically by the various daemons in the Octez suite.

:::note
When you install a Smart Rollup, you provide only the installer kernel on layer 1 and the full kernel via the reveal data channel.
Currently, you cannot send the full kernel data over the Data Availability Layer, so this tutorial relies on the reveal data channel to install the kernel as usual.
:::

When you are ready, get started by going to [Part 1: Setting up an environment](/tutorials/build-files-archive-with-dal/set-up-environment).


# Part 1: Setting up an environment

These steps cover how to set up a development environment to work with Smart Rollups and the DAL.
To work with these elements, you need the Octez suite, which includes the Octez command-line client for interacting with Tezos and the binaries for the DAL node and Smart Rollup node.
You must use the same version of the Octez suite that the network is using.

The easiest way to use the Octez suite is to use the `tezos/tezos` Docker image.
As another option, you can get the built version of the Octez suite from https://octez.tezos.com/docs/ or build the specific version of the Octez suite locally.

To set up an environment and account in a Docker container, follow these steps:

1. Retrieve the latest version of the `tezos/tezos` Docker image by running this command:

   ```bash
   docker pull tezos/tezos:latest
   ```

2. Start a Docker container from the image:

   ```bash
   docker run -it --entrypoint=/bin/sh tezos/tezos:latest
   ```

   :::tip
   If you're not used to working inside Docker containers, you can map a folder on your computer to a folder in the container to create a [Docker volume](https://docs.docker.com/storage/volumes/).
   This way, you can edit files on your computer and the changes will appear on the files inside the container.
   For example, to start a container and map the current folder to the `/home/tezos` folder in the container, run this command:

   ```bash
   docker run -it --entrypoint=/bin/sh -v .:/home/tezos tezos/tezos:latest
   ```

   You can map a folder like this only when you create a container; you cannot add it later.
   :::

3. In the container, configure the layer 1 node for Ghostnet:

   ```bash
   octez-node config init --network ghostnet
   ```

   If you see an error that says that the node has a pre-existing configuration file, update the existing configuration file by running this command:

   ```bash
   octez-node config update --network ghostnet
   ```

4. Download a snapshot of Ghostnet from https://snapshot.tzinit.org based on the instructions on that site.
   For example, the command to download the snapshot may look like this:

   ```bash
   wget -O snapshot_file https://snapshots.eu.tzinit.org/ghostnet/rolling
   ```

5. Load the snapshot in the node by running this command:

   ```bash
   octez-node snapshot import snapshot_file
   ```

6. Run this command to start the node:

   ```bash
   octez-node run --rpc-addr 127.0.0.1:8732
   ```

7. Leave the node running in that terminal window and open a new terminal window in the same environment.
   If you are using a Docker container, you can enter the container with the `docker exec` command, as in `docker exec -it my-image /bin/sh`.
   To get the name of the Docker container, run the `docker ps` command.

8. In the container, initialize the Octez client to use your node, such as this example:

   ```bash
   octez-client -E http://127.0.0.1:8732 config init
   ```

   This command uses the default port for the node, but you can change it if you are running the node somewhere else.

   If you get an error that says "Failed to acquire the protocol version from the node," the node is not ready yet.
   Wait a few minutes for the node to be ready, run `rm -rf /home/tezos/.tezos-client/config` to remove the configuration file, and try the `config init` command again.

9. Optional: Hide the network warning message by running this command:

   ```bash
   export TEZOS_CLIENT_UNSAFE_DISABLE_DISCLAIMER=y
   ```

   This command suppresses the message that your instance of the Octez client is not using Mainnet.

10. Create an account with the command `octez-client gen keys my_wallet`, where `my_wallet` is an alias for your account.

11. Get the public key hash of the new account by running the command `octez-client show address my_wallet`.

12. From the [Ghostnet](https://teztnets.com/ghostnet-about) page, open the Ghostnet faucet and send some tez to the account.
    50 tez is enough to get started, and you can always go back to the faucet to get more.

Now you can use this account to deploy Smart Rollups.

## Install Rust

To run this tutorial, install Rust in the environment by running the following command.
The application in this tutorial uses Rust because of its support for WebAssembly (WASM), the language that Smart Rollups use to communicate.
Rollups can use any language that has WASM compilation support.

1. Make sure that the `curl` program is installed.
   If you are using the Tezos Docker container, run `sudo apk add curl`.

2. Run this command to install Rust:

   ```bash
   curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
   ```

3. Follow the instructions in the Rust installation program.
   For example, it may prompt you to run `. "$HOME/.cargo/env"` to configure your current terminal window to run Rust.

4. Set the version of Rust to 1.80 by running this command:

   ```bash
   rustup override set 1.80
   ```

5. Add WASM as a compilation target for Rust by running this command:

   ```bash
   rustup target add wasm32-unknown-unknown
   ```

   You can see other ways of installing Rust at https://www.rust-lang.org.

## Install Clang

Clang and LLVM are required for compilation to WebAssembly.
Version 11 or later of Clang is required.

If you are using the `tezos/tezos` Docker image, run these commands:

```bash
sudo apk add clang
export CC=clang
```

Here are instructions for installing the appropriate tools on different operating systems:

**MacOS**

```bash
brew install llvm
export CC="$(brew --prefix llvm)/bin/clang"
```

**Ubuntu**

```bash
sudo apt-get install clang-11
export CC=clang-11
```

**Fedora**

```bash
dnf install clang
export CC=clang
```

**Arch Linux**

```bash
pacman -S clang
export CC=clang
```

The `export CC` command sets Clang as the default C/C++ compiler.

After you run these commands, run `$CC --version` to verify that you have version 11 or greater installed.

Also, ensure that your version of Clang `wasm32` target with by running the command `$CC -print-targets | grep wasm32` and verifying that the results include `wasm32`.

When your environment is ready, continue to [Part 2: Getting the DAL parameters](/tutorials/build-files-archive-with-dal/get-dal-params).


# Part 2: Getting the DAL parameters

The Data Availability Layer stores information about the available data in layer 1 blocks.
Each block has several byte-vectors called *slots*, each with a maximum size.
DAL users can add information about the available data as a *commitment* in a slot.
These commitments refer to the data that is stored on the DAL, which stores the data in *pages* as shown in this diagram:

![Two example blocks with different DAL slots in use in each](/img/architecture/dal-slots-in-blocks.png)

<!-- https://lucid.app/lucidchart/46fa8412-8443-4491-82f6-305aafaf85f2/edit -->

The data is broken into pages to ensure that each piece of data can fit in a single Tezos operation.
This data must fit in a single operation to allow the Smart Rollup refutation game to work, in which every execution step of the Smart Rollup must be provable to layer 1.
For more information about Smart Rollups, see [Smart Rollups](/architecture/smart-rollups).

When clients add data, they must specify which slot to add it to.
Note that because the DAL is permissionless, clients may try to add data to the same slot in the same block.
In this case, the first operation in the block takes precedence, which leaves the baker that creates the block in control of which data makes it into the block.
Other operations that try to add data to the same slot fail.

The number and size of these slots can change.
Different networks can have different DAL parameters.
Future changes to the protocol may allow the DAL to resize dynamically based on usage.

Therefore, clients must get information about the DAL before sending data to it.
Smart contracts can't access the DAL; it is intended for Smart Rollups, so in these steps you set up a simple Smart Rollup to get the current DAL parameters and print them to the log.

## Prerequisites

Before you begin, make sure that you have installed the prerequisites and set up an environment and an account as described in [Part 1: Setting up an environment](/tutorials/build-files-archive-with-dal/set-up-environment).

## Fetching the DAL parameters in a kernel

To get the DAL parameters, you can use built-in functions in the Tezos [Rust SDK](https://crates.io/crates/tezos-smart-rollup).

1. In a folder for your project, create a file named `Cargo.toml` with this code:

   ```toml
   [package]
   name = "files_archive"
   version = "0.1.0"
   edition = "2021"

   [lib]
   crate-type = ["cdylib", "lib"]

   [dependencies]
   tezos-smart-rollup = { version = "0.2.2", features = [ "proto-alpha" ] }
   ```

   If you set up your Docker container with a connected folder on the host machine, you can create this file in the connected folder and it will appear in the Docker container.

   As a reminder, the kernel of a Smart Rollup is a WASM program.
   The `proto-alpha` feature is necessary to get access to the functions specific to the DAL because they are not yet released in the main version of the Smart Rollup toolkit.

   If you need a text editor inside the Docker container, you can run `sudo apk add nano` to install the [Nano text editor](https://www.nano-editor.org/).
   If you set up the container with a volume, you can use any editor on your host machine to edit the file and it appears in the linked folder in the container.

2. Create a file named `src/lib.rs` to be the kernel.

3. In the `src/lib.rs` file, add this code:

   ```rust
   use tezos_smart_rollup::{kernel_entry, prelude::*};

   pub fn entry<R: Runtime>(host: &mut R) {
       let param = host.reveal_dal_parameters();
       debug_msg!(host, "{:?}\n", param);
   }

   kernel_entry!(entry);
   ```

   This function gets the DAL parameters of the currently connected network and prints them to the log.

4. From the folder that contains the `Cargo.toml` file, run this command to build the kernel:

   ```bash
   cargo build --release --target wasm32-unknown-unknown
   ```

5. Run this command to copy the compiled kernel to the current folder:

   ```bash
   cp target/wasm32-unknown-unknown/release/files_archive.wasm .
   ```

6. Run these commands to get the installer kernel, which is a version of the kernel that contains only enough information to download and install the full kernel:

   ```bash
   cargo install tezos-smart-rollup-installer
   export PATH="${HOME}/.local/bin:${PATH}"
   smart-rollup-installer get-reveal-installer \
       -P _rollup_node/wasm_2_0_0 \
       -u files_archive.wasm \
       -o installer.hex
   ```

   For more information about optimizing the kernel and using installer kernels, see the tutorial [Deploy a Smart Rollup](/tutorials/smart-rollup).

Now the Smart Rollup is ready to deploy.

## Deploying the Smart Rollup and starting a node

Follow these steps to deploy the Smart Rollup to Ghostnet and start a node:

1. Run this command to deploy the Smart Rollup, replacing `my_wallet` with your Octez client account alias:

   ```bash
   octez-client originate smart rollup files_archive from my_wallet \
       of kind wasm_2_0_0 of type unit with kernel "$(cat installer.hex)" \
       --burn-cap 2.0 --force
   ```

   The Octez client assumes that your local node is running at http://127.0.0.1:8732.
   If your node is running at a different host name or port, pass the host name and port of the node to the `--endpoint` argument.
   For example, if the node is running on port 8733, include `--endpoint http://127.0.0.1:8733` in the command.

2. Start the Smart Rollup node with this command:

   ```bash
   octez-smart-rollup-node run observer for files_archive \
     with operators --data-dir ./_rollup_node --log-kernel-debug
   ```

   For simplicity, this command runs the Smart Rollup in observer mode, which does not require a stake of 10,000 tez to publish commitments.

   Like the `octez-client` command, this command assumes that your local node is running at http://127.0.0.1:8732.
   If your node is running at a different host name or port, pass the host name and port of the node to the `--endpoint` argument.

3. Leave the node running in that terminal window and open a new terminal window in the same environment.

4. Run this command to watch the node's log:

   ```bash
   tail -F _rollup_node/kernel.log
   ```

The log prints the current DAL parameters, as in this example:

```
RollupDalParameters { number_of_slots: 32, attestation_lag: 8, slot_size: 126944, page_size: 3967 }
RollupDalParameters { number_of_slots: 32, attestation_lag: 8, slot_size: 126944, page_size: 3967 }
RollupDalParameters { number_of_slots: 32, attestation_lag: 8, slot_size: 126944, page_size: 3967 }
RollupDalParameters { number_of_slots: 32, attestation_lag: 8, slot_size: 126944, page_size: 3967 }
RollupDalParameters { number_of_slots: 32, attestation_lag: 8, slot_size: 126944, page_size: 3967 }
RollupDalParameters { number_of_slots: 32, attestation_lag: 8, slot_size: 126944, page_size: 3967 }
```

These parameters are:

* `number_of_slots`: The number of slots in each block
* `slot_size`: The size of each slot in bytes
* `page_size`: The size of each page in bytes
* `attestation_lag`: The number of subsequent blocks in which bakers can attest that the data is available; if enough attestations are available by the time this number of blocks have been created, the data becomes available to Smart Rollups

## Setting up a deployment script

In later parts of this tutorial, you update and redeploy the Smart Rollup multiple times.
To simplify the process, you can use this script:

```bash
#!/bin/sh

alias="${1}"

set -e

cargo build --release --target wasm32-unknown-unknown

rm -rf _rollup_node

cp target/wasm32-unknown-unknown/release/files_archive.wasm .

smart-rollup-installer get-reveal-installer -P _rollup_node/wasm_2_0_0 \
  -u files_archive.wasm -o installer.hex

octez-client originate smart rollup files_archive from "${alias}" of kind wasm_2_0_0 \
  of type unit with kernel "$(cat installer.hex)" --burn-cap 2.0 --force

octez-smart-rollup-node run observer for files_archive \
  with operators --data-dir _rollup_node \
  --dal-node http://localhost:10732 --log-kernel-debug
```

To use it, save it in a file with an `sh` extension, such as `deploy_smart_rollup.sh` and give it executable permission by running `chmod +x deploy_smart_rollup.sh`.
Then you can run it any tme you update the `lib.rs` or `Cargo.toml` files to deploy a new Smart Rollup by passing your account alias, as in this example:

```bash
./deploy_smart_rollup.sh my_wallet
```

If you run this script and see an error that says that the file was not found, update the first line of the script (the shebang) to the path to your shell interpreter.
For example, if you are using the Tezos Docker image, the path is `/bin/sh`, so the first line is `#!/bin/sh`.
Then try the command `./deploy_smart_rollup.sh my_wallet` again.

In the next section, you will get information about the state of slots in the DAL.
See [Part 3: Getting slot information](/tutorials/build-files-archive-with-dal/get-slot-info).


# Part 3: Getting slot information

When clients send data to the DAL, they must choose which slot to put it in.
This can cause conflicts, because only one client can write data to a given slot in a single block.
If more than one client tries to write to the same slot and a baker includes those operations in the same block, only the first operation in the block succeeds in writing data to the slot.
The other operations fail and the clients must re-submit the data to be included in a future block.

For this reason, clients should check the status of slots to avoid conflicts.

To see which slots are in use, you can use the Explorus indexer at https://explorus.io/dal and select your network.
For example, this screenshot shows that slots 10 and 25 are in use:

![The Explorus indexer, showing the slots that are in use in each block](/img/tutorials/dal-explorus-slots.png)

You can also see the state of the DAL slots by running a DAL node.
To reduce the amount of data that they have to manage, DAL nodes can subscribe to certain slots and ignore the data in others.
Similarly, the protocol assigns bakers to monitor certain slots.

## Starting a DAL node

To run a DAL node, you must configure a set of cryptographic parameters for it and the use the Octez `octez-dal-node` command and pass the slots to monitor in the `--observer-profiles` argument:

1. In a new terminal window in the Docker container, run this command to download the trusted setup scripts:

   ```bash
   wget https://gitlab.com/tezos/tezos/-/raw/master/scripts/install_dal_trusted_setup.sh https://gitlab.com/tezos/tezos/-/raw/master/scripts/version.sh
   ```

2. Run this command to make the scripts executable:

   ```bash
   chmod +x install_dal_trusted_setup.sh version.sh
   ```

3. Run this command to install the trusted setup:

   ```bash
   ./install_dal_trusted_setup.sh
   ```

   If you are using a version of Octez prior to 21.1, add the `--legacy` argument to this command.

4. Run this command to start a DAL node and monitor slot 0:

   ```bash
   octez-dal-node run --observer-profiles=0 --data-dir _dal_node
   ```

Leave this process running in the terminal window.

## Accessing the slot data from a Smart Rollup

Follow these steps to update the Smart Rollup to access information about slot 0:

1. Update the `src/lib.rs` file to have this code:

   ```rust
   use tezos_smart_rollup::{host::RuntimeError, kernel_entry, prelude::*};
   use tezos_smart_rollup_host::dal_parameters::RollupDalParameters;

   const SLOT_TO_MONITOR: u8 = 0;

   pub fn run<R: Runtime>(
       host: &mut R,
       param: &RollupDalParameters,
       slot_index: u8,
   ) -> Result<(), RuntimeError> {
       let sol = host.read_input()?.unwrap();

       let target_level = sol.level as usize - param.attestation_lag as usize;

       let mut buffer = vec![0u8; param.page_size as usize];

       let bytes_read = host.reveal_dal_page(target_level as i32, slot_index, 0, &mut buffer)?;

       if 0 < bytes_read {
           debug_msg!(
               host,
               "Attested slot at index {} for level {}: {:?}\n",
               slot_index,
               target_level,
               &buffer.as_slice()[0..10]
           );
       } else {
           debug_msg!(
               host,
               "No attested slot at index {} for level {}\n",
               slot_index,
               target_level
           );
       }

       Ok(())
   }

   pub fn entry<R: Runtime>(host: &mut R) {
       let param = host.reveal_dal_parameters();
       debug_msg!(host, "{:?}\n", param);

       match run(host, &param, SLOT_TO_MONITOR) {
           Ok(()) => debug_msg!(host, "See you in the next level\n"),
           Err(_) => debug_msg!(host, "Something went wrong for some reasons"),
       }
   }

   kernel_entry!(entry);
   ```

   The key change is the addition of the function `run`.
   Using this function allows the code to use the `?` operator of Rust by using a function that returns a `Result` type.

   The `run` function proceeds as follows:

   1. First, it uses the DAL parameters to know the first level where a slot might be used.
      It subtracts the attestation lag from the current level, which it gets from the Smart Rollup inbox; the result is the most recent block that may have attested data in it.
   2. It allocates `Vec<u8>` buffer of the current page size.
   3. It attempts to fill the buffer with the `read_dal_page` function provided
      by the SDK.
   4. It checks the value returned by the function, which is the number of bytes
      read.
      Zero bytes mean that the slot has no attested data in it.
      Otherwise, it is necessarily the size of the page, because that's the size of the buffer.

2. Update the `Cargo.toml` file to add this dependency at the end:

   ```toml
   tezos-smart-rollup-host = { version = "0.2.2", features = [ "proto-alpha" ] }
   ```

   The end of the file looks like this:

   ```toml
   [dependencies]
   tezos-smart-rollup = { version = "0.2.2", features = [ "proto-alpha" ] }
   tezos-smart-rollup-host = { version = "0.2.2", features = [ "proto-alpha" ] }
   ```

3. Stop the process that is running the `octez-smart-rollup-node` program.

4. Run the commands to build and deploy the Smart Rollup and start the Smart Rollup node.

   If you set up the deployment script as described in [Part 2: Getting the DAL parameters](/tutorials/build-files-archive-with-dal/get-dal-params), you can run `./deploy_smart_rollup.sh my_wallet`, where `my_wallet` is the Octez client alias of your address.

   If not, run these commands, where `my_wallet` is the Octez client alias of your address:

   ```bash
   rm -rf _rollup_node
   cargo build --release --target wasm32-unknown-unknown
   cp target/wasm32-unknown-unknown/release/files_archive.wasm .

   smart-rollup-installer get-reveal-installer -P _rollup_node/wasm_2_0_0 \
     -u files_archive.wasm -o installer.hex

   octez-client originate smart rollup files_archive from my_wallet of kind wasm_2_0_0 \
     of type unit with kernel "$(cat installer.hex)" --burn-cap 2.0 --force

   octez-smart-rollup-node run observer for files_archive \
     with operators --data-dir _rollup_node \
     --dal-node http://localhost:10732 --log-kernel-debug
   ```

5. In another terminal window, view the log with the command `tail -F _rollup_node/kernel.log`.

The log shows information about slot 0, as in this example:

```
RollupDalParameters { number_of_slots: 32, attestation_lag: 8, slot_size: 126944, page_size: 3967 }
No attested slot at index 0 for level 7325504
See you in the next level
RollupDalParameters { number_of_slots: 32, attestation_lag: 8, slot_size: 126944, page_size: 3967 }
No attested slot at index 0 for level 7325505
See you in the next level
RollupDalParameters { number_of_slots: 32, attestation_lag: 8, slot_size: 126944, page_size: 3967 }
No attested slot at index 0 for level 7325506
See you in the next level
```

For the first 8 Tezos blocks produced after the origination of the Smart Rollup, the kernel will report that no slot has been attested for the targeted level, *even if Explorus states the opposite*.
This is because, as of January, 2024, a Smart Rollup cannot fetch the content of a slot published before it is originated.
This is why you must wait for 8 blocks before seeing slot page contents being
logged.

Now that you can see the state of the slots, you can find an unused slot and publish data to it.
When you are ready, continue to [Part 4: Publishing on the DAL](/tutorials/build-files-archive-with-dal/publishing-on-the-dal).


# Part 4: Publishing on the DAL

Now that you can get information about the DAL, the next step is to publish data to it and verify that the kernel can access it.

:::note Planning ahead
Before trying to run the code yourself, look at [Explorus](https://explorus.io/dal), select Ghostnet, and choose a slot that is not currently being used.
:::

The examples in this tutorial use slot 10.
Throughout the rest of this tutorial, replace slot 10 with the number of the slot that you choose.

## Switching slots

When you have selected a slot that does not appear to be in use, follow these steps to restart the Smart Rollup and DAL node:

1. Stop the DAL node and restart it with a new `--observer-profiles` argument.
   For example, this command uses slot 10:

   ```bash
   octez-dal-node run --observer-profiles=10 --data-dir _dal_node
   ```

2. In the `lib.rs` file, update the kernel to monitor that slot by updating this line:

   ```rust
   const SLOT_TO_MONITOR: u8 = 0;
   ```

   For example, to monitor slot 10, change the 0 to a 10, as in this code:

   ```rust
   const SLOT_TO_MONITOR: u8 = 10;
   ```

3. Stop the Smart Rollup node and run the commands to build and deploy the Smart Rollup and start the node.
   You can use the script in [Part 2: Getting the DAL parameters](/tutorials/build-files-archive-with-dal/get-dal-params) to simplify the process.

## Publishing messages

The DAL node provides an RPC endpoint for clients to send data to be added to a slot: `POST /slots`, whose body is the contents of the slot.

1. Run this command to publish a message to the DAL:

   ```bash
   curl localhost:10732/slots --data '"Hello, world!"' -H 'Content-Type: application/json'
   ```

   Note that the value of the message is in double quotes because it must be a valid JSON string, as hinted by the `Content-Type` header.

   This command assumes that you have not changed the default RPC server address.

   The command returns the certificate from the DAL node, which looks like this example:

   ```json
   {
     "commitment": "sh1u3tr3YKPDYUp2wWKCfmV5KZb82FREhv8GtDeR3EJccsBerWGwJYKufsDNH8rk4XqGrXdooZ",
     "commitment_proof":"8229c63b8e858d9a96321c80a204756020dd13243621c11bec61f182a23714cf6e0985675fff45f1164657ad0c7b9418"
   }
   ```

2. Using the values of the commitment and proof from the previous command, post the certificate to layer 1 with this command, being sure to set the slot number that you are using and replacing `my_wallet` with your Octez client alias of your address:

   ```bash
   commitment="sh1u3tr3YKPDYUp2wWKCfmV5KZb82FREhv8GtDeR3EJccsBerWGwJYKufsDNH8rk4XqGrXdooZ"
   proof="8229c63b8e858d9a96321c80a204756020dd13243621c11bec61f182a23714cf6e0985675fff45f1164657ad0c7b9418"
   octez-client publish dal commitment "${commitment}" from my_wallet for slot 10 with proof "${proof}"
   ```

   If the Octez client successfully published the commitment, the response to the command shows the slot number and the block (level) that it was published in.
   For example, this response shows that the commitment is in level 7325485 in slot 10:

   ```
   Data availability slot header publishing:
   Slot: slot_index: 13, commitment: sh1u3tr3YKPDYUp2wWKCfmV5KZb82FREhv8GtDeR3EJccsBerWGwJYKufsDNH8rk4XqGrXdooZ
   This data availability slot header publishing was successfully applied
   id:(published_level: 7325485, index: 10), commitment: sh1u3tr3YKPDYUp2wWKCfmV5KZb82FREhv8GtDeR3EJccsBerWGwJYKufsDNH8rk4XqGrXdooZ
   Consumed gas: 1331.033
   ```

3. Note the value of the `published_level` field in the response and look for that block number on [Explorus](https://explorus.io/dal).
   The slot that you published the message to turns blue, as in this picture:

   ![The Explorus record of slots in use, showing slot 10 in use](/img/tutorials/dal-explorus-blue-slot.png)

   The blue slot means that data was published to the slot but has not been attested yet.

   After 8 blocks, the slot turns green if bakers attested to the availability of the data or red if they did not.

   If the slot turns green, you should see a message in the kernel log that looks like this:

   ```
   RollupDalParameters { number_of_slots: 32, attestation_lag: 8, slot_size: 126944, page_size: 3967 }
   Attested slot at index 10 for level 7325485: [72, 101, 108, 108, 111, 44, 32, 119, 111, 114]
   See you in the next level
   ```

   You can verify your message by converting the bytes in the message back to the first 10 characters of the string "Hello, World!"

   You can also access the data from the DAL node by running this command, where `<PUBLISHED_LEVEL>` is the level that you published the data in and `<SLOT_INDEX>` is the slot that you used:

   ```bash
   curl localhost:10732/levels/<PUBLISHED_LEVEL>/slots/<SLOT_INDEX>/content | more
   ```

   This RPC endpoint returns the full contents of the slot, padded with zeros to the standard size of DAL slots on that network.
   You can copy the contents, omitting the zeros, and use a hexadecimal to string conversion tool to convert it back to a string.
   Online tools can convert hex to string, or you can use the `xxd` program, as in this example, which returns `Hello, world!`:

   ```bash
   echo -n '48656c6c6f2c20776f726c6421'  | xxd -r -p
   ```

## Troubleshooting

If you don't see the message that the slot is attested and contains your data, try these things:

* If you see a message that says "A slot header for this slot was already proposed," another transaction tried to write to that slot in the same block, so you must try again.

* Make sure that the Smart Rollup and the DAL node are both using the slot that you published the commitment to:

  * In the file `lib/src.rs`, the line `const SLOT_TO_MONITOR: u8 = 10;` should use your slot.
  * When you run the command to start the DAL node, make sure that the `--observer-profiles` argument is set to your slot:

    ```bash
    octez-dal-node run --observer-profiles=10 --data-dir _dal_node
    ```
  * When you run the command to publish the commitment to the DAL, make sure that you publish it to your slot:

    ```bash
    octez-client publish dal commitment "${commitment}" \
      from my_wallet for slot 10 with proof "${proof}"
    ```

* If the slot turned red on Explorus, these things may have happened:

  * The attesters could not download the data to attest it.
    This can happen if your DAL node is misconfigured and did not share the data with other DAL nodes.
    Verify that your DAL node is accessible from outside your local network and that it is running with the correct arguments.
    For example, DAL nodes can fail to share the data if they are configured with an attester configuration but are not connected to a baker with attestation rights.
    You can try deleting the DAL node configuration and restarting the node with the correct `--observer-profiles` argument.

  * The attesters for the network are offline.
    In this case, your Smart Rollup cannot use the data on the DAL, but the blue slot in Explorus verifies that you published it successfully.
    Without active attesters, you cannot continue with this tutorial.
    You can try running your own attester by getting tez from the faucet and running a baker as described in [Join the DAL as a baker, in 5 steps](/tutorials/join-dal-baker).

## Publishing files

You can also send raw bytes to the DAL node with the header `Content-Type: application/octet-stream`.
In this case, you must prefix the data with its size due to limitations of the DAL.

1. Install the `jq` and `xxd` programs.
   If you are using the Tezos Docker image, you can run `sudo apk add jq xxd`.

2. Create a file named `upload_file.sh` and add this code:

   ```bash
   #!/bin/sh

   path="${1}"
   alias="${2}"
   index="${3}"

   target="$(mktemp)"
   echo "storing temporary file at ${target}"
   file_size="$(cat "${path}" | wc -c)"
   slot_size_bin="$(printf "%08x" "${file_size}")"
   slot_contents="$(cat ${path} | xxd -p)"

   echo -n "${slot_size_bin}${slot_contents}" | xxd -p -r > "${target}"

   certificate="$(curl localhost:10732/slots --data-binary "@${target}" -H 'Content-Type: application/octet-stream')"

   echo "${certificate}"

   commitment="$(echo -n ${certificate} | jq '.commitment' -r)"
   proof="$(echo -n ${certificate} | jq '.commitment_proof' -r)"

   octez-client publish dal commitment "${commitment}" \
       from "${alias}" for slot "${index}" with proof "${proof}"

   rm "${target}"
   ```

3. Make the script executable by running this command:

   ```bash
   chmod +x upload_file.sh
   ```

4. Try uploading a file with the script.

   The script accepts three arguments: the file to send, the account alias to use and the slot index to use.
   This script also assumes that the `PATH` environment variable is correctly set.
   For example, if you create a file named `myFile.txt` and are using slot 10, you can run this command:

   ```bash
   ./upload_file.sh myFile.txt my_wallet 10
   ```

   If you run this script and see an error that says that the file was not found, update the first line of the script (the shebang) to the path to your shell interpreter.
   For example, if you are using the Tezos Docker image, the path is `/bin/sh`.

   In the next section, you see how to get the contents of the file that you published.

Now you can publish data to the DAL and use it in a Smart Rollup.
In the next section, you write to and retrieve the entire slot.
When you are ready, go to [Part 5: Using the entire slot](/tutorials/build-files-archive-with-dal/using-full-slot).


# Part 5: Using the entire slot

In some cases, you may want to retrieve the entire contents of a slot.
For example, it can be convenient to get the entire slot because it has a fixed size, while the data in the slot may be smaller and padded to fit the slot.

## Fetching and storing the full slot

Retrieving the full slot is similar to retrieving any data from the slot.
In this case, you change the kernel to retrieve data of the exact size of the slot.

1. Update the `run` function in the `lib/rs` file to this code, without changing the rest of the file:

   ```rust
   pub fn run<R: Runtime>(
       host: &mut R,
       param: &RollupDalParameters,
       slot_index: u8,
   ) -> Result<(), RuntimeError> {
       // Reading one message from the shared inbox is always safe,
       // because the shared inbox contains at least 3 messages per
       // Tezos block.
       let sol = host.read_input()?.unwrap();

       let target_level = sol.level as usize - param.attestation_lag as usize;

       let mut buffer = vec![0u8; param.slot_size as usize];

       let bytes_read = host.reveal_dal_page(target_level as i32, slot_index, 0, &mut buffer)?;

       if bytes_read == 0 {
           debug_msg!(
               host,
               "No attested slot at index {} for level {}\n",
               slot_index,
               target_level
           );

           return Ok(());
       }

       debug_msg!(
           host,
           "Attested slot at index {} for level {}\n",
           slot_index,
           target_level
       );

       let num_pages = param.slot_size / param.page_size;

       for page_index in 1..num_pages {
           let _result = host.reveal_dal_page(
               target_level as i32,
               slot_index,
               page_index.try_into().unwrap(),
               &mut buffer[page_index as usize * (param.page_size as usize)
                   ..(page_index as usize + 1) * (param.page_size as usize)],
           );
       }

       let hash = blake2b::digest(&buffer, 32).unwrap();
       let key = hex::encode(hash);
       let path = OwnedPath::try_from(format!("/{}", key)).unwrap();

       debug_msg!(host, "Saving slot under `{}'\n", path);

       let () = host.store_write_all(&path, &buffer)?;

       Ok(())
   }
   ```

   Now the `run` function works like this:

   1. It allocates a buffer of the size of a slot, not a size of a page.
   2. It tries to fetch the contents of the first page.
      If 0 bytes are written by `reveal_dal_page`, the targeted slot has not been
      attested for this block.
   3. If the targeted slot has been attested, the function reads as many pages as necessary to get the full slot data.
   4. It stores the data in the durable storage, using the Blake2B hash (encoded in hexadecimal) as its key.

2. Add these `use` statements to the beginning of the file:

   ```rust
   use tezos_crypto_rs::blake2b;
   use tezos_smart_rollup::storage::path::OwnedPath;
   ```

   These dependencies use `tezos_crypto_rs` for hashing, and `hex` for encoding.

3. Add the matching dependencies to the end of the `Cargo.toml` file:

   ```toml
   tezos_crypto_rs = { version = "0.5.2", default-features = false }
   hex = "0.4.3"
   ```

   Adding `default-features = false` for `tezos_crypto_rs` is necessary for the crate to be compatible with Smart Rollups.

4. Deploy the Smart Rollup again, publish a file as you did in the previous section, and wait for enough levels to pass.
   The Smart Rollup log shows the hash of the data, as in this example:

   ```
   RollupDalParameters { number_of_slots: 32, attestation_lag: 8, slot_size: 126944, page_size: 3967 }
   Attested slot at index 10 for level 7325751
   Saving slot under `/6a578d1e6746d29243ff81923bcea6375e9344d719ca118e14cd9f3d3b00cd96'
   See you in the next level
   ```

5. Get the data from the slot by passing the hash, as in this example:

   ```bash
   hash=6a578d1e6746d29243ff81923bcea6375e9344d719ca118e14cd9f3d3b00cd96
   curl "http://localhost:8932/global/block/head/durable/wasm_2_0_0/value?key=/${hash}" \
       -H 'Content-Type: application/octet-stream' \
       -o slot.bin
   ```

6. Convert the contents of the slot to text by running this command:

   ```bash
   xxd -r -p slot.bin
   ```

   The console shows your message in text, such as "Hi! This is a message to go on the DAL."

:::note Why `diff` won't work
You cannot use `diff` to ensure that the file you originally published and the one that you downloaded from the rollup node are equal.
Indeed, they are not: because the size of a slot is fixed, the DAL node pads the value it receives from `POST /slots` in order to ensure that it has the correct slot size.
:::

## Next steps

Now you know how to send files to the DAL and use a Smart Rollup to store the data.

From there, the sky's the limit.
You can implement many other features, such as:

* Handling more than one file per level
* Having file publishers pay for the storage that they are using in layer 2 by allowing them to deposit tez to the Smart Rollup and sign the files they publish
* Building a frontend to visualize the files in the archive
* Providing the original size of the file by modifying the script to prefix the file with its size


