"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1489],{57241:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>l,frontMatter:()=>a,metadata:()=>r,toc:()=>h});const r=JSON.parse('{"id":"tutorials/smartpy-fa2-fungible/customizing-operations","title":"Part 4: Customizing operations","description":"As shown in previous parts, the SmartPy FA2 library provides the entrypoints that the standard requires.","source":"@site/docs/tutorials/smartpy-fa2-fungible/customizing-operations.md","sourceDirName":"tutorials/smartpy-fa2-fungible","slug":"/tutorials/smartpy-fa2-fungible/customizing-operations","permalink":"/previews/docs/biel-chatbot/tutorials/smartpy-fa2-fungible/customizing-operations","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1715054400000,"frontMatter":{"title":"Part 4: Customizing operations","authors":"Tim McMackin","last_update":{"date":"7 May 2024"}},"sidebar":"tutorialsSidebar","previous":{"title":"Part 3: Adding metadata","permalink":"/previews/docs/biel-chatbot/tutorials/smartpy-fa2-fungible/adding-metadata"},"next":{"title":"Part 5: Deploying the contract","permalink":"/previews/docs/biel-chatbot/tutorials/smartpy-fa2-fungible/deploying-contract"}}');var s=n(74848),o=n(28453);const a={title:"Part 4: Customizing operations",authors:"Tim McMackin",last_update:{date:"7 May 2024"}},i=void 0,c={},h=[{value:"Tutorial contract",id:"tutorial-contract",level:2},{value:"Exchanging one token for another",id:"exchanging-one-token-for-another",level:2}];function d(e){const t={a:"a",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"As shown in previous parts, the SmartPy FA2 library provides the entrypoints that the standard requires.\nYou can override these entrypoints, but you must be sure to follow the standard.\nYou can also customize their behavior by setting security policies."}),"\n",(0,s.jsx)(t.p,{children:"You can also customize the contract by adding your own entrypoints.\nIn this part, you add an entrypoint that allows users to exchange one token for another.\nTo convert one token into another, the entrypoint follows these general steps:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"Verify that the source and target tokens are defined."}),"\n",(0,s.jsx)(t.li,{children:"Burn the source tokens by decreasing the amount in the ledger for the account or fail if the account doesn't have enough."}),"\n",(0,s.jsx)(t.li,{children:"Mint the target tokens by increasing the amount in the ledger for the account."}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["The burn and mint steps are straightforward as long as you understand how FA2 contracts store information in their ledger.\nAs described in ",(0,s.jsx)(t.a,{href:"/tutorials/smartpy-fa2-fungible/basic-fa2-token",children:"Part 1"}),", the contract stores information about who owns tokens in a key-value store:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"The key is a pair that contains the address of the owner and the ID of the token"}),"\n",(0,s.jsx)(t.li,{children:"The value is the quantity of tokens"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"In table format, the ledger might look like this after some mint and burn transactions:"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"key"}),(0,s.jsx)(t.th,{children:"value"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Alice, token ID 0"}),(0,s.jsx)(t.td,{children:"10"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Alice, token ID 1"}),(0,s.jsx)(t.td,{children:"2"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Alice, token ID 2"}),(0,s.jsx)(t.td,{children:"1"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Alice, token ID 4"}),(0,s.jsx)(t.td,{children:"5"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Bob, token ID 1"}),(0,s.jsx)(t.td,{children:"2"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Bob, token ID 2"}),(0,s.jsx)(t.td,{children:"8"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Bob, token ID 3"}),(0,s.jsx)(t.td,{children:"14"})]})]})]}),"\n",(0,s.jsx)(t.p,{children:"That means that to get the amount of the source token that an account has, you must put the address and token ID together as a pair."}),"\n",(0,s.jsx)(t.h2,{id:"tutorial-contract",children:"Tutorial contract"}),"\n",(0,s.jsxs)(t.p,{children:["The completed contract that you create in this part is at ",(0,s.jsx)(t.a,{href:"https://github.com/trilitech/tutorial-applications/blob/main/smartpy_fa2_fungible/part_4_complete.py",children:"part_4_complete.py"}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"exchanging-one-token-for-another",children:"Exchanging one token for another"}),"\n",(0,s.jsxs)(t.p,{children:["Follow these steps to create the ",(0,s.jsx)(t.code,{children:"convert"})," entrypoint that exchanges one token for another:"]}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["At the beginning of the module, after the ",(0,s.jsx)(t.code,{children:"def my_module():"})," statement but before the ",(0,s.jsx)(t.code,{children:"class"})," statement, add a type that represents the information for a token transfer:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-smartpy",children:"conversion_type: type = sp.record(\n    source_token_id = sp.nat,  # The ID of the source token\n    target_token_id = sp.nat,  # The ID of the target token\n    amount = sp.nat,  # The number of source tokens to convert\n)\n"})}),"\n",(0,s.jsx)(t.p,{children:"The type includes the ID of the source token, the ID of the token to convert it into, and the amount of tokens to convert."}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"After this type, create a type that is a list of conversions:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-smartpy",children:"conversion_batch: type = sp.list[conversion_type]\n"})}),"\n",(0,s.jsxs)(t.p,{children:["This type is the parameter for the ",(0,s.jsx)(t.code,{children:"convert"})," entrypoint.\nThe FA2 standard says that custom entrypoints should accept batches for parameters to allow users to do multiple things in a single transaction."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["After the ",(0,s.jsx)(t.code,{children:"__init__()"})," function, add an entrypoint with the ",(0,s.jsx)(t.code,{children:"@sp.entrypoint"})," annotation and accept a parameter of the ",(0,s.jsx)(t.code,{children:"conversion_match"})," type:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-smartpy",children:"# Convert one token into another\n@sp.entrypoint\ndef convert(self, batch):\n    sp.cast(batch, conversion_batch)\n"})}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"Loop over the conversions in the batch:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-smartpy",children:"for conversion in batch:\n"})}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"Within the loop, destructure the conversion into individual variables:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-smartpy",children:"record(source_token_id, target_token_id, amount).match = conversion\n"})}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"Add this code to verify that the contract's security policy allows transfers (which it does by default) and that the source and target token exist:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-smartpy",children:'# Verify that transfers are allowed\nassert self.private.policy.supports_transfer, "FA2_TX_DENIED"\n# Verify that the source and target tokens exist\nassert self.is_defined_(source_token_id), "FA2_TOKEN_UNDEFINED"\nassert self.is_defined_(target_token_id), "FA2_TOKEN_UNDEFINED"\n'})}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"Create a pair that represents the key for the source token type:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-smartpy",children:"# Get a pair to represent the key for the ledger for the source tokens\nfrom_source = (sp.sender, source_token_id)\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Note that this code uses ",(0,s.jsx)(t.code,{children:"sp.sender"})," instead of ",(0,s.jsx)(t.code,{children:"sp.source"})," to identify the account that sent the transaction.\nThe source is the account that initiated the original transaction that led to this entrypoint call, while the sender is the account that made the call that led directly to this entrypoint call.\nUsing sender here is important to prevent other contracts from accepting a transaction from an account and then sending other transactions that impersonate that account.\nFor more information, see ",(0,s.jsx)(t.a,{href:"https://opentezos.com/smart-contracts/avoiding-flaws",children:"Avoiding flaws"})," on opentezos.com."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"Add this code to burn the source tokens:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-smartpy",children:'# Burn the source tokens\nself.data.ledger[from_source] = sp.as_nat(\n    self.data.ledger.get(from_source, default=0) - amount,\n    error="FA2_INSUFFICIENT_BALANCE",\n)\nis_supply = sp.is_nat(\n    self.data.supply.get(source_token_id, default=0) - amount\n)\nwith sp.match(is_supply):\n    with sp.case.Some as supply:\n        self.data.supply[source_token_id] = supply\n    with None:\n        self.data.supply[source_token_id] = 0\n'})}),"\n",(0,s.jsx)(t.p,{children:"This code uses the key from the previous step to subtract the tokens from the ledger entry.\nThen it updates the contract storage with the total number of that type of token remaining."}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"Add this code to create a pair that represents the key for the target token type:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-smartpy",children:"# Get a pair to represent the key for the ledger for the target tokens\nfrom_target = (sp.sender, target_token_id)\n"})}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"Add this code to mint the target tokens:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-smartpy",children:"# Mint the target tokens\ntarget_amount = self.data.ledger.get(from_target, default=0)\nself.data.ledger[from_target] = amount + target_amount\nself.data.supply[target_token_id] += amount\n"})}),"\n",(0,s.jsx)(t.p,{children:"This code attempts to retrieve the record by the pair in the previous step.\nIf it exists, the code adds the number of tokens to the existing amount.\nIf not, it creates a new record in the ledger.\nFinally, it increases the supply of that token."}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"At the end of the file, add this test to verify that a user can convert their own tokens:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-smartpy",children:'scenario.h2("Convert tokens")\n\n# Verify that you can convert your own tokens\nconversions = [\n    sp.record(source_token_id = 0, target_token_id = 1, amount = 2),\n]\ncontract.convert(\n    conversions,\n    _sender=alice\n)\nscenario.verify(\n    _get_balance(contract, sp.record(owner=alice.address, token_id=0)) == 8\n)\nscenario.verify(\n    _get_balance(contract, sp.record(owner=alice.address, token_id=1)) == 5\n)\nscenario.verify(_total_supply(contract, sp.record(token_id=0)) == 12)\nscenario.verify(_total_supply(contract, sp.record(token_id=1)) == 16)\n'})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"That's all that's necessary to convert one fungible token into another.\nIf you wanted to extend this feature, you could implement an exchange rate, take a fee for converting tokens, or allow only certain accounts to convert tokens.\nYou could also test the entrypoint more thoroughly, such as testing that a user can't convert more tokens than they have."}),"\n",(0,s.jsxs)(t.p,{children:["If you want to, you can deploy this new contract to the mockup mode with the same commands as in ",(0,s.jsx)(t.a,{href:"/tutorials/smartpy-fa2-fungible/basic-fa2-token",children:"Part 1: Setting up a simple FA2 token"})," and try it out locally.\nIn the next section, you deploy it to a test network."]})]})}function l(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>i});var r=n(96540);const s={},o=r.createContext(s);function a(e){const t=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(o.Provider,{value:t},e.children)}}}]);