"use strict";(self.webpackChunktezos_developer_docs=self.webpackChunktezos_developer_docs||[]).push([[9744],{23241:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>a,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"architecture/smart-rollups","title":"Smart Rollups","description":"Smart Rollups play a crucial part in providing high scalability on Tezos.","source":"@site/docs/architecture/smart-rollups.md","sourceDirName":"architecture","slug":"/architecture/smart-rollups","permalink":"/previews/docs/biel-chatbot/architecture/smart-rollups","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1738126800000,"frontMatter":{"title":"Smart Rollups","authors":"Nomadic Labs, TriliTech, Tim McMackin","last_update":{"date":"29 January 2025"}},"sidebar":"documentationSidebar","previous":{"title":"FA2.1 tokens","permalink":"/previews/docs/biel-chatbot/architecture/tokens/FA2.1"},"next":{"title":"The Data Availability Layer","permalink":"/previews/docs/biel-chatbot/architecture/data-availability-layer"}}');var i=n(74848),s=n(28453);const a={title:"Smart Rollups",authors:"Nomadic Labs, TriliTech, Tim McMackin",last_update:{date:"29 January 2025"}},r=void 0,l={},c=[{value:"Uses for Smart Rollups",id:"uses-for-smart-rollups",level:2},{value:"Communication",id:"communication",level:2},{value:"Rollup inbox",id:"rollup-inbox",level:3},{value:"Commitments",id:"commitments",level:2},{value:"Bonds",id:"bonds",level:2},{value:"Reveal data channel",id:"reveal-data-channel",level:3},{value:"Smart Rollup lifecycle",id:"smart-rollup-lifecycle",level:2},{value:"Origination",id:"origination",level:3},{value:"Commitment periods",id:"commitment-periods",level:3},{value:"Refutation periods",id:"refutation-periods",level:3},{value:"Triggering outbox messages",id:"triggering-outbox-messages",level:3},{value:"Bailout process",id:"bailout-process",level:3},{value:"Examples",id:"examples",level:2}];function h(e){const t={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"Smart Rollups play a crucial part in providing high scalability on Tezos.\nThey handle logic in a separate environment that can run transactions at a much higher rate and can use larger amounts of data than the main Tezos network."}),"\n",(0,i.jsxs)(t.p,{children:["The transactions and logic that Smart Rollups run is called ",(0,i.jsx)(t.em,{children:"layer 2"})," to differentiate it from the main network, which is called ",(0,i.jsx)(t.em,{children:"layer 1"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["Anyone can run a node based on a Smart Rollup to execute its code and verify that other nodes are running it correctly, just like anyone can run nodes, bakers, and accusers on layer 1.\nThis code, called the ",(0,i.jsx)(t.em,{children:"kernel"}),", runs in a deterministic manner and according to a given semantics, which guarantees that results are reproducible by any rollup node with the same kernel.\nThe semantics is precisely defined by a reference virtual machine called a proof-generating virtual machine (PVM), able to generate a proof that executing a program in a given context results in a given state.\nDuring normal execution, the Smart Rollup can use any virtual machine that is compatible with the PVM semantics, which allows the Smart Rollup to be more efficient."]}),"\n",(0,i.jsx)(t.p,{children:"Using the PVM and optionally a compatible VM guarantees that if a divergence in results is found, it can be tracked down to a single elementary step that was not executed correctly by some node.\nIn this way, multiple nodes can run the same rollup and each node can verify the state of the rollup."}),"\n",(0,i.jsxs)(t.p,{children:["For a tutorial on Smart Rollups, see ",(0,i.jsx)(t.a,{href:"/tutorials/smart-rollup",children:"Deploy a Smart Rollup"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["For reference on Smart Rollups, see ",(0,i.jsx)(t.a,{href:"https://octez.tezos.com/docs/active/smart_rollups.html",children:"Smart Optimistic Rollups"})," in the Octez documentation."]}),"\n",(0,i.jsx)(t.p,{children:"This diagram shows a high-level view of how Smart Rollups interact with layer 1:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Diagram of Smart Rollup architecture",src:n(82271).A+"",width:"1760",height:"1312"})}),"\n",(0,i.jsx)(t.h2,{id:"uses-for-smart-rollups",children:"Uses for Smart Rollups"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Smart Rollups allow you to run large amounts of processing and manipulate large amounts of data that would be too slow or expensive to run on layer 1."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Smart Rollups can run far more transactions per second than layer 1."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Smart Rollups allow you to avoid some transaction fees and storage fees."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Smart Rollups can retrieve data from outside the blockchain in specific ways that smart contracts can't."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["Smart Rollups can implement different execution environments, such as execution environments that are compatible with other blockchains.\nFor example, Smart Rollups enable ",(0,i.jsx)(t.a,{href:"https://www.etherlink.com/",children:"Etherlink"}),", which makes it possible to run EVM applications (originally written for Ethereum) on Tezos."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"communication",children:"Communication"}),"\n",(0,i.jsx)(t.p,{children:"Smart Rollups are limited to information from these sources:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"The Smart Rollup inbox, which contains messages from layer 1 to all rollups"}),"\n",(0,i.jsx)(t.li,{children:"The reveal data channel, which allows Smart Rollups to request information from outside sources"}),"\n",(0,i.jsxs)(t.li,{children:["The ",(0,i.jsx)(t.a,{href:"/architecture/data-availability-layer",children:"Data availability layer"})]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"These are the only sources of information that rollups can use.\nIn particular, Smart Rollup nodes cannot communicate directly with each other; they do not have a peer-to-peer communication channel like layer 1 nodes."}),"\n",(0,i.jsx)(t.h3,{id:"rollup-inbox",children:"Rollup inbox"}),"\n",(0,i.jsxs)(t.p,{children:["Each layer 1 block has a ",(0,i.jsx)(t.em,{children:"rollup inbox"})," that contains messages from layer 1 to all rollups.\nAnyone can add a message to this inbox and all messages are visible to all rollups.\nSmart Rollups filter the inbox to the messages that they are interested in and act on them accordingly."]}),"\n",(0,i.jsxs)(t.p,{children:["The messages that users add to the rollup inbox are called ",(0,i.jsx)(t.em,{children:"external messages"}),".\nFor example, users can add messages to the inbox with the Octez client ",(0,i.jsx)(t.code,{children:"send smart rollup message"})," command."]}),"\n",(0,i.jsxs)(t.p,{children:["Similarly, smart contracts can add messages in a way similar to calling a smart contract entrypoint, by using the Michelson ",(0,i.jsx)(t.code,{children:"TRANSFER_TOKENS"})," instruction.\nThe messages that smart contracts add to the inbox are called ",(0,i.jsx)(t.em,{children:"internal messages"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"Each block also contains the following internal messages, which are created by the protocol:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"Start of level"}),", which indicates the beginning of the block"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"Info per level"}),", which includes the timestamp and block hash of the preceding block"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"End of level"}),", which indicates the end of the block"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Smart Rollup nodes can use these internal messages to know when blocks begin and end."}),"\n",(0,i.jsx)(t.h2,{id:"commitments",children:"Commitments"}),"\n",(0,i.jsx)(t.p,{children:"Some Smart Rollup nodes post commitments to layer 1, which include a hash of the current state of the kernel.\nIf any node's commitment is different from the others, they play a refutation game to determine the correct commitment, eliminate incorrect commitments, and penalize the nodes that posted incorrect commitments.\nThis process ensures the security of the Smart Rollup by verifying that the nodes are running the kernel faithfully."}),"\n",(0,i.jsx)(t.p,{children:"Only Smart Rollup nodes running in operator or maintenance mode post these commitments on a regular basis.\nNodes running in other modes such as observer mode run the kernel and monitor the state of the Smart Rollup just like nodes in operator or maintenance mode, but they do not post commitments.\nNodes running in accuser mode monitor other commitments and post their own commitment only when it differs from other commitments."}),"\n",(0,i.jsx)(t.h2,{id:"bonds",children:"Bonds"}),"\n",(0,i.jsxs)(t.p,{children:["When a user runs a node that posts commitments, the protocol automatically locks a bond of 10,000 liquid, unstaked tez from user's account as assurance that they are running the kernel faithfully.\nIf the node posts a commitment that is refuted, they lose their bond, as described in ",(0,i.jsx)(t.a,{href:"#refutation-periods",children:"Refutation periods"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"Because nodes have the length of the refutation to challenge another node's commitment, the bond stays locked until the end of the refutation period for the last commitment that the node posted.\nRecovering the bond safely takes a few steps; in general, node operators follow these steps:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["Switch the rollup node to a mode that defends previously made commitments but does not post new commitments, such as ",(0,i.jsx)(t.code,{children:"accuser"})," mode or ",(0,i.jsx)(t.code,{children:"bailout"})," mode."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Keep the node running until the last commitment is cemented.\nIf operators shut down the node before the last commitment is cemented, they risk losing their bond if another node challenges their commitments."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["Recover the bond by running the ",(0,i.jsx)(t.code,{children:"octez-client recover bond"})," command, which unlocks their tez.\nNodes running in ",(0,i.jsx)(t.code,{children:"bailout"})," mode run this command automatically when the last commitment is cemented."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["For an example of how to use bailout mode to recover your bond, see ",(0,i.jsx)(t.a,{href:"https://docs.etherlink.com/network/smart-rollup-nodes/#stopping-the-smart-rollup-node",children:"Stopping the Smart Rollup node"})," in the Etherlink documentation."]}),"\n",(0,i.jsx)(t.h3,{id:"reveal-data-channel",children:"Reveal data channel"}),"\n",(0,i.jsxs)(t.p,{children:["Smart Rollups can request arbitrary information through the ",(0,i.jsx)(t.em,{children:"reveal data channel"}),".\nImportantly, as opposed to internal and external messages, the information that passes through the reveal data channel does not pass through layer 1, so it is not limited by the bandwidth of layer 1 and can include large amounts of data."]}),"\n",(0,i.jsx)(t.p,{children:"The reveal data channel supports these requests:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["A rollup node can request an arbitrary data page up to 4KB if it knows the blake2b hash of the page, known as ",(0,i.jsx)(t.em,{children:"preimage requests"}),".\nTo transfer more than 4KB of data, rollups must use multiple pages, which may contain hashes that point to other pages."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["A rollup node can request information about the rollup, including the address and origination level of the rollup, known as ",(0,i.jsx)(t.em,{children:"metadata requests"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"smart-rollup-lifecycle",children:"Smart Rollup lifecycle"}),"\n",(0,i.jsx)(t.p,{children:"The general flow of a Smart Rollup goes through these phases:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"Origination: A user originates the Smart Rollup to layer 1."}),"\n",(0,i.jsx)(t.li,{children:"One or more users start Smart Rollup nodes."}),"\n",(0,i.jsx)(t.li,{children:"Commitment periods: The Smart Rollup nodes receive the messages in the Smart Rollup inbox, run processing based on those messages, generate but do not run outbox messages, and publish a hash of their state at the end of the period, called a commitment."}),"\n",(0,i.jsx)(t.li,{children:"Refutation periods: Nodes can publish a concurrent commitment to refute a published commitment."}),"\n",(0,i.jsx)(t.li,{children:"Triggering outbox messages: When the commitment can no longer be refuted, any client can trigger outbox messages, which create transactions."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Here is more information on each of these phases:"}),"\n",(0,i.jsx)(t.h3,{id:"origination",children:"Origination"}),"\n",(0,i.jsxs)(t.p,{children:["Like smart contracts, users deploy Smart Rollups to layer 1 in a process called ",(0,i.jsx)(t.em,{children:"origination"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"The origination process stores data about the rollup on layer 1, including:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["An address for the rollup, which starts with ",(0,i.jsx)(t.code,{children:"sr1"})]}),"\n",(0,i.jsxs)(t.li,{children:["The type of proof-generating virtual machine (PVM) for the rollup, which defines the execution engine of the rollup kernel; currently only the ",(0,i.jsx)(t.code,{children:"wasm_2_0_0"})," PVM is supported"]}),"\n",(0,i.jsx)(t.li,{children:"The installer kernel, which is a WebAssembly program that allows nodes to download and install the complete rollup kernel"}),"\n",(0,i.jsx)(t.li,{children:"The Michelson data type of the messages it receives from layer 1"}),"\n",(0,i.jsx)(t.li,{children:"The genesis commitment that forms the basis for commitments that rollups nodes publish in the future"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"After it is originated, anyone can run a Smart Rollup node based on this information."}),"\n",(0,i.jsx)(t.h3,{id:"commitment-periods",children:"Commitment periods"}),"\n",(0,i.jsxs)(t.p,{children:["Starting from the rollup origination level, levels are partitioned into ",(0,i.jsx)(t.em,{children:"commitment periods"})," of 60 consecutive layer 1 blocks.\nDuring each commitment period, each rollup node receives the messages in the rollup inbox, processes them, and updates its state."]}),"\n",(0,i.jsx)(t.p,{children:'Because Smart Rollup nodes behave in a deterministic manner, their states should all be the same if they have processed the same inbox messages with the same kernel starting from the same origination level.\nThis state is referred to as the "state of the rollup."'}),"\n",(0,i.jsx)(t.p,{children:"Any time after each commitment period, Smart Rollup nodes in operator mode or maintenance mode publish a hash of their state to layer 1 as part of its commitment.\nEach commitment builds on the previous commitment, and so on, back to the genesis commitment from when the Smart Rollup was originated.\nThe protocol locks 10,000 tez as a bond from the operator of each node that posts commitments."}),"\n",(0,i.jsx)(t.p,{children:"At the end of a commitment period, the next commitment period starts."}),"\n",(0,i.jsx)(t.h3,{id:"refutation-periods",children:"Refutation periods"}),"\n",(0,i.jsx)(t.p,{children:"Because the PVM is deterministic and all of the inputs are the same for all nodes, any honest node that runs the same Smart Rollup produces the same commitment.\nAs long as nodes publish matching commitments, they continue running normally."}),"\n",(0,i.jsxs)(t.p,{children:["When the first commitment for a past commitment period is published, a refutation period starts, during which any rollup node can publish its own commitment for the same commitment period, especially if it did not achieve the same state.\nDuring the refutation period for a commitment period, if two or more nodes publish different commitments, two of them play a ",(0,i.jsx)(t.em,{children:"refutation game"})," to identify the correct commitment.\nThe nodes automatically play the refutation game by stepping through their logic using the PVM to identify the point at which they differ.\nAt this point, the PVM is used to identify the correct commitment, if any."]}),"\n",(0,i.jsx)(t.p,{children:"Each refutation game has one of two results:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Neither commitment is correct.\nIn this case, the protocol burns both commitments' stakes and eliminates both commitments."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"One commitment is correct and the other is not.\nIn this case, the protocol eliminates the incorrect commitment, burns half of the incorrect commitment's stake, and gives the other half to the correct commitment's stake."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"This refutation game happens as many times as is necessary to eliminate incorrect commitments.\nBecause the node that ran the PVM correctly is guaranteed to win the refutation game, a single honest node is enough to ensure that the Smart Rollup is running correctly.\nThis kind of Smart Rollup is called a Smart Optimistic Rollup because the commitments are assumed to be correct until they are proven wrong by an honest rollup node."}),"\n",(0,i.jsxs)(t.p,{children:["When there is only one commitment left, either because all nodes published identical commitments during the whole refutation period or because this commitment won the refutation games and eliminated all other commitments, then this correct commitment can be ",(0,i.jsx)(t.em,{children:"cemented"})," by a dedicated layer 1 operation and becomes final and unchangeable.\nThe commitments for the next commitment period build on the last cemented commitment."]}),"\n",(0,i.jsxs)(t.p,{children:["The refutation period lasts for a set number of blocks based on the ",(0,i.jsx)(t.code,{children:"smart_rollup_challenge_window_in_blocks"})," protocol constant.\nThis period adds up to two weeks on Mainnet and Ghostnet, but it could be different on other networks."]}),"\n",(0,i.jsx)(t.p,{children:"However, the refutation period for a specific commitment can vary if it is uncemented when a protocol upgrade changes the block times."}),"\n",(0,i.jsx)(t.p,{children:"When the time between blocks changes, the protocol adjusts the number of blocks in the refutation period to keep the refutation period at the same real-world length.\nIt uses this new number of blocks to determine whether commitments can be cemented."}),"\n",(0,i.jsx)(t.p,{children:"For this reason, if the block time gets shorter during the commitment's refutation period, the number of blocks that must pass before cementing a commitment increases.\nTherefore, commitments that are not cemented when the number of blocks changes must wait slightly longer before they can be cemented."}),"\n",(0,i.jsx)(t.p,{children:"This variation affects only commitments that are not cemented when the layer 1 protocol upgrade happens.\nThe delay is based on how much the block times changed and on how close a commitment is to being cemented when the number of blocks in the refutation period changes."}),"\n",(0,i.jsx)(t.p,{children:"The maximum change is the new block time divided by the old block time multiplied by the standard refutation period.\nFor example, if the new block time is 8 seconds and the old block time is 10 seconds, the maximum addition to a commitment's refutation period is 10 / 8, or 1.25 times the standard 14-day period.\nCommitments that are close to being cemented when the block time changes have the largest change to their refutation periods, while commitments that are made close to when the block time changes have a very small change."}),"\n",(0,i.jsx)(t.h3,{id:"triggering-outbox-messages",children:"Triggering outbox messages"}),"\n",(0,i.jsx)(t.p,{children:"Smart Rollups can generate transactions to run on layer 1, but those transactions do not run immediately.\nWhen a commitment includes layer 1 transactions, these transactions go into the Smart Rollup outbox and wait for the commitment to be cemented."}),"\n",(0,i.jsxs)(t.p,{children:["After the commitment is cemented, clients can trigger transactions in the outbox with the Octez client ",(0,i.jsx)(t.code,{children:"execute outbox message"})," command.\nWhen they trigger a transaction, it runs like any other call to a smart contract.\nFor more information, see ",(0,i.jsx)(t.a,{href:"https://octez.tezos.com/docs/shell/smart_rollup_node.html#triggering-the-execution-of-an-outbox-message",children:"Triggering the execution of an outbox message"})," in the Octez documentation."]}),"\n",(0,i.jsx)(t.h3,{id:"bailout-process",children:"Bailout process"}),"\n",(0,i.jsx)(t.p,{children:"Nodes that do not post commitments can stop running at any time without risk because they do not have a bond.\nNodes that post commitments cannot stop immediately without risking their bonds because they will not be online to participate in the refutation game."}),"\n",(0,i.jsxs)(t.p,{children:["For this reason, nodes can switch to bailout mode to prepare to shut down without risking their bonds.\nIn bailout mode, nodes defend their existing commitments without posting new commitments.\nWhen their final commitment is cemented, they can shut down safely.\nFor more information about node modes, see ",(0,i.jsx)(t.a,{href:"https://octez.tezos.com/docs/shell/smart_rollup_node.html",children:"Smart rollup node"})," in the Octez documentation."]}),"\n",(0,i.jsx)(t.h2,{id:"examples",children:"Examples"}),"\n",(0,i.jsxs)(t.p,{children:["For examples of Smart Rollups, see this repository: ",(0,i.jsx)(t.a,{href:"https://gitlab.com/tezos/kernel-gallery",children:"https://gitlab.com/tezos/kernel-gallery"}),"."]})]})}function m(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},82271:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/smart-rollup-architecture-ca6a56a655c8b1471559b011111c9ec9.png"},28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>r});var o=n(96540);const i={},s=o.createContext(i);function a(e){const t=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),o.createElement(s.Provider,{value:t},e.children)}}}]);