"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[495],{80810:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>c,metadata:()=>o,toc:()=>r});const o=JSON.parse('{"id":"dApps/wallets","title":"Connecting to wallets","description":"dApps must connect to user wallets to view the tokens in the account and to submit transactions on behalf of the wallet\'s owner.","source":"@site/docs/dApps/wallets.md","sourceDirName":"dApps","slug":"/dApps/wallets","permalink":"/previews/docs/biel-chatbot/dApps/wallets","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1699246800000,"frontMatter":{"title":"Connecting to wallets","authors":"Claude Barde, Tim McMackin","last_update":{"date":"6 November 2023"},"dependencies":{"taquito":"21.0.1"}},"sidebar":"documentationSidebar","previous":{"title":"Sample dApps","permalink":"/previews/docs/biel-chatbot/dApps/samples"},"next":{"title":"Sending transactions","permalink":"/previews/docs/biel-chatbot/dApps/sending-transactions"}}');var a=t(74848),s=t(28453);const c={title:"Connecting to wallets",authors:"Claude Barde, Tim McMackin",last_update:{date:"6 November 2023"},dependencies:{taquito:"21.0.1"}},i=void 0,l={},r=[{value:"Beacon and Taquito",id:"beacon-and-taquito",level:2},{value:"Connecting to wallets",id:"connecting-to-wallets",level:3},{value:"Reconnecting to wallets",id:"reconnecting-to-wallets",level:3},{value:"Disconnecting wallets",id:"disconnecting-wallets",level:3},{value:"Beacon by itself",id:"beacon-by-itself",level:2},{value:"Connecting to wallets",id:"connecting-to-wallets-1",level:3},{value:"Reconnecting to wallets",id:"reconnecting-to-wallets-1",level:3},{value:"Disconnecting wallets",id:"disconnecting-wallets-1",level:3},{value:"Other tools",id:"other-tools",level:2},{value:"Best practices",id:"best-practices",level:2},{value:"Keep tools up to date",id:"keep-tools-up-to-date",level:3},{value:"Reuse connected accounts",id:"reuse-connected-accounts",level:3},{value:"Connect to multiple RPC nodes",id:"connect-to-multiple-rpc-nodes",level:3},{value:"Allow users to connect their wallet early",id:"allow-users-to-connect-their-wallet-early",level:3}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"dApps must connect to user wallets to view the tokens in the account and to submit transactions on behalf of the wallet's owner."}),"\n",(0,a.jsx)(n.p,{children:"The primary tools that dApps use to connect to wallets are:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Beacon: A JavaScript/TypeScript SDK for connecting to wallets, signing transactions, and sending information about this connection between connected apps"}),"\n",(0,a.jsxs)(n.p,{children:["Beacon supports many Tezos wallets seamlessly, including TZIP-10 and WalletConnect2.0 wallets, so you don't have to write different code for each wallet that you want to support.\nBeacon also implements the ",(0,a.jsx)(n.a,{href:"https://gitlab.com/tezos/tzip/-/tree/master/proposals/tzip-10",children:"TZIP-10 proposal"}),", which describes an interaction standard between wallets and dApps.\nBy using this standard, a dApp that uses Beacon can send messages over a peer-to-peer communication layer to a wallet, such as allowing a user to connect with an app on one platform, such as by scanning a QR code on a mobile app, and then use the dApp with the connected wallet on another platform, such as a desktop browser."]}),"\n",(0,a.jsx)(n.p,{children:"Beacon can remember the connections that have been established and the accounts that have connected to the app.\nIt also includes default UI elements for connecting wallets and showing the status of a transaction."}),"\n",(0,a.jsxs)(n.p,{children:["For more information about Beacon, see ",(0,a.jsx)(n.a,{href:"https://www.walletbeacon.io",children:"https://www.walletbeacon.io"}),"."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Taquito: A JavaScript/TypeScript SDK for sending transactions"}),"\n",(0,a.jsx)(n.p,{children:"Taquito provides a wrapper for Beacon so dApps can interact with wallets and with Tezos with the same code."}),"\n",(0,a.jsxs)(n.p,{children:["For more information about Taquito, see ",(0,a.jsx)(n.a,{href:"/dApps/taquito",children:"Taquito"}),"."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"beacon-and-taquito",children:"Beacon and Taquito"}),"\n",(0,a.jsxs)(n.p,{children:["Most of the time, dApps use Beacon and Taquito together for a straightforward way to connect to wallets and submit transactions.\nFor an example, see the tutorial ",(0,a.jsx)(n.a,{href:"/tutorials/build-your-first-app",children:"Build a simple web application"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"connecting-to-wallets",children:"Connecting to wallets"}),"\n",(0,a.jsxs)(n.p,{children:["That tutorial connects to the wallet using the Taquito ",(0,a.jsx)(n.code,{children:"BeaconWallet"})," object, which is a wrapper around Beacon's wallet functionality, with code like this example:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'import { BeaconWallet } from "@taquito/beacon-wallet";\n\nconst wallet = new BeaconWallet({\n  name: "My dApp",\n  preferredNetwork: network\n});\nawait wallet.requestPermissions();\nconst address = await wallet.getPKH();\n'})}),"\n",(0,a.jsx)(n.p,{children:"When this code runs, Beacon opens a popup window that guides the user through connecting their wallet."}),"\n",(0,a.jsxs)(n.p,{children:["Then the application can send transactions to Tezos.\nSee ",(0,a.jsx)(n.a,{href:"/tutorials/build-your-first-app/sending-transactions",children:"Part 3: Sending transactions"})," in the tutorial ",(0,a.jsx)(n.a,{href:"/tutorials/build-your-first-app",children:"Build a simple web application"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"reconnecting-to-wallets",children:"Reconnecting to wallets"}),"\n",(0,a.jsx)(n.p,{children:"As with using Beacon on its own, you can detect whether a user has previously connected their wallet and reconnect automatically.\nFor example, this code checks to see if the user has connected and if so, it automatically reconnects to the wallet:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'import { BeaconWallet } from "@taquito/beacon-wallet";\n\nconst newWallet = new BeaconWallet({\n  name: "My dApp",\n  preferredNetwork: network\n});\nconst activeAccount = await newWallet.client.getActiveAccount();\nif (activeAccount) {\n  wallet = newWallet;\n  console.log("Reconnected to wallet:", await newWallet.getPKH());\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"disconnecting-wallets",children:"Disconnecting wallets"}),"\n",(0,a.jsx)(n.p,{children:"It's good programming practice to allow a user to disconnect their wallet, such as if they want to connect with a different wallet."}),"\n",(0,a.jsxs)(n.p,{children:["To disconnect the active wallet, call the ",(0,a.jsx)(n.code,{children:"clearActiveAccount"})," method, as in this example:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"wallet.client.clearActiveAccount();\nwallet = undefined;\n"})}),"\n",(0,a.jsx)(n.h2,{id:"beacon-by-itself",children:"Beacon by itself"}),"\n",(0,a.jsx)(n.p,{children:"You can also use Beacon without Taquito."}),"\n",(0,a.jsx)(n.h3,{id:"connecting-to-wallets-1",children:"Connecting to wallets"}),"\n",(0,a.jsxs)(n.p,{children:["To connect to a wallet with Beacon, import the Beacon package and use the ",(0,a.jsx)(n.code,{children:"getDAppClientInstance"})," function to get an instance of the Beacon ",(0,a.jsx)(n.code,{children:"DAppClient"})," object.\nUsing this function ensures that you have only one instance of the Beacon client because it returns an instance if one already exists or creates one if it does not.\nCreating multiple instances or copies of the Beacon ",(0,a.jsx)(n.code,{children:"DAppClient"})," object can lead to unexpected behavior."]}),"\n",(0,a.jsx)(n.p,{children:"Then, use this object to send a permission request to prompt the user to connect a wallet:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"import { getDAppClientInstance } from '@airgap/beacon-sdk'\n\nconst dAppClient = getDAppClientInstance({ name: 'My dApp' })\n\ntry {\n  console.log('Requesting permissions...')\n  const permissions = await dAppClient.requestPermissions()\n  console.log('Got permissions for the wallet with this address:', permissions.address)\n} catch (error) {\n  console.log('Got error:', error)\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"When this code runs, Beacon opens a popup window that guides the user through connecting their wallet."}),"\n",(0,a.jsx)(n.h3,{id:"reconnecting-to-wallets-1",children:"Reconnecting to wallets"}),"\n",(0,a.jsxs)(n.p,{children:["Beacon can detect users that return to the dApp after connecting previously.\nThe ",(0,a.jsx)(n.code,{children:"getActiveAccount"})," method returns an address if the user has previously connected a wallet.\nYou can run this code when the page loads and if it finds a connection, you can skip calling the ",(0,a.jsx)(n.code,{children:"requestPermissions"})," method unless the user wants to connect a different account:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"import { DAppClient } from '@airgap/beacon-sdk'\n\nconst dAppClient = new DAppClient({ name: 'My dApp' })\n\n// The following code should always be run during pageload if you want to show if the user is connected.\nconst activeAccount = await dAppClient.getActiveAccount()\nif (activeAccount) {\n  // User already has account connected, everything is ready\n  // You can now do an operation request, sign request, or send another permission request to switch wallet\n  console.log('Already connected:', activeAccount.address)\n  return activeAccount\n} else {\n  // The user is not connected. A button should be displayed where the user can connect to his wallet.\n  console.log('Not connected!')\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"disconnecting-wallets-1",children:"Disconnecting wallets"}),"\n",(0,a.jsx)(n.p,{children:"It's good programming practice to allow a user to disconnect their wallet, such as if they want to connect with a different wallet."}),"\n",(0,a.jsxs)(n.p,{children:["To disconnect the active wallet, call the ",(0,a.jsx)(n.code,{children:"clearActiveAccount"})," method, as in this example:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'import { DAppClient } from "@airgap/beacon-sdk";\n\nconst dAppClient = new DAppClient({ name: "My dApp" });\n\n[...]\n\nawait dAppClient.clearActiveAccount();\n'})}),"\n",(0,a.jsx)(n.h2,{id:"other-tools",children:"Other tools"}),"\n",(0,a.jsxs)(n.p,{children:["Some specific wallets provide toolkits to connect dApps to them.\nFor example, the Temple wallet provides the ",(0,a.jsx)(n.a,{href:"https://www.npmjs.com/package/@temple-wallet/dapp",children:"@temple-wallet/dapp"})," NPM package.\nFor more information, see ",(0,a.jsx)(n.a,{href:"https://github.com/madfish-solutions/templewallet-dapp",children:"https://github.com/madfish-solutions/templewallet-dapp"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best practices"}),"\n",(0,a.jsx)(n.h3,{id:"keep-tools-up-to-date",children:"Keep tools up to date"}),"\n",(0,a.jsx)(n.p,{children:"It's important to keep the SDKs that you use to connect to wallets up to date for the best user experience and performance."}),"\n",(0,a.jsx)(n.h3,{id:"reuse-connected-accounts",children:"Reuse connected accounts"}),"\n",(0,a.jsx)(n.p,{children:'For the best user experience, use the reconnection feature of Beacon described above to persist user accounts.\nThe UI can reflect that the user is connected and display the account address.\nIn this case, you can replace the "Connect" and "Sync" buttons with "Disconnect" and "Unsync" button.'}),"\n",(0,a.jsx)(n.h3,{id:"connect-to-multiple-rpc-nodes",children:"Connect to multiple RPC nodes"}),"\n",(0,a.jsx)(n.p,{children:"If a high number of users are using your dApp at the same time, the load on the RPC can spike.\nIdeally, the server infrastructure should be using a load balancer and caching to handle the load.\nIf no such infrastructure is available, it is a good idea to provide an array of nodes and randomly select one when the page loads.\nIn case one of the nodes goes down, a user can connect to a different one by refreshing."}),"\n",(0,a.jsx)(n.p,{children:"An even better approach is to add a node selection to your dApp, including a way for users to provide their own RPC node.\nSee the documentation for your platform for information on changing the RPC node."}),"\n",(0,a.jsx)(n.h3,{id:"allow-users-to-connect-their-wallet-early",children:"Allow users to connect their wallet early"}),"\n",(0,a.jsx)(n.p,{children:"If your dApp is focused around a specific time, such as an NFT drop or a countdown, you can provide a way for users to connect their wallet to the dApp prior to that time.\nConnecting early reduces the load on the Beacon peer-to-peer communication layer so users don't experience delays by connecting at the same time when the time arrives."})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>i});var o=t(96540);const a={},s=o.createContext(a);function c(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:c(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);