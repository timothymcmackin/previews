"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3693],{75952:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>l,frontMatter:()=>r,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"tutorials/create-nfts/show-info","title":"Part 5: Showing token information","description":"You can use Taquito to retrieve information about tokens from Tezos.","source":"@site/docs/tutorials/create-nfts/show-info.md","sourceDirName":"tutorials/create-nfts","slug":"/tutorials/create-nfts/show-info","permalink":"/previews/docs/biel-chatbot/tutorials/create-nfts/show-info","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1736226000000,"frontMatter":{"title":"Part 5: Showing token information","authors":"Tim McMackin","last_update":{"date":"7 January 2025"}},"sidebar":"tutorialsSidebar","previous":{"title":"Part 4: Creating the contract","permalink":"/previews/docs/biel-chatbot/tutorials/create-nfts/create-contract"},"next":{"title":"Summary","permalink":"/previews/docs/biel-chatbot/tutorials/create-nfts/summary"}}');var o=n(74848),a=n(28453);const r={title:"Part 5: Showing token information",authors:"Tim McMackin",last_update:{date:"7 January 2025"}},i=void 0,c={},h=[{value:"Getting token owners",id:"getting-token-owners",level:2}];function d(e){const t={a:"a",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:"You can use Taquito to retrieve information about tokens from Tezos.\nIn this section, you retrieve information about the connected user's tokens and show them on the web page."}),"\n",(0,o.jsxs)(t.p,{children:["The process takes a few steps because of how the data about the token owners is stored.\nThe ledger that records the owner of each token isn't stored as a simple table or as a single object.\nInstead, each entry in the big-map (in this case, an entry that represents the owner of each token) is lazily deserialized.\nIn other words, when you look up the owner of a token, Tezos reads only the entry for that token ID, not the entire table of owners.\nReading a single entry like this reduces the cost of reading data from the ledger, especially as the ledger gets large.\nFor more information about maps and big-maps, see ",(0,o.jsx)(t.a,{href:"/smart-contracts/data-types/complex-data-types#big-maps",children:"Big-maps and maps"}),"."]}),"\n",(0,o.jsx)(t.h2,{id:"getting-token-owners",children:"Getting token owners"}),"\n",(0,o.jsx)(t.p,{children:"If you ignore the internal complexities of how the data is stored in the big-map, you can imagine that the contract stores data about the NFT owners in a table.\nOne column of the table stores the ID of the NFT and the other column stores the address of the owner, as in this example:"}),"\n",(0,o.jsxs)(t.table,{children:[(0,o.jsx)(t.thead,{children:(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.th,{children:"Token ID"}),(0,o.jsx)(t.th,{children:"Owner"})]})}),(0,o.jsxs)(t.tbody,{children:[(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{children:"0"}),(0,o.jsx)(t.td,{children:(0,o.jsx)(t.code,{children:"tz1QCVQinE8iVj1H2fckqx6oiM85CNJSK9Sx"})})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{children:"1"}),(0,o.jsx)(t.td,{children:(0,o.jsx)(t.code,{children:"tz1QCVQinE8iVj1H2fckqx6oiM85CNJSK9Sx"})})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{children:"2"}),(0,o.jsx)(t.td,{children:(0,o.jsx)(t.code,{children:"tz1hQKqRPHmxET8du3fNACGyCG8kZRsXm2zD"})})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{children:"3"}),(0,o.jsx)(t.td,{children:(0,o.jsx)(t.code,{children:"tz1Z2iXBaFTd1PKhEUxCpXj7LzY7W7nRouqf"})})]})]})]}),"\n",(0,o.jsxs)(t.p,{children:["Data about fungible tokens is stored differently; see ",(0,o.jsx)(t.a,{href:"/architecture/tokens",children:"Tokens"})," for examples."]}),"\n",(0,o.jsx)(t.p,{children:"In this section, you create a function to read the data from the contract's ledger to find the IDs of the tokens that the connected account owns."}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["In the ",(0,o.jsx)(t.code,{children:"src/App.svelte"})," file, add a top-level variable to represent the list of tokens that the connected account owns:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:"let userNfts;\n"})}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsx)(t.p,{children:"Add a function that retrieves the NFTs that the user owns and puts them in the top-level variable:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:"const getUserNfts = async () => {\n  if (!address) {\n    return;\n  }\n  // Get the ID of the big-map that records token owners\n  const contract = await Tezos.wallet.at(nftContractAddress);\n  const nftStorage = await contract.storage();\n  const ledger = nftStorage['ledger'];\n  const ledgerID = ledger.id.toString();\n\n  // Get the contents of the big-map\n  const data = await fetch(`${rpcUrl}/chains/main/blocks/head/context/raw/json/big_maps/index/${ledgerID}/contents`);\n  const keys = await data.json();\n\n  // Get the owner of each NFT\n  const tokenOwners = await Promise.all(\n    keys.map((_k, index) => ledger.get(index.toString()))\n  );\n\n  // Filter to the IDs of the tokens that the connected address owns\n  userNfts = tokenOwners.reduce((matchingIndexes, ownerAddress, index) => {\n    if (ownerAddress === address) {\n      matchingIndexes.push(index);\n    }\n    return matchingIndexes;\n  }, []);\n};\n"})}),"\n",(0,o.jsx)(t.p,{children:"This function starts by requesting the storage of the contract.\nHowever, due to the way that big-maps are stored, the contract storage that Taquito provides does not contain the token owners.\nInstead, it contains an ID of the big-map, which the code uses to retrieve the current fields in the big-map.\nThen it retrieves the data in each of these fields, which is the address of the account that owns the token for a given ID."}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["Call the ",(0,o.jsx)(t.code,{children:"getUserNfts"})," function at the end of the ",(0,o.jsx)(t.code,{children:"connectWallet"})," and ",(0,o.jsx)(t.code,{children:"createNFT"})," functions."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["In the ",(0,o.jsx)(t.code,{children:"<main>"}),' section, after the "Create NFT" button, add a section that shows the NFTs that the connected account owns:']}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",children:'<div class="user-nfts">\n  {#if userNfts?.length > 0}\n    <p>\n      IDs of your NFTs:\n      {#each userNfts as nftID, index}\n        {nftID}\n        {#if index < userNfts.length - 1}\n          <span>,&nbsp;</span>\n        {/if}\n      {/each}\n    </p>\n  {:else if userNfts?.length === 0}\n    <p>The connected account has no NFTs.</p>\n  {:else}\n    <p>Loading this account\'s NFTs...</p>\n  {/if}\n</div>\n'})}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsx)(t.p,{children:"Run the application.\nAfter you connect your wallet, the application should show the IDs of the NFTs that the connected account owns, as in this picture:"}),"\n",(0,o.jsx)("img",{src:"/img/tutorials/create-nfts-show-info-ids.png",alt:"The application showing the IDs of the owned NFTs",style:{width:300}}),"\n",(0,o.jsxs)(t.p,{children:["If you don't see the IDs of the NFTs that your account owns, compare your source code to the code in ",(0,o.jsx)(t.a,{href:"https://github.com/trilitech/tutorial-applications/tree/main/create-nfts/part-5",children:"https://github.com/trilitech/tutorial-applications/tree/main/create-nfts/part-5"}),"."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["Now you can get information about NFTs in web applications.\nYou could extend the application to provide links for each NFT, a table of the NFTs and their owners, or a thumbnail image for each NFT.\nFor some closing information about the tutorial, see the ",(0,o.jsx)(t.a,{href:"/tutorials/create-nfts/summary",children:"Summary"}),"."]})]})}function l(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>i});var s=n(96540);const o={},a=s.createContext(o);function r(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);