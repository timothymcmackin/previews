"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2249],{14248:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>i,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"tutorials/build-an-nft-marketplace/part-4","title":"Part 4: Handling multi-asset tokens","description":"Because a wine store can have many bottles of many different types, the appropriate template to use is the multi-asset template.","source":"@site/docs/tutorials/build-an-nft-marketplace/part-4.md","sourceDirName":"tutorials/build-an-nft-marketplace","slug":"/tutorials/build-an-nft-marketplace/part-4","permalink":"/previews/docs/biel-chatbot/tutorials/build-an-nft-marketplace/part-4","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1716350400000,"frontMatter":{"title":"Part 4: Handling multi-asset tokens","authors":"Benjamin Fuentes (Marigold)","last_update":{"date":"22 May 2024"}},"sidebar":"tutorialsSidebar","previous":{"title":"Part 3: Managing tokens with quantities","permalink":"/previews/docs/biel-chatbot/tutorials/build-an-nft-marketplace/part-3"},"next":{"title":"Learn and play with security","permalink":"/previews/docs/biel-chatbot/tutorials/security"}}');var r=t(74848),o=t(28453);const i={title:"Part 4: Handling multi-asset tokens",authors:"Benjamin Fuentes (Marigold)",last_update:{date:"22 May 2024"}},s=void 0,l={},d=[{value:"Updating the smart contract",id:"updating-the-smart-contract",level:2},{value:"Updating the frontend",id:"updating-the-frontend",level:2},{value:"Working with the completed application",id:"working-with-the-completed-application",level:2},{value:"Summary",id:"summary",level:2}];function c(n){const e={a:"a",code:"code",h2:"h2",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.p,{children:"Because a wine store can have many bottles of many different types, the appropriate template to use is the multi-asset template.\nWith this template, you can create as many token types as you need and set a different quantity for each type."}),"\n",(0,r.jsxs)(e.p,{children:["You can continue from your code from part 3 or start from the completed version here: ",(0,r.jsx)(e.a,{href:"https://github.com/marigold-dev/training-nft-3/tree/main/solution",children:"https://github.com/marigold-dev/training-nft-3/tree/main/solution"}),"."]}),"\n",(0,r.jsx)(e.p,{children:"If you start from the completed version, run these commands to install dependencies for the web application:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"npm i\ncd ./app\nyarn install\ncd ..\n"})}),"\n",(0,r.jsx)(e.h2,{id:"updating-the-smart-contract",children:"Updating the smart contract"}),"\n",(0,r.jsx)(e.p,{children:"To use the multi-asset template, you must change the code that your smart contract imports from the NFT template to the multi-asset template:"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:["In the ",(0,r.jsx)(e.code,{children:"nft.jsligo"})," file, change the first line to this code:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-jsligo",children:' #import "@ligo/fa/lib/fa2/asset/extendable_multi_asset.impl.jsligo" "FA2Impl"\n'})}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:["In the storage, change the ",(0,r.jsx)(e.code,{children:"offers"})," value to ",(0,r.jsx)(e.code,{children:"map<[address, nat], offer>"}),".\nThe storage type looks like this:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-jsligo",children:" export type Extension = {\n   administrators: set<address>,\n   offers: map<[address, nat], offer>, //user sells an offer for a token_id\n };\n"})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"Now the offers map is indexed on the address of the seller and the ID of the token for sale."}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:["Replace the ",(0,r.jsx)(e.code,{children:"mint"})," entrypoint with this code:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-jsligo",children:'   @entry\n const mint = (\n   [token_id, quantity, name, description, symbol, ipfsUrl]: [\n     nat,\n     nat,\n     bytes,\n     bytes,\n     bytes,\n     bytes\n   ],\n   s: storage\n ): ret => {\n   if (quantity <= (0 as nat)) return failwith("0");\n   if (! Set.mem(Tezos.get_sender(), s.extension.administrators)) return failwith(\n     "1"\n   );\n   const token_info: map<string, bytes> =\n     Map.literal(\n       list(\n         [\n           ["name", name],\n           ["description", description],\n           ["interfaces", (bytes `["TZIP-12"]`)],\n           ["artifactUri", ipfsUrl],\n           ["displayUri", ipfsUrl],\n           ["thumbnailUri", ipfsUrl],\n           ["symbol", symbol],\n           ["decimals", (bytes `0`)]\n         ]\n       )\n     ) as map<string, bytes>;\n   return [\n     list([]) as list<operation>,\n     {\n       ...s,\n       ledger: Big_map.add(\n         [Tezos.get_sender(), token_id],\n         quantity as nat,\n         s.ledger\n       ) as FA2Impl.ledger,\n       token_metadata: Big_map.add(\n         token_id,\n         { token_id: token_id, token_info: token_info },\n         s.token_metadata\n       ),\n       operators: Big_map.empty as FA2Impl.operators\n     }\n   ]\n };\n\n'})}),"\n",(0,r.jsx)(e.p,{children:"This updated mint entrypoint accepts both a token ID and a quantity and mints the specified number of that token."}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:["Replace the ",(0,r.jsx)(e.code,{children:"sell"})," entrypoint with this code:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-jsligo",children:'   @entry\n const sell = ([token_id, quantity, price]: [nat, nat, nat], s: storage): ret => {\n   //check balance of seller\n   const sellerBalance =\n     FA2Impl.get_for_user([s.ledger, Tezos.get_source(), token_id]);\n   if (quantity > sellerBalance) return failwith("2");\n   //need to allow the contract itself to be an operator on behalf of the seller\n   const newOperators =\n     FA2Impl.add_operator(\n       [s.operators, Tezos.get_source(), Tezos.get_self_address(), token_id]\n     );\n   //DECISION CHOICE: if offer already exists, we just override it\n   return [\n     list([]) as list<operation>,\n     {\n       ...s,\n       extension: {\n         ...s.extension,\n         offers: Map.add(\n           [Tezos.get_source(), token_id],\n           { quantity: quantity, price: price },\n           s.extension.offers\n         )\n       },\n       operators: newOperators\n     }\n   ]\n };\n\n'})}),"\n",(0,r.jsx)(e.p,{children:"Like the mint entrypoint, this entrypoint now accepts a token ID and quantity as parameters."}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:["Replace the ",(0,r.jsx)(e.code,{children:"buy"})," entrypoint with this code:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-jsligo",children:'@entry\nconst buy = ([token_id, quantity, seller]: [nat, nat, address], s: storage): ret => {\n//search for the offer\nreturn match(Map.find_opt([seller, token_id], s.extension.offers)) {\n when (None()):\n   failwith("3")\n when (Some(offer)):\n   do {\n     //check if amount have been paid enough\n     if (Tezos.get_amount() < offer.price * (1 as mutez)) return failwith(\n       "5"\n     );\n     // prepare transfer of XTZ to seller\n     const op =\n       Tezos.transaction(\n         unit,\n         offer.price * (1 as mutez),\n         Tezos.get_contract_with_error(seller, "6")\n       );\n     //transfer tokens from seller to buyer\n     let ledger =\n       FA2Impl.decrease_token_amount_for_user(\n         [s.ledger, seller, token_id, quantity]\n       );\n     ledger\n     = FA2Impl.increase_token_amount_for_user(\n         [ledger, Tezos.get_source(), token_id, quantity]\n       );\n     //update new offer\n     const newOffer = { ...offer, quantity: abs(offer.quantity - quantity) };\n     return [\n       list([op]) as list<operation>,\n       {\n         ...s,\n         extension: {\n           ...s.extension,\n           offers: Map.update(\n             [seller, token_id],\n             Some(newOffer),\n             s.extension.offers\n           )\n         },\n         ledger: ledger\n       }\n     ]\n   }\n}\n};\n'})}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:["Update the ",(0,r.jsx)(e.code,{children:"nft.storageList.jsligo"})," with this code:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-jsligo",children:'#import "nft.jsligo" "Contract"\n\n #import "@ligo/fa/lib/fa2/asset/extendable_multi_asset.impl.jsligo" "FA2Impl"\n\n const default_storage: Contract.storage = {\n     extension: {\n         administrators: Set.literal(\n             list(["tz1VSUr8wwNhLAzempoch5d6hLRiTh8Cjcjb" as address])\n         ) as set<address>,\n         offers: Map.empty as map<[address, nat], Contract.offer>\n     },\n     ledger: Big_map.empty as FA2Impl.ledger,\n     metadata: Big_map.literal(\n         list(\n             [\n                 ["", bytes `tezos-storage:data`],\n                 [\n                     "data",\n                     bytes\n                     `{\n         "name":"FA2 NFT Marketplace",\n         "description":"Example of FA2 implementation",\n         "version":"0.0.1",\n         "license":{"name":"MIT"},\n         "authors":["Marigold<contact@marigold.dev>"],\n         "homepage":"https://marigold.dev",\n         "source":{\n           "tools":["Ligo"],\n           "location":"https://github.com/ligolang/contract-catalogue/tree/main/lib/fa2"},\n         "interfaces":["TZIP-012"],\n         "errors": [],\n         "views": []\n         }`\n                 ]\n             ]\n         )\n     ) as FA2Impl.TZIP16.metadata,\n     token_metadata: Big_map.empty as FA2Impl.TZIP12.tokenMetadata,\n     operators: Big_map.empty as FA2Impl.operators,\n };\n\n'})}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"As in the previous parts, update the administrators to include addresses that you have access to."}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"Compile and deploy the new contract:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:'TAQ_LIGO_IMAGE=ligolang/ligo:1.6.0 taq compile nft.jsligo\ntaq deploy nft.tz -e "testing"\n'})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"updating-the-frontend",children:"Updating the frontend"}),"\n",(0,r.jsx)(e.p,{children:"Now that the contract handles both token IDs and quantities, you must update the frontend in the same way:"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"Generate the TypeScript classes and start the server:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"taq generate types ./app/src\ncd ./app\nyarn dev\n"})}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:["In the file ",(0,r.jsx)(e.code,{children:"src/App.tsx"}),", replace the function ",(0,r.jsx)(e.code,{children:"refreshUserContextOnPageReload"})," with this code:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:"const refreshUserContextOnPageReload = async () => {\n  console.log('refreshUserContext');\n  //CONTRACT\n  try {\n    let c = await Tezos.contract.at(nftContractAddress, tzip12);\n    console.log('nftContractAddress', nftContractAddress);\n\n    let nftContrat: NftWalletType = await Tezos.wallet.at<NftWalletType>(\n      nftContractAddress\n    );\n    const storage = (await nftContrat.storage()) as Storage;\n\n    const token_metadataBigMapId = (\n      storage.token_metadata as unknown as { id: BigNumber }\n    ).id.toNumber();\n\n    const token_ids = await api.bigMapsGetKeys(token_metadataBigMapId, {\n      micheline: 'Json',\n      active: true,\n    });\n    await Promise.all(\n      token_ids.map(async (token_idKey) => {\n        const key: string = token_idKey.key;\n\n        let tokenMetadata: TZIP21TokenMetadata = (await c\n          .tzip12()\n          .getTokenMetadata(Number(key))) as TZIP21TokenMetadata;\n        nftContratTokenMetadataMap.set(key, tokenMetadata);\n      })\n    );\n    setNftContratTokenMetadataMap(new Map(nftContratTokenMetadataMap)); //new Map to force refresh\n    setNftContrat(nftContrat);\n    setStorage(storage);\n  } catch (error) {\n    console.log('error refreshing nft contract: ', error);\n  }\n\n  //USER\n  const activeAccount = await wallet.client.getActiveAccount();\n  if (activeAccount) {\n    setUserAddress(activeAccount.address);\n    const balance = await Tezos.tz.getBalance(activeAccount.address);\n    setUserBalance(balance.toNumber());\n  }\n\n  console.log('refreshUserContext ended.');\n};\n"})}),"\n",(0,r.jsx)(e.p,{children:"This function now retrieves all of the tokens in the contract."}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:["Replace the content of the ",(0,r.jsx)(e.code,{children:"src/MintPage.tsx"})," file with this code:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:"import {\n  AddCircleOutlined,\n  Close,\n  KeyboardArrowLeft,\n  KeyboardArrowRight,\n} from '@mui/icons-material';\nimport OpenWithIcon from '@mui/icons-material/OpenWith';\nimport {\n  Box,\n  Button,\n  CardHeader,\n  CardMedia,\n  MobileStepper,\n  Stack,\n  SwipeableDrawer,\n  TextField,\n  Toolbar,\n  useMediaQuery,\n} from '@mui/material';\nimport Card from '@mui/material/Card';\nimport CardContent from '@mui/material/CardContent';\nimport Paper from '@mui/material/Paper';\nimport Typography from '@mui/material/Typography';\nimport { char2Bytes } from '@taquito/utils';\nimport { BigNumber } from 'bignumber.js';\nimport { useFormik } from 'formik';\nimport { useSnackbar } from 'notistack';\nimport React, { useEffect, useState } from 'react';\nimport SwipeableViews from 'react-swipeable-views';\nimport * as yup from 'yup';\nimport { TZIP21TokenMetadata, UserContext, UserContextType } from './App';\nimport { TransactionInvalidBeaconError } from './TransactionInvalidBeaconError';\nimport { address, bytes, nat } from './type-aliases';\n\nexport default function MintPage() {\n  const {\n    userAddress,\n    nftContrat,\n    refreshUserContextOnPageReload,\n    nftContratTokenMetadataMap,\n    storage,\n  } = React.useContext(UserContext) as UserContextType;\n  const { enqueueSnackbar } = useSnackbar();\n  const [pictureUrl, setPictureUrl] = useState<string>('');\n  const [file, setFile] = useState<File | null>(null);\n\n  const [activeStep, setActiveStep] = React.useState(0);\n\n  const handleNext = () => {\n    setActiveStep((prevActiveStep) => prevActiveStep + 1);\n  };\n\n  const handleBack = () => {\n    setActiveStep((prevActiveStep) => prevActiveStep - 1);\n  };\n\n  const handleStepChange = (step: number) => {\n    setActiveStep(step);\n  };\n\n  const validationSchema = yup.object({\n    name: yup.string().required('Name is required'),\n    description: yup.string().required('Description is required'),\n    symbol: yup.string().required('Symbol is required'),\n    quantity: yup\n      .number()\n      .required('Quantity is required')\n      .positive('ERROR: The number must be greater than 0!'),\n  });\n\n  const formik = useFormik({\n    initialValues: {\n      name: '',\n      description: '',\n      token_id: 0,\n      symbol: 'WINE',\n      quantity: 1,\n    } as TZIP21TokenMetadata & { quantity: number },\n    validationSchema: validationSchema,\n    onSubmit: (values) => {\n      mint(values);\n    },\n  });\n\n  //open mint drawer if admin\n  useEffect(() => {\n    if (\n      storage &&\n      storage!.extension.administrators.indexOf(userAddress! as address) < 0\n    )\n      setFormOpen(false);\n    else setFormOpen(true);\n  }, [userAddress]);\n\n  useEffect(() => {\n    (async () => {\n      if (\n        nftContratTokenMetadataMap &&\n        nftContratTokenMetadataMap.size > 0\n      ) {\n        formik.setFieldValue('token_id', nftContratTokenMetadataMap.size);\n      }\n    })();\n  }, [nftContratTokenMetadataMap?.size]);\n\n  const mint = async (\n    newTokenDefinition: TZIP21TokenMetadata & { quantity: number }\n  ) => {\n    try {\n      //IPFS\n      if (file) {\n        const formData = new FormData();\n        formData.append('file', file);\n\n        const requestHeaders: HeadersInit = new Headers();\n        requestHeaders.set(\n          'pinata_api_key',\n          `${import.meta.env.VITE_PINATA_API_KEY}`\n        );\n        requestHeaders.set(\n          'pinata_secret_api_key',\n          `${import.meta.env.VITE_PINATA_API_SECRET}`\n        );\n\n        const resFile = await fetch(\n          'https://api.pinata.cloud/pinning/pinFileToIPFS',\n          {\n            method: 'post',\n            body: formData,\n            headers: requestHeaders,\n          }\n        );\n\n        const responseJson = await resFile.json();\n        console.log('responseJson', responseJson);\n\n        const thumbnailUri = `ipfs://${responseJson.IpfsHash}`;\n        setPictureUrl(\n          `https://gateway.pinata.cloud/ipfs/${responseJson.IpfsHash}`\n        );\n\n        const op = await nftContrat!.methods\n          .mint(\n            new BigNumber(newTokenDefinition.token_id) as nat,\n            new BigNumber(newTokenDefinition.quantity) as nat,\n            char2Bytes(newTokenDefinition.name!) as bytes,\n            char2Bytes(newTokenDefinition.description!) as bytes,\n            char2Bytes(newTokenDefinition.symbol!) as bytes,\n            char2Bytes(thumbnailUri) as bytes\n          )\n          .send();\n\n        //close directly the form\n        setFormOpen(false);\n        enqueueSnackbar(\n          'Wine collection is minting ... it will be ready on next block, wait for the confirmation message before minting another collection',\n          { variant: 'info' }\n        );\n\n        await op.confirmation(2);\n\n        enqueueSnackbar('Wine collection minted', { variant: 'success' });\n\n        refreshUserContextOnPageReload(); //force all app to refresh the context\n      }\n    } catch (error) {\n      console.table(`Error: ${JSON.stringify(error, null, 2)}`);\n      let tibe: TransactionInvalidBeaconError =\n        new TransactionInvalidBeaconError(error);\n      enqueueSnackbar(tibe.data_message, {\n        variant: 'error',\n        autoHideDuration: 10000,\n      });\n    }\n  };\n\n  const [formOpen, setFormOpen] = useState<boolean>(false);\n\n  const toggleDrawer =\n    (open: boolean) => (event: React.KeyboardEvent | React.MouseEvent) => {\n      if (\n        event.type === 'keydown' &&\n        ((event as React.KeyboardEvent).key === 'Tab' ||\n          (event as React.KeyboardEvent).key === 'Shift')\n      ) {\n        return;\n      }\n      setFormOpen(open);\n    };\n\n  const isTablet = useMediaQuery('(min-width:600px)');\n\n  return (\n    <Paper>\n      {storage ? (\n        <Button\n          disabled={\n            storage.extension.administrators.indexOf(\n              userAddress! as address\n            ) < 0\n          }\n          sx={{\n            p: 1,\n            position: 'absolute',\n            right: '0',\n            display: formOpen ? 'none' : 'block',\n            zIndex: 1,\n          }}\n          onClick={toggleDrawer(!formOpen)}\n        >\n          {' Mint Form ' +\n            (storage!.extension.administrators.indexOf(\n              userAddress! as address\n            ) < 0\n              ? ' (You are not admin)'\n              : '')}\n          <OpenWithIcon />\n        </Button>\n      ) : (\n        ''\n      )}\n\n      <SwipeableDrawer\n        onClose={toggleDrawer(false)}\n        onOpen={toggleDrawer(true)}\n        anchor=\"right\"\n        open={formOpen}\n        variant=\"temporary\"\n      >\n        <Toolbar\n          sx={\n            isTablet\n              ? { marginTop: '0', marginRight: '0' }\n              : { marginTop: '35px', marginRight: '125px' }\n          }\n        />\n        <Box\n          sx={{\n            width: isTablet ? '40vw' : '60vw',\n            borderColor: 'text.secondary',\n            borderStyle: 'solid',\n            borderWidth: '1px',\n\n            height: 'calc(100vh - 64px)',\n          }}\n        >\n          <Button\n            sx={{\n              position: 'absolute',\n              right: '0',\n              display: !formOpen ? 'none' : 'block',\n            }}\n            onClick={toggleDrawer(!formOpen)}\n          >\n            <Close />\n          </Button>\n          <form onSubmit={formik.handleSubmit}>\n            <Stack spacing={2} margin={2} alignContent={'center'}>\n              <Typography variant=\"h5\">Mint a new collection</Typography>\n\n              <TextField\n                id=\"standard-basic\"\n                name=\"token_id\"\n                label=\"token_id\"\n                value={formik.values.token_id}\n                disabled\n                variant=\"filled\"\n              />\n              <TextField\n                id=\"standard-basic\"\n                name=\"name\"\n                label=\"name\"\n                required\n                value={formik.values.name}\n                onChange={formik.handleChange}\n                error={formik.touched.name && Boolean(formik.errors.name)}\n                helperText={formik.touched.name && formik.errors.name}\n                variant=\"filled\"\n              />\n              <TextField\n                id=\"standard-basic\"\n                name=\"symbol\"\n                label=\"symbol\"\n                required\n                value={formik.values.symbol}\n                onChange={formik.handleChange}\n                error={\n                  formik.touched.symbol && Boolean(formik.errors.symbol)\n                }\n                helperText={formik.touched.symbol && formik.errors.symbol}\n                variant=\"filled\"\n              />\n              <TextField\n                id=\"standard-basic\"\n                name=\"description\"\n                label=\"description\"\n                required\n                multiline\n                minRows={2}\n                value={formik.values.description}\n                onChange={formik.handleChange}\n                error={\n                  formik.touched.description &&\n                  Boolean(formik.errors.description)\n                }\n                helperText={\n                  formik.touched.description && formik.errors.description\n                }\n                variant=\"filled\"\n              />\n\n              <TextField\n                type=\"number\"\n                id=\"standard-basic\"\n                name=\"quantity\"\n                label=\"quantity\"\n                required\n                value={formik.values.quantity}\n                onChange={formik.handleChange}\n                error={\n                  formik.touched.quantity && Boolean(formik.errors.quantity)\n                }\n                helperText={\n                  formik.touched.quantity && formik.errors.quantity\n                }\n                variant=\"filled\"\n              />\n\n              {pictureUrl ? (\n                <img height={100} width={100} src={pictureUrl} />\n              ) : (\n                ''\n              )}\n              <Button variant=\"contained\" component=\"label\" color=\"primary\">\n                <AddCircleOutlined />\n                Upload an image\n                <input\n                  type=\"file\"\n                  hidden\n                  name=\"data\"\n                  onChange={(e: React.ChangeEvent<HTMLInputElement>) => {\n                    const data = e.target.files ? e.target.files[0] : null;\n                    if (data) {\n                      setFile(data);\n                    }\n                    e.preventDefault();\n                  }}\n                />\n              </Button>\n\n              <Button variant=\"contained\" type=\"submit\">\n                Mint\n              </Button>\n            </Stack>\n          </form>\n        </Box>\n      </SwipeableDrawer>\n\n      <Typography variant=\"h5\">Mint your wine collection</Typography>\n\n      {nftContratTokenMetadataMap.size != 0 ? (\n        <Box sx={{ width: '70vw' }}>\n          <SwipeableViews\n            axis=\"x\"\n            index={activeStep}\n            onChangeIndex={handleStepChange}\n            enableMouseEvents\n          >\n            {Array.from(nftContratTokenMetadataMap!.entries()).map(\n              ([token_id, token]) => (\n                <Card\n                  sx={{\n                    display: 'block',\n                    maxWidth: '80vw',\n                    overflow: 'hidden',\n                  }}\n                  key={token_id.toString()}\n                >\n                  <CardHeader\n                    titleTypographyProps={\n                      isTablet ? { fontSize: '1.5em' } : { fontSize: '1em' }\n                    }\n                    title={token.name}\n                  />\n\n                  <CardMedia\n                    sx={\n                      isTablet\n                        ? {\n                            width: 'auto',\n                            marginLeft: '33%',\n                            maxHeight: '50vh',\n                          }\n                        : { width: '100%', maxHeight: '40vh' }\n                    }\n                    component=\"img\"\n                    image={token.thumbnailUri?.replace(\n                      'ipfs://',\n                      'https://gateway.pinata.cloud/ipfs/'\n                    )}\n                  />\n\n                  <CardContent>\n                    <Box>\n                      <Typography>{'ID : ' + token_id}</Typography>\n                      <Typography>{'Symbol : ' + token.symbol}</Typography>\n                      <Typography>\n                        {'Description : ' + token.description}\n                      </Typography>\n                    </Box>\n                  </CardContent>\n                </Card>\n              )\n            )}\n          </SwipeableViews>\n          <MobileStepper\n            variant=\"text\"\n            steps={Array.from(nftContratTokenMetadataMap!.entries()).length}\n            position=\"static\"\n            activeStep={activeStep}\n            nextButton={\n              <Button\n                size=\"small\"\n                onClick={handleNext}\n                disabled={\n                  activeStep ===\n                  Array.from(nftContratTokenMetadataMap!.entries()).length -\n                    1\n                }\n              >\n                Next\n                <KeyboardArrowRight />\n              </Button>\n            }\n            backButton={\n              <Button\n                size=\"small\"\n                onClick={handleBack}\n                disabled={activeStep === 0}\n              >\n                <KeyboardArrowLeft />\n                Back\n              </Button>\n            }\n          />\n        </Box>\n      ) : (\n        <Typography sx={{ py: '2em' }} variant=\"h4\">\n          Sorry, there is not NFT yet, you need to mint bottles first\n        </Typography>\n      )}\n    </Paper>\n  );\n}\n"})}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:["Replace the content of the ",(0,r.jsx)(e.code,{children:"src/OffersPage.tsx"})," file with this code:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:"import { InfoOutlined } from '@mui/icons-material';\nimport SellIcon from '@mui/icons-material/Sell';\nimport * as api from '@tzkt/sdk-api';\n\nimport {\n  Box,\n  Button,\n  Card,\n  CardActions,\n  CardContent,\n  CardHeader,\n  CardMedia,\n  ImageList,\n  InputAdornment,\n  Pagination,\n  TextField,\n  Tooltip,\n  Typography,\n  useMediaQuery,\n} from '@mui/material';\nimport Paper from '@mui/material/Paper';\nimport BigNumber from 'bignumber.js';\nimport { useFormik } from 'formik';\nimport { useSnackbar } from 'notistack';\nimport React, { Fragment, useEffect, useState } from 'react';\nimport * as yup from 'yup';\nimport { UserContext, UserContextType } from './App';\nimport ConnectButton from './ConnectWallet';\nimport { TransactionInvalidBeaconError } from './TransactionInvalidBeaconError';\nimport { address, nat } from './type-aliases';\n\nconst itemPerPage: number = 6;\n\nconst validationSchema = yup.object({\n  price: yup\n    .number()\n    .required('Price is required')\n    .positive('ERROR: The number must be greater than 0!'),\n  quantity: yup\n    .number()\n    .required('Quantity is required')\n    .positive('ERROR: The number must be greater than 0!'),\n});\n\ntype Offer = {\n  price: nat;\n  quantity: nat;\n};\n\nexport default function OffersPage() {\n  api.defaults.baseUrl = 'https://api.ghostnet.tzkt.io';\n\n  const [selectedTokenId, setSelectedTokenId] = React.useState<number>(0);\n  const [currentPageIndex, setCurrentPageIndex] = useState<number>(1);\n\n  let [offersTokenIDMap, setOffersTokenIDMap] = React.useState<\n    Map<number, Offer>\n  >(new Map());\n  let [ledgerTokenIDMap, setLedgerTokenIDMap] = React.useState<\n    Map<number, nat>\n  >(new Map());\n\n  const {\n    nftContrat,\n    nftContratTokenMetadataMap,\n    userAddress,\n    storage,\n    refreshUserContextOnPageReload,\n    Tezos,\n    setUserAddress,\n    setUserBalance,\n    wallet,\n  } = React.useContext(UserContext) as UserContextType;\n\n  const { enqueueSnackbar } = useSnackbar();\n\n  const formik = useFormik({\n    initialValues: {\n      price: 0,\n      quantity: 1,\n    },\n    validationSchema: validationSchema,\n    onSubmit: (values) => {\n      console.log('onSubmit: (values)', values, selectedTokenId);\n      sell(selectedTokenId, values.quantity, values.price);\n    },\n  });\n\n  const initPage = async () => {\n    if (storage) {\n      console.log('context is not empty, init page now');\n      ledgerTokenIDMap = new Map();\n      offersTokenIDMap = new Map();\n\n      const ledgerBigMapId = (\n        storage.ledger as unknown as { id: BigNumber }\n      ).id.toNumber();\n\n      const owner_token_ids = await api.bigMapsGetKeys(ledgerBigMapId, {\n        micheline: 'Json',\n        active: true,\n      });\n\n      await Promise.all(\n        owner_token_ids.map(async (owner_token_idKey) => {\n          const key: { address: string; nat: string } =\n            owner_token_idKey.key;\n\n          if (key.address === userAddress) {\n            const ownerBalance = await storage.ledger.get({\n              0: userAddress as address,\n              1: BigNumber(key.nat) as nat,\n            });\n            if (ownerBalance.toNumber() !== 0)\n              ledgerTokenIDMap.set(Number(key.nat), ownerBalance);\n            const ownerOffers = await storage.extension.offers.get({\n              0: userAddress as address,\n              1: BigNumber(key.nat) as nat,\n            });\n            if (ownerOffers && ownerOffers.quantity.toNumber() !== 0)\n              offersTokenIDMap.set(Number(key.nat), ownerOffers);\n\n            console.log(\n              'found for ' +\n                key.address +\n                ' on token_id ' +\n                key.nat +\n                ' with balance ' +\n                ownerBalance\n            );\n          } else {\n            console.log('skip to next owner');\n          }\n        })\n      );\n      setLedgerTokenIDMap(new Map(ledgerTokenIDMap)); //force refresh\n      setOffersTokenIDMap(new Map(offersTokenIDMap)); //force refresh\n\n      console.log('ledgerTokenIDMap', ledgerTokenIDMap);\n    } else {\n      console.log('context is empty, wait for parent and retry ...');\n    }\n  };\n\n  useEffect(() => {\n    (async () => {\n      console.log('after a storage changed');\n      await initPage();\n    })();\n  }, [storage]);\n\n  useEffect(() => {\n    (async () => {\n      console.log('on Page init');\n      await initPage();\n    })();\n  }, []);\n\n  const sell = async (token_id: number, quantity: number, price: number) => {\n    try {\n      const op = await nftContrat?.methods\n        .sell(\n          BigNumber(token_id) as nat,\n          BigNumber(quantity) as nat,\n          BigNumber(price * 1000000) as nat //to mutez\n        )\n        .send();\n\n      await op?.confirmation(2);\n\n      enqueueSnackbar(\n        'Wine collection (token_id=' +\n          token_id +\n          ') offer for ' +\n          quantity +\n          ' units at price of ' +\n          price +\n          ' XTZ',\n        { variant: 'success' }\n      );\n\n      refreshUserContextOnPageReload(); //force all app to refresh the context\n    } catch (error) {\n      console.table(`Error: ${JSON.stringify(error, null, 2)}`);\n      let tibe: TransactionInvalidBeaconError =\n        new TransactionInvalidBeaconError(error);\n      enqueueSnackbar(tibe.data_message, {\n        variant: 'error',\n        autoHideDuration: 10000,\n      });\n    }\n  };\n\n  const isDesktop = useMediaQuery('(min-width:1100px)');\n  const isTablet = useMediaQuery('(min-width:600px)');\n\n  return (\n    <Paper>\n      <Typography style={{ paddingBottom: '10px' }} variant=\"h5\">\n        Sell my bottles\n      </Typography>\n      {ledgerTokenIDMap && ledgerTokenIDMap.size != 0 ? (\n        <Fragment>\n          <Pagination\n            page={currentPageIndex}\n            onChange={(_, value) => setCurrentPageIndex(value)}\n            count={Math.ceil(\n              Array.from(ledgerTokenIDMap.entries()).length / itemPerPage\n            )}\n            showFirstButton\n            showLastButton\n          />\n\n          <ImageList\n            cols={\n              isDesktop ? itemPerPage / 2 : isTablet ? itemPerPage / 3 : 1\n            }\n          >\n            {Array.from(ledgerTokenIDMap.entries())\n              .filter((_, index) =>\n                index >= currentPageIndex * itemPerPage - itemPerPage &&\n                index < currentPageIndex * itemPerPage\n                  ? true\n                  : false\n              )\n              .map(([token_id, balance]) => (\n                <Card key={token_id + '-' + token_id.toString()}>\n                  <CardHeader\n                    avatar={\n                      <Tooltip\n                        title={\n                          <Box>\n                            <Typography>\n                              {' '}\n                              {'ID : ' + token_id.toString()}{' '}\n                            </Typography>\n                            <Typography>\n                              {'Description : ' +\n                                nftContratTokenMetadataMap.get(\n                                  token_id.toString()\n                                )?.description}\n                            </Typography>\n                          </Box>\n                        }\n                      >\n                        <InfoOutlined />\n                      </Tooltip>\n                    }\n                    title={\n                      nftContratTokenMetadataMap.get(token_id.toString())\n                        ?.name\n                    }\n                  />\n                  <CardMedia\n                    sx={{ width: 'auto', marginLeft: '33%' }}\n                    component=\"img\"\n                    height=\"100px\"\n                    image={nftContratTokenMetadataMap\n                      .get(token_id.toString())\n                      ?.thumbnailUri?.replace(\n                        'ipfs://',\n                        'https://gateway.pinata.cloud/ipfs/'\n                      )}\n                  />\n\n                  <CardContent>\n                    <Box>\n                      <Typography variant=\"body2\">\n                        {'Owned : ' + balance.toNumber()}\n                      </Typography>\n                      <Typography variant=\"body2\">\n                        {offersTokenIDMap.get(token_id)\n                          ? 'Traded : ' +\n                            offersTokenIDMap.get(token_id)?.quantity +\n                            ' (price : ' +\n                            offersTokenIDMap\n                              .get(token_id)\n                              ?.price.dividedBy(1000000) +\n                            ' Tz/b)'\n                          : ''}\n                      </Typography>\n                    </Box>\n                  </CardContent>\n\n                  <CardActions>\n                    {!userAddress ? (\n                      <Box marginLeft=\"5vw\">\n                        <ConnectButton\n                          Tezos={Tezos}\n                          nftContratTokenMetadataMap={\n                            nftContratTokenMetadataMap\n                          }\n                          setUserAddress={setUserAddress}\n                          setUserBalance={setUserBalance}\n                          wallet={wallet}\n                        />\n                      </Box>\n                    ) : (\n                      <form\n                        style={{ width: '100%' }}\n                        onSubmit={(values) => {\n                          setSelectedTokenId(token_id);\n                          formik.handleSubmit(values);\n                        }}\n                      >\n                        <span>\n                          <TextField\n                            type=\"number\"\n                            sx={{ width: '40%' }}\n                            name=\"price\"\n                            label=\"price/bottle\"\n                            placeholder=\"Enter a price\"\n                            variant=\"filled\"\n                            value={formik.values.price}\n                            onChange={formik.handleChange}\n                            error={\n                              formik.touched.price &&\n                              Boolean(formik.errors.price)\n                            }\n                            helperText={\n                              formik.touched.price && formik.errors.price\n                            }\n                          />\n                          <TextField\n                            sx={{\n                              width: '60%',\n                              bottom: 0,\n                              position: 'relative',\n                            }}\n                            type=\"number\"\n                            label=\"quantity\"\n                            name=\"quantity\"\n                            placeholder=\"Enter a quantity\"\n                            variant=\"filled\"\n                            value={formik.values.quantity}\n                            onChange={formik.handleChange}\n                            error={\n                              formik.touched.quantity &&\n                              Boolean(formik.errors.quantity)\n                            }\n                            helperText={\n                              formik.touched.quantity &&\n                              formik.errors.quantity\n                            }\n                            InputProps={{\n                              inputProps: {\n                                min: 0,\n                                max: balance.toNumber(),\n                              },\n                              endAdornment: (\n                                <InputAdornment position=\"end\">\n                                  <Button\n                                    type=\"submit\"\n                                    aria-label=\"add to favorites\"\n                                  >\n                                    <SellIcon /> Sell\n                                  </Button>\n                                </InputAdornment>\n                              ),\n                            }}\n                          />\n                        </span>\n                      </form>\n                    )}\n                  </CardActions>\n                </Card>\n              ))}{' '}\n          </ImageList>\n        </Fragment>\n      ) : (\n        <Typography sx={{ py: '2em' }} variant=\"h4\">\n          Sorry, you don't own any bottles, buy or mint some first\n        </Typography>\n      )}\n    </Paper>\n  );\n}\n"})}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:["Replace the content of the ",(0,r.jsx)(e.code,{children:"src/WineCataloguePage.tsx"})," file with this code:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:"import { InfoOutlined } from '@mui/icons-material';\nimport ShoppingCartIcon from '@mui/icons-material/ShoppingCart';\nimport {\n  Box,\n  Button,\n  Card,\n  CardActions,\n  CardContent,\n  CardHeader,\n  CardMedia,\n  ImageList,\n  InputAdornment,\n  Pagination,\n  TextField,\n  Tooltip,\n  useMediaQuery,\n} from '@mui/material';\nimport Paper from '@mui/material/Paper';\nimport Typography from '@mui/material/Typography';\n\nimport BigNumber from 'bignumber.js';\nimport { useFormik } from 'formik';\nimport { useSnackbar } from 'notistack';\nimport React, { Fragment, useState } from 'react';\nimport * as yup from 'yup';\nimport { UserContext, UserContextType } from './App';\nimport ConnectButton from './ConnectWallet';\nimport { TransactionInvalidBeaconError } from './TransactionInvalidBeaconError';\nimport { address, nat } from './type-aliases';\n\nconst itemPerPage: number = 6;\n\ntype OfferEntry = [{ 0: address; 1: nat }, Offer];\n\ntype Offer = {\n  price: nat;\n  quantity: nat;\n};\n\nconst validationSchema = yup.object({\n  quantity: yup\n    .number()\n    .required('Quantity is required')\n    .positive('ERROR: The number must be greater than 0!'),\n});\n\nexport default function WineCataloguePage() {\n  const {\n    Tezos,\n    nftContratTokenMetadataMap,\n    setUserAddress,\n    setUserBalance,\n    wallet,\n    userAddress,\n    nftContrat,\n    refreshUserContextOnPageReload,\n    storage,\n  } = React.useContext(UserContext) as UserContextType;\n  const [selectedOfferEntry, setSelectedOfferEntry] =\n    React.useState<OfferEntry | null>(null);\n\n  const formik = useFormik({\n    initialValues: {\n      quantity: 1,\n    },\n    validationSchema: validationSchema,\n    onSubmit: (values) => {\n      console.log('onSubmit: (values)', values, selectedOfferEntry);\n      buy(values.quantity, selectedOfferEntry!);\n    },\n  });\n  const { enqueueSnackbar } = useSnackbar();\n  const [currentPageIndex, setCurrentPageIndex] = useState<number>(1);\n\n  const buy = async (quantity: number, selectedOfferEntry: OfferEntry) => {\n    try {\n      const op = await nftContrat?.methods\n        .buy(\n          selectedOfferEntry[0][1],\n          BigNumber(quantity) as nat,\n          selectedOfferEntry[0][0]\n        )\n        .send({\n          amount: quantity * selectedOfferEntry[1].price.toNumber(),\n          mutez: true,\n        });\n\n      await op?.confirmation(2);\n\n      enqueueSnackbar(\n        'Bought ' +\n          quantity +\n          ' unit of Wine collection (token_id:' +\n          selectedOfferEntry[0][1] +\n          ')',\n        {\n          variant: 'success',\n        }\n      );\n\n      refreshUserContextOnPageReload(); //force all app to refresh the context\n    } catch (error) {\n      console.table(`Error: ${JSON.stringify(error, null, 2)}`);\n      let tibe: TransactionInvalidBeaconError =\n        new TransactionInvalidBeaconError(error);\n      enqueueSnackbar(tibe.data_message, {\n        variant: 'error',\n        autoHideDuration: 10000,\n      });\n    }\n  };\n  const isDesktop = useMediaQuery('(min-width:1100px)');\n  const isTablet = useMediaQuery('(min-width:600px)');\n  return (\n    <Paper>\n      <Typography style={{ paddingBottom: '10px' }} variant=\"h5\">\n        Wine catalogue\n      </Typography>\n\n      {storage?.extension.offers && storage?.extension.offers.size != 0 ? (\n        <Fragment>\n          <Pagination\n            page={currentPageIndex}\n            onChange={(_, value) => setCurrentPageIndex(value)}\n            count={Math.ceil(\n              Array.from(storage?.extension.offers.entries()).filter(\n                ([_, offer]) => offer.quantity.isGreaterThan(0)\n              ).length / itemPerPage\n            )}\n            showFirstButton\n            showLastButton\n          />\n          <ImageList\n            cols={\n              isDesktop ? itemPerPage / 2 : isTablet ? itemPerPage / 3 : 1\n            }\n          >\n            {Array.from(storage?.extension.offers.entries())\n              .filter(([_, offer]) => offer.quantity.isGreaterThan(0))\n              .filter((_, index) =>\n                index >= currentPageIndex * itemPerPage - itemPerPage &&\n                index < currentPageIndex * itemPerPage\n                  ? true\n                  : false\n              )\n              .map(([key, offer]) => (\n                <Card key={key[0] + '-' + key[1].toString()}>\n                  <CardHeader\n                    avatar={\n                      <Tooltip\n                        title={\n                          <Box>\n                            <Typography>\n                              {' '}\n                              {'ID : ' + key[1].toString()}{' '}\n                            </Typography>\n                            <Typography>\n                              {'Description : ' +\n                                nftContratTokenMetadataMap.get(\n                                  key[1].toString()\n                                )?.description}\n                            </Typography>\n                            <Typography>{'Seller : ' + key[0]} </Typography>\n                          </Box>\n                        }\n                      >\n                        <InfoOutlined />\n                      </Tooltip>\n                    }\n                    title={\n                      nftContratTokenMetadataMap.get(key[1].toString())?.name\n                    }\n                  />\n                  <CardMedia\n                    sx={{ width: 'auto', marginLeft: '33%' }}\n                    component=\"img\"\n                    height=\"100px\"\n                    image={nftContratTokenMetadataMap\n                      .get(key[1].toString())\n                      ?.thumbnailUri?.replace(\n                        'ipfs://',\n                        'https://gateway.pinata.cloud/ipfs/'\n                      )}\n                  />\n\n                  <CardContent>\n                    <Box>\n                      <Typography variant=\"body2\">\n                        {' '}\n                        {'Price : ' +\n                          offer.price.dividedBy(1000000) +\n                          ' XTZ/bottle'}\n                      </Typography>\n                      <Typography variant=\"body2\">\n                        {'Available units : ' + offer.quantity}\n                      </Typography>\n                    </Box>\n                  </CardContent>\n\n                  <CardActions>\n                    {!userAddress ? (\n                      <Box marginLeft=\"5vw\">\n                        <ConnectButton\n                          Tezos={Tezos}\n                          nftContratTokenMetadataMap={\n                            nftContratTokenMetadataMap\n                          }\n                          setUserAddress={setUserAddress}\n                          setUserBalance={setUserBalance}\n                          wallet={wallet}\n                        />\n                      </Box>\n                    ) : (\n                      <form\n                        style={{ width: '100%' }}\n                        onSubmit={(values) => {\n                          setSelectedOfferEntry([key, offer]);\n                          formik.handleSubmit(values);\n                        }}\n                      >\n                        <TextField\n                          type=\"number\"\n                          sx={{ bottom: 0, position: 'relative' }}\n                          fullWidth\n                          name=\"quantity\"\n                          label=\"quantity\"\n                          placeholder=\"Enter a quantity\"\n                          variant=\"filled\"\n                          value={formik.values.quantity}\n                          onChange={formik.handleChange}\n                          error={\n                            formik.touched.quantity &&\n                            Boolean(formik.errors.quantity)\n                          }\n                          helperText={\n                            formik.touched.quantity && formik.errors.quantity\n                          }\n                          InputProps={{\n                            inputProps: { min: 0, max: offer.quantity },\n                            endAdornment: (\n                              <InputAdornment position=\"end\">\n                                <Button\n                                  type=\"submit\"\n                                  aria-label=\"add to favorites\"\n                                >\n                                  <ShoppingCartIcon /> BUY\n                                </Button>\n                              </InputAdornment>\n                            ),\n                          }}\n                        />\n                      </form>\n                    )}\n                  </CardActions>\n                </Card>\n              ))}\n          </ImageList>\n        </Fragment>\n      ) : (\n        <Typography sx={{ py: '2em' }} variant=\"h4\">\n          Sorry, there is not NFT to buy yet, you need to mint or sell\n          bottles first\n        </Typography>\n      )}\n    </Paper>\n  );\n}\n"})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"working-with-the-completed-application",children:"Working with the completed application"}),"\n",(0,r.jsx)(e.p,{children:"Now you can create, buy, and sell bottles of wine as in the applications in the previous parts.\nFor example, if you connect an administrator account you can create types of wine with quantities and offer them for sale.\nThen you can connect a different account and buy bottles from the available different types, as in this picture:"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.img,{alt:"Buying bottles from the available different types",src:t(10815).A+"",width:"1370",height:"916"})}),"\n",(0,r.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsxs)(e.p,{children:["Now you can create token collections from the different templates that are available in the ",(0,r.jsx)(e.code,{children:"@ligo/fa"})," library, including NFTs, single-asset tokens, and multi-asset tokens.\nYou can create web applications that manage token transactions and show information about tokens."]}),"\n",(0,r.jsxs)(e.p,{children:["For the complete content of the contract and web app at the end of the tutorial, see the completed part 4 app at ",(0,r.jsx)(e.a,{href:"https://github.com/marigold-dev/training-nft-4",children:"https://github.com/marigold-dev/training-nft-4"}),"."]}),"\n",(0,r.jsx)(e.p,{children:"If you want to continue with the application, you can extend the contract or application.\nHere are some ideas:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Create an online marketplace for a different kind of token, like flowers, candy, or cars"}),"\n",(0,r.jsx)(e.li,{children:"Change how tokens behave, like sending a royalty to the marketplace as a sales fee when they are transferred"}),"\n",(0,r.jsx)(e.li,{children:"Add error checking for the application to prevent it from sending invalid transactions"}),"\n",(0,r.jsx)(e.li,{children:"Add new features to the marketplace, such as a shopping cart that lets people buy more than one kind of bottle at a time"}),"\n"]})]})}function p(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(c,{...n})}):c(n)}},10815:(n,e,t)=>{t.d(e,{A:()=>a});const a=t.p+"assets/images/nft-marketplace-4-buy-54222a7fa963ae1bf071195f3ce324bf.png"},28453:(n,e,t)=>{t.d(e,{R:()=>i,x:()=>s});var a=t(96540);const r={},o=a.createContext(r);function i(n){const e=a.useContext(o);return a.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:i(n.components),a.createElement(o.Provider,{value:e},n.children)}}}]);