"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5460],{10285:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"tutorials/security/part-1","title":"Part 1: Programming errors","description":"Note: clone this project for compiling and testing this tutorial.","source":"@site/docs/tutorials/security/part-1.md","sourceDirName":"tutorials/security","slug":"/tutorials/security/part-1","permalink":"/previews/docs/biel-custom-location/tutorials/security/part-1","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1704949200000,"frontMatter":{"title":"Part 1: Programming errors","authors":"Benjamin Fuentes (Marigold)","last_update":{"date":"11 January 2024"}},"sidebar":"tutorialsSidebar","previous":{"title":"Learn and play with security","permalink":"/previews/docs/biel-custom-location/tutorials/security"},"next":{"title":"Part 2: Leaks","permalink":"/previews/docs/biel-custom-location/tutorials/security/part-2"}}');var s=n(74848),a=n(28453);const r={title:"Part 1: Programming errors",authors:"Benjamin Fuentes (Marigold)",last_update:{date:"11 January 2024"}},o=void 0,c={},l=[{value:"Bugs",id:"bugs",level:2},{value:"Rounding issues",id:"rounding-issues",level:2},{value:"Unsecure bitwise operations",id:"unsecure-bitwise-operations",level:2},{value:"Sender vs Source confusion",id:"sender-vs-source-confusion",level:2},{value:"Library updates",id:"library-updates",level:2},{value:"Private data",id:"private-data",level:2},{value:"Predictable information used as a random value",id:"predictable-information-used-as-a-random-value",level:2},{value:"Blocked state",id:"blocked-state",level:2}];function h(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",hr:"hr",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsxs)(t.p,{children:["Note: clone this ",(0,s.jsx)(t.a,{href:"https://github.com/marigold-dev/training-security-1.git",children:"project"})," for compiling and testing this tutorial."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Programming errors in web3 are mistakes or bugs that occur when writing smart contracts."}),"\n",(0,s.jsx)(t.h2,{id:"bugs",children:"Bugs"}),"\n",(0,s.jsx)(t.p,{children:"Writing Michelson code requires careful attention to detail and rigorous testing. If the code contains errors or inconsistencies, it may result in a failed transaction that consumes gas and storage fees. Therefore, it is advisable to use high-level languages that compile to Michelson, such as LIGO, and to verify the generated code before deploying it on the node."}),"\n",(0,s.jsx)(t.p,{children:"For example, LIGO uses the Option type to safely work with values that may or may not exist.\nIf you subtract two tez or mutez variables, the result may be a negative number, which is not valid for the tez and mutez types.\nFor this reason, LIGO requires you to wrap the result in an Option type, even if you are confident that the result is a positive number, as in this example:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-jsligo",children:"option<tez> = 2mutez - 1mutez;\n"})}),"\n",(0,s.jsxs)(t.p,{children:["In the source code ",(0,s.jsx)(t.code,{children:".contracts/1-bugs.jsligo"}),", we have also a subtraction returning an optional value:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-jsligo",children:"    match(store - delta) {\n"})}),"\n",(0,s.jsx)(t.p,{children:"Compile the code and watch the generated Michelson code:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:"taq init\ntaq compile 1-bugs.jsligo\nmore ./artifacts/1-bugs.tz\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Line 6 of the compiled Michelson uses the ",(0,s.jsx)(t.code,{children:"SUB_MUTEZ"})," instruction to subtract the two values.\nNext, it uses the ",(0,s.jsx)(t.code,{children:"IF_NONE"})," instruction to check whether the subtraction instruction returned a result.\nIf it did, it returns the number.\nLIGO returns a compilation error if you forget to manage the optional value and try to use the result directly."]}),"\n",(0,s.jsxs)(t.p,{children:["Run the code for the decrement of 0 by 1. 0 is the default value of the storage in the ",(0,s.jsx)(t.strong,{children:"1-bugs.storageList.jsligo"})," file. 1 is the parameter passed on the simulation in the ",(0,s.jsx)(t.strong,{children:"1-bugs.parameterList.jsligo"})," file."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:"taq simulate 1-bugs.tz --param 1-bugs.parameter.default_parameter.tz\n"})}),"\n",(0,s.jsx)(t.p,{children:"All goes well; if there is an error on the subtraction, it is caught and returns an unchanged value."}),"\n",(0,s.jsxs)(t.p,{children:["Modify directly the Michelson file ",(0,s.jsx)(t.strong,{children:"./artifacts/1-bugs.tz"})," to not check the diff, as in the following code. Using ",(0,s.jsx)(t.strong,{children:"SUB"})," will not do specific checks for mutez and will not wrap it into an optional value."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-michelson",children:"{ parameter (or (unit %reset) (or (mutez %decrement) (mutez %increment))) ;\n  storage mutez ;\n  code { UNPAIR ;\n         IF_LEFT\n           { DROP 2 ; PUSH mutez 0 }\n           { IF_LEFT {  SWAP ; SUB  } { ADD } } ;\n         NIL operation ;\n         PAIR } }\n"})}),"\n",(0,s.jsx)(t.p,{children:"Run it again:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:"taq simulate 1-bugs.tz --param 1-bugs.parameter.default_parameter.tz\n"})}),"\n",(0,s.jsx)(t.p,{children:"This time the operation returns an error:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-logs",children:"Underflowing subtraction of 0 tez and 0.000001 tez\n"})}),"\n",(0,s.jsx)(t.p,{children:"In this way, using the LIGO compiler instead of coding Michelson directly helps you avoid problems."}),"\n",(0,s.jsxs)(t.p,{children:["\u2192 ",(0,s.jsx)(t.strong,{children:"SOLUTION"}),": Use the LIGO compiler to prevent runtime errors."]}),"\n",(0,s.jsx)(t.h2,{id:"rounding-issues",children:"Rounding issues"}),"\n",(0,s.jsx)(t.p,{children:"Michelson does not support floating point numbers, so rounding issues after division can happen if it is not done carefully. This can cause a smart contract to halt in some situations."}),"\n",(0,s.jsxs)(t.p,{children:["Let's take an example of the division of 101 by 4. In the file ",(0,s.jsx)(t.code,{children:"2-rounding.jsligo"})," we have 2 users who would like to redeem the contract balance, with the user Alice receiving 3/4 and user Bob receiving 1/4. The contract calculates Alice's amount as the total minus 1/4 and Bob's amount as the total minus 3/4. Due to rounding, the total amount to withdraw from the contract can exceed the contract balance."]}),"\n",(0,s.jsx)(t.p,{children:"Run the following code:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:"taq compile 2-rounding.jsligo\ntaq simulate 2-rounding.tz --param 2-rounding.parameter.default_parameter.tz\n"})}),"\n",(0,s.jsx)(t.p,{children:"It will fail because the result is negative. Alice will have 101-25=76 and Bob 101-(3*25)=26, so the total to redeem is 102, which is greater than the initial 101."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-logs",children:'script reached FAILWITH instruction\nwith "It is a failure !!!"\n'})}),"\n",(0,s.jsxs)(t.p,{children:["\u2192 ",(0,s.jsx)(t.strong,{children:"SOLUTION"}),": Change the way to do the operation to not be influenced by the rounding effect. Calculate the first value and use the rest for the second user."]}),"\n",(0,s.jsx)(t.p,{children:"Change the line for bob from this code:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-jsligo",children:"const bob = s - (3n * quotient);\n"})}),"\n",(0,s.jsx)(t.p,{children:"To this code:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-jsligo",children:"const bob = s - alice;\n"})}),"\n",(0,s.jsx)(t.p,{children:"Recompile and run the code:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:"taq compile 2-rounding.jsligo\ntaq simulate 2-rounding.tz --param 2-rounding.parameter.default_parameter.tz\n"})}),"\n",(0,s.jsx)(t.p,{children:"All good now. =)"}),"\n",(0,s.jsx)(t.h2,{id:"unsecure-bitwise-operations",children:"Unsecure bitwise operations"}),"\n",(0,s.jsx)(t.p,{children:"A bitwise operation is a type of computation that operates on the individual bits of a binary number. A bitwise shift moves the bits of the operand to the left or right by a certain number of positions, filling the vacated bits with zeros."}),"\n",(0,s.jsx)(t.p,{children:"However, there is a caveat: if the shift amount is too large, it can cause an overflow, which means that some bits are lost or added beyond the expected size of the input. This can lead to unexpected results or errors in the execution of the contract in Michelson."}),"\n",(0,s.jsx)(t.p,{children:"Run our two examples shifting to left and right:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:"taq compile 3-bitwise.jsligo\ntaq simulate 3-bitwise.tz --param 3-bitwise.parameter.shiftLeftOneNat.tz\ntaq simulate 3-bitwise.tz --param 3-bitwise.parameter.shiftRight257times.tz\n"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"The first example shifts 2n (0x0010) one time to the left, so it gives 4n (0x0100)"}),"\n",(0,s.jsxs)(t.li,{children:["The second example shifts 2n (0x0010) 257 times to the right. Because the limit is 256 shifts, it produces the error ",(0,s.jsx)(t.code,{children:"unexpected arithmetic overflow"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["\u2192 ",(0,s.jsx)(t.strong,{children:"SOLUTION"}),": To avoid this, check the size of the input and the shift amount before applying the bitwise instructions. Here you should check if the number of shifts is less than or equal to 256; otherwise, you raise an error."]}),"\n",(0,s.jsx)(t.h2,{id:"sender-vs-source-confusion",children:"Sender vs Source confusion"}),"\n",(0,s.jsxs)(t.p,{children:["When a transaction is sent by a user, it can create other transactions on other smart contracts. Depending on the transaction, the address that initiated the original transaction (the ",(0,s.jsx)(t.em,{children:"source"}),") could be different from the direct sender of the additional transactions (the ",(0,s.jsx)(t.em,{children:"sender"}),")."]}),"\n",(0,s.jsx)(t.mermaid,{value:"sequenceDiagram\n  Note left of User: I am the source of tx1 and tx2\n  User->>SmartContract1: transaction tx1\n  Note right of SmartContract1: I am the sender of tx2\n  SmartContract1->>SmartContract2: transaction tx2"}),"\n",(0,s.jsx)(t.p,{children:"In this example, transaction tx2 on SmartContract2 has:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["The ",(0,s.jsx)(t.strong,{children:"User"})," as the source"]}),"\n",(0,s.jsxs)(t.li,{children:["The ",(0,s.jsx)(t.strong,{children:"SmartContract1"})," as the sender"]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Man-in-the-middle attack"}),": The victim contract is checking the source ",(0,s.jsx)(t.code,{children:"Tezos.get_source()"})," to give access to an endpoint. If we have a phishing contract in the middle, it can call the endpoint while appearing to be the authorized caller. In this case, it can even grab some money in addition to the malicious action."]}),"\n",(0,s.jsx)(t.p,{children:"Run the following test:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:"taq test 4-manInTheMiddleTest.jsligo\n"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-logs",children:'"Successfully hacked the victim and grab it money !!!"\n\ud83c\udf89 All tests passed \ud83c\udf89\n'})}),"\n",(0,s.jsxs)(t.p,{children:["\u2192 ",(0,s.jsx)(t.strong,{children:"SOLUTION"}),": Fix the code on the file ",(0,s.jsx)(t.code,{children:"4-manInTheMiddleVictim.jsligo"}),", replacing ",(0,s.jsx)(t.code,{children:"Tezos.get_source()"})," by ",(0,s.jsx)(t.code,{children:"Tezos.get_sender()"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"Run it again:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:"taq test 4-manInTheMiddleTest.jsligo\n"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-logs",children:'Failwith: "You are not the admin to do this action"\nTrace:\nFile "contracts/4-manInTheMiddleTest.jsligo", line 51, character 2 to line 59, character 3 ,\nFile "contracts/4-manInTheMiddleTest.jsligo", line 51, character 2 to line 59, character 3 ,\nFile "contracts/4-manInTheMiddleTest.jsligo", line 69, characters 17-24\n\n===\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Contract \u2502 Test Results \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 4-manInTheMiddleTest.jsligo \u2502 Some tests failed :( \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n'})}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsx)(t.p,{children:"Note: On some specific cases it is important to authorize an intermediary contract to communicate with our contract. We should not always check the source as the default behavior for rejection"}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"library-updates",children:"Library updates"}),"\n",(0,s.jsx)(t.p,{children:"This is a DevOps issue. If a continuous integration pipeline recompiles the code before deploying a new version and there are dependencies to fetch, it's possible that the new behavior will not be compatible with your code logic and bring new security flaws."}),"\n",(0,s.jsxs)(t.p,{children:["\u2192 ",(0,s.jsx)(t.strong,{children:"SOLUTION"}),": Do more unit tests and publish CI test reports."]}),"\n",(0,s.jsx)(t.h2,{id:"private-data",children:"Private data"}),"\n",(0,s.jsx)(t.p,{children:"One of the most important security considerations for smart contract developers is to avoid storing any sensitive or confidential information on the contract storage. This is because the contract storage is public and immutable, meaning that anyone can read its contents and those contents cannot be erased or modified. Therefore, any secret value, such as a private key, a password, or a personal identification number, should never be stored on the contract storage. Doing so exposes the secret value to potential attackers and compromises the security and privacy of the contract and its users."}),"\n",(0,s.jsxs)(t.p,{children:["\u2192 ",(0,s.jsx)(t.strong,{children:"SOLUTION"}),": Instead, secret values should be stored off-chain, such as in a secure database or a hardware wallet, and only communicated to the contract when necessary using encryption with the commit-reveal pattern or zero-knowledge proofs."]}),"\n",(0,s.jsx)(t.h2,{id:"predictable-information-used-as-a-random-value",children:"Predictable information used as a random value"}),"\n",(0,s.jsx)(t.p,{children:"Due to the deterministic nature of blockchain execution, it is not possible to generate random numbers or values within a smart contract. This means that any logic that relies on randomness, such as games, lotteries, or auctions, cannot be implemented securely and fairly on a blockchain. Therefore, smart contract developers need to find alternative ways to introduce randomness into their applications, such as using external sources of randomness (oracles) or cryptographic techniques (commit-reveal schemes)."}),"\n",(0,s.jsxs)(t.p,{children:["\u2192 ",(0,s.jsx)(t.strong,{children:"SOLUTION"}),":"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Use block timestamp: This approach has a low cost but also a high risk of being compromised, as the time parameter is too coarse and can be easily estimated based on the average block time."}),"\n",(0,s.jsx)(t.li,{children:"Use contract origination address: This approach has a low cost but also a high risk of being compromised, because it is composed of the hash of the operation concatenated with an origination index."}),"\n",(0,s.jsx)(t.li,{children:"Multi-participant random seed: One possible way to generate a multi-participant random seed is to ask each participant to submit a random number in a secure and verifiable way. This can be done using a commit-reveal scheme, where each participant first commits to their number by sending a hash of it and then reveals it later by sending the actual number. The hash function ensures that the participants cannot change their numbers after committing, and the reveal phase allows everyone to verify that the numbers match the hashes. The final seed can be computed by combining all the revealed numbers using some deterministic function, such as XOR or modular addition.\nHowever, this method has some drawbacks, such as requiring two rounds of communication and being vulnerable to a locked situation, where some participants do not reveal their numbers and prevent the seed from being generated. To avoid this, there should be some incentive mechanism or timeout mechanism to ensure that everyone reveals their numbers in time, or else they are penalized or excluded from the seed generation."}),"\n",(0,s.jsx)(t.li,{children:"Good randomness oracle: Creating a good off-chain random Oracle is not easy, as it requires a way to prove that the numbers are indeed random and not manipulated by anyone. One possible solution is to use a verifiable random function (VRF), which is a cryptographic algorithm that generates a random output from an input and a secret key. It produces a proof that the output was correctly computed. The proof can be verified by anyone who knows the input and the public key, but not the secret key. Chainlink is a decentralized network of Oracles that offers a VRF-based randomness Oracle for smart contracts. It claims to be one of the few, if not the only reasonably good available randomness oracle on the market. However, it has some limitations, such as being only compatible with Ethereum. Moreover, it still relies on the trustworthiness of a third party, namely the Chainlink node operators that hold the secret keys and generate the random numbers and proofs."}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"blocked-state",children:"Blocked state"}),"\n",(0,s.jsx)(t.p,{children:"One of the possible scenarios in a blockchain smart contract is to have a blocked state where the contract execution is paused until a certain condition is met. For example, a contract that implements a simple escrow service might have a blocked state where the seller has to confirm the delivery of the goods before the buyer can release the payment. This way, the contract ensures that both parties are satisfied with the transaction and no one can cheat or withdraw from the agreement."}),"\n",(0,s.jsxs)(t.p,{children:["Another example is in the tutorial ",(0,s.jsx)(t.a,{href:"/tutorials/mobile",children:"Create a mobile game"}),". The contract in this tutorial is blocked while the players make their decisions. However, if one of the players does not reveal their choice within 10 minutes, the other player can claim a resolution and win the game by calling an entrypoint on the contract. This way, the contract is not stuck indefinitely and the honest player is rewarded."]}),"\n",(0,s.jsxs)(t.p,{children:["\u2192 ",(0,s.jsx)(t.strong,{children:"SOLUTION"}),":"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Define clear and objective rules for entering and exiting the blocked state, as well as for handling exceptions and disputes."}),"\n",(0,s.jsx)(t.li,{children:"Use timeouts or deadlines to limit the duration of the blocked state and avoid indefinite waiting or deadlock situations."}),"\n",(0,s.jsx)(t.li,{children:"Implement incentives or penalties to encourage or discourage certain behaviors or actions by the participants during the blocked state."}),"\n",(0,s.jsx)(t.li,{children:"Provide feedback and notifications to the participants about the status and progress of the contract during the blocked state."}),"\n",(0,s.jsx)(t.li,{children:"Use external oracles or trusted third parties to verify or arbitrate the condition that triggers the blocked state, if necessary."}),"\n"]}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsxs)(t.p,{children:["Go to ",(0,s.jsx)(t.a,{href:"/tutorials/security/part-2",children:"Part 2: Leaks"}),"."]})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var i=n(96540);const s={},a=i.createContext(s);function r(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);